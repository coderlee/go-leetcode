

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh-CN" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh-CN" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>} &mdash; go-leetcode v1.0.0 文档</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> go-leetcode
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id24">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id25">]</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id48">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id65">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id80">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id95">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id112">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id115">]</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id120">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id131">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id142">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id153">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id164">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id175">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id192">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id219">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id250">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id261">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id272">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id283">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id294">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id305">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id316">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id327">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id350">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id18">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id23">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id34">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id51">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id62">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id73">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id138">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id157">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id168">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id217">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id234">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id253">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id266">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id277">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id296">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id301">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id312">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id323">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id334">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id345">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id356">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id367">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id378">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id20">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id25">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id36">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id47">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id58">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id69">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id74">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id79">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id90">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id101">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id106">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id111">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id124">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id26">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id37">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id42">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id45">]</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id50">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id55">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id66">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id71">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id100">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id105">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id116">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id127">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id138">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id143">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id154">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id159">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id170">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id181">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id192">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id203">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id214">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id225">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id236">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id247">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id258">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id24">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id35">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id40">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id51">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id62">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id73">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id98">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id109">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id138">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id149">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id170">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id181">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id192">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id207">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id218">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id235">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id246">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id273">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id284">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id295">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id306">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id323">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id328">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id339">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id350">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id28">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id51">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id62">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id67">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id84">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id95">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id106">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id133">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id144">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id155">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id166">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id185">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id204">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id209">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id220">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id231">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id242">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id267">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id280">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id287">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id298">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id309">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id328">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id46">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id85">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id96">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id111">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id122">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id133">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id146">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id157">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id170">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id181">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id192">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id203">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id214">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id225">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id252">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id263">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id274">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id285">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id22">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id33">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id44">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id55">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id66">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id77">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id82">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id93">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id104">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id115">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id126">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id137">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id148">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id159">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id170">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id181">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id186">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id221">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id232">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id255">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id266">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id277">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id288">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id299">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id310">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id321">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id356">}</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">go-leetcode</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>}</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/question/0000-0100.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <p># 0001-0100-Easy
* [0001-0100-Easy](#0001-0100-easy)</p>
<blockquote>
<div><ul class="simple">
<li><p>[1.两数之和(3)](#1两数之和3)</p></li>
<li><p>[7.整数反转(2)](#7整数反转2)</p></li>
<li><p>[9.回文数(3)](#9回文数3)</p></li>
<li><p>[13.罗马数字转整数(2)](#13罗马数字转整数2)</p></li>
<li><p>[14.最长公共前缀(6)](#14最长公共前缀6)</p></li>
<li><p>[20.有效的括号(3)](#20有效的括号3)</p></li>
<li><p>[21.合并两个有序链表(2)](#21合并两个有序链表2)</p></li>
<li><p>[26.删除排序数组中的重复项(2)](#26删除排序数组中的重复项2)</p></li>
<li><p>[27.移除元素(3)](#27移除元素3)</p></li>
<li><p>[28.实现strStr()(4)](#28实现strstr4)</p></li>
<li><p>[35.搜索插入位置(3)](#35搜索插入位置3)</p></li>
<li><p>[38.报数(2)](#38报数2)</p></li>
<li><p>[53.最大子序和(5)](#53最大子序和5)</p></li>
<li><p>[58.最后一个单词的长度(2)](#58最后一个单词的长度2)</p></li>
<li><p>[66.加一(2)](#66加一2)</p></li>
<li><p>[67.二进制求和(2)](#67二进制求和2)</p></li>
<li><p>[69.x的平方根 (5)](#69x的平方根-5)</p></li>
<li><p>[70.爬楼梯(3)](#70爬楼梯3)</p></li>
<li><p>[83.删除排序链表中的重复元素(3)](#83删除排序链表中的重复元素3)</p></li>
<li><p>[88.合并两个有序数组(3)](#88合并两个有序数组3)</p></li>
<li><p>[100.相同的树(2)](#100相同的树2)</p></li>
</ul>
</div></blockquote>
<p>## 1.两数之和(3)
- 题目</p>
<p><a href="#id1"><span class="problematic" id="id2">``</span></a>`
给定一个整数数组 nums 和一个目标值 target，
请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<p>示例:
给定 nums = [2, 7, 11, 15], target = 9</p>
<p>因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
<a href="#id3"><span class="problematic" id="id4">``</span></a>`
- 解答思路</p>
<div class="line-block">
<div class="line">No.      | 思路                | 时间复杂度 | 空间复杂度 |</div>
<div class="line">——– | ——————- | ———- | ———- |</div>
<div class="line">01       | 暴力法: 2层循环遍历 | O(n^2)     | O(1)       |</div>
<div class="line">02       | 两遍哈希遍历        | O(n)       | O(n)       |</div>
<div class="line">03(最优) | 一遍哈希遍历        | O(n)       | O(n)       |</div>
</div>
<p><a href="#id5"><span class="problematic" id="id6">``</span></a><a href="#id7"><span class="problematic" id="id8">`</span></a>go
# 暴力法: 2层循环遍历
func twoSum(nums []int, target int) []int {</p>
<blockquote>
<div><dl>
<dt>for i := 0; i &lt; len(nums); i++ {</dt><dd><dl>
<dt>for j := i + 1; j &lt; len(nums); j++ {</dt><dd><dl class="simple">
<dt>if nums[i]+nums[j] == target {</dt><dd><p>return []int{i, j}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
return []int{}</p>
</div></blockquote>
<p>}</p>
<p># 两遍哈希遍历
func twoSum(nums []int, target int) []int {</p>
<blockquote>
<div><p>m := make(map[int]int,len(nums))
for k, v := range nums{</p>
<blockquote>
<div><p>m[v] = k</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>for i := 0; i &lt; len(nums); i++{</dt><dd><p>b := target - nums[i]
if num, ok := m[b]; ok &amp;&amp; num != i{</p>
<blockquote>
<div><p>return []int{i,m[b]}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}
return []int{}</p>
</div></blockquote>
<p>}</p>
<p># 一遍哈希遍历
func twoSum(nums []int, target int) []int {</p>
<blockquote>
<div><p>m := make(map[int]int, len(nums))
for i, b := range nums {</p>
<blockquote>
<div><dl class="simple">
<dt>if j, ok := m[target-b]; ok {</dt><dd><p>return []int{j, i}</p>
</dd>
</dl>
<p>}
m[b] = i</p>
</div></blockquote>
<p>}
return nil</p>
</div></blockquote>
<div class="section" id="id9">
<h1>}<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h1>
<p>##  7.整数反转(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id10"><span class="problematic" id="id11">``</span></a>`
给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
<p>示例 1:
输入: 123
输出: 321</p>
<p>示例 2:
输入: -123
输出: -321</p>
<p>示例 3:
输入: 120
输出: 21</p>
<p>注意:假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31,  2^31 − 1]。
请根据这个假设，如果反转后整数溢出那么就返回 0。
<a href="#id12"><span class="problematic" id="id13">``</span></a><a href="#id14"><span class="problematic" id="id15">`</span></a></p>
<ul class="simple">
<li><p>解答思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.      | 思路                                                  | 时间复杂度 | 空间复杂度 |</div>
<div class="line">——– | —————————————————– | ———- | ———- |</div>
<div class="line">01       | 使用符号标记，转成正数，循环得到%10的余数，再加上符号 | O(log(x))  | O(1)       |</div>
<div class="line">02(最优) | 对x进行逐个%10取个位，一旦溢出，直接跳出循环          | O(log(x))  | O(1)       |</div>
</div>
<p><a href="#id16"><span class="problematic" id="id17">``</span></a><a href="#id18"><span class="problematic" id="id19">`</span></a>go
// 使用符号标记，转成正数，循环得到%10的余数，再加上符号
func reverse(x int) int {</p>
<blockquote>
<div><p>flag := 1
if x &lt; 0 {</p>
<blockquote>
<div><p>flag = -1
x = -1 * x</p>
</div></blockquote>
<p>}</p>
<p>result := 0
for x &gt; 0 {</p>
<blockquote>
<div><p>temp := x % 10
x = x / 10</p>
<p>result = result*10 + temp</p>
</div></blockquote>
<p>}</p>
<p>result = flag * result
if result &gt; math.MaxInt32 || result &lt; math.MinInt32 {</p>
<blockquote>
<div><p>result = 0</p>
</div></blockquote>
<p>}
return result</p>
</div></blockquote>
<p>}</p>
<p>// 对x进行逐个%10取个位，一旦溢出，直接跳出循环
func reverse(x int) int {</p>
<blockquote>
<div><p>result := 0
for x != 0 {</p>
<blockquote>
<div><p>temp := x % 10
result = result*10 + temp
if result &gt; math.MaxInt32 || result &lt; math.MinInt32 {</p>
<blockquote>
<div><p>return 0</p>
</div></blockquote>
<p>}
x = x / 10</p>
</div></blockquote>
<p>}
return result</p>
</div></blockquote>
</div>
<div class="section" id="id20">
<h1>}<a class="headerlink" href="#id20" title="永久链接至标题">¶</a></h1>
<p>## 9.回文数(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id21"><span class="problematic" id="id22">``</span></a>`
判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<p>示例 1:   输入: 121 输出: true</p>
<p>示例 2:输入: -121   输出: false
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</p>
<p>示例 3:输入: 10     输出: false
解释: 从右向左读, 为 01 。因此它不是一个回文数。</p>
<p>进阶:
你能不将整数转为字符串来解决这个问题吗？
<a href="#id23"><span class="problematic" id="id24">``</span></a><a href="#id25"><span class="problematic" id="id26">`</span></a></p>
<ul class="simple">
<li><p>解答思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.      | 思路                                               | 时间复杂度 | 空间复杂度 |</div>
<div class="line">——– | ————————————————– | ———- | ———- |</div>
<div class="line">01(最优) | 数学解法，取出后半段数字进行翻转，然后判断是否相等 | O(log(x))  | O(1)       |</div>
<div class="line">02       | 转成字符串，依次判断                               | O(log(x))  | O(log(x))  |</div>
<div class="line">03       | 转成byte数组，依次判断，同2                        | O(log(x))  | O(log(x))  |</div>
</div>
<p><a href="#id27"><span class="problematic" id="id28">``</span></a><a href="#id29"><span class="problematic" id="id30">`</span></a>go
// 数学解法，取出后半段数字进行翻转，然后判断是否相等
func isPalindrome(x int) bool {</p>
<blockquote>
<div><dl class="simple">
<dt>if x &lt; 0 || (x%10 == 0 &amp;&amp; x != 0) {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}</p>
<p>revertedNumber := 0
for x &gt; revertedNumber {</p>
<blockquote>
<div><p>temp := x % 10
revertedNumber = revertedNumber*10 + temp
x = x / 10</p>
</div></blockquote>
<p>}
// for example:
// x = 1221  =&gt; x = 12 revertedNumber = 12
// x = 12321 =&gt; x = 12 revertedNumber = 123
return x == revertedNumber || x == revertedNumber/10</p>
</div></blockquote>
<p>}</p>
<p>// 转成字符串，依次判断
func isPalindrome(x int) bool {</p>
<blockquote>
<div><dl class="simple">
<dt>if x &lt; 0 {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}</p>
<p>s := strconv.Itoa(x)
for i, j := 0, len(s)-1; i &lt; j; i, j = i+1, j-1 {</p>
<blockquote>
<div><dl class="simple">
<dt>if s[i] != s[j] {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return true</p>
</div></blockquote>
<p>}</p>
<p>// 转成byte数组，依次判断，同2
func isPalindrome(x int) bool {</p>
<blockquote>
<div><dl class="simple">
<dt>if x &lt; 0 {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}
arrs := []byte(strconv.Itoa(x))
Len := len(arrs)
for i := 0; i &lt; Len/2; i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if arrs[i] != arrs[Len-i-1] {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return true</p>
</div></blockquote>
</div>
<div class="section" id="id31">
<h1>}<a class="headerlink" href="#id31" title="永久链接至标题">¶</a></h1>
<p>## 13.罗马数字转整数(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id32"><span class="problematic" id="id33">``</span></a>`
罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p>
<p>字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。
27 写做  XXVII, 即为 XX + V + II 。
通常情况下，罗马数字中小的数字在大的数字的右边。
但也存在特例，例如 4 不写做 IIII，而是 IV。
数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。
同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<blockquote>
<div><p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</p>
</div></blockquote>
<p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>
<p>示例 1:输入: “III” 输出: 3
示例 2:   输入: “IV” 输出: 4
示例 3:   输入: “IX”        输出: 9
示例 4:   输入: “LVIII”     输出: 58 解释: L = 50, V= 5, III = 3.
示例 5: 输入: “MCMXCIV”     输出: 1994 解释: M = 1000, CM = 900, XC = 90, IV = 4.
<a href="#id34"><span class="problematic" id="id35">``</span></a><a href="#id36"><span class="problematic" id="id37">`</span></a></p>
<ul class="simple">
<li><p>解答思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.      | 思路                                                         | 时间复杂度 | 空间复杂度 |</div>
<div class="line">——– | ———————————————————— | ———- | ———- |</div>
<div class="line">01       | 本质上其实就是全部累加，然后遇到特殊的就做判断。使用一个字段记录递增 | O(n)       | O(1)       |</div>
<div class="line">02(最优) | 从右到左遍历字符串，如果当前字符代表的值不小于其右边，就加上该值；否则就减去该值。 | O(n)       | O(1)       |</div>
</div>
<p><a href="#id38"><span class="problematic" id="id39">``</span></a><a href="#id40"><span class="problematic" id="id41">`</span></a>go
// 带标记位
func romanToInt(s string) int {</p>
<blockquote>
<div><dl class="simple">
<dt>m := map[byte]int{</dt><dd><p>‘I’: 1,
‘V’: 5,
‘X’: 10,
‘L’: 50,
‘C’: 100,
‘D’: 500,
‘M’: 1000,</p>
</dd>
</dl>
<p>}
result := 0
last := 0</p>
<dl>
<dt>for i := len(s) - 1; i &gt;= 0; i– {</dt><dd><p>current := m[s[i]]
flag := 1
if current &lt; last {</p>
<blockquote>
<div><p>flag = -1</p>
</div></blockquote>
<p>}
result = result + flag*current
last = current</p>
</dd>
</dl>
<p>}
return result</p>
</div></blockquote>
<p>}</p>
<p>// 不带标记位，小于则减去2倍数
func romanToInt(s string) int {</p>
<blockquote>
<div><dl class="simple">
<dt>m := map[byte]int{</dt><dd><p>‘I’: 1,
‘V’: 5,
‘X’: 10,
‘L’: 50,
‘C’: 100,
‘D’: 500,
‘M’: 1000,</p>
</dd>
</dl>
<p>}
result := 0
last := 0</p>
<dl>
<dt>for i := len(s) - 1; i &gt;= 0; i– {</dt><dd><p>current := m[s[i]]
if current &lt; last {</p>
<blockquote>
<div><p>result = result - current</p>
</div></blockquote>
<dl class="simple">
<dt>}else {</dt><dd><p>result = result + current</p>
</dd>
</dl>
<p>}
last = current</p>
</dd>
</dl>
<p>}
return result</p>
</div></blockquote>
</div>
<div class="section" id="id42">
<h1>}<a class="headerlink" href="#id42" title="永久链接至标题">¶</a></h1>
<p>## 14.最长公共前缀(6)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id43"><span class="problematic" id="id44">``</span></a>`
编写一个函数来查找字符串数组中的最长公共前缀。
如果不存在公共前缀，返回空字符串 “”。</p>
<p>示例 1:
输入: [“flower”,”flow”,”flight”]
输出: “fl”</p>
<p>示例 2:
输入: [“dog”,”racecar”,”car”]
输出: “”
解释: 输入不存在公共前缀。</p>
<p>说明:
所有输入只包含小写字母 a-z 。
<a href="#id45"><span class="problematic" id="id46">``</span></a><a href="#id47"><span class="problematic" id="id48">`</span></a></p>
<ul class="simple">
<li><p>解答思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.      | 思路                                                         | 时间复杂度    | 空间复杂度 |</div>
<div class="line">——– | ———————————————————— | ————- | ———- |</div>
<div class="line">01       | 先找最短的一个字符串，依次比较最短字符串子串是否是其他字符串子串 | O(n^2)/O(n*m) | O(1)       |</div>
<div class="line">02       | 纵向扫描(暴力法):直接取第一个字符串作为最长公共前缀，将其每个字符遍历过一次 | O(n^2)/O(n*m) | O(1)       |</div>
<div class="line">03(最优) | 排序后，然后计算第一个，和最后一个字符串的最长前缀           | O(nlog(n))    | O(1)       |</div>
<div class="line">04       | trie树                                                       | O(n^2)        | O(n^2)     |</div>
<div class="line">05       | 水平扫描法:比较前2个字符串得到最长前缀，然后跟第3个比较得到一个新的最长前缀，继续比较，直到最后 | O(n^2)/O(n*m) | O(1)       |</div>
<div class="line">06       | 分治法                                                       | O(n^2)        | O(1)       |</div>
</div>
<p><a href="#id49"><span class="problematic" id="id50">``</span></a><a href="#id51"><span class="problematic" id="id52">`</span></a>go
// 先找最短的一个字符串，依次比较最短字符串子串是否是其他字符串子串
func longestCommonPrefix(strs []string) string {</p>
<blockquote>
<div><dl class="simple">
<dt>if len(strs) == 0{</dt><dd><p>return “”</p>
</dd>
</dl>
<p>}
if len(strs) == 1{</p>
<blockquote>
<div><p>return strs[0]</p>
</div></blockquote>
<p>}</p>
<p>short := strs[0]
for _, s := range strs{</p>
<blockquote>
<div><dl class="simple">
<dt>if len(short) &gt; len(s){</dt><dd><p>short = s</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>for i := range short{</dt><dd><p>shortest := short[:i+1]
for _,str := range strs{</p>
<blockquote>
<div><dl class="simple">
<dt>if strings.Index(str,shortest) != 0{</dt><dd><p>return short[:i]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}
return short</p>
</div></blockquote>
<p>}</p>
<p>// 暴力法:直接依次遍历
func longestCommonPrefix(strs []string) string {</p>
<blockquote>
<div><dl class="simple">
<dt>if len(strs) == 0 {</dt><dd><p>return “”</p>
</dd>
</dl>
<p>}
if len(strs) == 1 {</p>
<blockquote>
<div><p>return strs[0]</p>
</div></blockquote>
<p>}</p>
<p>length := 0</p>
<dl>
<dt>for i := 0; i &lt; len(strs[0]); i++ {</dt><dd><p>char := strs[0][i]
for j := 1; j &lt; len(strs); j++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if i &gt;= len(strs[j]) || char != strs[j][i] {</dt><dd><p>return strs[0][:length]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
length++</p>
</dd>
</dl>
<p>}
return strs[0][:length]</p>
</div></blockquote>
<p>}</p>
<p>// 排序后，遍历比较第一个，和最后一个字符串
func longestCommonPrefix(strs []string) string {</p>
<blockquote>
<div><dl class="simple">
<dt>if len(strs) == 0{</dt><dd><p>return “”</p>
</dd>
</dl>
<p>}
if len(strs) == 1{</p>
<blockquote>
<div><p>return strs[0]</p>
</div></blockquote>
<p>}</p>
<p>sort.Strings(strs)
first := strs[0]
last := strs[len(strs)-1]
i := 0
length := len(first)
if len(last) &lt; length{</p>
<blockquote>
<div><p>length = len(last)</p>
</div></blockquote>
<p>}
for i &lt; length{</p>
<blockquote>
<div><dl class="simple">
<dt>if first[i] != last[i]{</dt><dd><p>return first[:i]</p>
</dd>
</dl>
<p>}
i++</p>
</div></blockquote>
<p>}</p>
<p>return first[:i]</p>
</div></blockquote>
<p>}</p>
<p>// trie树
var trie [][]int
var index int</p>
<dl>
<dt>func longestCommonPrefix(strs []string) string {</dt><dd><dl class="simple">
<dt>if len(strs) == 0 {</dt><dd><p>return “”</p>
</dd>
</dl>
<p>}
if len(strs) == 1 {</p>
<blockquote>
<div><p>return strs[0]</p>
</div></blockquote>
<p>}</p>
<p>trie = make([][]int, 2000)
for k := range trie {</p>
<blockquote>
<div><p>value := make([]int, 26)
trie[k] = value</p>
</div></blockquote>
<p>}
insert(strs[0])</p>
<p>minValue := math.MaxInt32
for i := 1; i &lt; len(strs); i++ {</p>
<blockquote>
<div><p>retValue := insert(strs[i])
if minValue &gt; retValue {</p>
<blockquote>
<div><p>minValue = retValue</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return strs[0][:minValue]</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func insert(str string) int {</dt><dd><p>p := 0
count := 0
for i := 0; i &lt; len(str); i++ {</p>
<blockquote>
<div><p>ch := str[i] - ‘a’
// fmt.Println(string(str[i]),p,ch,trie[p][ch])
if value := trie[p][ch]; value == 0 {</p>
<blockquote>
<div><p>index++
trie[p][ch] = index</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>count++</p>
</dd>
</dl>
<p>}
p = trie[p][ch]</p>
</div></blockquote>
<p>}
return count</p>
</dd>
</dl>
<p>}</p>
<p>// 水平扫描法:比较前2个字符串得到最长前缀，然后跟第3个比较得到一个新的最长前缀，继续比较，直到最后
func longestCommonPrefix(strs []string) string {</p>
<blockquote>
<div><dl class="simple">
<dt>if len(strs) == 0 {</dt><dd><p>return “”</p>
</dd>
</dl>
<p>}
if len(strs) == 1 {</p>
<blockquote>
<div><p>return strs[0]</p>
</div></blockquote>
<p>}</p>
<p>commonStr := common(strs[0], strs[1])
if commonStr == “” {</p>
<blockquote>
<div><p>return “”</p>
</div></blockquote>
<p>}
for i := 2; i &lt; len(strs); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if commonStr == “” {</dt><dd><p>return “”</p>
</dd>
</dl>
<p>}
commonStr = common(commonStr, strs[i])</p>
</div></blockquote>
<p>}
return commonStr</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func common(str1, str2 string) string {</dt><dd><p>length := 0
for i := 0; i &lt; len(str1); i++ {</p>
<blockquote>
<div><p>char := str1[i]
if i &gt;= len(str2) || char != str2[i] {</p>
<blockquote>
<div><p>return str1[:length]</p>
</div></blockquote>
<p>}
length++</p>
</div></blockquote>
<p>}
return str1[:length]</p>
</dd>
</dl>
<p>}</p>
<p>// 分治法
func longestCommonPrefix(strs []string) string {</p>
<blockquote>
<div><dl class="simple">
<dt>if len(strs) == 0 {</dt><dd><p>return “”</p>
</dd>
</dl>
<p>}
if len(strs) == 1 {</p>
<blockquote>
<div><p>return strs[0]</p>
</div></blockquote>
<p>}</p>
<p>return commonPrefix(strs, 0, len(strs)-1)</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func commonPrefix(strs []string, left, right int) string {</dt><dd><dl class="simple">
<dt>if left == right {</dt><dd><p>return strs[left]</p>
</dd>
</dl>
<p>}</p>
<p>middle := (left + right) / 2
leftStr := commonPrefix(strs, left, middle)
rightStr := commonPrefix(strs, middle+1, right)
return commonPrefixWord(leftStr, rightStr)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func commonPrefixWord(leftStr, rightStr string) string {</dt><dd><dl class="simple">
<dt>if len(leftStr) &gt; len(rightStr) {</dt><dd><p>leftStr = leftStr[:len(rightStr)]</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>if len(leftStr) &lt; 1 {</dt><dd><p>return leftStr</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>for i := 0; i &lt; len(leftStr); i++ {</dt><dd><dl class="simple">
<dt>if leftStr[i] != rightStr[i] {</dt><dd><p>return leftStr[:i]</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
return leftStr</p>
</dd>
</dl>
</div>
<div class="section" id="id53">
<h1>}<a class="headerlink" href="#id53" title="永久链接至标题">¶</a></h1>
<p>## 20.有效的括号(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id54"><span class="problematic" id="id55">``</span></a>`
给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。
有效字符串需满足：</p>
<blockquote>
<div><p>左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。</p>
</div></blockquote>
<p>注意空字符串可被认为是有效字符串。</p>
<p>示例 1: 输入: “()” 输出: true
示例 2: 输入: “()[]{}” 输出: true
示例 3: 输入: “(]” 输出: false
示例 4: 输入: “([)]” 输出: false
示例 5: 输入: “{[]}” 输出: true
<a href="#id56"><span class="problematic" id="id57">``</span></a><a href="#id58"><span class="problematic" id="id59">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路                               | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ———————————- | ———- | ———- |</div>
<div class="line">01   | 使用栈结构实现栈                   | O(n)       | O(n)       |</div>
<div class="line">02   | 借助数组实现栈                     | O(n)       | O(n)       |</div>
<div class="line">03   | 借助数组实现栈，使用数字表示来匹配 | O(n)       | O(n)       |</div>
</div>
<p><a href="#id60"><span class="problematic" id="id61">``</span></a><a href="#id62"><span class="problematic" id="id63">`</span></a>go
// 使用栈结构实现
func isValid(s string) bool {</p>
<blockquote>
<div><p>st := new(stack)
for _, char := range s {</p>
<blockquote>
<div><p>switch char {
case ‘(‘, ‘[‘, ‘{‘:</p>
<blockquote>
<div><p>st.push(char)</p>
</div></blockquote>
<dl>
<dt>case ‘)’, ‘]’, ‘}’:</dt><dd><p>ret, ok := st.pop()
if !ok || ret != match[char] {</p>
<blockquote>
<div><p>return false</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>if len(<a href="#id64"><span class="problematic" id="id65">*</span></a>st) &gt; 0 {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}
return true</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>var match = map[rune]rune{</dt><dd><p>‘)’: ‘(‘,
‘]’: ‘[‘,
‘}’: ‘{‘,</p>
</dd>
</dl>
<p>}</p>
<p>type stack []rune</p>
<dl class="simple">
<dt>func (s <a href="#id66"><span class="problematic" id="id67">*</span></a>stack) push(b rune) {</dt><dd><p><a href="#id68"><span class="problematic" id="id69">*</span></a>s = append(<a href="#id70"><span class="problematic" id="id71">*</span></a>s, b)</p>
</dd>
</dl>
<p>}
func (s <a href="#id72"><span class="problematic" id="id73">*</span></a>stack) pop() (rune, bool) {</p>
<blockquote>
<div><dl class="simple">
<dt>if len(<a href="#id74"><span class="problematic" id="id75">*</span></a>s) &gt; 0 {</dt><dd><p>res := (<a href="#id76"><span class="problematic" id="id77">*</span></a>s)[len(<a href="#id78"><span class="problematic" id="id79">*</span></a>s)-1]
<a href="#id80"><span class="problematic" id="id81">*</span></a>s = (<a href="#id82"><span class="problematic" id="id83">*</span></a>s)[:len(<a href="#id84"><span class="problematic" id="id85">*</span></a>s)-1]
return res, true</p>
</dd>
</dl>
<p>}
return 0, false</p>
</div></blockquote>
<p>}</p>
<p>// 借助数组实现栈
func isValid(s string) bool {</p>
<blockquote>
<div><dl class="simple">
<dt>if s == “” {</dt><dd><p>return true</p>
</dd>
</dl>
<p>}</p>
<p>stack := make([]rune, len(s))
length := 0
var match = map[rune]rune{</p>
<blockquote>
<div><p>‘)’: ‘(‘,
‘]’: ‘[‘,
‘}’: ‘{‘,</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>for _, char := range s {</dt><dd><p>switch char {
case ‘(‘, ‘[‘, ‘{‘:</p>
<blockquote>
<div><p>stack[length] = char
length++</p>
</div></blockquote>
<dl>
<dt>case ‘)’, ‘]’, ‘}’:</dt><dd><dl class="simple">
<dt>if length == 0 {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}
if stack[length-1] != match[char]{</p>
<blockquote>
<div><p>return false</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>length–</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
return length == 0</p>
</div></blockquote>
<p>}</p>
<p>// 借助数组实现栈，使用数字表示来匹配
func isValid(s string) bool {</p>
<blockquote>
<div><dl class="simple">
<dt>if s == “” {</dt><dd><p>return true</p>
</dd>
</dl>
<p>}</p>
<p>stack := make([]int, len(s))
length := 0
var match = map[rune]int{</p>
<blockquote>
<div><p>‘)’: 1,
‘(‘: -1,
‘]’: 2,
‘[‘: -2,
‘}’: 3,
‘{‘: -3,</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>for _, char := range s {</dt><dd><p>switch char {
case ‘(‘, ‘[‘, ‘{‘:</p>
<blockquote>
<div><p>stack[length] = match[char]
length++</p>
</div></blockquote>
<dl>
<dt>case ‘)’, ‘]’, ‘}’:</dt><dd><dl class="simple">
<dt>if length == 0 {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}
if stack[length-1]+match[char] != 0 {</p>
<blockquote>
<div><p>return false</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>length–</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
return length == 0</p>
</div></blockquote>
</div>
<div class="section" id="id86">
<h1>}<a class="headerlink" href="#id86" title="永久链接至标题">¶</a></h1>
<p>## 21.合并两个有序链表(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id87"><span class="problematic" id="id88">``</span></a>`
将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<p>示例：
输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4
输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4
<a href="#id89"><span class="problematic" id="id90">``</span></a><a href="#id91"><span class="problematic" id="id92">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.      | 思路     | 时间复杂度 | 空间复杂度 |</div>
<div class="line">——– | ——– | ———- | ———- |</div>
<div class="line">01(最优) | 迭代遍历 | O(n)       | O(1)       |</div>
<div class="line">02       | 递归实现 | O(n)       | O(n)       |</div>
</div>
<p><a href="#id93"><span class="problematic" id="id94">``</span></a><a href="#id95"><span class="problematic" id="id96">`</span></a>go
// 迭代遍历
func mergeTwoLists(l1 <a href="#id97"><span class="problematic" id="id98">*</span></a>ListNode, l2 <a href="#id99"><span class="problematic" id="id100">*</span></a>ListNode) <a href="#id101"><span class="problematic" id="id102">*</span></a>ListNode {</p>
<blockquote>
<div><dl class="simple">
<dt>if l1 == nil {</dt><dd><p>return l2</p>
</dd>
</dl>
<p>}
if l2 == nil {</p>
<blockquote>
<div><p>return l1</p>
</div></blockquote>
<p>}</p>
<p>var head, node <a href="#id103"><span class="problematic" id="id104">*</span></a>ListNode
if l1.Val &lt; l2.Val {</p>
<blockquote>
<div><p>head = l1
node = l1
l1 = l1.Next</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>head = l2
node = l2
l2 = l2.Next</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>for l1 != nil &amp;&amp; l2 != nil {</dt><dd><dl class="simple">
<dt>if l1.Val &lt; l2.Val {</dt><dd><p>node.Next = l1
l1 = l1.Next</p>
</dd>
<dt>} else {</dt><dd><p>node.Next = l2
l2 = l2.Next</p>
</dd>
</dl>
<p>}
node = node.Next</p>
</dd>
</dl>
<p>}
if l1 != nil {</p>
<blockquote>
<div><p>node.Next = l1</p>
</div></blockquote>
<p>}
if l2 != nil {</p>
<blockquote>
<div><p>node.Next = l2</p>
</div></blockquote>
<p>}
return head</p>
</div></blockquote>
<p>}</p>
<p>// 递归遍历
func mergeTwoLists(l1 <a href="#id105"><span class="problematic" id="id106">*</span></a>ListNode, l2 <a href="#id107"><span class="problematic" id="id108">*</span></a>ListNode) <a href="#id109"><span class="problematic" id="id110">*</span></a>ListNode {</p>
<blockquote>
<div><dl class="simple">
<dt>if l1 == nil {</dt><dd><p>return l2</p>
</dd>
</dl>
<p>}
if l2 == nil {</p>
<blockquote>
<div><p>return l1</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>if l1.Val &lt; l2.Val{</dt><dd><p>l1.Next = mergeTwoLists(l1.Next,l2)
return l1</p>
</dd>
<dt>}else {</dt><dd><p>l2.Next = mergeTwoLists(l1,l2.Next)
return l2</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
</div>
<div class="section" id="id111">
<h1>}<a class="headerlink" href="#id111" title="永久链接至标题">¶</a></h1>
<p>## 26.删除排序数组中的重复项(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id112"><span class="problematic" id="id113">``</span></a>`
给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<p>示例 1:
给定数组 nums = [1,1,2],
函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。
你不需要考虑数组中超出新长度后面的元素。</p>
<p>示例 2:
给定 nums = [0,0,1,1,1,2,2,3,3,4],
函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。
你不需要考虑数组中超出新长度后面的元素。</p>
<p>说明:
为什么返回数值是整数，但输出的答案是数组呢?
请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
你可以想象内部操作如下:
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);</p>
<p>// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i &lt; len; i++) {</p>
<blockquote>
<div><p>print(nums[i]);</p>
</div></blockquote>
</div>
<div class="section" id="id114">
<h1>}<a class="headerlink" href="#id114" title="永久链接至标题">¶</a></h1>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.      | 思路     | 时间复杂度 | 空间复杂度 |</div>
<div class="line">——– | ——– | ———- | ———- |</div>
<div class="line">01       | 双指针法 | O(n)       | O(1)       |</div>
<div class="line">02(最优) | 计数法   | O(n)       | O(1)       |</div>
</div>
<p><a href="#id115"><span class="problematic" id="id116">``</span></a><a href="#id117"><span class="problematic" id="id118">`</span></a>go
// 双指针法
func removeDuplicates(nums []int) int {</p>
<blockquote>
<div><p>i , j , length := 0, 1, len(nums)
for ; j &lt; length; j++{</p>
<blockquote>
<div><dl class="simple">
<dt>if nums[i] == nums[j]{</dt><dd><p>continue</p>
</dd>
</dl>
<p>}
i++
nums[i] = nums[j]</p>
</div></blockquote>
<p>}
return i+1</p>
</div></blockquote>
<p>}</p>
<p>// 计数法
func removeDuplicates(nums []int) int {</p>
<blockquote>
<div><p>count := 1
for i := 0; i &lt; len(nums)-1; i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if nums[i] != nums[i+1] {</dt><dd><p>nums[count] = nums[i+1]
count++</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return count</p>
</div></blockquote>
</div>
<div class="section" id="id119">
<h1>}<a class="headerlink" href="#id119" title="永久链接至标题">¶</a></h1>
<p>## 27.移除元素(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id120"><span class="problematic" id="id121">``</span></a>`
给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p>示例 1:
给定 nums = [3,2,2,3], val = 3,
函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。
你不需要考虑数组中超出新长度后面的元素。</p>
<p>示例 2:
给定 nums = [0,1,2,2,3,0,4,2], val = 2,
函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。
注意这五个元素可为任意顺序。
你不需要考虑数组中超出新长度后面的元素。
说明:
为什么返回数值是整数，但输出的答案是数组呢?
请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
你可以想象内部操作如下:
// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
int len = removeElement(nums, val);
// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i &lt; len; i++) {</p>
<blockquote>
<div><p>print(nums[i]);</p>
</div></blockquote>
</div>
<div class="section" id="id122">
<h1>}<a class="headerlink" href="#id122" title="永久链接至标题">¶</a></h1>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.      | 思路                         | 时间复杂度 | 空间复杂度 |</div>
<div class="line">——– | —————————- | ———- | ———- |</div>
<div class="line">01(最优) | 双指针，数字前移             | O(n)       | O(1)       |</div>
<div class="line">02       | 双指针，出现重复最后数字前移 | O(n)       | O(1)       |</div>
<div class="line">03       | 首位指针法                   | O(n)       | O(1)       |</div>
</div>
<p><a href="#id123"><span class="problematic" id="id124">``</span></a><a href="#id125"><span class="problematic" id="id126">`</span></a>go
// 双指针，数字前移
func removeElement(nums []int, val int) int {</p>
<blockquote>
<div><p>i := 0
for j := 0; j &lt; len(nums); j++{</p>
<blockquote>
<div><dl class="simple">
<dt>if nums[j] != val{</dt><dd><p>nums[i] = nums[j]
i++</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return i</p>
</div></blockquote>
<p>}</p>
<p>// 双指针，出现重复最后数字前移
func removeElement(nums []int, val int) int {</p>
<blockquote>
<div><p>i := 0
n := len(nums)
for i &lt; n{</p>
<blockquote>
<div><dl class="simple">
<dt>if nums[i] == val{</dt><dd><p>nums[i] = nums[n-1]
n–</p>
</dd>
<dt>}else {</dt><dd><p>i++</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return n</p>
</div></blockquote>
<p>}</p>
<p>// 首位指针法
func removeElement(nums []int, val int) int {</p>
<blockquote>
<div><p>i, j := 0, len(nums)-1
for {</p>
<blockquote>
<div><p>// 从左向右找到等于 val 的位置
for i &lt; len(nums) &amp;&amp; nums[i] != val {</p>
<blockquote>
<div><p>i++</p>
</div></blockquote>
<p>}
// 从右向左找到不等于 val 的位置
for j &gt;= 0 &amp;&amp; nums[j] == val {</p>
<blockquote>
<div><p>j–</p>
</div></blockquote>
<p>}
if i &gt;= j {</p>
<blockquote>
<div><p>break</p>
</div></blockquote>
<p>}
// fmt.Println(i,j)
nums[i], nums[j] = nums[j], nums[i]</p>
</div></blockquote>
<p>}
return i</p>
</div></blockquote>
</div>
<div class="section" id="id127">
<h1>}<a class="headerlink" href="#id127" title="永久链接至标题">¶</a></h1>
<p>## 28.实现strStr()(4)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id128"><span class="problematic" id="id129">``</span></a>`
实现 strStr() 函数。
给定一个 haystack 字符串和一个 needle 字符串，
在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。
如果不存在，则返回-1。</p>
<p>示例 1:
输入: haystack = “hello”, needle = “ll”
输出: 2</p>
<p>示例 2:
输入: haystack = “aaaaa”, needle = “bba”
输出: -1</p>
<p>说明:
当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。
对于本题而言，当 needle 是空字符串时我们应当返回 0 。
这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。
<a href="#id130"><span class="problematic" id="id131">``</span></a><a href="#id132"><span class="problematic" id="id133">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.      | 思路       | 时间复杂度 | 空间复杂度 |</div>
<div class="line">——– | ———- | ———- | ———- |</div>
<div class="line">01(最优) | Sunday算法 | O(n)       | O(1)       |</div>
<div class="line">02       | 直接匹配   | O(n)       | O(1)       |</div>
<div class="line">03       | 系统函数   | O(n)       | O(1)       |</div>
<div class="line">04       | kmp算法    | O(n)       | O(n)       |</div>
</div>
<p><a href="#id134"><span class="problematic" id="id135">``</span></a><a href="#id136"><span class="problematic" id="id137">`</span></a>go
// Sunday算法
func strStr(haystack string, needle string) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if needle == “”{</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
if len(needle) &gt; len(haystack){</p>
<blockquote>
<div><p>return -1</p>
</div></blockquote>
<p>}
// 计算模式串needle的偏移量
m := make(map[int32]int)
for k,v := range needle{</p>
<blockquote>
<div><p>m[v] = len(needle)-k</p>
</div></blockquote>
<p>}</p>
<p>index := 0
for index+len(needle) &lt;= len(haystack){</p>
<blockquote>
<div><p>// 匹配字符串
str := haystack[index:index+len(needle)]
if str == needle{</p>
<blockquote>
<div><p>return index</p>
</div></blockquote>
<dl>
<dt>}else {</dt><dd><dl class="simple">
<dt>if index + len(needle) &gt;= len(haystack){</dt><dd><p>return -1</p>
</dd>
</dl>
<p>}
// 后一位字符串
next := haystack[index+len(needle)]
if nextStep,ok := m[int32(next)];ok{</p>
<blockquote>
<div><p>index = index+nextStep</p>
</div></blockquote>
<dl class="simple">
<dt>}else {</dt><dd><p>index = index+len(needle)+1</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
if index + len(needle) &gt;= len(haystack){</p>
<blockquote>
<div><p>return -1</p>
</div></blockquote>
<dl class="simple">
<dt>}else {</dt><dd><p>return index</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>//
func strStr(haystack string, needle string) int {</p>
<blockquote>
<div><p>hlen, nlen := len(haystack), len(needle)
for i := 0; i &lt;= hlen-nlen; i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if haystack[i:i+nlen] == needle {</dt><dd><p>return i</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return -1</p>
</div></blockquote>
<p>}</p>
<p>//
func strStr(haystack string, needle string) int {</p>
<blockquote>
<div><p>return strings.Index(haystack, needle)</p>
</div></blockquote>
<p>}</p>
<p>//
func strStr(haystack string, needle string) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if len(needle) == 0 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}</p>
<p>next := getNext(needle)</p>
<p>i := 0
j := 0
for i &lt; len(haystack) &amp;&amp; j &lt; len(needle) {</p>
<blockquote>
<div><dl class="simple">
<dt>if j == -1 || haystack[i] == needle[j] {</dt><dd><p>i++
j++</p>
</dd>
<dt>} else {</dt><dd><p>j = next[j]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>if j == len(needle) {</dt><dd><p>return i - j</p>
</dd>
</dl>
<p>}
return -1</p>
</div></blockquote>
<p>}</p>
<p>// 求next数组
func getNext(str string) []int {</p>
<blockquote>
<div><p>var next = make([]int, len(str))
next[0] = -1</p>
<p>i := 0
j := -1</p>
<dl>
<dt>for i &lt; len(str)-1 {</dt><dd><dl class="simple">
<dt>if j == -1 || str[i] == str[j] {</dt><dd><p>i++
j++
next[i] = j</p>
</dd>
<dt>} else {</dt><dd><p>j = next[j]</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
return next</p>
</div></blockquote>
</div>
<div class="section" id="id138">
<h1>}<a class="headerlink" href="#id138" title="永久链接至标题">¶</a></h1>
<p>## 35.搜索插入位置(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id139"><span class="problematic" id="id140">``</span></a>`
给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。
如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>你可以假设数组中无重复元素。
示例 1: 输入: [1,3,5,6], 5 输出: 2
示例 2: 输入: [1,3,5,6], 2 输出: 1
示例 3: 输入: [1,3,5,6], 7 输出: 4
示例 4: 输入: [1,3,5,6], 0 输出: 0
<a href="#id141"><span class="problematic" id="id142">``</span></a><a href="#id143"><span class="problematic" id="id144">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.      | 思路     | 时间复杂度 | 空间复杂度 |</div>
<div class="line">——– | ——– | ———- | ———- |</div>
<div class="line">01(最优) | 二分查找 | O(log(n))  | O(1)       |</div>
<div class="line">02       | 顺序查找 | O(n)       | O(1)       |</div>
<div class="line">03       | 顺序查找 | O(n)       | O(1)       |</div>
</div>
<p><a href="#id145"><span class="problematic" id="id146">``</span></a><a href="#id147"><span class="problematic" id="id148">`</span></a>go
// 二分查找
func searchInsert(nums []int, target int) int {</p>
<blockquote>
<div><p>low, high := 0, len(nums)-1
for low &lt;= high {</p>
<blockquote>
<div><p>mid := (low + high) / 2
switch {
case nums[mid] &lt; target:</p>
<blockquote>
<div><p>low = mid + 1</p>
</div></blockquote>
<dl class="simple">
<dt>case nums[mid] &gt; target:</dt><dd><p>high = mid - 1</p>
</dd>
<dt>default:</dt><dd><p>return mid</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return low</p>
</div></blockquote>
<p>}</p>
<p>// 顺序查找
func searchInsert(nums []int, target int) int {</p>
<blockquote>
<div><p>i := 0
for i &lt; len(nums) &amp;&amp; nums[i] &lt; target {</p>
<blockquote>
<div><dl class="simple">
<dt>if nums[i] == target {</dt><dd><p>return i</p>
</dd>
</dl>
<p>}
i++</p>
</div></blockquote>
<p>}
return i</p>
</div></blockquote>
<p>}</p>
<p>// 顺序查找
func searchInsert(nums []int, target int) int {</p>
<blockquote>
<div><dl>
<dt>for i := 0; i &lt; len(nums); i++ {</dt><dd><dl class="simple">
<dt>if nums[i] &gt;= target {</dt><dd><p>return i</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
return len(nums)</p>
</div></blockquote>
</div>
<div class="section" id="id149">
<h1>}<a class="headerlink" href="#id149" title="永久链接至标题">¶</a></h1>
<p>## 38.报数(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id150"><span class="problematic" id="id151">``</span></a>`
报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：
1.     1
2.     11
3.     21
4.     1211
5.     111221</p>
<p>1 被读作  “one 1”  (“一个一”) , 即 11。
11 被读作 “two 1s” (“两个一”）, 即 21。
21 被读作 “one 2”,  “one 1” （”一个二” ,  “一个一”) , 即 1211。</p>
<p>给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。
注意：整数顺序将表示为一个字符串。</p>
<p>示例 1:输入: 1 输出: “1”
示例 2: 输入: 4 输出: “1211”
<a href="#id152"><span class="problematic" id="id153">``</span></a><a href="#id154"><span class="problematic" id="id155">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.       | 思路            | 时间复杂度 | 空间复杂度 |</div>
<div class="line">——— | ————— | ———- | ———- |</div>
<div class="line">01 (最优) | 递推+双指针计数 | O(n^2)     | O(1)       |</div>
<div class="line">02        | 递归+双指针计数 | O(n^2)     | O(n)       |</div>
</div>
<p><a href="#id156"><span class="problematic" id="id157">``</span></a><a href="#id158"><span class="problematic" id="id159">`</span></a>go
// 递推+双指针计数
func countAndSay(n int) string {</p>
<blockquote>
<div><p>strs := []byte{‘1’}
for i := 1; i &lt; n; i++ {</p>
<blockquote>
<div><p>strs = say(strs)</p>
</div></blockquote>
<p>}
return string(strs)</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func say(strs []byte) []byte {</dt><dd><p>result := make([]byte, 0, len(strs)*2)</p>
<p>i, j := 0, 1
for i &lt; len(strs) {</p>
<blockquote>
<div><dl class="simple">
<dt>for j &lt; len(strs) &amp;&amp; strs[i] == strs[j] {</dt><dd><p>j++</p>
</dd>
</dl>
<p>}
// 几个几
result = append(result, byte(j-i+’0’))
result = append(result, strs[i])
i = j</p>
</div></blockquote>
<p>}
return result</p>
</dd>
</dl>
<p>}</p>
<p>// 递归+双指针计数
func countAndSay(n int) string {</p>
<blockquote>
<div><dl class="simple">
<dt>if n == 1 {</dt><dd><p>return “1”</p>
</dd>
</dl>
<p>}
strs := countAndSay(n - 1)</p>
<p>result := make([]byte, 0, len(strs)*2)</p>
<p>i, j := 0, 1
for i &lt; len(strs) {</p>
<blockquote>
<div><dl class="simple">
<dt>for j &lt; len(strs) &amp;&amp; strs[i] == strs[j] {</dt><dd><p>j++</p>
</dd>
</dl>
<p>}
// 几个几
result = append(result, byte(j-i+’0’))
result = append(result, strs[i])
i = j</p>
</div></blockquote>
<p>}
return string(result)</p>
</div></blockquote>
</div>
<div class="section" id="id160">
<h1>}<a class="headerlink" href="#id160" title="永久链接至标题">¶</a></h1>
<p>## 53.最大子序和(5)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id161"><span class="problematic" id="id162">``</span></a>`
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:
输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>
<p>进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。
<a href="#id163"><span class="problematic" id="id164">``</span></a><a href="#id165"><span class="problematic" id="id166">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.      | 思路     | 时间复杂度 | 空间复杂度 |</div>
<div class="line">——– | ——– | ———- | ———- |</div>
<div class="line">01(最优) | 贪心法   | O(n)       | O(1)       |</div>
<div class="line">02       | 暴力法   | O(n^2)     | O(1)       |</div>
<div class="line">03       | 动态规划 | O(n)       | O(n)       |</div>
<div class="line">04       | 动态规划 | O(n)       | O(1)       |</div>
<div class="line">05       | 分治     | O(nlog(n)) | O(log(n))  |</div>
</div>
<p><a href="#id167"><span class="problematic" id="id168">``</span></a><a href="#id169"><span class="problematic" id="id170">`</span></a>go
// 贪心法
func maxSubArray(nums []int) int {</p>
<blockquote>
<div><p>result := nums[0]
sum := 0
for i := 0; i &lt; len(nums); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if sum &gt; 0 {</dt><dd><p>sum += nums[i]</p>
</dd>
<dt>} else {</dt><dd><p>sum = nums[i]</p>
</dd>
</dl>
<p>}
if sum &gt; result {</p>
<blockquote>
<div><p>result = sum</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return result</p>
</div></blockquote>
<p>}</p>
<p>// 暴力法
func maxSubArray(nums []int) int {</p>
<blockquote>
<div><p>result := math.MinInt32</p>
<dl>
<dt>for i := 0; i &lt; len(nums); i++ {</dt><dd><p>sum := 0
for j := i; j &lt; len(nums); j++ {</p>
<blockquote>
<div><p>sum += nums[j]
if sum &gt; result {</p>
<blockquote>
<div><p>result = sum</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}
return result</p>
</div></blockquote>
<p>}</p>
<p>//
func maxSubArray(nums []int) int {</p>
<blockquote>
<div><p>dp := make([]int, len(nums))
dp[0] = nums[0]
result := nums[0]</p>
<dl>
<dt>for i := 1; i &lt; len(nums); i++ {</dt><dd><dl class="simple">
<dt>if dp[i-1]+nums[i] &gt; nums[i] {</dt><dd><p>dp[i] = dp[i-1] + nums[i]</p>
</dd>
<dt>} else {</dt><dd><p>dp[i] = nums[i]</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>if dp[i] &gt; result {</dt><dd><p>result = dp[i]</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
return result</p>
</div></blockquote>
<p>}</p>
<p>// 动态规划
func maxSubArray(nums []int) int {</p>
<blockquote>
<div><p>dp := nums[0]
result := dp</p>
<dl>
<dt>for i := 1; i &lt; len(nums); i++ {</dt><dd><dl class="simple">
<dt>if dp+nums[i] &gt; nums[i] {</dt><dd><p>dp = dp + nums[i]</p>
</dd>
<dt>} else {</dt><dd><p>dp = nums[i]</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>if dp &gt; result {</dt><dd><p>result = dp</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
return result</p>
</div></blockquote>
<p>}</p>
<p>// 分治法
func maxSubArray(nums []int) int {</p>
<blockquote>
<div><p>result := maxSubArr(nums, 0, len(nums)-1)
return result</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func maxSubArr(nums []int, left, right int) int {</dt><dd><dl class="simple">
<dt>if left == right {</dt><dd><p>return nums[left]</p>
</dd>
</dl>
<p>}</p>
<p>mid := (left + right) / 2
leftSum := maxSubArr(nums, left, mid)        // 最大子序在左边
rightSum := maxSubArr(nums, mid+1, right)    // 最大子序在右边
midSum := findMaxArr(nums, left, mid, right) // 跨中心
result := max(leftSum, rightSum)
result = max(result, midSum)
return result</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func findMaxArr(nums []int, left, mid, right int) int {</dt><dd><p>leftSum := math.MinInt32
sum := 0
// 从右到左
for i := mid; i &gt;= left; i– {</p>
<blockquote>
<div><p>sum += nums[i]
leftSum = max(leftSum, sum)</p>
</div></blockquote>
<p>}</p>
<p>rightSum := math.MinInt32
sum = 0
// 从左到右
for i := mid + 1; i &lt;= right; i++ {</p>
<blockquote>
<div><p>sum += nums[i]
rightSum = max(rightSum, sum)</p>
</div></blockquote>
<p>}
return leftSum + rightSum</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func max(a, b int) int {</dt><dd><dl class="simple">
<dt>if a &gt; b {</dt><dd><p>return a</p>
</dd>
</dl>
<p>}
return b</p>
</dd>
</dl>
</div>
<div class="section" id="id171">
<h1>}<a class="headerlink" href="#id171" title="永久链接至标题">¶</a></h1>
<p>## 58.最后一个单词的长度(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id172"><span class="problematic" id="id173">``</span></a>`
给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串，返回其最后一个单词的长度。
如果不存在最后一个单词，请返回 0 。
说明：一个单词是指由字母组成，但不包含任何空格的字符串。</p>
<p>示例: 输入: “Hello World” 输出: 5
<a href="#id174"><span class="problematic" id="id175">``</span></a><a href="#id176"><span class="problematic" id="id177">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.      | 思路                                 | 时间复杂度 | 空间复杂度 |</div>
<div class="line">——– | ———————————— | ———- | ———- |</div>
<div class="line">01(最优) | 调用系统函数，切割为数组取最后一个值 | O(n)       | O(1)       |</div>
<div class="line">02       | 遍历统计                             | O(n)       | O(1)       |</div>
</div>
<p><a href="#id178"><span class="problematic" id="id179">``</span></a><a href="#id180"><span class="problematic" id="id181">`</span></a>go
// 调用系统函数，切割为数组取最后一个值
func lengthOfLastWord(s string) int {</p>
<blockquote>
<div><p>arr := strings.Split(strings.Trim(s, ” “), ” “)
return len(arr[len(arr)-1])</p>
</div></blockquote>
<p>}</p>
<p>// 遍历统计
func lengthOfLastWord(s string) int {</p>
<blockquote>
<div><p>length := len(s)
if length == 0 {</p>
<blockquote>
<div><p>return 0</p>
</div></blockquote>
<p>}</p>
<p>result := 0
for i := length - 1; i &gt;= 0; i– {</p>
<blockquote>
<div><dl>
<dt>if s[i] == ‘ ‘ {</dt><dd><dl class="simple">
<dt>if result &gt; 0 {</dt><dd><p>return result</p>
</dd>
</dl>
<p>}
continue</p>
</dd>
</dl>
<p>}
result++</p>
</div></blockquote>
<p>}
return result</p>
</div></blockquote>
</div>
<div class="section" id="id182">
<h1>}<a class="headerlink" href="#id182" title="永久链接至标题">¶</a></h1>
<p>## 66.加一(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id183"><span class="problematic" id="id184">``</span></a>`
给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。
最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。
你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<p>示例 1: 输入: [1,2,3] 输出: [1,2,4] 解释: 输入数组表示数字 123。
示例 2: 输入: [4,3,2,1] 输出: [4,3,2,2] 解释: 输入数组表示数字 4321。
<a href="#id185"><span class="problematic" id="id186">``</span></a><a href="#id187"><span class="problematic" id="id188">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.      | 思路     | 时间复杂度 | 空间复杂度 |</div>
<div class="line">——– | ——– | ———- | ———- |</div>
<div class="line">01       | 直接模拟 | O(n)       | O(1)       |</div>
<div class="line">02(最优) | 直接模拟 | O(n)       | O(1)       |</div>
</div>
<p><a href="#id189"><span class="problematic" id="id190">``</span></a><a href="#id191"><span class="problematic" id="id192">`</span></a>go
// 模拟进位
func plusOne(digits []int) []int {</p>
<blockquote>
<div><p>length := len(digits)
if length == 0 {</p>
<blockquote>
<div><p>return []int{1}</p>
</div></blockquote>
<p>}</p>
<p>digits[length-1]++
for i := length - 1; i &gt; 0; i– {</p>
<blockquote>
<div><dl class="simple">
<dt>if digits[i] &lt; 10 {</dt><dd><p>break</p>
</dd>
</dl>
<p>}
digits[i] = digits[i] - 10
digits[i-1]++</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>if digits[0] &gt; 9 {</dt><dd><p>digits[0] = digits[0] - 10
digits = append([]int{1}, digits…)</p>
</dd>
</dl>
<p>}</p>
<p>return digits</p>
</div></blockquote>
<p>}</p>
<p>// 模拟进位
func plusOne(digits []int) []int {</p>
<blockquote>
<div><dl>
<dt>for i := len(digits) - 1; i &gt;= 0; i– {</dt><dd><dl class="simple">
<dt>if digits[i] &lt; 9 {</dt><dd><p>digits[i]++
return digits</p>
</dd>
<dt>} else {</dt><dd><p>digits[i] = 0</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
return append([]int{1}, digits…)</p>
</div></blockquote>
</div>
<div class="section" id="id193">
<h1>}<a class="headerlink" href="#id193" title="永久链接至标题">¶</a></h1>
<p>## 67.二进制求和(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id194"><span class="problematic" id="id195">``</span></a>`
给定两个二进制字符串，返回他们的和（用二进制表示）。
输入为非空字符串且只包含数字 1 和 0。</p>
<p>示例 1: 输入: a = “11”, b = “1” 输出: “100”
示例 2:输入: a = “1010”, b = “1011” 输出: “10101”
<a href="#id196"><span class="problematic" id="id197">``</span></a><a href="#id198"><span class="problematic" id="id199">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.      | 思路           | 时间复杂度 | 空间复杂度 |</div>
<div class="line">——– | ————– | ———- | ———- |</div>
<div class="line">01       | 转换成数组模拟 | O(n)       | O(n)       |</div>
<div class="line">02(最优) | 直接模拟       | O(n)       | O(1)       |</div>
</div>
<p><a href="#id200"><span class="problematic" id="id201">``</span></a><a href="#id202"><span class="problematic" id="id203">`</span></a>go
// 转换成数组模拟
func addBinary(a string, b string) string {</p>
<blockquote>
<div><dl class="simple">
<dt>if len(a) &lt; len(b) {</dt><dd><p>a, b = b, a</p>
</dd>
</dl>
<p>}
length := len(a)</p>
<p>A := transToInt(a, length)
B := transToInt(b, length)</p>
<p>return makeString(add(A, B))</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func transToInt(s string, length int) []int {</dt><dd><p>result := make([]int, length)
ls := len(s)
for i, b := range s {</p>
<blockquote>
<div><p>result[length-ls+i] = int(b - ‘0’)</p>
</div></blockquote>
<p>}
return result</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func add(a, b []int) []int {</dt><dd><p>length := len(a) + 1
result := make([]int, length)
for i := length - 1; i &gt;= 1; i– {</p>
<blockquote>
<div><p>temp := result[i] + a[i-1] + b[i-1]
result[i] = temp % 2
result[i-1] = temp / 2</p>
</div></blockquote>
<p>}
i := 0
for i &lt; length-1 &amp;&amp; result[i] == 0 {</p>
<blockquote>
<div><p>i++</p>
</div></blockquote>
<p>}
return result[i:]</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func makeString(nums []int) string {</dt><dd><p>bytes := make([]byte, len(nums))
for i := range bytes {</p>
<blockquote>
<div><p>bytes[i] = byte(nums[i]) + ‘0’</p>
</div></blockquote>
<p>}
return string(bytes)</p>
</dd>
</dl>
<p>}</p>
<p>// 直接模拟
func addBinary(a string, b string) string {</p>
<blockquote>
<div><p>i := len(a) - 1
j := len(b) - 1
result := “”
flag := 0
current := 0</p>
<dl>
<dt>for i &gt;= 0 || j &gt;= 0 {</dt><dd><p>intA, intB := 0, 0
if i &gt;= 0 {</p>
<blockquote>
<div><p>intA = int(a[i] - ‘0’)</p>
</div></blockquote>
<p>}
if j &gt;= 0 {</p>
<blockquote>
<div><p>intB = int(b[j] - ‘0’)</p>
</div></blockquote>
<p>}
current = intA + intB + flag
flag = 0
if current &gt;= 2 {</p>
<blockquote>
<div><p>flag = 1
current = current - 2</p>
</div></blockquote>
<p>}
cur := strconv.Itoa(current)
result = cur + result
i–
j–</p>
</dd>
</dl>
<p>}
if flag == 1 {</p>
<blockquote>
<div><p>result = “1” + result</p>
</div></blockquote>
<p>}
return result</p>
</div></blockquote>
</div>
<div class="section" id="id204">
<h1>}<a class="headerlink" href="#id204" title="永久链接至标题">¶</a></h1>
<p>## 69.x的平方根 (5)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id205"><span class="problematic" id="id206">``</span></a>`
实现 int sqrt(int x) 函数。
计算并返回 x 的平方根，其中 x 是非负整数。
由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<p>示例 1:
输入: 4
输出: 2</p>
<p>示例 2:
输入: 8
输出: 2
说明: 8 的平方根是 2.82842…,</p>
<blockquote>
<div><p>由于返回类型是整数，小数部分将被舍去。</p>
</div></blockquote>
<p><a href="#id207"><span class="problematic" id="id208">``</span></a><a href="#id209"><span class="problematic" id="id210">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.      | 思路        | 时间复杂度 | 空间复杂度 |</div>
<div class="line">——– | ———– | ———- | ———- |</div>
<div class="line">01       | 系统函数    | O(log(n))  | O(1)       |</div>
<div class="line">02       | 系统函数    | O(log(n))  | O(1)       |</div>
<div class="line">03(最优) | 牛顿迭代法  | O(log(n))  | O(1)       |</div>
<div class="line">04       | 二分查找法  | O(log(n))  | O(1)       |</div>
<div class="line">05       | 暴力法:遍历 | O(n)       | O(1)       |</div>
</div>
<p><a href="#id211"><span class="problematic" id="id212">``</span></a><a href="#id213"><span class="problematic" id="id214">`</span></a>go
// 系统函数
func mySqrt(x int) int {</p>
<blockquote>
<div><p>result := int(math.Sqrt(float64(x)))
return result</p>
</div></blockquote>
<p>}</p>
<p>// 系统函数
func mySqrt(x int) int {</p>
<blockquote>
<div><p>result := math.Floor(math.Sqrt(float64(x)))
return int(result)</p>
</div></blockquote>
<p>}</p>
<p>// 牛顿迭代法
func mySqrt(x int) int {</p>
<blockquote>
<div><p>result := x
for result*result &gt; x {</p>
<blockquote>
<div><p>result = (result + x/result) / 2</p>
</div></blockquote>
<p>}
return result</p>
</div></blockquote>
<p>}</p>
<p>// 二分查找法
func mySqrt(x int) int {</p>
<blockquote>
<div><p>left := 1
right := x
for left &lt;= right {</p>
<blockquote>
<div><p>mid := (left + right) / 2
if mid == x/mid {</p>
<blockquote>
<div><p>return mid</p>
</div></blockquote>
<dl class="simple">
<dt>} else if mid &lt; x/mid {</dt><dd><p>left = mid + 1</p>
</dd>
<dt>} else {</dt><dd><p>right = mid - 1</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
if left * left &lt;= x{</p>
<blockquote>
<div><p>return left</p>
</div></blockquote>
<dl class="simple">
<dt>}else {</dt><dd><p>return left-1</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// 暴力法:遍历
func mySqrt(x int) int {</p>
<blockquote>
<div><p>result := 0
for i := 1; i &lt;= x/i; i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if i*i == x {</dt><dd><p>return i</p>
</dd>
</dl>
<p>}
result = i</p>
</div></blockquote>
<p>}
return result</p>
</div></blockquote>
</div>
<div class="section" id="id215">
<h1>}<a class="headerlink" href="#id215" title="永久链接至标题">¶</a></h1>
<p>## 70.爬楼梯(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id216"><span class="problematic" id="id217">``</span></a>`
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
注意：给定 n 是一个正整数。</p>
<p>示例 1： 输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶</p>
<p>示例 2： 输入： 3 输出： 3 解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
<a href="#id218"><span class="problematic" id="id219">``</span></a><a href="#id220"><span class="problematic" id="id221">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.      | 思路     | 时间复杂度 | 空间复杂度 |</div>
<div class="line">——– | ——– | ———- | ———- |</div>
<div class="line">01       | 递归     | O(n)       | O(n)       |</div>
<div class="line">02       | 动态规划 | O(n)       | O(n)       |</div>
<div class="line">03(最优) | 斐波那契 | O(n)       | O(1)       |</div>
</div>
<p><a href="#id222"><span class="problematic" id="id223">``</span></a><a href="#id224"><span class="problematic" id="id225">`</span></a>go
// 递归
var arr []int</p>
<dl class="simple">
<dt>func climbStairs(n int) int {</dt><dd><p>arr = make([]int, n+1)
return climbStart(0, n)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func climbStart(i, n int) int {</dt><dd><dl class="simple">
<dt>if i &gt; n {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
if i == n {</p>
<blockquote>
<div><p>return 1</p>
</div></blockquote>
<p>}
if arr[i] &gt; 0 {</p>
<blockquote>
<div><p>return arr[i]</p>
</div></blockquote>
<p>}
arr[i] = climbStart(i+1, n) + climbStart(i+2, n)
return arr[i]</p>
</dd>
</dl>
<p>}</p>
<p>// 动态规划
func climbStairs(n int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if n == 1 {</dt><dd><p>return 1</p>
</dd>
</dl>
<p>}
if n == 2 {</p>
<blockquote>
<div><p>return 2</p>
</div></blockquote>
<p>}
dp := make([]int, n+1)
dp[1] = 1
dp[2] = 2
for i := 3; i &lt;= n; i++ {</p>
<blockquote>
<div><p>dp[i] = dp[i-1] + dp[i-2]</p>
</div></blockquote>
<p>}
return dp[n]</p>
</div></blockquote>
<p>}</p>
<p>// 斐波那契
func climbStairs(n int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if n == 1 {</dt><dd><p>return 1</p>
</dd>
</dl>
<p>}
first := 1
second := 2
for i := 3; i &lt;= n; i++ {</p>
<blockquote>
<div><p>third := first + second
first = second
second = third</p>
</div></blockquote>
<p>}
return second</p>
</div></blockquote>
</div>
<div class="section" id="id226">
<h1>}<a class="headerlink" href="#id226" title="永久链接至标题">¶</a></h1>
<p>## 83.删除排序链表中的重复元素(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id227"><span class="problematic" id="id228">``</span></a>`
给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p>
<p>示例 1:
输入: 1-&gt;1-&gt;2
输出: 1-&gt;2</p>
<p>示例 2:
输入: 1-&gt;1-&gt;2-&gt;3-&gt;3
输出: 1-&gt;2-&gt;3
<a href="#id229"><span class="problematic" id="id230">``</span></a><a href="#id231"><span class="problematic" id="id232">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.       | 思路     | 时间复杂度 | 空间复杂度 |</div>
<div class="line">——— | ——– | ———- | ———- |</div>
<div class="line">01( 最优) | 直接法   | O(n)       | O(1)       |</div>
<div class="line">02        | 递归法   | O(n)       | O(1)       |</div>
<div class="line">03        | 双指针法 | O(n)       | O(1)       |</div>
</div>
<p><a href="#id233"><span class="problematic" id="id234">``</span></a><a href="#id235"><span class="problematic" id="id236">`</span></a>go
// 直接法
func deleteDuplicates(head <a href="#id237"><span class="problematic" id="id238">*</span></a>ListNode) <a href="#id239"><span class="problematic" id="id240">*</span></a>ListNode {</p>
<blockquote>
<div><dl class="simple">
<dt>if head == nil {</dt><dd><p>return nil</p>
</dd>
</dl>
<p>}
temp := head
for temp.Next != nil {</p>
<blockquote>
<div><dl class="simple">
<dt>if temp.Val == temp.Next.Val {</dt><dd><p>temp.Next = temp.Next.Next</p>
</dd>
<dt>} else {</dt><dd><p>temp = temp.Next</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return head</p>
</div></blockquote>
<p>}</p>
<p>// 递归法
func deleteDuplicates(head <a href="#id241"><span class="problematic" id="id242">*</span></a>ListNode) <a href="#id243"><span class="problematic" id="id244">*</span></a>ListNode {</p>
<blockquote>
<div><dl class="simple">
<dt>if head == nil || head.Next == nil{</dt><dd><p>return head</p>
</dd>
</dl>
<p>}
head.Next = deleteDuplicates(head.Next)
if head.Val == head.Next.Val{</p>
<blockquote>
<div><p>head = head.Next</p>
</div></blockquote>
<p>}
return head</p>
</div></blockquote>
<p>}</p>
<p>// 双指针法
func deleteDuplicates(head <a href="#id245"><span class="problematic" id="id246">*</span></a>ListNode) <a href="#id247"><span class="problematic" id="id248">*</span></a>ListNode {</p>
<blockquote>
<div><dl class="simple">
<dt>if head == nil || head.Next == nil{</dt><dd><p>return head</p>
</dd>
</dl>
<p>}
p := head
q := head.Next
for p.Next != nil{</p>
<blockquote>
<div><dl>
<dt>if p.Val == q.Val{</dt><dd><dl class="simple">
<dt>if q.Next == nil{</dt><dd><p>p.Next = nil</p>
</dd>
<dt>}else {</dt><dd><p>p.Next = q.Next
q = q.Next</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>}else {</dt><dd><p>p = p.Next
q = q.Next</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return head</p>
</div></blockquote>
</div>
<div class="section" id="id249">
<h1>}<a class="headerlink" href="#id249" title="永久链接至标题">¶</a></h1>
<p>## 88.合并两个有序数组(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id250"><span class="problematic" id="id251">``</span></a>`
给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。
说明:</p>
<blockquote>
<div><p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n。
你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</p>
</div></blockquote>
<p>示例:
输入:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3
输出: [1,2,2,3,5,6]
<a href="#id252"><span class="problematic" id="id253">``</span></a><a href="#id254"><span class="problematic" id="id255">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.      | 思路       | 时间复杂度 | 空间复杂度 |</div>
<div class="line">——– | ———- | ———- | ———- |</div>
<div class="line">01       | 合并后排序 | O(nlog(n)) | O(1)       |</div>
<div class="line">02(最优) | 双指针法   | O(n)       | O(1)       |</div>
<div class="line">03       | 拷贝后插入 | O(n)       | O(n)       |</div>
</div>
<p><a href="#id256"><span class="problematic" id="id257">``</span></a><a href="#id258"><span class="problematic" id="id259">`</span></a>go
// 合并后排序
func merge(n ums1 []int, m int, nums2 []int, n int) {</p>
<blockquote>
<div><p>nums1 = nums1[:m]
nums1 = append(nums1, nums2[:n]…)
sort.Ints(nums1)</p>
</div></blockquote>
<p>}</p>
<p>// 双指针法
func merge(nums1 []int, m int, nums2 []int, n int) {</p>
<blockquote>
<div><dl>
<dt>for m &gt; 0 &amp;&amp; n &gt; 0 {</dt><dd><dl class="simple">
<dt>if nums1[m-1] &lt; nums2[n-1] {</dt><dd><p>nums1[m+n-1] = nums2[n-1]
n–</p>
</dd>
<dt>} else {</dt><dd><p>nums1[m+n-1] = nums1[m-1]
m–</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
if m == 0 &amp;&amp; n &gt; 0 {</p>
<blockquote>
<div><dl class="simple">
<dt>for n &gt; 0 {</dt><dd><p>nums1[n-1] = nums2[n-1]
n–</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// 拷贝后插入
func merge(nums1 []int, m int, nums2 []int, n int) {</p>
<blockquote>
<div><p>temp := make([]int, m)
copy(temp, nums1)</p>
<dl class="simple">
<dt>if n == 0 {</dt><dd><p>return</p>
</dd>
</dl>
<p>}
first, second := 0, 0
for i := 0; i &lt; len(nums1); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if second &gt;= n {</dt><dd><p>nums1[i] = temp[first]
first++
continue</p>
</dd>
</dl>
<p>}
if first &gt;= m {</p>
<blockquote>
<div><p>nums1[i] = nums2[second]
second++
continue</p>
</div></blockquote>
<p>}
if temp[first] &lt; nums2[second] {</p>
<blockquote>
<div><p>nums1[i] = temp[first]
first++</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>nums1[i] = nums2[second]
second++</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
</div>
<div class="section" id="id260">
<h1>}<a class="headerlink" href="#id260" title="永久链接至标题">¶</a></h1>
<p>## 100.相同的树(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id261"><span class="problematic" id="id262">``</span></a>`
给定两个二叉树，编写一个函数来检验它们是否相同。
如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<p>示例 1:
输入:       1         1</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>/       / </p>
</div></blockquote>
<p>2   3     2   3</p>
</div></blockquote>
<p>[1,2,3],   [1,2,3]</p>
</div></blockquote>
<p>输出: true</p>
<p>示例 2:
输入:      1          1</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>/           </p>
</div></blockquote>
<p>2             2</p>
</div></blockquote>
<p>[1,2],     [1,null,2]</p>
</div></blockquote>
<p>输出: false</p>
<p>示例 3:
输入:       1         1</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>/       / </p>
</div></blockquote>
<p>2   1     1   2</p>
</div></blockquote>
<p>[1,2,1],   [1,1,2]</p>
</div></blockquote>
<p>输出: false
<a href="#id263"><span class="problematic" id="id264">``</span></a><a href="#id265"><span class="problematic" id="id266">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路               | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —————— | ———- | ———- |</div>
<div class="line">01   | 递归(深度优先)     | O(n)       | O(log(n))  |</div>
<div class="line">02   | 层序遍历(宽度优先) | O(n)       | O(log(n))  |</div>
</div>
<p><a href="#id267"><span class="problematic" id="id268">``</span></a><a href="#id269"><span class="problematic" id="id270">`</span></a>go
// 递归(深度优先)
func isSameTree(p <a href="#id271"><span class="problematic" id="id272">*</span></a>TreeNode, q <a href="#id273"><span class="problematic" id="id274">*</span></a>TreeNode) bool {</p>
<blockquote>
<div><dl class="simple">
<dt>if p == nil &amp;&amp; q == nil {</dt><dd><p>return true</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>if p == nil || q == nil {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>return p.Val == q.Val &amp;&amp; isSameTree(p.Left, q.Left) &amp;&amp;</dt><dd><p>isSameTree(p.Right, q.Right)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<p>// 层序遍历(宽度优先)
func isSameTree(p <a href="#id275"><span class="problematic" id="id276">*</span></a>TreeNode, q <a href="#id277"><span class="problematic" id="id278">*</span></a>TreeNode) bool {</p>
<blockquote>
<div><dl class="simple">
<dt>if p == nil &amp;&amp; q == nil {</dt><dd><p>return true</p>
</dd>
</dl>
<p>}
if p == nil || q == nil {</p>
<blockquote>
<div><p>return false</p>
</div></blockquote>
<p>}</p>
<p>var queueP, queueQ []*TreeNode
if p != nil {</p>
<blockquote>
<div><p>queueP = append(queueP, p)
queueQ = append(queueQ, q)</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>for len(queueP) &gt; 0 &amp;&amp; len(queueQ) &gt; 0 {</dt><dd><p>tempP := queueP[0]
queueP = queueP[1:]</p>
<p>tempQ := queueQ[0]
queueQ = queueQ[1:]</p>
<dl class="simple">
<dt>if tempP.Val != tempQ.Val {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>if (tempP.Left != nil &amp;&amp; tempQ.Left == nil) ||</dt><dd><p>(tempP.Left == nil &amp;&amp; tempQ.Left != nil) {
return false</p>
</dd>
</dl>
<p>}
if tempP.Left != nil {</p>
<blockquote>
<div><p>queueP = append(queueP, tempP.Left)
queueQ = append(queueQ, tempQ.Left)</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>if (tempP.Right != nil &amp;&amp; tempQ.Right == nil) ||</dt><dd><p>(tempP.Right == nil &amp;&amp; tempQ.Right != nil) {
return false</p>
</dd>
</dl>
<p>}
if tempP.Right != nil {</p>
<blockquote>
<div><p>queueP = append(queueP, tempP.Right)
queueQ = append(queueQ, tempQ.Right)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}
return true</p>
</div></blockquote>
</div>
<div class="section" id="id279">
<h1>}<a class="headerlink" href="#id279" title="永久链接至标题">¶</a></h1>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, willshang

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>