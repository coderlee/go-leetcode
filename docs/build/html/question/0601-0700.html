

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh-CN" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh-CN" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>} &mdash; go-leetcode v1.0.0 文档</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="}" href="0701-0800.html" />
    <link rel="prev" title="}" href="0501-0600.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> go-leetcode
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id20">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id31">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id42">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id53">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id86">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id111">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id114">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id119">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id122">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id127">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id138">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id149">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id160">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id171">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id182">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id193">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id204">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id215">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id226">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id249">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id260">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id279">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id24">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id25">]</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id48">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id65">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id80">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id95">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id112">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id115">]</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id120">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id131">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id142">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id153">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id164">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id175">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id192">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id219">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id250">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id261">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id272">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id283">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id294">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id305">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id316">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id327">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id350">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id18">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id23">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id34">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id51">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id62">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id73">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id138">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id157">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id168">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id217">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id234">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id253">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id266">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id277">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id296">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id301">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id312">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id323">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id334">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id345">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id356">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id367">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id378">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id20">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id25">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id36">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id47">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id58">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id69">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id74">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id79">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id90">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id101">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id106">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id111">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id124">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id26">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id37">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id42">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id45">]</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id50">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id55">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id66">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id71">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id100">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id105">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id116">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id127">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id138">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id143">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id154">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id159">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id170">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id181">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id192">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id203">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id214">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id225">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id236">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id247">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id258">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id24">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id35">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id40">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id51">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id62">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id73">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id98">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id109">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id138">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id149">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id170">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id181">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id192">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id207">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id218">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id235">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id246">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id273">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id284">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id295">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id306">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id323">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id328">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id339">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id350">}</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id28">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id51">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id62">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id67">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id84">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id95">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id106">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id133">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id144">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id155">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id166">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id185">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id204">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id209">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id220">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id231">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id242">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id267">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id280">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id287">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id298">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id309">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id328">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id46">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id85">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id96">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id111">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id122">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id133">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id146">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id157">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id170">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id181">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id192">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id203">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id214">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id225">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id252">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id263">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id274">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id285">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id22">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id33">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id44">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id55">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id66">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id77">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id82">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id93">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id104">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id115">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id126">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id137">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id148">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id159">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id170">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id181">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id186">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id221">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id232">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id255">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id266">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id277">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id288">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id299">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id310">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id321">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id356">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id22">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id33">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id44">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id55">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id66">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id77">}</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">go-leetcode</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>}</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/question/0601-0700.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <p># 0601-0700-Easy</p>
<ul class="simple">
<li><dl class="simple">
<dt>[0601-0700-Easy](#0601-0700-easy)</dt><dd><ul>
<li><p>[605.种花问题(3)](#605种花问题3)</p></li>
<li><p>[606.根据二叉树创建字符串(2)](#606根据二叉树创建字符串2)</p></li>
<li><p>[617.合并二叉树(2)](#617合并二叉树2)</p></li>
<li><p>[628.三个数的最大乘积(2)](#628三个数的最大乘积2)</p></li>
<li><p>[633.平方数之和(2)](#633平方数之和2)</p></li>
<li><p>[637.二叉树的层平均值(2)](#637二叉树的层平均值2)</p></li>
<li><p>[643.子数组最大平均数 I(3)](#643子数组最大平均数-i3)</p></li>
<li><p>[645.错误的集合(5)](#645错误的集合5)</p></li>
<li><p>[653.两数之和IV输入BST(4)](#653两数之和iv输入bst4)</p></li>
<li><p>[657.机器人能否返回原点(2)](#657机器人能否返回原点2)</p></li>
<li><p>[661.图片平滑器(2)](#661图片平滑器2)</p></li>
<li><p>[665.非递减数列(3)](#665非递减数列3)</p></li>
<li><p>[669.修剪二叉搜索树(2)](#669修剪二叉搜索树2)</p></li>
<li><p>[671.二叉树中第二小的节点(3)](#671二叉树中第二小的节点3)</p></li>
<li><p>[674.最长连续递增序列(3)](#674最长连续递增序列3)</p></li>
<li><p>[680.验证回文字符串 Ⅱ(2)](#680验证回文字符串-ⅱ2)</p></li>
<li><p>[682.棒球比赛(1)](#682棒球比赛1)</p></li>
<li><p>[686.重复叠加字符串匹配(2)](#686重复叠加字符串匹配2)</p></li>
<li><p>[687.最长同值路径(3)](#687最长同值路径3)</p></li>
<li><p>[690.员工的重要性(2)](#690员工的重要性2)</p></li>
<li><p>[693.交替位二进制数(4)](#693交替位二进制数4)</p></li>
<li><p>[696.计数二进制子串(3)](#696计数二进制子串3)</p></li>
<li><p>[697.数组的度(3)](#697数组的度3)</p></li>
<li><p>[700.二叉搜索树中的搜索(2)](#700二叉搜索树中的搜索2)</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>## 605.种花问题(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">``</span></a>`
假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。
可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。
给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。
能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。</p>
<p>示例 1:输入: flowerbed = [1,0,0,0,1], n = 1 输出: True
示例 2:输入: flowerbed = [1,0,0,0,1], n = 2 输出: False</p>
<dl class="simple">
<dt>注意:</dt><dd><p>数组内已种好的花不会违反种植规则。
输入的数组长度范围为 [1, 20000]。
n 是非负整数，且不会超过输入数组的大小。</p>
</dd>
</dl>
<p><a href="#id3"><span class="problematic" id="id4">``</span></a><a href="#id5"><span class="problematic" id="id6">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路          | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ————- | ———- | ———- |</div>
<div class="line">01   | 遍历          | O(n)       | O(1)       |</div>
<div class="line">02   | 遍历统计      | O(n)       | O(1)       |</div>
<div class="line">03   | 补数+遍历统计 | O(n)       | O(1)       |</div>
</div>
<p><a href="#id7"><span class="problematic" id="id8">``</span></a><a href="#id9"><span class="problematic" id="id10">`</span></a>go
func canPlaceFlowers(flowerbed []int, n int) bool {</p>
<blockquote>
<div><p>length := len(flowerbed)
// 判断条件
// 1:当前元素是0
// 2.前一个元素是0，或者当前是第一个元素
// 3.后一个元素是0，或者当前是最后一个元素
for i := 0; i &lt; length; i++ {</p>
<blockquote>
<div><dl>
<dt>if flowerbed[i] == 0 &amp;&amp;</dt><dd><p>(i == 0 || flowerbed[i-1] == 0) &amp;&amp;
(i == length-1 || flowerbed[i+1] == 0) {
flowerbed[i] = 1
n–
if n &lt;= 0 {</p>
<blockquote>
<div><p>return true</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return n &lt;= 0</p>
</div></blockquote>
<p>}</p>
<p>#
func canPlaceFlowers(flowerbed []int, n int) bool {</p>
<blockquote>
<div><p>length := len(flowerbed)
count := 0
temp := 1
// 以0开头，计算情况同以0结束，为向中间情况靠齐，可以特殊处理把temp初始化为1
// 中间计算可以种花，value = (temp-1)/2
// 最后结束如果为偶数, value=temp/2
for i := 0; i &lt; length; i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if flowerbed[i] == 1 {</dt><dd><p>count = count + (temp-1)/2
temp = 0</p>
</dd>
<dt>} else {</dt><dd><p>temp++</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
count = count + temp/2
return n &lt;= count</p>
</div></blockquote>
<p>}</p>
<p>#
func canPlaceFlowers(flowerbed []int, n int) bool {</p>
<blockquote>
<div><p>flowerbed = append([]int{0}, flowerbed…)
flowerbed = append(flowerbed, []int{0, 1}…)
count := 0
temp := 0
// 首补0，尾补0，1，统一一种情况
for i := 0; i &lt; len(flowerbed); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if flowerbed[i] == 1 {</dt><dd><p>count = count + (temp-1)/2
temp = 0</p>
</dd>
<dt>} else {</dt><dd><p>temp++</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return n &lt;= count</p>
</div></blockquote>
<div class="section" id="id11">
<h1>}<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h1>
<p>## 606.根据二叉树创建字符串(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id12"><span class="problematic" id="id13">``</span></a>`
你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。
空节点则用一对空括号 “()” 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。
示例 1:
输入: 二叉树: [1,2,3,4]</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><p>1</p>
</div></blockquote>
<p>/   </p>
</div></blockquote>
<p>2     3</p>
</div></blockquote>
<p>/</p>
</div></blockquote>
<p>4</p>
</div></blockquote>
<p>输出: “1(2(4))(3)”
解释: 原本将是“1(2(4)())(3())”，
在你省略所有不必要的空括号对之后，
它将是“1(2(4))(3)”。
示例 2:
输入: 二叉树: [1,2,3,null,4]</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>1</p>
</div></blockquote>
<p>/   </p>
</div></blockquote>
<dl class="simple">
<dt>2     3</dt><dd><dl class="simple">
<dt></dt><dd><p>4</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>输出: “1(2()(4))(3)”
解释: 和第一个示例相似，
除了我们不能省略第一个对括号来中断输入和输出之间的一对一映射关系。
<a href="#id14"><span class="problematic" id="id15">``</span></a><a href="#id16"><span class="problematic" id="id17">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路 | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —- | ———- | ———- |</div>
<div class="line">01   | 递归 | O(n)       | O(log(n))  |</div>
<div class="line">02   | 迭代 | O(n)       | O(n)       |</div>
</div>
<p><a href="#id18"><span class="problematic" id="id19">``</span></a><a href="#id20"><span class="problematic" id="id21">`</span></a>go
func tree2str(t <a href="#id22"><span class="problematic" id="id23">*</span></a>TreeNode) string {</p>
<blockquote>
<div><dl class="simple">
<dt>if t == nil {</dt><dd><p>return “”</p>
</dd>
</dl>
<p>}
res := strconv.Itoa(t.Val)
if t.Left == nil &amp;&amp; t.Right == nil {</p>
<blockquote>
<div><p>return res</p>
</div></blockquote>
<p>}
res += “(” + tree2str(t.Left) + “)”
if t.Right != nil{</p>
<blockquote>
<div><p>res += “(” + tree2str(t.Right) + “)”</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
func tree2str(t <a href="#id24"><span class="problematic" id="id25">*</span></a>TreeNode) string {</p>
<blockquote>
<div><dl class="simple">
<dt>if t == nil {</dt><dd><p>return “”</p>
</dd>
</dl>
<p>}
stack := make([]*TreeNode, 0)
m := make(map[<a href="#id26"><span class="problematic" id="id27">*</span></a>TreeNode]bool)
stack = append(stack, t)
res := “”
for len(stack) &gt; 0 {</p>
<blockquote>
<div><p>node := stack[len(stack)-1]
if _, ok := m[node]; ok {</p>
<blockquote>
<div><p>stack = stack[:len(stack)-1]
res = res + “)”</p>
</div></blockquote>
<dl>
<dt>} else {</dt><dd><p>m[node] = true
res = res + “(” + strconv.Itoa(node.Val)
if node.Left == nil &amp;&amp; node.Right != nil {</p>
<blockquote>
<div><p>res = res + “()”</p>
</div></blockquote>
<p>}
if node.Right != nil {</p>
<blockquote>
<div><p>stack = append(stack, node.Right)</p>
</div></blockquote>
<p>}
if node.Left != nil {</p>
<blockquote>
<div><p>stack = append(stack, node.Left)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return res[1 : len(res)-1]</p>
</div></blockquote>
</div>
<div class="section" id="id28">
<h1>}<a class="headerlink" href="#id28" title="永久链接至标题">¶</a></h1>
<p>## 617.合并二叉树(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id29"><span class="problematic" id="id30">``</span></a>`
给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。
你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，
否则不为 NULL 的节点将直接作为新二叉树的节点。</p>
<p>示例 1:
输入:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><dl>
<dt>Tree 1                     Tree 2</dt><dd><blockquote>
<div><p>1                         2</p>
</div></blockquote>
<p>/                       / </p>
</dd>
</dl>
<p>3   2                     1   3</p>
</div></blockquote>
<p>/                             </p>
</div></blockquote>
<p>5                             4   7</p>
</div></blockquote>
<p>输出:
合并后的树:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><p>3</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<p>4   5</p>
</div></blockquote>
<p>/   </p>
</div></blockquote>
<p>5   4   7</p>
</div></blockquote>
<p>注意: 合并必须从两个树的根节点开始。
<a href="#id31"><span class="problematic" id="id32">``</span></a><a href="#id33"><span class="problematic" id="id34">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路 | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —- | ———- | ———- |</div>
<div class="line">01   | 递归 | O(n)       | O(log(n))  |</div>
<div class="line">02   | 迭代 | O(n)       | O(n)       |</div>
</div>
<p><a href="#id35"><span class="problematic" id="id36">``</span></a><a href="#id37"><span class="problematic" id="id38">`</span></a>go
func mergeTrees(t1 <a href="#id39"><span class="problematic" id="id40">*</span></a>TreeNode, t2 <a href="#id41"><span class="problematic" id="id42">*</span></a>TreeNode) <a href="#id43"><span class="problematic" id="id44">*</span></a>TreeNode {</p>
<blockquote>
<div><dl class="simple">
<dt>if t1 == nil {</dt><dd><p>return t2</p>
</dd>
</dl>
<p>}
if t2 == nil {</p>
<blockquote>
<div><p>return t1</p>
</div></blockquote>
<p>}
t1.Val = t1.Val + t2.Val
t1.Left = mergeTrees(t1.Left, t2.Left)
t1.Right = mergeTrees(t1.Right, t2.Right)
return t1</p>
</div></blockquote>
<p>}</p>
<p>#
func mergeTrees(t1 <a href="#id45"><span class="problematic" id="id46">*</span></a>TreeNode, t2 <a href="#id47"><span class="problematic" id="id48">*</span></a>TreeNode) <a href="#id49"><span class="problematic" id="id50">*</span></a>TreeNode {</p>
<blockquote>
<div><dl class="simple">
<dt>if t1 == nil {</dt><dd><p>return t2</p>
</dd>
</dl>
<p>}
if t2 == nil {</p>
<blockquote>
<div><p>return t1</p>
</div></blockquote>
<p>}
list := make([]*TreeNode, 0)
list = append(list, t1)
list = append(list, t2)
for len(list) &gt; 0 {</p>
<blockquote>
<div><p>node1 := list[0]
node2 := list[1]
node1.Val = node1.Val + node2.Val
if node1.Left != nil &amp;&amp; node2.Left != nil {</p>
<blockquote>
<div><p>list = append(list, node1.Left)
list = append(list, node2.Left)</p>
</div></blockquote>
<dl class="simple">
<dt>} else if node1.Left == nil &amp;&amp; node2.Left != nil {</dt><dd><p>node1.Left = node2.Left</p>
</dd>
</dl>
<p>}
if node1.Right != nil &amp;&amp; node2.Right != nil {</p>
<blockquote>
<div><p>list = append(list, node1.Right)
list = append(list, node2.Right)</p>
</div></blockquote>
<dl class="simple">
<dt>} else if node1.Right == nil &amp;&amp; node2.Right != nil {</dt><dd><p>node1.Right = node2.Right</p>
</dd>
</dl>
<p>}
list = list[2:]</p>
</div></blockquote>
<p>}
return t1</p>
</div></blockquote>
</div>
<div class="section" id="id51">
<h1>}<a class="headerlink" href="#id51" title="永久链接至标题">¶</a></h1>
<p>## 628.三个数的最大乘积(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id52"><span class="problematic" id="id53">``</span></a>`
给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。
示例 1:输入: [1,2,3]输出: 6
示例 2:输入: [1,2,3,4]输出: 24
注意:</p>
<blockquote>
<div><p>给定的整型数组长度范围是[3,104]，数组中所有的元素范围是[-1000, 1000]。
输入的数组中任意三个数的乘积不会超出32位有符号整数的范围。</p>
</div></blockquote>
<p><a href="#id54"><span class="problematic" id="id55">``</span></a><a href="#id56"><span class="problematic" id="id57">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路 | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —- | ———- | ———- |</div>
<div class="line">01   | 排序 | O(nlog(n)) | O(1)       |</div>
<div class="line">02   | 遍历 | O(n)       | O(1)       |</div>
</div>
<p><a href="#id58"><span class="problematic" id="id59">``</span></a><a href="#id60"><span class="problematic" id="id61">`</span></a>go
func maximumProduct(nums []int) int {</p>
<blockquote>
<div><p>sort.Ints(nums)
return max(nums[0]*nums[1]*nums[len(nums)-1],</p>
<blockquote>
<div><p>nums[len(nums)-3]*nums[len(nums)-2]*nums[len(nums)-1])</p>
</div></blockquote>
</div></blockquote>
<p>}</p>
<dl>
<dt>func max(a, b int) int {</dt><dd><dl class="simple">
<dt>if a &gt; b {</dt><dd><p>return a</p>
</dd>
</dl>
<p>}
return b</p>
</dd>
</dl>
<p>}</p>
<p>#
func maximumProduct(nums []int) int {</p>
<blockquote>
<div><p>max1, max2, max3 := math.MinInt32, math.MinInt32, math.MinInt32
min1, min2 := math.MaxInt32, math.MaxInt32
for i := 0; i &lt; len(nums); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if nums[i] &lt;= min1 {</dt><dd><p>min2 = min1
min1 = nums[i]</p>
</dd>
<dt>} else if nums[i] &lt;= min2 {</dt><dd><p>min2 = nums[i]</p>
</dd>
</dl>
<p>}
if nums[i] &gt;= max1 {</p>
<blockquote>
<div><p>max3 = max2
max2 = max1
max1 = nums[i]</p>
</div></blockquote>
<dl class="simple">
<dt>} else if nums[i] &gt;= max2 {</dt><dd><p>max3 = max2
max2 = nums[i]</p>
</dd>
<dt>} else if nums[i] &gt;= max3 {</dt><dd><p>max3 = nums[i]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return max(min1*min2*max1, max1*max2*max3)</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func max(a, b int) int {</dt><dd><dl class="simple">
<dt>if a &gt; b {</dt><dd><p>return a</p>
</dd>
</dl>
<p>}
return b</p>
</dd>
</dl>
</div>
<div class="section" id="id62">
<h1>}<a class="headerlink" href="#id62" title="永久链接至标题">¶</a></h1>
<p>## 633.平方数之和(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">给定一个非负整数</span> <span class="pre">c</span> <span class="pre">，你要判断是否存在两个整数</span> <span class="pre">a</span> <span class="pre">和</span> <span class="pre">b，使得</span> <span class="pre">a2</span> <span class="pre">+</span> <span class="pre">b2</span> <span class="pre">=</span> <span class="pre">c。</span>
<span class="pre">示例1:输入:</span> <span class="pre">5</span> <span class="pre">输出:</span> <span class="pre">True</span> <span class="pre">解释:</span> <span class="pre">1</span> <span class="pre">*</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">2</span> <span class="pre">=</span> <span class="pre">5</span>
<span class="pre">示例2:输入:</span> <span class="pre">3</span> <span class="pre">输出:</span> <span class="pre">False</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路   | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —— | ———- | ———- |</div>
<div class="line">01   | 双指针 | O(log(n))  | O(1)       |</div>
<div class="line">02   | 遍历   | O(log(n))  | O(1)       |</div>
</div>
<p><a href="#id63"><span class="problematic" id="id64">``</span></a><a href="#id65"><span class="problematic" id="id66">`</span></a>go
func judgeSquareSum(c int) bool {</p>
<blockquote>
<div><dl class="simple">
<dt>if c &lt; 0 {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}
i, j := 0, int(math.Sqrt(float64(c)))
for i &lt;= j {</p>
<blockquote>
<div><p>current := i*i + j*j
if current &lt; c {</p>
<blockquote>
<div><p>i++</p>
</div></blockquote>
<dl class="simple">
<dt>} else if current &gt; c {</dt><dd><p>j–</p>
</dd>
<dt>} else {</dt><dd><p>return true</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return false</p>
</div></blockquote>
<p>}</p>
<p>#
func judgeSquareSum(c int) bool {</p>
<blockquote>
<div><dl>
<dt>for i := 0; i &lt;= int(math.Sqrt(float64(c))); i++ {</dt><dd><p>b := c - i*i
s := int(math.Sqrt(float64(b)))
if s*s == b {</p>
<blockquote>
<div><p>return true</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}
return false</p>
</div></blockquote>
</div>
<div class="section" id="id67">
<h1>}<a class="headerlink" href="#id67" title="永久链接至标题">¶</a></h1>
<p>## 637.二叉树的层平均值(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id68"><span class="problematic" id="id69">``</span></a>`
给定一个非空二叉树, 返回一个由每层节点平均值组成的数组.
示例 1:
输入:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>3</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<dl>
<dt>9  20</dt><dd><blockquote>
<div><p>/  </p>
</div></blockquote>
<p>15   7</p>
</dd>
</dl>
</div></blockquote>
<p>输出: [3, 14.5, 11]
解释:第0层的平均值是 3,  第1层是 14.5, 第2层是 11. 因此返回 [3, 14.5, 11].
注意：</p>
<blockquote>
<div><p>节点值的范围在32位有符号整数范围内。</p>
</div></blockquote>
<p><a href="#id70"><span class="problematic" id="id71">``</span></a><a href="#id72"><span class="problematic" id="id73">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路 | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —- | ———- | ———- |</div>
<div class="line">01   | 递归 | O(n)       | O(log(n))  |</div>
<div class="line">02   | 迭代 | O(n)       | O(n)       |</div>
</div>
<p><a href="#id74"><span class="problematic" id="id75">``</span></a><a href="#id76"><span class="problematic" id="id77">`</span></a>go
func averageOfLevels(root <a href="#id78"><span class="problematic" id="id79">*</span></a>TreeNode) []float64 {</p>
<blockquote>
<div><p>var sum, node []int
res := make([]float64, 0)
sum = append(sum, root.Val)
node = append(node, 1)
sum, node = dfs(root, sum, node, 1)
for i := 0; i &lt; len(sum); i++ {</p>
<blockquote>
<div><p>res = append(res, float64(sum[i])/float64(node[i]))</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func dfs(root <a href="#id80"><span class="problematic" id="id81">*</span></a>TreeNode, sum, node []int, level int) ([]int, []int) {</dt><dd><dl class="simple">
<dt>if root == nil || (root.Left == nil &amp;&amp; root.Right == nil) {</dt><dd><p>return sum, node</p>
</dd>
</dl>
<p>}
if level &gt;= len(sum) {</p>
<blockquote>
<div><p>sum = append(sum, 0)
node = append(node, 0)</p>
</div></blockquote>
<p>}
if root.Left != nil {</p>
<blockquote>
<div><p>sum[level] += root.Left.Val
node[level]++</p>
</div></blockquote>
<p>}
if root.Right != nil {</p>
<blockquote>
<div><p>sum[level] += root.Right.Val
node[level]++</p>
</div></blockquote>
<p>}
sum, node = dfs(root.Left, sum, node, level+1)
sum, node = dfs(root.Right, sum, node, level+1)
return sum, node</p>
</dd>
</dl>
<p>}</p>
<p>#
func averageOfLevels(root <a href="#id82"><span class="problematic" id="id83">*</span></a>TreeNode) []float64 {</p>
<blockquote>
<div><p>res := make([]float64, 0)
list := make([]*TreeNode, 0)
list = append(list, root)
for len(list) &gt; 0 {</p>
<blockquote>
<div><p>length := len(list)
sum := 0
for i := 0; i &lt; length; i++ {</p>
<blockquote>
<div><p>sum = sum + list[i].Val
if list[i].Left != nil {</p>
<blockquote>
<div><p>list = append(list, list[i].Left)</p>
</div></blockquote>
<p>}
if list[i].Right != nil {</p>
<blockquote>
<div><p>list = append(list, list[i].Right)</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
res = append(res, float64(sum)/float64(length))
list = list[length:]</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
</div>
<div class="section" id="id84">
<h1>}<a class="headerlink" href="#id84" title="永久链接至标题">¶</a></h1>
<p>## 643.子数组最大平均数 I(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id85"><span class="problematic" id="id86">``</span></a>`
给定 n 个整数，找出平均数最大且长度为 k 的连续子数组，并输出该最大平均数。
示例 1:输入: [1,12,-5,-6,50,3], k = 4 输出: 12.75
解释: 最大平均数 (12-5-6+50)/4 = 51/4 = 12.75
注意:</p>
<blockquote>
<div><p>1 &lt;= k &lt;= n &lt;= 30,000。
所给数据范围 [-10,000，10,000]。</p>
</div></blockquote>
<p><a href="#id87"><span class="problematic" id="id88">``</span></a><a href="#id89"><span class="problematic" id="id90">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路          | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ————- | ———- | ———- |</div>
<div class="line">01   | 遍历+滑动窗口 | O(n)       | O(1)       |</div>
<div class="line">02   | 遍历+暴力法   | O(n^2)     | O(1)       |</div>
<div class="line">03   | 遍历+累计求和 | O(n)       | O(n)       |</div>
</div>
<p><a href="#id91"><span class="problematic" id="id92">``</span></a><a href="#id93"><span class="problematic" id="id94">`</span></a>go
func findMaxAverage(nums []int, k int) float64 {</p>
<blockquote>
<div><p>temp := 0
for i := 0; i &lt; k; i++ {</p>
<blockquote>
<div><p>temp = temp + nums[i]</p>
</div></blockquote>
<p>}
max := temp
for i := k; i &lt; len(nums); i++ {</p>
<blockquote>
<div><p>temp = temp + nums[i] - nums[i-k]
if max &lt; temp {</p>
<blockquote>
<div><p>max = temp</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return float64(max) / float64(k)</p>
</div></blockquote>
<p>}</p>
<p>#
func findMaxAverage(nums []int, k int) float64 {</p>
<blockquote>
<div><p>max := math.MinInt32
for i := 0; i &lt; len(nums); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if i + k &gt; len(nums){</dt><dd><p>break</p>
</dd>
</dl>
<p>}
sum := 0
for j := i; j &lt; i+k; j++{</p>
<blockquote>
<div><p>sum = sum+nums[j]</p>
</div></blockquote>
<p>}
if sum &gt; max{</p>
<blockquote>
<div><p>max = sum</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return float64(max) / float64(k)</p>
</div></blockquote>
<p>}</p>
<p>#
func findMaxAverage(nums []int, k int) float64 {</p>
<blockquote>
<div><p>sum := make([]int, len(nums))
sum[0] = nums[0]
for i := 1; i &lt; len(nums); i++ {</p>
<blockquote>
<div><p>sum[i] = sum[i-1] + nums[i]</p>
</div></blockquote>
<p>}
max := sum[k-1]
for i := k; i &lt; len(nums); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if sum[i]-sum[i-k] &gt; max {</dt><dd><p>max = sum[i] - sum[i-k]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return float64(max) / float64(k)</p>
</div></blockquote>
</div>
<div class="section" id="id95">
<h1>}<a class="headerlink" href="#id95" title="永久链接至标题">¶</a></h1>
<p>## 645.错误的集合(5)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id96"><span class="problematic" id="id97">``</span></a>`
集合 S 包含从1到 n 的整数。不幸的是，因为数据错误，
导致集合里面某一个元素复制了成了集合里面的另外一个元素的值，导致集合丢失了一个整数并且有一个元素重复。
给定一个数组 nums 代表了集合 S 发生错误后的结果。
你的任务是首先寻找到重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。</p>
<p>示例 1:输入: nums = [1,2,2,4]输出: [2,3]
注意:</p>
<blockquote>
<div><blockquote>
<div><p>给定数组的长度范围是 [2, 10000]。</p>
</div></blockquote>
<p>给定的数组是无序的。</p>
</div></blockquote>
<p><a href="#id98"><span class="problematic" id="id99">``</span></a><a href="#id100"><span class="problematic" id="id101">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路     | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ——– | ———- | ———- |</div>
<div class="line">01   | 数组辅助 | O(n)       | O(n)       |</div>
<div class="line">02   | 置反     | O(n)       | O(1)       |</div>
<div class="line">03   | 位运算   | O(n)       | O(1)       |</div>
<div class="line">04   | 哈希辅助 | O(n)       | O(n)       |</div>
<div class="line">05   | 排序     | O(nlog(n)) | O(1)       |</div>
</div>
<p><a href="#id102"><span class="problematic" id="id103">``</span></a><a href="#id104"><span class="problematic" id="id105">`</span></a>go
func findErrorNums(nums []int) []int {</p>
<blockquote>
<div><p>newNums := make([]int, len(nums))
var repeatNum int
for _, v := range nums {</p>
<blockquote>
<div><dl class="simple">
<dt>if newNums[v-1] != 0 {</dt><dd><p>repeatNum = v</p>
</dd>
</dl>
<p>}
newNums[v-1] = v</p>
</div></blockquote>
<p>}
for i, v := range newNums {</p>
<blockquote>
<div><dl class="simple">
<dt>if v == 0 {</dt><dd><p>return []int{repeatNum, i + 1}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return []int{0, 0}</p>
</div></blockquote>
<p>}</p>
<p>#
func findErrorNums(nums []int) []int {</p>
<blockquote>
<div><p>repeatNum := 0
for i := 0; i &lt; len(nums); i++ {</p>
<blockquote>
<div><p>n := abs(nums[i])
if nums[n-1] &lt; 0 {</p>
<blockquote>
<div><p>repeatNum = n</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>nums[n-1] = -nums[n-1]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
misNum := 0
for i, v := range nums {</p>
<blockquote>
<div><dl class="simple">
<dt>if v &gt; 0 {</dt><dd><p>misNum = i + 1
break</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return []int{repeatNum, misNum}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func abs(a int) int {</dt><dd><dl class="simple">
<dt>if a &gt; 0 {</dt><dd><p>return a</p>
</dd>
</dl>
<p>}
return -a</p>
</dd>
</dl>
<p>}</p>
<p>#
func findErrorNums(nums []int) []int {</p>
<blockquote>
<div><p>res := 0
// 异或得到repeatedNum^misNum
for i := 0; i &lt; len(nums); i++ {</p>
<blockquote>
<div><p>res = res ^ (i + 1) ^ (nums[i])</p>
</div></blockquote>
<p>}
// 找到第一位不是0的
h := 1
for res&amp;h == 0 {</p>
<blockquote>
<div><p>h = h &lt;&lt; 1</p>
</div></blockquote>
<p>}
a := 0
b := 0
for i := range nums {</p>
<blockquote>
<div><dl class="simple">
<dt>if h&amp;nums[i] == 0 {</dt><dd><p>a ^= nums[i]</p>
</dd>
<dt>} else {</dt><dd><p>b ^= nums[i]</p>
</dd>
</dl>
<p>}
if h&amp;(i+1) == 0 {</p>
<blockquote>
<div><p>a ^= i + 1</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>b ^= i + 1</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
for i := range nums {</p>
<blockquote>
<div><dl class="simple">
<dt>if nums[i] == b {</dt><dd><p>return []int{b, a}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return []int{a, b}</p>
</div></blockquote>
<p>}</p>
<p>#
func findErrorNums(nums []int) []int {</p>
<blockquote>
<div><p>m := make(map[int]int)
n := len(nums)
sum := 0
repeatNum := 0
for i := 0; i &lt; len(nums); i++ {</p>
<blockquote>
<div><p>sum = sum + nums[i]
if _, ok := m[nums[i]]; ok {</p>
<blockquote>
<div><p>repeatNum = nums[i]</p>
</div></blockquote>
<p>}
m[nums[i]] = 1</p>
</div></blockquote>
<p>}
return []int{repeatNum, n*(n+1)/2 - sum + repeatNum}</p>
</div></blockquote>
<p>}</p>
<p>#
func findErrorNums(nums []int) []int {</p>
<blockquote>
<div><p>sort.Ints(nums)
n := len(nums)
sum := 0
repeatNum := nums[0]
for i := 0; i &lt; len(nums); i++ {</p>
<blockquote>
<div><p>sum = sum + nums[i]
if i &lt; len(nums)-1 &amp;&amp; nums[i] == nums[i+1] {</p>
<blockquote>
<div><p>repeatNum = nums[i]</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return []int{repeatNum, n*(n+1)/2 - sum + repeatNum}</p>
</div></blockquote>
</div>
<div class="section" id="id106">
<h1>}<a class="headerlink" href="#id106" title="永久链接至标题">¶</a></h1>
<p>## 653.两数之和IV输入BST(4)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id107"><span class="problematic" id="id108">``</span></a>`
给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。
案例 1:
输入:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><p>5</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<p>3   6</p>
</div></blockquote>
<p>/   </p>
</div></blockquote>
<p>2   4   7
Target = 9
输出: True
案例 2:
输入:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><p>5</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<p>3   6</p>
</div></blockquote>
<p>/   </p>
</div></blockquote>
<p>2   4   7
Target = 28 输出: False
<a href="#id109"><span class="problematic" id="id110">``</span></a><a href="#id111"><span class="problematic" id="id112">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路          | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ————- | ———- | ———- |</div>
<div class="line">01   | 递归+哈希辅助 | O(n)       | O(n)       |</div>
<div class="line">02   | 递归          | O(nlog(n)) | O(log(n))  |</div>
<div class="line">03   | 迭代          | O(n)       | O(n)       |</div>
<div class="line">04   | 递归+二分查找 | O(n)       | O(n)       |</div>
</div>
<p><a href="#id113"><span class="problematic" id="id114">``</span></a><a href="#id115"><span class="problematic" id="id116">`</span></a>go
func findTarget(root <a href="#id117"><span class="problematic" id="id118">*</span></a>TreeNode, k int) bool {</p>
<blockquote>
<div><dl class="simple">
<dt>if root == nil {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}
m := map[int]int{}
return dfs(root, k, m)</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func dfs(node <a href="#id119"><span class="problematic" id="id120">*</span></a>TreeNode, k int, m map[int]int) bool {</dt><dd><dl class="simple">
<dt>if node == nil {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}
if _, ok := m[k-node.Val]; ok {</p>
<blockquote>
<div><p>return true</p>
</div></blockquote>
<p>}
m[node.Val] = node.Val
return dfs(node.Left, k, m) || dfs(node.Right, k, m)</p>
</dd>
</dl>
<p>}</p>
<p>#
func dfs(root, searchRoot <a href="#id121"><span class="problematic" id="id122">*</span></a>TreeNode, k int) bool {</p>
<blockquote>
<div><dl class="simple">
<dt>if root == nil {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}
found := findNode(searchRoot, k-root.Val)
if found != nil &amp;&amp; found != root {</p>
<blockquote>
<div><p>return true</p>
</div></blockquote>
<p>}
return dfs(root.Left, searchRoot, k) ||</p>
<blockquote>
<div><p>dfs(root.Right, searchRoot, k)</p>
</div></blockquote>
</div></blockquote>
<p>}</p>
<dl>
<dt>func findNode(root <a href="#id123"><span class="problematic" id="id124">*</span></a>TreeNode, target int) <a href="#id125"><span class="problematic" id="id126">*</span></a>TreeNode {</dt><dd><dl class="simple">
<dt>if root == nil {</dt><dd><p>return nil</p>
</dd>
</dl>
<p>}
if root.Val == target {</p>
<blockquote>
<div><p>return root</p>
</div></blockquote>
<p>}
if root.Val &lt; target {</p>
<blockquote>
<div><p>return findNode(root.Right, target)</p>
</div></blockquote>
<p>}
return findNode(root.Left, target)</p>
</dd>
</dl>
<p>}</p>
<p>#
func findTarget(root <a href="#id127"><span class="problematic" id="id128">*</span></a>TreeNode, k int) bool {</p>
<blockquote>
<div><dl class="simple">
<dt>if root == nil {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}
m := make(map[int]int)
queue := make([]*TreeNode, 0)
queue = append(queue, root)
for len(queue) &gt; 0 {</p>
<blockquote>
<div><p>node := queue[len(queue)-1]
queue = queue[:len(queue)-1]
if _, ok := m[k-node.Val]; ok {</p>
<blockquote>
<div><p>return true</p>
</div></blockquote>
<p>}
if node.Left != nil {</p>
<blockquote>
<div><p>queue = append(queue, node.Left)</p>
</div></blockquote>
<p>}
if node.Right != nil {</p>
<blockquote>
<div><p>queue = append(queue, node.Right)</p>
</div></blockquote>
<p>}
m[node.Val] = 1</p>
</div></blockquote>
<p>}
return false</p>
</div></blockquote>
<p>}</p>
<p>#
var arr []int</p>
<dl>
<dt>func findTarget(root <a href="#id129"><span class="problematic" id="id130">*</span></a>TreeNode, k int) bool {</dt><dd><dl class="simple">
<dt>if root == nil {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}
arr = make([]int, 0)
dfs(root)
i := 0
j := len(arr) - 1
for i &lt; j {</p>
<blockquote>
<div><dl class="simple">
<dt>if arr[i]+arr[j] == k {</dt><dd><p>return true</p>
</dd>
<dt>} else if arr[i]+arr[j] &gt; k {</dt><dd><p>j–</p>
</dd>
<dt>} else {</dt><dd><p>i++</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return false</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func dfs(node <a href="#id131"><span class="problematic" id="id132">*</span></a>TreeNode) {</dt><dd><dl class="simple">
<dt>if node == nil {</dt><dd><p>return</p>
</dd>
</dl>
<p>}
dfs(node.Left)
arr = append(arr, node.Val)
dfs(node.Right)</p>
</dd>
</dl>
</div>
<div class="section" id="id133">
<h1>}<a class="headerlink" href="#id133" title="永久链接至标题">¶</a></h1>
<p>## 657.机器人能否返回原点(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id134"><span class="problematic" id="id135">``</span></a>`
在二维平面上，有一个机器人从原点 (0, 0) 开始。
给出它的移动顺序，判断这个机器人在完成移动后是否在 (0, 0) 处结束。
移动顺序由字符串表示。字符 move[i] 表示其第 i 次移动。
机器人的有效动作有 R（右），L（左），U（上）和 D（下）。
如果机器人在完成所有动作后返回原点，则返回 true。否则，返回 false。</p>
<p>注意：机器人“面朝”的方向无关紧要。 “R” 将始终使机器人向右移动一次，“L” 将始终向左移动等。
此外，假设每次移动机器人的移动幅度相同。</p>
<p>示例 1:输入: “UD” 出: true
解释：机器人向上移动一次，然后向下移动一次。
所有动作都具有相同的幅度，因此它最终回到它开始的原点。因此，我们返回 true。</p>
<p>示例 2:输入: “LL”输出: false
解释：机器人向左移动两次。它最终位于原点的左侧，距原点有两次 “移动” 的距离。
我们返回 false，因为它在移动结束时没有返回原点。
<a href="#id136"><span class="problematic" id="id137">``</span></a><a href="#id138"><span class="problematic" id="id139">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路              | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —————– | ———- | ———- |</div>
<div class="line">01   | 内置函数-字符统计 | O(n)       | O(1)       |</div>
<div class="line">02   | 模拟              | O(n)       | O(1)       |</div>
</div>
<p><a href="#id140"><span class="problematic" id="id141">``</span></a><a href="#id142"><span class="problematic" id="id143">`</span></a>go
func judgeCircle(moves string) bool {</p>
<blockquote>
<div><dl class="simple">
<dt>return strings.Count(moves, “U”) == strings.Count(moves, “D”) &amp;&amp;</dt><dd><p>strings.Count(moves, “L”) == strings.Count(moves, “R”)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<p>#
func judgeCircle(moves string) bool {</p>
<blockquote>
<div><p>x, y := 0, 0
for i := range moves {</p>
<blockquote>
<div><p>switch i {
case ‘U’:</p>
<blockquote>
<div><p>y = y + 1</p>
</div></blockquote>
<dl class="simple">
<dt>case ‘D’:</dt><dd><p>y = y - 1</p>
</dd>
<dt>case ‘L’:</dt><dd><p>x = x - 1</p>
</dd>
<dt>case ‘R’:</dt><dd><p>x = x + 1</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return x == 0 &amp;&amp; y == 0</p>
</div></blockquote>
</div>
<div class="section" id="id144">
<h1>}<a class="headerlink" href="#id144" title="永久链接至标题">¶</a></h1>
<p>## 661.图片平滑器(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id145"><span class="problematic" id="id146">``</span></a>`
包含整数的二维矩阵 M 表示一个图片的灰度。你需要设计一个平滑器来让每一个单元的灰度成为平均灰度 (向下舍入) ，
平均灰度的计算是周围的8个单元和它本身的值求平均，如果周围的单元格不足八个，则尽可能多的利用它们。</p>
<p>示例 1:
输入:
[[1,1,1],</p>
<blockquote>
<div><p>[1,0,1],
[1,1,1]]</p>
</div></blockquote>
<p>输出:
[[0, 0, 0],</p>
<blockquote>
<div><p>[0, 0, 0],
[0, 0, 0]]</p>
</div></blockquote>
<p>解释:
对于点 (0,0), (0,2), (2,0), (2,2): 平均(3/4) = 平均(0.75) = 0
对于点 (0,1), (1,0), (1,2), (2,1): 平均(5/6) = 平均(0.83333333) = 0
对于点 (1,1): 平均(8/9) = 平均(0.88888889) = 0
注意:</p>
<blockquote>
<div><p>给定矩阵中的整数范围为 [0, 255]。
矩阵的长和宽的范围均为 [1, 150]。</p>
</div></blockquote>
<p><a href="#id147"><span class="problematic" id="id148">``</span></a><a href="#id149"><span class="problematic" id="id150">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路 | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —- | ———- | ———- |</div>
<div class="line">01   | 遍历 | O(n^2)     | O(n^2)     |</div>
<div class="line">02   | 遍历 | O(n^2)     | O(n^2)     |</div>
</div>
<p><a href="#id151"><span class="problematic" id="id152">``</span></a><a href="#id153"><span class="problematic" id="id154">`</span></a>go
func imageSmoother(M [][]int) [][]int {</p>
<blockquote>
<div><p>res := make([][]int, len(M))
for i := range res {</p>
<blockquote>
<div><p>res[i] = make([]int, len(M[0]))
for j := range res[i] {</p>
<blockquote>
<div><p>res[i][j] = getValue(M, i, j)</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func getValue(M [][]int, r, c int) int {</dt><dd><p>value, count := 0, 0
for i := r - 1; i &lt; r+2; i++ {</p>
<blockquote>
<div><dl>
<dt>for j := c - 1; j &lt; c+2; j++ {</dt><dd><dl class="simple">
<dt>if 0 &lt;= i &amp;&amp; i &lt; len(M) &amp;&amp; 0 &lt;= j &amp;&amp; j &lt; len(M[0]) {</dt><dd><p>value = value + M[i][j]
count++</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return value / count</p>
</dd>
</dl>
<p>}</p>
<p>#
func imageSmoother(M [][]int) [][]int {</p>
<blockquote>
<div><p>res := make([][]int, len(M))
for i := range res {</p>
<blockquote>
<div><p>res[i] = make([]int, len(M[0]))
for j := range res[i] {</p>
<blockquote>
<div><p>value, count := 0, 0
for r := i - 1; r &lt;= i+1; r++ {</p>
<blockquote>
<div><dl>
<dt>for c := j - 1; c &lt;= j+1; c++ {</dt><dd><dl class="simple">
<dt>if 0 &lt;= r &amp;&amp; r &lt; len(M) &amp;&amp; 0 &lt;= c &amp;&amp; c &lt; len(M[0]) {</dt><dd><p>value = value + M[r][c]
count++</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
res[i][j] = value / count</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
</div>
<div class="section" id="id155">
<h1>}<a class="headerlink" href="#id155" title="永久链接至标题">¶</a></h1>
<p>## 665.非递减数列(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id156"><span class="problematic" id="id157">``</span></a>`
给你一个长度为 n 的整数数组，请你判断在 最多 改变 1 个元素的情况下，该数组能否变成一个非递减数列。
我们是这样定义一个非递减数列的： 对于数组中所有的 i (1 &lt;= i &lt; n)，总满足 array[i] &lt;= array[i + 1]。</p>
<p>示例 1:输入: nums = [4,2,3] 输出: true
解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。
示例 2:输入: nums = [4,2,1] 输出: false
解释: 你不能在只改变一个元素的情况下将其变为非递减数列。</p>
<dl class="simple">
<dt>说明：</dt><dd><p>1 &lt;= n &lt;= 10 ^ 4
- 10 ^ 5 &lt;= nums[i] &lt;= 10 ^ 5</p>
</dd>
</dl>
<p><a href="#id158"><span class="problematic" id="id159">``</span></a><a href="#id160"><span class="problematic" id="id161">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路         | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ———— | ———- | ———- |</div>
<div class="line">01   | 暴力法       | O(n^2)     | O(n)       |</div>
<div class="line">02   | 遍历修改前后 | O(n)       | O(n)       |</div>
<div class="line">03   | 遍历         | O(n)       | )          |</div>
</div>
<p><a href="#id162"><span class="problematic" id="id163">``</span></a><a href="#id164"><span class="problematic" id="id165">`</span></a>go
func checkPossibility(nums []int) bool {</p>
<blockquote>
<div><dl>
<dt>for i := 0; i &lt; len(nums); i++ {</dt><dd><p>res := make([]int,0)
res = append(res, nums[0:i]…)
res = append(res, nums[i+1:]…)
if isSort(res) {</p>
<blockquote>
<div><p>return true</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}
return false</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func isSort(nums []int) bool {</dt><dd><dl>
<dt>for i := 0; i &lt; len(nums)-1; i++ {</dt><dd><dl class="simple">
<dt>if nums[i] &gt; nums[i+1] {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
return true</p>
</dd>
</dl>
<p>}</p>
<p>#
func checkPossibility(nums []int) bool {</p>
<blockquote>
<div><dl>
<dt>for i := 1; i &lt; len(nums); i++{</dt><dd><dl class="simple">
<dt>if nums[i-1] &gt; nums[i]{</dt><dd><p>pre := deepCopy(nums)
pre[i-1] = pre[i]
next := deepCopy(nums)
next[i] = next[i-1]
return sort.IsSorted(sort.IntSlice(pre)) || sort.IsSorted(sort.IntSlice(next))</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
return true</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>func deepCopy(nums []int) []int  {</dt><dd><p>res := make([]int, len(nums))
copy(res,nums)
return res</p>
</dd>
</dl>
<p>}</p>
<p>#
func checkPossibility(nums []int) bool {</p>
<blockquote>
<div><p>count := 0
for i := 0; i &lt; len(nums)-1; i++ {</p>
<blockquote>
<div><dl>
<dt>if nums[i] &gt; nums[i+1] {</dt><dd><dl class="simple">
<dt>if count == 1 {</dt><dd><p>return false</p>
</dd>
<dt>} else if i == 0 {</dt><dd><p>// 4 2 3 =&gt; 2 2 3
nums[i] = nums[i+1]
count++</p>
</dd>
<dt>} else if nums[i-1] &gt; nums[i+1] {</dt><dd><p>// 3 4 2 =&gt; 3 4 4
nums[i+1] = nums[i]
count++</p>
</dd>
<dt>} else {</dt><dd><p>// 1 4 2 =&gt;  1 2 2
nums[i] = nums[i+1]
count++</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return true</p>
</div></blockquote>
</div>
<div class="section" id="id166">
<h1>}<a class="headerlink" href="#id166" title="永久链接至标题">¶</a></h1>
<p>## 669.修剪二叉搜索树(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id167"><span class="problematic" id="id168">``</span></a>`
给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。
通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R&gt;=L) 。
你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。</p>
<p>示例 1:
输入:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>1</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<p>0   2</p>
<p>L = 1
R = 2</p>
</div></blockquote>
<dl class="simple">
<dt>输出:</dt><dd><dl class="simple">
<dt>1</dt><dd><dl class="simple">
<dt></dt><dd><p>2</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>示例 2:
输入:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>3</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<dl>
<dt>0   4</dt><dd><dl class="simple">
<dt></dt><dd><p>2</p>
</dd>
</dl>
<p>/</p>
</dd>
</dl>
<p>1
L = 1
R = 3</p>
</div></blockquote>
<dl>
<dt>输出:</dt><dd><blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><p>3</p>
</div></blockquote>
<p>/</p>
</div></blockquote>
<p>2</p>
</div></blockquote>
<p>/</p>
</div></blockquote>
<p>1</p>
</dd>
</dl>
<p><a href="#id169"><span class="problematic" id="id170">``</span></a><a href="#id171"><span class="problematic" id="id172">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路 | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —- | ———- | ———- |</div>
<div class="line">01   | 递归 | O(n)       | O(log(n))  |</div>
<div class="line">02   | 迭代 | O(n)       | O(n)       |</div>
</div>
<p><a href="#id173"><span class="problematic" id="id174">``</span></a><a href="#id175"><span class="problematic" id="id176">`</span></a>go
func trimBST(root <a href="#id177"><span class="problematic" id="id178">*</span></a>TreeNode, L int, R int) <a href="#id179"><span class="problematic" id="id180">*</span></a>TreeNode {</p>
<blockquote>
<div><dl class="simple">
<dt>if root == nil {</dt><dd><p>return nil</p>
</dd>
</dl>
<p>}
if root.Val &lt; L {</p>
<blockquote>
<div><p>return trimBST(root.Right, L, R)</p>
</div></blockquote>
<p>}
if R &lt; root.Val {</p>
<blockquote>
<div><p>return trimBST(root.Left, L, R)</p>
</div></blockquote>
<p>}
root.Left = trimBST(root.Left, L, R)
root.Right = trimBST(root.Right, L, R)
return root</p>
</div></blockquote>
<p>}</p>
<p>#
func trimBST(root <a href="#id181"><span class="problematic" id="id182">*</span></a>TreeNode, L int, R int) <a href="#id183"><span class="problematic" id="id184">*</span></a>TreeNode {</p>
<blockquote>
<div><dl class="simple">
<dt>if root == nil {</dt><dd><p>return nil</p>
</dd>
</dl>
<p>}
// 找到根节点
for root.Val &lt; L || root.Val &gt; R {</p>
<blockquote>
<div><dl class="simple">
<dt>if root.Val &lt; L {</dt><dd><p>root = root.Right</p>
</dd>
<dt>} else {</dt><dd><p>root = root.Left</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>stack := make([]*TreeNode, 0)
stack = append(stack, root)
cur := root
temp := root
for len(stack) &gt; 0 {</p>
<blockquote>
<div><p>cur = stack[len(stack)-1]
stack = stack[:len(stack)-1]
if cur.Left != nil {</p>
<blockquote>
<div><dl>
<dt>if cur.Left.Val &gt;= L {</dt><dd><p>// 左节点&gt;=L，继续向左
stack = append(stack, cur.Left)</p>
</dd>
<dt>} else {</dt><dd><p>// 在当前左节点，向它的右节点找到满足&lt;L的值，
// 并把当前左指针指向找到的值
// 如示例2里面的，3的Left指向找到的2
// 然后入栈继续在2找
temp = cur.Left
for temp != nil &amp;&amp; temp.Val &lt; L {</p>
<blockquote>
<div><p>temp = temp.Right</p>
</div></blockquote>
<p>}
cur.Left = temp
if temp != nil {</p>
<blockquote>
<div><p>stack = append(stack, temp)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
if cur.Right != nil {</p>
<blockquote>
<div><dl>
<dt>if cur.Right.Val &lt;= R {</dt><dd><p>stack = append(stack, cur.Right)</p>
</dd>
<dt>} else {</dt><dd><p>temp = cur.Right
for temp != nil &amp;&amp; temp.Val &gt; R {</p>
<blockquote>
<div><p>temp = temp.Left</p>
</div></blockquote>
<p>}
cur.Right = temp
if temp != nil {</p>
<blockquote>
<div><p>stack = append(stack, temp)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return root</p>
</div></blockquote>
</div>
<div class="section" id="id185">
<h1>}<a class="headerlink" href="#id185" title="永久链接至标题">¶</a></h1>
<p>## 671.二叉树中第二小的节点(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id186"><span class="problematic" id="id187">``</span></a>`
给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。
如果一个节点有两个子节点的话，那么这个节点的值不大于它的子节点的值。
给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。
示例 1:
输入:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>2</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<dl>
<dt>2   5</dt><dd><blockquote>
<div><p>/ </p>
</div></blockquote>
<p>5   7</p>
</dd>
</dl>
</div></blockquote>
<p>输出: 5
说明: 最小的值是 2 ，第二小的值是 5 。
示例 2:
输入:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>2</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<p>2   2</p>
</div></blockquote>
<p>输出: -1
说明: 最小的值是 2, 但是不存在第二小的值。
<a href="#id188"><span class="problematic" id="id189">``</span></a><a href="#id190"><span class="problematic" id="id191">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路          | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ————- | ———- | ———- |</div>
<div class="line">01   | 递归+数组辅助 | O(n)       | O(n)       |</div>
<div class="line">02   | 递归          | O(n)       | O(log(n))    |</div>
<div class="line">03 | 迭代 | O(n) | O(n) |</div>
</div>
<p><a href="#id192"><span class="problematic" id="id193">``</span></a><a href="#id194"><span class="problematic" id="id195">`</span></a>go
var arr []int</p>
<dl>
<dt>func findSecondMinimumValue(root <a href="#id196"><span class="problematic" id="id197">*</span></a>TreeNode) int {</dt><dd><p>arr = make([]int, 0)
dfs(root)
min, second := math.MaxInt32, math.MaxInt32
flag := 0
for i := 0; i &lt; len(arr); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if arr[i] &lt; min {</dt><dd><p>second = min
min = arr[i]</p>
</dd>
<dt>} else if min &lt; arr[i] &amp;&amp; arr[i] &lt;= second {</dt><dd><p>flag = 1
second = arr[i]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
if second == math.MaxInt32 &amp;&amp; flag == 0 {</p>
<blockquote>
<div><p>return -1</p>
</div></blockquote>
<p>}
return second</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func dfs(root <a href="#id198"><span class="problematic" id="id199">*</span></a>TreeNode) {</dt><dd><dl class="simple">
<dt>if root == nil {</dt><dd><p>return</p>
</dd>
</dl>
<p>}
arr = append(arr, root.Val)
dfs(root.Left)
dfs(root.Right)</p>
</dd>
</dl>
<p>}</p>
<p>#
func dfs(root <a href="#id200"><span class="problematic" id="id201">*</span></a>TreeNode, val int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if root == nil {</dt><dd><p>return -1</p>
</dd>
</dl>
<p>}
if root.Val &gt; val {</p>
<blockquote>
<div><p>return root.Val</p>
</div></blockquote>
<p>}
left := dfs(root.Left, val)
right := dfs(root.Right, val)
if left == -1 {</p>
<blockquote>
<div><p>return right</p>
</div></blockquote>
<p>}
if right == -1 {</p>
<blockquote>
<div><p>return left</p>
</div></blockquote>
<p>}
return min(left, right)</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func min(a, b int) int {</dt><dd><dl class="simple">
<dt>if a &gt; b {</dt><dd><p>return b</p>
</dd>
</dl>
<p>}
return a</p>
</dd>
</dl>
<p>}</p>
<p>#
func findSecondMinimumValue(root <a href="#id202"><span class="problematic" id="id203">*</span></a>TreeNode) int {</p>
<blockquote>
<div><p>min, second := root.Val, math.MaxInt32
queue := make([]*TreeNode, 0)
queue = append(queue, root)
flag := 0
for len(queue) &gt; 0 {</p>
<blockquote>
<div><p>node := queue[len(queue)-1]
queue = queue[:len(queue)-1]
if node.Val &lt; min {</p>
<blockquote>
<div><p>second = min
min = node.Val</p>
</div></blockquote>
<dl class="simple">
<dt>} else if min &lt; node.Val &amp;&amp; node.Val &lt;= second {</dt><dd><p>flag = 1
second = node.Val</p>
</dd>
</dl>
<p>}
if node.Left != nil {</p>
<blockquote>
<div><p>// 有0个或2节点
queue = append(queue, node.Left)
queue = append(queue, node.Right)</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
if second == math.MaxInt32 &amp;&amp; flag == 0 {</p>
<blockquote>
<div><p>return -1</p>
</div></blockquote>
<p>}
return second</p>
</div></blockquote>
</div>
<div class="section" id="id204">
<h1>}<a class="headerlink" href="#id204" title="永久链接至标题">¶</a></h1>
<p>## 674.最长连续递增序列(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">给定一个未经排序的整数数组，找到最长且连续的的递增序列。</span>
<span class="pre">示例</span> <span class="pre">1:输入:</span> <span class="pre">[1,3,5,4,7]</span> <span class="pre">输出:</span> <span class="pre">3</span>
<span class="pre">解释:</span> <span class="pre">最长连续递增序列是</span> <span class="pre">[1,3,5],</span> <span class="pre">长度为3。</span>
<span class="pre">尽管</span> <span class="pre">[1,3,5,7]</span> <span class="pre">也是升序的子序列,</span> <span class="pre">但它不是连续的，因为5和7在原数组里被4隔开。</span>
<span class="pre">示例</span> <span class="pre">2:输入:</span> <span class="pre">[2,2,2,2,2]</span> <span class="pre">输出:</span> <span class="pre">1</span>
<span class="pre">解释:</span> <span class="pre">最长连续递增序列是</span> <span class="pre">[2],</span> <span class="pre">长度为1。</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路     | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ——– | ———- | ———- |</div>
<div class="line">01   | 双指针   | O(n)       | O(1)       |</div>
<div class="line">02   | 动态规划 | O(n)       | O(n)       |</div>
<div class="line">03   | 遍历     | O(n)        | O(1)           |</div>
</div>
<p><a href="#id205"><span class="problematic" id="id206">``</span></a><a href="#id207"><span class="problematic" id="id208">`</span></a>go
func findLengthOfLCIS(nums []int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if len(nums) == 0 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
res := 1
i, j := 0, 1
for j &lt; len(nums) {</p>
<blockquote>
<div><dl class="simple">
<dt>for j &lt; len(nums) &amp;&amp; nums[j-1] &lt; nums[j] {</dt><dd><p>j++</p>
</dd>
</dl>
<p>}
if res &lt; j-i {</p>
<blockquote>
<div><p>res = j - i</p>
</div></blockquote>
<p>}
i = j
j++</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
// 状态转移方程
// 若nums[i-1]&lt;nums[i]，则dp[i]=dp[i-1]+1；否则dp[i]=1
func findLengthOfLCIS(nums []int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if len(nums) == 0 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
res := 1
dp := make([]int,len(nums))
for i := 0; i &lt; len(nums); i++{</p>
<blockquote>
<div><p>dp[i] = 1</p>
</div></blockquote>
<p>}
for i := 1; i &lt; len(nums); i++{</p>
<blockquote>
<div><dl class="simple">
<dt>if nums[i-1] &lt; nums[i]{</dt><dd><p>dp[i] = dp[i-1]+1</p>
</dd>
</dl>
<p>}
if dp[i] &gt; res{</p>
<blockquote>
<div><p>res = dp[i]</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
</div>
<div class="section" id="id209">
<h1>}<a class="headerlink" href="#id209" title="永久链接至标题">¶</a></h1>
<p>## 680.验证回文字符串 Ⅱ(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id210"><span class="problematic" id="id211">``</span></a>`
给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。
示例 1:输入: “aba” 输出: True
示例 2:输入: “abca”输出: True 解释: 你可以删除c字符。
注意:</p>
<blockquote>
<div><p>字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。</p>
</div></blockquote>
<p><a href="#id212"><span class="problematic" id="id213">``</span></a><a href="#id214"><span class="problematic" id="id215">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路   | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —— | ———- | ———- |</div>
<div class="line">01   | 双指针 | O(n)       | O(1)       |</div>
<div class="line">02   | 递归   | O(n)       | O(n)       |</div>
</div>
<p><a href="#id216"><span class="problematic" id="id217">``</span></a><a href="#id218"><span class="problematic" id="id219">`</span></a>go
func validPalindrome(s string) bool {</p>
<blockquote>
<div><p>i := 0
j := len(s) - 1
for i &lt; j {</p>
<blockquote>
<div><dl class="simple">
<dt>if s[i] != s[j] {</dt><dd><p>return isPalindrome(s, i, j-1) || isPalindrome(s, i+1, j)</p>
</dd>
</dl>
<p>}
i++
j–</p>
</div></blockquote>
<p>}
return true</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func isPalindrome(s string, i, j int) bool {</dt><dd><dl>
<dt>for i &lt; j {</dt><dd><dl class="simple">
<dt>if s[i] != s[j] {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}
i++
j–</p>
</dd>
</dl>
<p>}
return true</p>
</dd>
</dl>
<p>}</p>
<p>#
func validPalindrome(s string) bool {</p>
<blockquote>
<div><p>length := len(s)
if length &lt; 2 {</p>
<blockquote>
<div><p>return true</p>
</div></blockquote>
<p>}
if s[0] == s[length-1] {</p>
<blockquote>
<div><p>return validPalindrome(s[1 : length-1])</p>
</div></blockquote>
<p>}
return isPalindrome(s[0:length-1]) || isPalindrome(s[1:length])</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func isPalindrome(s string) bool {</dt><dd><p>i := 0
j := len(s) - 1
for i &lt; j {</p>
<blockquote>
<div><dl class="simple">
<dt>if s[i] != s[j] {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}
i++
j–</p>
</div></blockquote>
<p>}
return true</p>
</dd>
</dl>
</div>
<div class="section" id="id220">
<h1>}<a class="headerlink" href="#id220" title="永久链接至标题">¶</a></h1>
<p>## 682.棒球比赛(1)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id221"><span class="problematic" id="id222">``</span></a>`
你现在是棒球比赛记录员。
给定一个字符串列表，每个字符串可以是以下四种类型之一：
1.整数（一轮的得分）：直接表示您在本轮中获得的积分数。
2. “+”（一轮的得分）：表示本轮获得的得分是前两轮有效 回合得分的总和。
3. “D”（一轮的得分）：表示本轮获得的得分是前一轮有效 回合得分的两倍。
4. “C”（一个操作，这不是一个回合的分数）：表示您获得的最后一个有效 回合的分数是无效的，应该被移除。</p>
<p>每一轮的操作都是永久性的，可能会对前一轮和后一轮产生影响。
你需要返回你在所有回合中得分的总和。
示例 1:输入: [“5”,”2”,”C”,”D”,”+”] 输出: 30
解释:
第1轮：你可以得到5分。总和是：5。
第2轮：你可以得到2分。总和是：7。
操作1：第2轮的数据无效。总和是：5。
第3轮：你可以得到10分（第2轮的数据已被删除）。总数是：15。
第4轮：你可以得到5 + 10 = 15分。总数是：30。</p>
<p>示例 2:输入: [“5”,”-2”,”4”,”C”,”D”,”9”,”+”,”+”] 输出: 27
解释:
第1轮：你可以得到5分。总和是：5。
第2轮：你可以得到-2分。总数是：3。
第3轮：你可以得到4分。总和是：7。
操作1：第3轮的数据无效。总数是：3。
第4轮：你可以得到-4分（第三轮的数据已被删除）。总和是：-1。
第5轮：你可以得到9分。总数是：8。
第6轮：你可以得到-4 + 9 = 5分。总数是13。
第7轮：你可以得到9 + 5 = 14分。总数是27。</p>
<dl class="simple">
<dt>注意：</dt><dd><p>输入列表的大小将介于1和1000之间。
列表中的每个整数都将介于-30000和30000之间。</p>
</dd>
</dl>
<p><a href="#id223"><span class="problematic" id="id224">``</span></a><a href="#id225"><span class="problematic" id="id226">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路        | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ———– | ———- | ———- |</div>
<div class="line">01   | 模拟-栈辅助 | O(n)       | O(n)       |</div>
</div>
<p><a href="#id227"><span class="problematic" id="id228">``</span></a><a href="#id229"><span class="problematic" id="id230">`</span></a>go
func calPoints(ops []string) int {</p>
<blockquote>
<div><p>stacks := make([]int, 0)
for i := range ops {</p>
<blockquote>
<div><p>switch ops[i] {
case “+”:</p>
<blockquote>
<div><p>r1 := stacks[len(stacks)-1]
r2 := stacks[len(stacks)-2]
stacks = append(stacks, r1+r2)</p>
</div></blockquote>
<dl class="simple">
<dt>case “D”:</dt><dd><p>r1 := stacks[len(stacks)-1]
stacks = append(stacks, 2*r1)</p>
</dd>
<dt>case “C”:</dt><dd><p>stacks = stacks[:len(stacks)-1]</p>
</dd>
<dt>default:</dt><dd><p>tempInt, _ := strconv.Atoi(ops[i])
stacks = append(stacks, tempInt)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
res := 0
for _, value := range stacks {</p>
<blockquote>
<div><p>res = res + value</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
</div>
<div class="section" id="id231">
<h1>}<a class="headerlink" href="#id231" title="永久链接至标题">¶</a></h1>
<p>## 686.重复叠加字符串匹配(2)</p>
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
- 题目
=======
－ 题目
&gt;&gt;&gt;&gt;&gt;&gt;&gt; 167ff051e1bed62c3e84043cdd3460ecc3db1eae</p>
<p><a href="#id232"><span class="problematic" id="id233">``</span></a>`
给定两个字符串 A 和 B, 寻找重复叠加字符串A的最小次数，
使得字符串B成为叠加后的字符串A的子串，如果不存在则返回 -1。</p>
<p>举个例子，A = “abcd”，B = “cdabcdab”。
答案为 3， 因为 A 重复叠加三遍后为 “abcdabcdabcd”，
此时 B 是其子串；A 重复叠加两遍后为”abcdabcd”，B 并不是其子串。</p>
<p>注意:
A 与 B 字符串的长度在1和10000区间范围内。
<a href="#id234"><span class="problematic" id="id235">``</span></a><a href="#id236"><span class="problematic" id="id237">`</span></a></p>
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
- 解题思路</p>
<div class="line-block">
<div class="line">No.  | 思路     | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ——– | ———- | ———- |</div>
<div class="line">01   | 内置函数 | O(n)       | O(n)       |</div>
<div class="line">02   | 遍历     | O(n)       | O(n)       |</div>
</div>
<p><a href="#id238"><span class="problematic" id="id239">``</span></a><a href="#id240"><span class="problematic" id="id241">`</span></a>go
func repeatedStringMatch(A string, B string) int {</p>
<blockquote>
<div><p>times := len(B) / len(A)
// 要确保B是A的子串，就要最少重复len(B)/len(A)次A次，最多len(B)/len(A)+2次
// 如长度为 len(B) = 6, len(A) = 3,至少重复2次
// 长度为len(B) = 7, len(A) = 3, 至少重复3次
// 另外如B=”cabcabca”, A=”abc”,需要重复4次
for i := times; i &lt;= times+2; i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if strings.Contains(strings.Repeat(A, i), B) {</dt><dd><p>return i</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return -1</p>
</div></blockquote>
<p>}</p>
<p>#
func repeatedStringMatch(A string, B string) int {</p>
<blockquote>
<div><p>temp := A
count := 1
for len(temp) &lt; len(B) {</p>
<blockquote>
<div><p>temp = temp + A
count++</p>
</div></blockquote>
<p>}
if strings.Contains(temp, B) {</p>
<blockquote>
<div><p>return count</p>
</div></blockquote>
<p>}
temp = temp + A
if strings.Contains(temp, B) {</p>
<blockquote>
<div><p>return count + 1</p>
</div></blockquote>
<p>}
return -1</p>
</div></blockquote>
</div>
<div class="section" id="id242">
<h1>}<a class="headerlink" href="#id242" title="永久链接至标题">¶</a></h1>
<p>## 687.最长同值路径(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id243"><span class="problematic" id="id244">``</span></a>`
给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。
注意：两个节点之间的路径长度由它们之间的边数表示。
示例 1:
输入:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><p>5</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<p>4   5</p>
</div></blockquote>
<p>/   </p>
</div></blockquote>
<p>1   1   5</p>
</div></blockquote>
<p>输出:2
示例 2:
输入:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><p>1</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<p>4   5</p>
</div></blockquote>
<p>/   </p>
</div></blockquote>
<p>4   4   5</p>
</div></blockquote>
<p>输出:2
注意: 给定的二叉树不超过10000个结点。 树的高度不超过1000。
<a href="#id245"><span class="problematic" id="id246">``</span></a><a href="#id247"><span class="problematic" id="id248">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路        | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ———– | ———- | ———- |</div>
<div class="line">01   | 递归        | O(n)       | O(log(n))  |</div>
<div class="line">02   | 递归        | O(n)       | O(log(n))  |</div>
<div class="line">03   | 迭代+栈辅助 | O(n)       | O(n)       |</div>
</div>
<p><a href="#id249"><span class="problematic" id="id250">``</span></a><a href="#id251"><span class="problematic" id="id252">`</span></a>go
var maxLen int</p>
<dl class="simple">
<dt>func longestUnivaluePath(root <a href="#id253"><span class="problematic" id="id254">*</span></a>TreeNode) int {</dt><dd><p>maxLen = 0
dfs(root)
return maxLen</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func dfs(root <a href="#id255"><span class="problematic" id="id256">*</span></a>TreeNode) int {</dt><dd><dl class="simple">
<dt>if root == nil {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
left := dfs(root.Left)
right := dfs(root.Right)
l, r := 0, 0
if root.Left != nil &amp;&amp; root.Val == root.Left.Val {</p>
<blockquote>
<div><p>l = left + 1</p>
</div></blockquote>
<p>}
if root.Right != nil &amp;&amp; root.Val == root.Right.Val {</p>
<blockquote>
<div><p>r = right + 1</p>
</div></blockquote>
<p>}
if l+r &gt; maxLen {</p>
<blockquote>
<div><p>maxLen = l + r</p>
</div></blockquote>
<p>}
return max(l, r)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func max(a, b int) int {</dt><dd><dl class="simple">
<dt>if a &gt; b {</dt><dd><p>return a</p>
</dd>
</dl>
<p>}
return b</p>
</dd>
</dl>
<p>}</p>
<p>#
var maxLen int</p>
<dl>
<dt>func longestUnivaluePath(root <a href="#id257"><span class="problematic" id="id258">*</span></a>TreeNode) int {</dt><dd><p>maxLen = 0
if root == nil {</p>
<blockquote>
<div><p>return 0</p>
</div></blockquote>
<p>}
dfs(root, root.Val)
return maxLen</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func dfs(root <a href="#id259"><span class="problematic" id="id260">*</span></a>TreeNode, val int) int {</dt><dd><dl class="simple">
<dt>if root == nil {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
left := dfs(root.Left, root.Val)
right := dfs(root.Right, root.Val)
if left+right &gt; maxLen {</p>
<blockquote>
<div><p>maxLen = left + right</p>
</div></blockquote>
<p>}
if root.Val == val {</p>
<blockquote>
<div><p>return max(left, right) + 1</p>
</div></blockquote>
<p>}
return 0</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func max(a, b int) int {</dt><dd><dl class="simple">
<dt>if a &gt; b {</dt><dd><p>return a</p>
</dd>
</dl>
<p>}
return b</p>
</dd>
</dl>
<p>}</p>
<p># 参考543.二叉树的直径做法
func longestUnivaluePath(root <a href="#id261"><span class="problematic" id="id262">*</span></a>TreeNode) int {</p>
<blockquote>
<div><p>res := 0
stack := make([]*TreeNode, 0)
m := make(map[<a href="#id263"><span class="problematic" id="id264">*</span></a>TreeNode]int)</p>
<p>cur := root
var prev <a href="#id265"><span class="problematic" id="id266">*</span></a>TreeNode
for cur != nil || len(stack) != 0 {</p>
<blockquote>
<div><dl class="simple">
<dt>for cur != nil {</dt><dd><p>stack = append(stack, cur)
cur = cur.Left</p>
</dd>
</dl>
<p>}
cur = stack[len(stack)-1]
if cur.Right == nil || cur.Right == prev {</p>
<blockquote>
<div><p>cur = stack[len(stack)-1]
stack = stack[:len(stack)-1]
leftLen := 0
rightLen := 0
if v, ok := m[cur.Left]; ok {</p>
<blockquote>
<div><p>leftLen = v</p>
</div></blockquote>
<p>}
if v, ok := m[cur.Right]; ok {</p>
<blockquote>
<div><p>rightLen = v</p>
</div></blockquote>
<p>}
var left, right int
if cur.Left != nil &amp;&amp; cur.Val == cur.Left.Val {</p>
<blockquote>
<div><p>left = leftLen + 1</p>
</div></blockquote>
<p>}
if cur.Right != nil &amp;&amp; cur.Val == cur.Right.Val {</p>
<blockquote>
<div><p>right = rightLen + 1</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>if left+right &gt; res {</dt><dd><p>res = left + right</p>
</dd>
</dl>
<p>}
if left &gt; right {</p>
<blockquote>
<div><p>m[cur] = left</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>m[cur] = right</p>
</dd>
</dl>
<p>}
prev = cur
cur = nil</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>cur = cur.Right</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
</div>
<div class="section" id="id267">
<h1>}<a class="headerlink" href="#id267" title="永久链接至标题">¶</a></h1>
<p>## 690.员工的重要性(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id268"><span class="problematic" id="id269">``</span></a>`
给定一个保存员工信息的数据结构，它包含了员工唯一的id，重要度 和 直系下属的id。
比如，员工1是员工2的领导，员工2是员工3的领导。他们相应的重要度为15, 10, 5。
那么员工1的数据结构是[1, 15, [2]]，员工2的数据结构是[2, 10, [3]]，员工3的数据结构是[3, 5, []]。
注意虽然员工3也是员工1的一个下属，但是由于并不是直系下属，因此没有体现在员工1的数据结构中。
现在输入一个公司的所有员工信息，以及单个员工id，返回这个员工和他所有下属的重要度之和。</p>
<p>示例 1:输入: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1 输出: 11
解释:
员工1自身的重要度是5，他有两个直系下属2和3，而且2和3的重要度均为3。因此员工1的总重要度是 5 + 3 + 3 = 11。
注意:</p>
<blockquote>
<div><p>一个员工最多有一个直系领导，但是可以有多个直系下属
员工数量不超过2000。</p>
</div></blockquote>
<p><a href="#id270"><span class="problematic" id="id271">``</span></a><a href="#id272"><span class="problematic" id="id273">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路              | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —————– | ———- | ———- |</div>
<div class="line">01   | 深度优先搜索-递归 | O(n)       | O(log(n))  |</div>
<div class="line">02   | 广度优先搜索-迭代 | O(n)       | O(n)       |</div>
</div>
<p><a href="#id274"><span class="problematic" id="id275">``</span></a><a href="#id276"><span class="problematic" id="id277">`</span></a>go
func getImportance(employees []*Employee, id int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if len(employees) == 0 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
var root <a href="#id278"><span class="problematic" id="id279">*</span></a>Employee
for i := 0; i &lt; len(employees); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if employees[i].Id == id {</dt><dd><p>root = employees[i]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
if root == nil {</p>
<blockquote>
<div><p>return 0</p>
</div></blockquote>
<p>}
res := root.Importance
for i := range root.Subordinates {</p>
<blockquote>
<div><p>res = res + getImportance(employees, root.Subordinates[i])</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
func getImportance(employees []*Employee, id int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if len(employees) == 0 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
m := make(map[int]*Employee)
for i := 0; i &lt; len(employees); i++ {</p>
<blockquote>
<div><p>m[employees[i].Id] = employees[i]</p>
</div></blockquote>
<p>}
root := m[id]
if root == nil {</p>
<blockquote>
<div><p>return 0</p>
</div></blockquote>
<p>}
res := 0
list := make([]*Employee, 0)
list = append(list, root)
for len(list) &gt; 0 {</p>
<blockquote>
<div><p>node := list[0]
list = list[1:]
res = res + node.Importance
for i := range node.Subordinates {</p>
<blockquote>
<div><dl class="simple">
<dt>if value, ok := m[node.Subordinates[i]]; ok {</dt><dd><p>list = append(list, value)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
</div>
<div class="section" id="id280">
<h1>}<a class="headerlink" href="#id280" title="永久链接至标题">¶</a></h1>
<p>## 693.交替位二进制数(4)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">给定一个正整数，检查他是否为交替位二进制数：换句话说，就是他的二进制数相邻的两个位数永不相等。</span>
<span class="pre">示例</span> <span class="pre">1:</span> <span class="pre">输入:</span> <span class="pre">5</span> <span class="pre">输出:</span> <span class="pre">True</span>
<span class="pre">解释:5的二进制数是:</span> <span class="pre">101</span>
<span class="pre">示例</span> <span class="pre">2:输入:</span> <span class="pre">7</span> <span class="pre">输出:</span> <span class="pre">False</span>
<span class="pre">解释:</span> <span class="pre">7的二进制数是:</span> <span class="pre">111</span>
<span class="pre">示例</span> <span class="pre">3:输入:</span> <span class="pre">11</span> <span class="pre">输出:</span> <span class="pre">False</span>
<span class="pre">解释:</span> <span class="pre">11的二进制数是:</span> <span class="pre">1011</span>
<span class="pre">示例</span> <span class="pre">4:输入:</span> <span class="pre">10</span> <span class="pre">输出:</span> <span class="pre">True</span>
<span class="pre">解释:</span> <span class="pre">10的二进制数是:</span> <span class="pre">1010</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路          | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ————- | ———- | ———- |</div>
<div class="line">01   | 转字符串+遍历 | O(1)       | O(1)       |</div>
<div class="line">02   | 位运算        | O(1)       | O(1)       |</div>
<div class="line">03   | 位运算        | O(1)       | O(1)       |</div>
<div class="line">04   | 遍历          | O(1)       | O(1)       |</div>
</div>
<p><a href="#id281"><span class="problematic" id="id282">``</span></a><a href="#id283"><span class="problematic" id="id284">`</span></a>go
func hasAlternatingBits(n int) bool {</p>
<blockquote>
<div><p>str := strconv.FormatInt(int64(n), 2)
for i := 1; i &lt; len(str); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if str[i] == str[i-1] {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return true</p>
</div></blockquote>
<p>}</p>
<p>#
/*
示例1：
1. n=1010
2. n&gt;&gt;1=101
3. n=n^(n&gt;&gt;1)=1010^101=1111
4. n&amp;(n+1)=1111&amp;(10000)=0</p>
<p>示例2:
1. n=101
2. n&gt;&gt;1=10
3. n=n^(n&gt;&gt;1)=101^10=111
4. n&amp;(n+1)=111&amp;(1000)=0
<a href="#id285"><span class="problematic" id="id286">*</span></a>/
func hasAlternatingBits(n int) bool {</p>
<blockquote>
<div><p>n = n ^ (n &gt;&gt; 1)
return n&amp;(n+1) == 0</p>
</div></blockquote>
<p>}</p>
<p>#
// n (10|01)&amp;3(11)=10|01
func hasAlternatingBits(n int) bool {</p>
<blockquote>
<div><p>temp := n &amp; 3
if temp != 1 &amp;&amp; temp != 2 {</p>
<blockquote>
<div><p>return false</p>
</div></blockquote>
<p>}
for n &gt; 0 {</p>
<blockquote>
<div><dl class="simple">
<dt>if n&amp;3 != temp {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}
n = n &gt;&gt; 2</p>
</div></blockquote>
<p>}
return true</p>
</div></blockquote>
<p>}</p>
<p>#
// n (10|01)&amp;3(11)=10|01
func hasAlternatingBits(n int) bool {</p>
<blockquote>
<div><p>temp := n &amp; 3
if temp != 1 &amp;&amp; temp != 2 {</p>
<blockquote>
<div><p>return false</p>
</div></blockquote>
<p>}
for n &gt; 0 {</p>
<blockquote>
<div><dl class="simple">
<dt>if n&amp;3 != temp {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}
n = n &gt;&gt; 2</p>
</div></blockquote>
<p>}
return true</p>
</div></blockquote>
<p>}</p>
<p>#
func hasAlternatingBits(n int) bool {</p>
<blockquote>
<div><p>pre := n &amp; 1
n = n &gt;&gt; 1
for n &gt; 0 {</p>
<blockquote>
<div><dl class="simple">
<dt>if n&amp;1 == pre {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}
pre = n &amp; 1
n = n &gt;&gt; 1</p>
</div></blockquote>
<p>}
return true</p>
</div></blockquote>
</div>
<div class="section" id="id287">
<h1>}<a class="headerlink" href="#id287" title="永久链接至标题">¶</a></h1>
<p>## 696.计数二进制子串(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id288"><span class="problematic" id="id289">``</span></a>`
给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，
并且这些子字符串中的所有0和所有1都是组合在一起的。
重复出现的子串要计算它们出现的次数。</p>
<p>示例 1 :输入: “00110011” 输出: 6
解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。
请注意，一些重复出现的子串要计算它们出现的次数。
另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。</p>
<p>示例 2 :输入: “10101”输出: 4
解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。
注意：</p>
<blockquote>
<div><p>s.length 在1到50,000之间。
s 只包含“0”或“1”字符。</p>
</div></blockquote>
<p><a href="#id290"><span class="problematic" id="id291">``</span></a><a href="#id292"><span class="problematic" id="id293">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路   | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —— | ———- | ———- |</div>
<div class="line">01   | 遍历   | O(n)       | O(1)       |</div>
<div class="line">02   | 遍历   | O(n)       | O(n)       |</div>
<div class="line">03   | 暴力法 | O(n^2)     | O(1)       |</div>
</div>
<p><a href="#id294"><span class="problematic" id="id295">``</span></a><a href="#id296"><span class="problematic" id="id297">`</span></a>go
func countBinarySubstrings(s string) int {</p>
<blockquote>
<div><p>res := 0
cur := 1
pre := 0
for i := 0; i &lt; len(s)-1; i++ {</p>
<blockquote>
<div><dl>
<dt>if s[i] == s[i+1] {</dt><dd><p>cur++</p>
</dd>
<dt>} else {</dt><dd><dl class="simple">
<dt>if pre &gt; cur {</dt><dd><p>res = res + cur</p>
</dd>
<dt>} else {</dt><dd><p>res = res + pre</p>
</dd>
</dl>
<p>}
pre = cur
cur = 1</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
if pre &gt; cur {</p>
<blockquote>
<div><p>return res + cur</p>
</div></blockquote>
<p>}
return res + pre</p>
</div></blockquote>
<p>}</p>
<p>#
func countBinarySubstrings(s string) int {</p>
<blockquote>
<div><p>res := 0
arr := make([]int, 0)
arr = append(arr, 1)
for i := 1; i &lt; len(s); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if s[i] == s[i-1] {</dt><dd><p>arr[len(arr)-1]++</p>
</dd>
<dt>} else {</dt><dd><p>arr = append(arr, 1)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
for i := 0; i &lt; len(arr)-1; i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if arr[i] &gt; arr[i+1] {</dt><dd><p>res = res + arr[i+1]</p>
</dd>
<dt>} else {</dt><dd><p>res = res + arr[i]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
var count int</p>
<dl>
<dt>func countBinarySubstrings(s string) int {</dt><dd><p>count = 0
for i := 1; i &lt; len(s); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if s[i-1] == ‘0’ &amp;&amp; s[i] == ‘1’ {</dt><dd><p>CountString(s, i-1, i)</p>
</dd>
</dl>
<p>}
if s[i-1] == ‘1’ &amp;&amp; s[i] == ‘0’ {</p>
<blockquote>
<div><p>CountString(s, i-1, i)</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return count</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func CountString(s string, left, right int) {</dt><dd><p>leftStr := s[left]
rightStr := s[right]
for left &gt;= 0 &amp;&amp; right &lt; len(s) &amp;&amp; s[left] == leftStr &amp;&amp; s[right] == rightStr {</p>
<blockquote>
<div><p>left–
right++
count++</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</div>
<div class="section" id="id298">
<h1>}<a class="headerlink" href="#id298" title="永久链接至标题">¶</a></h1>
<p>## 697.数组的度(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id299"><span class="problematic" id="id300">``</span></a>`
给定一个非空且只包含非负数的整数数组 nums, 数组的度的定义是指数组里任一元素出现频数的最大值。
你的任务是找到与 nums 拥有相同大小的度的最短连续子数组，返回其长度。</p>
<p>示例 1:输入: [1, 2, 2, 3, 1]输出: 2
解释: 输入数组的度是2，因为元素1和2的出现频数最大，均为2.
连续子数组里面拥有相同度的有如下所示:
[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]
最短连续子数组[2, 2]的长度为2，所以返回2.</p>
<p>示例 2:输入: [1,2,2,3,1,4,2] 输出: 6</p>
<dl class="simple">
<dt>注意:</dt><dd><p>nums.length 在1到50,000区间范围内。
nums[i] 是一个在0到49,999范围内的整数。</p>
</dd>
</dl>
<p><a href="#id301"><span class="problematic" id="id302">``</span></a><a href="#id303"><span class="problematic" id="id304">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路              | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —————– | ———- | ———- |</div>
<div class="line">01   | 自定义结构体+遍历 | O(n)       | O(n)       |</div>
<div class="line">02   | 哈希辅助          | O(n)       | O(n)       |</div>
<div class="line">03   | 哈希辅助          | O(n)       | O(n)       |</div>
</div>
<p><a href="#id305"><span class="problematic" id="id306">``</span></a><a href="#id307"><span class="problematic" id="id308">`</span></a>go
type node struct {</p>
<blockquote>
<div><p>count int
left  int
right int</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func findShortestSubArray(nums []int) int {</dt><dd><p>m := make(map[int]*node, 0)
for k, v := range nums {</p>
<blockquote>
<div><dl>
<dt>if nd, ok := m[v]; ok {</dt><dd><p>nd.count = nd.count + 1
nd.right = k</p>
</dd>
<dt>} else {</dt><dd><dl class="simple">
<dt>m[v] = &amp;node{</dt><dd><p>count: 1,
left:  k,
right: k,</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
maxNode := new(node)
for _, v := range m {</p>
<blockquote>
<div><dl class="simple">
<dt>if v.count &gt; maxNode.count {</dt><dd><p>maxNode = v</p>
</dd>
<dt>} else if v.count == maxNode.count &amp;&amp;</dt><dd><p>v.right-v.left &lt; maxNode.right-maxNode.left {
maxNode = v</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return maxNode.right - maxNode.left + 1</p>
</dd>
</dl>
<p>}</p>
<p>#
func findShortestSubArray(nums []int) int {</p>
<blockquote>
<div><p>size := len(nums)
if size &lt; 2 {</p>
<blockquote>
<div><p>return size</p>
</div></blockquote>
<p>}
first := make(map[int]int)
count := make(map[int]int)
maxCount := 1
minLen := size
for i, n := range nums {</p>
<blockquote>
<div><p>count[n]++
if count[n] == 1 {</p>
<blockquote>
<div><p>first[n] = i</p>
</div></blockquote>
<dl>
<dt>} else {</dt><dd><p>length := i - first[n] + 1
if maxCount &lt; count[n] ||</p>
<blockquote>
<div><p>(maxCount == count[n] &amp;&amp; minLen &gt; length) {
maxCount = count[n]
minLen = length</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
if len(count) == size {</p>
<blockquote>
<div><p>return 1</p>
</div></blockquote>
<p>}
return minLen</p>
</div></blockquote>
<p>}</p>
<p>#
func findShortestSubArray(nums []int) int {</p>
<blockquote>
<div><p>size := len(nums)
if size &lt; 2 {</p>
<blockquote>
<div><p>return size</p>
</div></blockquote>
<p>}
res := 0
maxLen := 0
m := make(map[int][]int)
for i := 0; i &lt; len(nums); i++ {</p>
<blockquote>
<div><p>m[nums[i]] = append(m[nums[i]], i)</p>
</div></blockquote>
<p>}
for _, v := range m{</p>
<blockquote>
<div><dl class="simple">
<dt>if len(v) &gt; maxLen {</dt><dd><p>maxLen = len(v)
res = v[len(v)-1] - v[0] + 1</p>
</dd>
<dt>} else if len(v) == maxLen &amp;&amp; v[len(v)-1]-v[0]+1 &lt; res {</dt><dd><p>res = v[len(v)-1] - v[0] + 1</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
</div>
<div class="section" id="id309">
<h1>}<a class="headerlink" href="#id309" title="永久链接至标题">¶</a></h1>
<p>## 700.二叉搜索树中的搜索(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id310"><span class="problematic" id="id311">``</span></a>`
给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。
返回以该节点为根的子树。 如果节点不存在，则返回 NULL。
例如，
给定二叉搜索树:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><p>4</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<p>2   7</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<p>1   3</p>
</div></blockquote>
<p>和值: 2
你应该返回如下子树:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>2</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<p>1   3</p>
</div></blockquote>
<p>在上述示例中，如果要找的值是 5，但因为没有节点值为 5，我们应该返回 NULL。
<a href="#id312"><span class="problematic" id="id313">``</span></a><a href="#id314"><span class="problematic" id="id315">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路 | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —- | ———- | ———- |</div>
<div class="line">01   | 递归 | O(n)       | O(log(n))  |</div>
<div class="line">02   | 迭代 | O(n)       | O(n)       |</div>
</div>
<p><a href="#id316"><span class="problematic" id="id317">``</span></a><a href="#id318"><span class="problematic" id="id319">`</span></a>go
func searchBST(root <a href="#id320"><span class="problematic" id="id321">*</span></a>TreeNode, val int) <a href="#id322"><span class="problematic" id="id323">*</span></a>TreeNode {</p>
<blockquote>
<div><dl class="simple">
<dt>if root == nil {</dt><dd><p>return nil</p>
</dd>
</dl>
<p>}
if root.Val &lt; val {</p>
<blockquote>
<div><p>return searchBST(root.Right, val)</p>
</div></blockquote>
<dl class="simple">
<dt>} else if root.Val &gt; val {</dt><dd><p>return searchBST(root.Left, val)</p>
</dd>
</dl>
<p>}
return root</p>
</div></blockquote>
<p>}</p>
<p>#
func searchBST(root <a href="#id324"><span class="problematic" id="id325">*</span></a>TreeNode, val int) <a href="#id326"><span class="problematic" id="id327">*</span></a>TreeNode {</p>
<blockquote>
<div><dl class="simple">
<dt>if root == nil {</dt><dd><p>return nil</p>
</dd>
</dl>
<p>}
stack := make([]*TreeNode, 0)
if root.Val == val {</p>
<blockquote>
<div><p>return root</p>
</div></blockquote>
<dl class="simple">
<dt>} else if root.Val &gt; val &amp;&amp; root.Left != nil {</dt><dd><p>stack = append(stack, root.Left)</p>
</dd>
<dt>} else if root.Val &lt; val &amp;&amp; root.Right != nil {</dt><dd><p>stack = append(stack, root.Right)</p>
</dd>
</dl>
<p>}
for len(stack) &gt; 0 {</p>
<blockquote>
<div><p>node := stack[len(stack)-1]
stack = stack[:len(stack)-1]
if node.Val == val {</p>
<blockquote>
<div><p>return node</p>
</div></blockquote>
<dl class="simple">
<dt>} else if node.Val &gt; val &amp;&amp; node.Left != nil {</dt><dd><p>stack = append(stack, node.Left)</p>
</dd>
<dt>} else if node.Val &lt; val &amp;&amp; node.Right != nil {</dt><dd><p>stack = append(stack, node.Right)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return nil</p>
</div></blockquote>
</div>
<div class="section" id="id328">
<h1>}<a class="headerlink" href="#id328" title="永久链接至标题">¶</a></h1>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="0701-0800.html" class="btn btn-neutral float-right" title="}" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="0501-0600.html" class="btn btn-neutral float-left" title="}" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, willshang

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>