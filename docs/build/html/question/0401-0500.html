

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh-CN" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh-CN" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>} &mdash; go-leetcode v1.0.0 文档</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="}" href="0501-0600.html" />
    <link rel="prev" title="}" href="0301-0400.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> go-leetcode
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id20">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id31">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id42">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id53">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id86">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id111">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id114">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id119">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id122">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id127">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id138">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id149">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id160">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id171">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id182">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id193">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id204">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id215">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id226">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id249">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id260">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id279">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id24">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id25">]</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id48">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id65">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id80">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id95">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id112">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id115">]</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id120">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id131">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id142">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id153">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id164">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id175">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id192">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id219">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id250">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id261">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id272">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id283">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id294">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id305">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id316">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id327">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id350">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id18">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id23">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id34">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id51">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id62">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id73">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id138">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id157">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id168">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id217">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id234">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id253">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id266">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id277">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id296">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id301">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id312">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id323">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id334">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id345">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id356">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id367">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id378">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id20">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id25">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id36">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id47">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id58">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id69">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id74">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id79">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id90">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id101">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id106">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id111">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id124">}</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id26">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id37">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id42">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id45">]</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id50">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id55">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id66">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id71">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id100">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id105">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id116">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id127">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id138">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id143">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id154">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id159">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id170">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id181">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id192">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id203">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id214">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id225">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id236">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id247">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id258">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id24">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id35">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id40">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id51">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id62">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id73">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id98">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id109">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id138">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id149">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id170">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id181">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id192">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id207">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id218">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id235">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id246">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id273">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id284">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id295">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id306">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id323">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id328">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id339">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id350">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id28">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id51">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id62">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id67">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id84">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id95">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id106">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id133">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id144">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id155">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id166">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id185">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id204">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id209">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id220">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id231">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id242">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id267">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id280">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id287">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id298">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id309">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id328">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id46">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id85">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id96">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id111">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id122">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id133">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id146">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id157">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id170">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id181">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id192">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id203">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id214">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id225">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id252">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id263">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id274">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id285">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id22">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id33">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id44">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id55">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id66">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id77">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id82">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id93">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id104">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id115">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id126">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id137">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id148">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id159">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id170">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id181">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id186">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id221">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id232">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id255">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id266">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id277">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id288">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id299">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id310">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id321">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id356">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id22">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id33">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id44">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id55">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id66">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id77">}</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">go-leetcode</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>}</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/question/0401-0500.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <p># 0401-0500-Easy
* [0401-0500-Easy](#0401-0500-easy)</p>
<blockquote>
<div><ul class="simple">
<li><p>[401.二进制手表(3)](#401二进制手表3)</p></li>
<li><p>[404.左叶子之和(2)](#404左叶子之和2)</p></li>
<li><p>[405.数字转换为十六进制数(2)](#405数字转换为十六进制数2)</p></li>
<li><p>[409.最长回文串(2)](#409最长回文串2)</p></li>
<li><p>[412.Fizz Buzz(1)](#412fizz-buzz1)</p></li>
<li><p>[414.第三大的数(2)](#414第三大的数2)</p></li>
<li><p>[415.字符串相加(2)](#415字符串相加2)</p></li>
<li><p>[434.字符串中的单词数(2)](#434字符串中的单词数2)</p></li>
<li><p>[437.路径总和III(4)](#437路径总和iii4)</p></li>
<li><p>[441.排列硬币(3)](#441排列硬币3)</p></li>
<li><p>[443.压缩字符串(1)](#443压缩字符串1)</p></li>
<li><p>[447.回旋镖的数量(1)](#447回旋镖的数量1)</p></li>
<li><p>[448.找到所有数组中消失的数字(3)](#448找到所有数组中消失的数字3)</p></li>
<li><p>[453.最小移动次数使数组元素相等(2)](#453最小移动次数使数组元素相等2)</p></li>
<li><p>[455.分发饼干(1)](#455分发饼干1)</p></li>
<li><p>[459.重复的子字符串(2)](#459重复的子字符串2)</p></li>
<li><p>[461.汉明距离(3)](#461汉明距离3)</p></li>
<li><p>[463.岛屿的周长(3)](#463岛屿的周长3)</p></li>
<li><p>[475.供暖器(2)](#475供暖器2)</p></li>
<li><p>[476.数字的补数(3)](#476数字的补数3)</p></li>
<li><p>[482.密钥格式化(2)](#482密钥格式化2)</p></li>
<li><p>[485.最大连续1的个数(2)](#485最大连续1的个数2)</p></li>
<li><p>[492.构造矩形(1)](#492构造矩形1)</p></li>
<li><p>[496.下一个更大元素 I(3)](#496下一个更大元素-i3)</p></li>
<li><p>[500.键盘行(4)](#500键盘行4)</p></li>
</ul>
</div></blockquote>
<p>## 401.二进制手表(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">``</span></a>`
二进制手表顶部有 4 个 LED 代表小时（0-11），底部的 6 个 LED 代表分钟（0-59）。
每个 LED 代表一个 0 或 1，最低位在右侧。
例如，上面的二进制手表读取 “3:25”。
给定一个非负整数 n 代表当前 LED 亮着的数量，返回所有可能的时间。</p>
<p>案例:输入: n = 1
返回: [“1:00”, “2:00”, “4:00”, “8:00”, “0:01”, “0:02”, “0:04”, “0:08”, “0:16”, “0:32”]</p>
<p>注意事项:
输出的顺序没有要求。
小时不会以零开头，比如 “01:00” 是不允许的，应为 “1:00”。
分钟必须由两位数组成，可能会以零开头，比如 “10:2” 是无效的，应为 “10:02”。
<a href="#id3"><span class="problematic" id="id4">``</span></a><a href="#id5"><span class="problematic" id="id6">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路   | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —— | ———- | ———- |</div>
<div class="line">01   | 暴力法 | O(1)       | O(1)       |</div>
<div class="line">02   | 暴力法 | O(1)       | O(1)       |</div>
<div class="line">03   | 回溯法 | O(2^n)     | O(n)       |</div>
</div>
<p><a href="#id7"><span class="problematic" id="id8">``</span></a><a href="#id9"><span class="problematic" id="id10">`</span></a>go
func binCount(num int) int {</p>
<blockquote>
<div><p>count := make([]int, 0)
for num != 0 {</p>
<blockquote>
<div><p>temp := num % 2
count = append(count, temp)
num = num / 2</p>
</div></blockquote>
<p>}
countNum := 0
for i := 0; i &lt; len(count); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if count[i] == 1 {</dt><dd><p>countNum++</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return countNum</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func readBinaryWatch(num int) []string {</dt><dd><p>res := make([]string, 0)
for i := 0; i &lt; 12; i++ {</p>
<blockquote>
<div><dl>
<dt>for j := 0; j &lt; 60; j++ {</dt><dd><dl class="simple">
<dt>if binCount(i)+binCount(j) == num {</dt><dd><p>res = append(res, fmt.Sprintf(“%d:%02d”, i, j))</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</dd>
</dl>
<p>}</p>
<p>#
func readBinaryWatch(num int) []string {</p>
<blockquote>
<div><p>res := make([]string, 0)
for i := 0; i &lt; 12; i++ {</p>
<blockquote>
<div><dl>
<dt>for j := 0; j &lt; 60; j++ {</dt><dd><p>hour := fmt.Sprintf(“%b”, i)
minute := fmt.Sprintf(“%b”, j)
if strings.Count(hour, “1”)+strings.Count(minute, “1”) == num {</p>
<blockquote>
<div><p>res = append(res, fmt.Sprintf(“%d:%02d”, i, j))</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
func readBinaryWatch(num int) []string {</p>
<blockquote>
<div><p>res := make([]string, 0)
ledS := make([]bool, 10)</p>
<p>var dfs func(int, int)
dfs = func(idx, num int) {</p>
<blockquote>
<div><dl>
<dt>if num == 0 {</dt><dd><p>// 满足条件
m, h := get(ledS[:6]), get(ledS[6:])
if h &lt; 12 &amp;&amp; m &lt; 60 {</p>
<blockquote>
<div><p>res = append(res, fmt.Sprintf(“%d:%02d”, h, m))</p>
</div></blockquote>
<p>}
return</p>
</dd>
</dl>
<p>}
for i := idx; i &lt; 11-num; i++ {</p>
<blockquote>
<div><p>ledS[i] = true
dfs(i+1, num-1)
ledS[i] = false</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
dfs(0, num)
return res</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func get(ledS []bool) int {</dt><dd><p>bs := []int{1, 2, 4, 8, 16, 32}
var sum int
size := len(ledS)
for i := 0; i &lt; size; i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if ledS[i] {</dt><dd><p>sum += bs[i]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return sum</p>
</dd>
</dl>
<div class="section" id="id11">
<h1>}<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h1>
<p>## 404.左叶子之和(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id12"><span class="problematic" id="id13">``</span></a>`
计算给定二叉树的所有左叶子之和。
示例：</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>3</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<dl>
<dt>9  20</dt><dd><blockquote>
<div><p>/  </p>
</div></blockquote>
<p>15   7</p>
</dd>
</dl>
</div></blockquote>
<p>在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
<a href="#id14"><span class="problematic" id="id15">``</span></a><a href="#id16"><span class="problematic" id="id17">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路 | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —- | ———- | ———- |</div>
<div class="line">01   | 递归 | O(n)       | O(log(n))  |</div>
<div class="line">02   | 迭代 | O(n)       | O(n)       |</div>
</div>
<p><a href="#id18"><span class="problematic" id="id19">``</span></a><a href="#id20"><span class="problematic" id="id21">`</span></a>go
func sumOfLeftLeaves(root <a href="#id22"><span class="problematic" id="id23">*</span></a>TreeNode) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if root == nil {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
if root.Left == nil {</p>
<blockquote>
<div><p>return sumOfLeftLeaves(root.Right)</p>
</div></blockquote>
<p>}
if root.Left.Left == nil &amp;&amp; root.Left.Right == nil {</p>
<blockquote>
<div><p>return root.Left.Val + sumOfLeftLeaves(root.Right)</p>
</div></blockquote>
<p>}
return sumOfLeftLeaves(root.Left) + sumOfLeftLeaves(root.Right)</p>
</div></blockquote>
<p>}</p>
<p>#
func sumOfLeftLeaves(root <a href="#id24"><span class="problematic" id="id25">*</span></a>TreeNode) int {</p>
<blockquote>
<div><p>sum := 0
if root == nil{</p>
<blockquote>
<div><p>return 0</p>
</div></blockquote>
<p>}
queue := make([]*TreeNode,0)
queue = append(queue, root)
for len(queue) &gt; 0{</p>
<blockquote>
<div><p>node := queue[0]
queue = queue[1:]
if node.Left != nil &amp;&amp; node.Left.Left == nil &amp;&amp; node.Left.Right == nil{</p>
<blockquote>
<div><p>sum = sum + node.Left.Val</p>
</div></blockquote>
<p>}
if node.Left != nil{</p>
<blockquote>
<div><p>queue = append(queue, node.Left)</p>
</div></blockquote>
<p>}
if node.Right != nil{</p>
<blockquote>
<div><p>queue = append(queue, node.Right)</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return sum</p>
</div></blockquote>
</div>
<div class="section" id="id26">
<h1>}<a class="headerlink" href="#id26" title="永久链接至标题">¶</a></h1>
<p>## 405.数字转换为十六进制数(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id27"><span class="problematic" id="id28">``</span></a>`
给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。
注意:</p>
<blockquote>
<div><p>十六进制中所有字母(a-f)都必须是小写。
十六进制字符串中不能包含多余的前导零。
如果要转化的数为0，那么以单个字符’0’来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。
给定的数确保在32位有符号整数范围内。
不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。</p>
</div></blockquote>
<p>示例 1： 输入:26 输出:”1a”
示例 2： 输入:-1 输出:”ffffffff”
<a href="#id29"><span class="problematic" id="id30">``</span></a><a href="#id31"><span class="problematic" id="id32">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路   | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —— | ———- | ———- |</div>
<div class="line">01   | 位运算 | O(1)       | O(1)       |</div>
<div class="line">02   | 遍历   | O(1)       | O(1)       |</div>
</div>
<p><a href="#id33"><span class="problematic" id="id34">``</span></a><a href="#id35"><span class="problematic" id="id36">`</span></a>go
var h = []string{</p>
<blockquote>
<div><p>“0”, “1”, “2”, “3”, “4”, “5”, “6”, “7”,
“8”, “9”, “a”, “b”, “c”, “d”, “e”, “f”,</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func toHex(num int) string {</dt><dd><p>hex := “”
if num == 0 {</p>
<blockquote>
<div><p>return “0”</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>for i := 0; i &lt; 8 &amp;&amp; num != 0; i++ {</dt><dd><p>hex = h[num&amp;15] + hex
num = num &gt;&gt; 4</p>
</dd>
</dl>
<p>}
return hex</p>
</dd>
</dl>
<p>}</p>
<p>#
var h = []string{</p>
<blockquote>
<div><p>“0”, “1”, “2”, “3”, “4”, “5”, “6”, “7”,
“8”, “9”, “a”, “b”, “c”, “d”, “e”, “f”,</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func toHex(num int) string {</dt><dd><p>res := “”
if num == 0{</p>
<blockquote>
<div><p>return “0”</p>
</div></blockquote>
<p>}
if num &lt; 0 {</p>
<blockquote>
<div><p>num = num + 4294967296</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>for num != 0{</dt><dd><p>temp := num % 16
res = h[temp] + res
num = num / 16</p>
</dd>
</dl>
<p>}
return res</p>
</dd>
</dl>
</div>
<div class="section" id="id37">
<h1>}<a class="headerlink" href="#id37" title="永久链接至标题">¶</a></h1>
<p>## 409.最长回文串(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。</span>
<span class="pre">在构造过程中，请注意区分大小写。比如</span> <span class="pre">&quot;Aa&quot;</span> <span class="pre">不能当做一个回文字符串。</span>
<span class="pre">注意:假设字符串的长度不会超过</span> <span class="pre">1010。</span>
<span class="pre">示例</span> <span class="pre">1:输入:&quot;abccccdd&quot;输出:7</span>
<span class="pre">解释:我们可以构造的最长的回文串是&quot;dccaccd&quot;,</span> <span class="pre">它的长度是</span> <span class="pre">7。</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路     | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ——– | ———- | ———- |</div>
<div class="line">01   | 数组辅助 | O(n)       | O(1)       |</div>
<div class="line">02   | 哈希辅助 | O(n)       | O(1)       |</div>
</div>
<p><a href="#id38"><span class="problematic" id="id39">``</span></a><a href="#id40"><span class="problematic" id="id41">`</span></a>go
func longestPalindrome(s string) int {</p>
<blockquote>
<div><p>ret := 0
a := [123]int{}
for i := range s {</p>
<blockquote>
<div><p>a[s[i]]++</p>
</div></blockquote>
<p>}
hasOdd := 0
for i := range a {</p>
<blockquote>
<div><dl class="simple">
<dt>if a[i] == 0 {</dt><dd><p>continue</p>
</dd>
</dl>
<p>}
if a[i] % 2 == 0 {</p>
<blockquote>
<div><p>ret += a[i]</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>ret += a[i] - 1
hasOdd = 1</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return ret + hasOdd</p>
</div></blockquote>
<p>}</p>
<p>#
func longestPalindrome(s string) int {</p>
<blockquote>
<div><p>ret := 0
a := make(map[byte]int)
for i := range s {</p>
<blockquote>
<div><p>a[s[i]]++</p>
</div></blockquote>
<p>}
hasOdd := 0
for i := range a {</p>
<blockquote>
<div><dl class="simple">
<dt>if a[i] == 0 {</dt><dd><p>continue</p>
</dd>
</dl>
<p>}
if a[i]%2 == 0 {</p>
<blockquote>
<div><p>ret += a[i]</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>ret += a[i] - 1
hasOdd = 1</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return ret + hasOdd</p>
</div></blockquote>
</div>
<div class="section" id="id42">
<h1>}<a class="headerlink" href="#id42" title="永久链接至标题">¶</a></h1>
<p>## 412.Fizz Buzz(1)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id43"><span class="problematic" id="id44">``</span></a>`
写一个程序，输出从 1 到 n 数字的字符串表示。
1. 如果 n 是3的倍数，输出“Fizz”；
2. 如果 n 是5的倍数，输出“Buzz”；
3.如果 n 同时是3和5的倍数，输出 “FizzBuzz”。</p>
<p>示例：n = 15,
返回:
[</p>
<blockquote>
<div><p>“1”,
“2”,
“Fizz”,
“4”,
“Buzz”,
“Fizz”,
“7”,
“8”,
“Fizz”,
“Buzz”,
“11”,
“Fizz”,
“13”,
“14”,
“FizzBuzz”</p>
</div></blockquote>
</div>
<div class="section" id="id45">
<h1>]<a class="headerlink" href="#id45" title="永久链接至标题">¶</a></h1>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路 | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —- | ———- | ———- |</div>
<div class="line">01   | 遍历 | O(n)       | O(1)       |</div>
</div>
<p><a href="#id46"><span class="problematic" id="id47">``</span></a><a href="#id48"><span class="problematic" id="id49">`</span></a>go
func fizzBuzz(n int) []string {</p>
<blockquote>
<div><p>ret := make([]string, n)
for i := range ret {</p>
<blockquote>
<div><p>x := i + 1
switch {
case x%15 == 0:</p>
<blockquote>
<div><p>ret[i] = “FizzBuzz”</p>
</div></blockquote>
<dl class="simple">
<dt>case x%5 == 0:</dt><dd><p>ret[i] = “Buzz”</p>
</dd>
<dt>case x%3 == 0:</dt><dd><p>ret[i] = “Fizz”</p>
</dd>
<dt>default:</dt><dd><p>ret[i] = strconv.Itoa(x)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return ret</p>
</div></blockquote>
</div>
<div class="section" id="id50">
<h1>}<a class="headerlink" href="#id50" title="永久链接至标题">¶</a></h1>
<p>## 414.第三大的数(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。</span>
<span class="pre">示例</span> <span class="pre">1:输入:</span> <span class="pre">[3,</span> <span class="pre">2,</span> <span class="pre">1]输出:</span> <span class="pre">1</span>
<span class="pre">解释:</span> <span class="pre">第三大的数是</span> <span class="pre">1.</span>
<span class="pre">示例</span> <span class="pre">2:输入:</span> <span class="pre">[1,</span> <span class="pre">2]输出:</span> <span class="pre">2</span>
<span class="pre">解释:</span> <span class="pre">第三大的数不存在,</span> <span class="pre">所以返回最大的数</span> <span class="pre">2</span> <span class="pre">.</span>
<span class="pre">示例</span> <span class="pre">3:输入:</span> <span class="pre">[2,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">1]输出:</span> <span class="pre">1</span>
<span class="pre">解释:</span> <span class="pre">注意，要求返回第三大的数，是指第三大且唯一出现的数。存在两个值为2的数，它们都排第二。</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路     | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ——– | ———- | ———- |</div>
<div class="line">01   | 遍历     | O(n)       | O(1)       |</div>
<div class="line">02   | 排序遍历 | O(nlog(n)) | O(1)       |</div>
</div>
<p><a href="#id51"><span class="problematic" id="id52">``</span></a><a href="#id53"><span class="problematic" id="id54">`</span></a>go
func thirdMax(nums []int) int {</p>
<blockquote>
<div><p>max1, max2, max3 := math.MinInt64, math.MinInt64, math.MinInt64
for _, n := range nums {</p>
<blockquote>
<div><dl class="simple">
<dt>if n == max1 || n == max2 {</dt><dd><p>continue</p>
</dd>
</dl>
<p>}
switch {
case max1 &lt; n:</p>
<blockquote>
<div><p>max1, max2, max3 = n, max1, max2</p>
</div></blockquote>
<dl class="simple">
<dt>case max2 &lt; n:</dt><dd><p>max2, max3 = n, max2</p>
</dd>
<dt>case max3 &lt; n:</dt><dd><p>max3 = n</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>if max3 == math.MinInt64 {</dt><dd><p>return max1</p>
</dd>
</dl>
<p>}
return max3</p>
</div></blockquote>
<p>}</p>
<p>#
func thirdMax(nums []int) int {</p>
<blockquote>
<div><p>sort.Ints(nums)
if len(nums) &lt; 3 {</p>
<blockquote>
<div><p>return nums[len(nums)-1]</p>
</div></blockquote>
<p>}</p>
<p>k := 2
maxValue := nums[len(nums)-1]
for i := len(nums) - 2; i &gt;= 0; i– {</p>
<blockquote>
<div><dl class="simple">
<dt>if nums[i] != nums[i+1] {</dt><dd><p>k–</p>
</dd>
</dl>
<p>}
if k == 0 {</p>
<blockquote>
<div><p>return nums[i]</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return maxValue</p>
</div></blockquote>
</div>
<div class="section" id="id55">
<h1>}<a class="headerlink" href="#id55" title="永久链接至标题">¶</a></h1>
<p>## 415.字符串相加(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id56"><span class="problematic" id="id57">``</span></a>`
给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。</p>
<p>注意：
num1 和num2 的长度都小于 5100.
num1 和num2 都只包含数字 0-9.
num1 和num2 都不包含任何前导零。
你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。
<a href="#id58"><span class="problematic" id="id59">``</span></a><a href="#id60"><span class="problematic" id="id61">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路         | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ———— | ———- | ———- |</div>
<div class="line">01   | 模拟遍历     | O(n)       | O(1)       |</div>
<div class="line">02   | 逆置进位模拟 | O(n)       | O(1)       |</div>
</div>
<p><a href="#id62"><span class="problematic" id="id63">``</span></a><a href="#id64"><span class="problematic" id="id65">`</span></a>go
func addStrings(num1 string, num2 string) string {</p>
<blockquote>
<div><dl class="simple">
<dt>if len(num1) &gt; len(num2) {</dt><dd><p>num1, num2 = num2, num1</p>
</dd>
</dl>
<p>}
n1, n2 := len(num1), len(num2)
a1, a2 := []byte(num1), []byte(num2)
carry := byte(0)
buf := make([]byte, n2+1)
buf[0] = ‘1’</p>
<dl>
<dt>for i := 1; i &lt;= n2; i++ {</dt><dd><dl class="simple">
<dt>if i &lt;= n1 {</dt><dd><p>buf[n2+1-i] = a1[n1-i] - ‘0’</p>
</dd>
</dl>
<p>}
buf[n2+1-i] = buf[n2+1-i] + a2[n2-i] + carry</p>
<dl class="simple">
<dt>if buf[n2+1-i] &gt; ‘9’ {</dt><dd><p>buf[n2+1-i] = buf[n2+1-i] - 10
carry = byte(1)</p>
</dd>
<dt>} else {</dt><dd><p>carry = byte(0)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
if carry == 1 {</p>
<blockquote>
<div><p>return string(buf)</p>
</div></blockquote>
<p>}
return string(buf[1:])</p>
</div></blockquote>
<p>}</p>
<p>#
func addStrings(num1 string, num2 string) string {</p>
<blockquote>
<div><dl class="simple">
<dt>if len(num1) &gt; len(num2) {</dt><dd><p>num1, num2 = num2, num1</p>
</dd>
</dl>
<p>}
n1, n2 := len(num1), len(num2)
a1, a2 := []byte(num1), []byte(num2)
a1 = reverse(a1)
a2 = reverse(a2)</p>
<p>carry := 0
buf := make([]byte, 0)
for i := 0; i &lt; n2; i++ {</p>
<blockquote>
<div><p>temp := 0
if i &lt; n1 {</p>
<blockquote>
<div><p>temp = int(a1[i] - ‘0’)</p>
</div></blockquote>
<p>}
temp = int(a2[i]-‘0’) + temp + carry
if temp &gt; 9 {</p>
<blockquote>
<div><p>buf = append(buf, byte(temp-10+’0’))
carry = 1</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>buf = append(buf, byte(temp+’0’))
carry = 0</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
if carry == 1 {</p>
<blockquote>
<div><p>buf = append(buf, byte(‘1’))</p>
</div></blockquote>
<p>}
return string(reverse(buf))</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func reverse(arr []byte) []byte {</dt><dd><dl class="simple">
<dt>for i := 0; i &lt; len(arr)/2; i++ {</dt><dd><p>arr[i], arr[len(arr)-1-i] = arr[len(arr)-1-i], arr[i]</p>
</dd>
</dl>
<p>}
return arr</p>
</dd>
</dl>
</div>
<div class="section" id="id66">
<h1>}<a class="headerlink" href="#id66" title="永久链接至标题">¶</a></h1>
<p>## 434.字符串中的单词数(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。</span>
<span class="pre">请注意，你可以假定字符串里不包括任何不可打印的字符。</span>
<span class="pre">示例:输入:</span> <span class="pre">&quot;Hello,</span> <span class="pre">my</span> <span class="pre">name</span> <span class="pre">is</span> <span class="pre">John&quot;输出:</span> <span class="pre">5</span>
<span class="pre">解释:</span> <span class="pre">这里的单词是指连续的不是空格的字符，所以</span> <span class="pre">&quot;Hello,&quot;</span> <span class="pre">算作</span> <span class="pre">1</span> <span class="pre">个单词。</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路     | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ——– | ———- | ———- |</div>
<div class="line">01   | 内置函数 | O(n)       | O(n)       |</div>
<div class="line">02   | 遍历     | O(n)       | O(1)       |</div>
</div>
<p><a href="#id67"><span class="problematic" id="id68">``</span></a><a href="#id69"><span class="problematic" id="id70">`</span></a>go
func countSegments(s string) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if len(s) == 0 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
return len(strings.Fields(s))</p>
</div></blockquote>
<p>}</p>
<p>#
func countSegments(s string) int {</p>
<blockquote>
<div><p>count := 0
for i := 0; i &lt; len(s); i++{</p>
<blockquote>
<div><dl class="simple">
<dt>if (i == 0 || s[i-1] == ‘ ‘) &amp;&amp; s[i] != ‘ ‘{</dt><dd><p>count++</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return count</p>
</div></blockquote>
</div>
<div class="section" id="id71">
<h1>}<a class="headerlink" href="#id71" title="永久链接至标题">¶</a></h1>
<p>## 437.路径总和III(4)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id72"><span class="problematic" id="id73">``</span></a>`
给定一个二叉树，它的每个结点都存放着一个整数值。
找出路径和等于给定数值的路径总数。
路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<p>二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。
示例：
root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><p>10</p>
</div></blockquote>
<p>/  </p>
</div></blockquote>
<p>5   -3</p>
</div></blockquote>
<p>/    </p>
</div></blockquote>
<p>3   2   11</p>
</div></blockquote>
<p>/   </p>
</div></blockquote>
<p>3  -2   1</p>
<p>返回 3。和等于 8 的路径有:
1.  5 -&gt; 3
2.  5 -&gt; 2 -&gt; 1
3.  -3 -&gt; 11
<a href="#id74"><span class="problematic" id="id75">``</span></a><a href="#id76"><span class="problematic" id="id77">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路  | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —– | ———- | ———- |</div>
<div class="line">01   | 递归  | O(n^2)     | O(n)       |</div>
<div class="line">02   | 2次递归 | O(n^2)        |    O(n)        |</div>
<div class="line">03 | 迭代+递归 | O(n^2) | O(n) |</div>
<div class="line">04 | 保存路径 | O(n^2) | O(n) |</div>
</div>
<p><a href="#id78"><span class="problematic" id="id79">``</span></a><a href="#id80"><span class="problematic" id="id81">`</span></a>go
func pathSum(root <a href="#id82"><span class="problematic" id="id83">*</span></a>TreeNode, sum int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if root == nil {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
res := 0
var helper func(<a href="#id84"><span class="problematic" id="id85">*</span></a>TreeNode, int)
helper = func(node <a href="#id86"><span class="problematic" id="id87">*</span></a>TreeNode, sum int) {</p>
<blockquote>
<div><dl class="simple">
<dt>if node == nil {</dt><dd><p>return</p>
</dd>
</dl>
<p>}
sum = sum - node.Val
// 路径不需要从根节点开始，也不需要在叶子节点结束
if sum == 0 {</p>
<blockquote>
<div><p>res++</p>
</div></blockquote>
<p>}
helper(node.Left, sum)
helper(node.Right, sum)</p>
</div></blockquote>
<p>}
helper(root, sum)
return res + pathSum(root.Left, sum) + pathSum(root.Right, sum)</p>
</div></blockquote>
<p>}</p>
<p>#
func helper(node <a href="#id88"><span class="problematic" id="id89">*</span></a>TreeNode, sum int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if node == nil {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
sum = sum - node.Val
res := 0
if sum == 0 {</p>
<blockquote>
<div><p>res = 1</p>
</div></blockquote>
<p>}
return res + helper(node.Left, sum) + helper(node.Right, sum)</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func pathSum(root <a href="#id90"><span class="problematic" id="id91">*</span></a>TreeNode, sum int) int {</dt><dd><dl class="simple">
<dt>if root == nil {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
return helper(root, sum) + pathSum(root.Left, sum) + pathSum(root.Right, sum)</p>
</dd>
</dl>
<p>}</p>
<p># 迭代+递归
func helper(node <a href="#id92"><span class="problematic" id="id93">*</span></a>TreeNode, sum int, curSum int) int {</p>
<blockquote>
<div><p>res := 0
curSum = curSum + node.Val
if curSum == sum {</p>
<blockquote>
<div><p>res++</p>
</div></blockquote>
<p>}
if node.Left != nil {</p>
<blockquote>
<div><p>res += helper(node.Left, sum, curSum)</p>
</div></blockquote>
<p>}
if node.Right != nil {</p>
<blockquote>
<div><p>res += helper(node.Right, sum, curSum)</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func pathSum(root <a href="#id94"><span class="problematic" id="id95">*</span></a>TreeNode, sum int) int {</dt><dd><dl class="simple">
<dt>if root == nil {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
queue := make([]*TreeNode, 0)
queue = append(queue, root)
res := 0
for len(queue) &gt; 0 {</p>
<blockquote>
<div><p>node := queue[0]
queue = queue[1:]
tempSum := 0
res += helper(node, sum, tempSum)
if node.Left != nil {</p>
<blockquote>
<div><p>queue = append(queue, node.Left)</p>
</div></blockquote>
<p>}
if node.Right != nil {</p>
<blockquote>
<div><p>queue = append(queue, node.Right)</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</dd>
</dl>
<p>}</p>
<p>#
func helper(node <a href="#id96"><span class="problematic" id="id97">*</span></a>TreeNode, sum int, path []int, level int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if node == nil {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
res := 0
if sum == node.Val {</p>
<blockquote>
<div><p>res = 1</p>
</div></blockquote>
<p>}
temp := node.Val
for i := level - 1; i &gt;= 0; i– {</p>
<blockquote>
<div><p>temp = temp + path[i]
if temp == sum {</p>
<blockquote>
<div><p>res++</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
path[level] = node.Val
return res + helper(node.Left, sum, path, level+1) +</p>
<blockquote>
<div><p>helper(node.Right, sum, path, level+1)</p>
</div></blockquote>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>func pathSum(root <a href="#id98"><span class="problematic" id="id99">*</span></a>TreeNode, sum int) int {</dt><dd><p>return helper(root, sum, make([]int, 1001), 0)</p>
</dd>
</dl>
</div>
<div class="section" id="id100">
<h1>}<a class="headerlink" href="#id100" title="永久链接至标题">¶</a></h1>
<p>## 441.排列硬币(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">你总共有</span> <span class="pre">n</span> <span class="pre">枚硬币，你需要将它们摆成一个阶梯形状，第</span> <span class="pre">k</span> <span class="pre">行就必须正好有</span> <span class="pre">k</span> <span class="pre">枚硬币。</span>
<span class="pre">给定一个数字</span> <span class="pre">n，找出可形成完整阶梯行的总行数。</span>
<span class="pre">n</span> <span class="pre">是一个非负整数，并且在32位有符号整型的范围内。</span>
<span class="pre">示例</span> <span class="pre">1:n</span> <span class="pre">=</span> <span class="pre">5</span>
<span class="pre">硬币可排列成以下几行:</span>
<span class="pre">¤</span>
<span class="pre">¤</span> <span class="pre">¤</span>
<span class="pre">¤</span> <span class="pre">¤</span>
<span class="pre">因为第三行不完整，所以返回2.</span>
<span class="pre">示例</span> <span class="pre">2:n</span> <span class="pre">=</span> <span class="pre">8</span>
<span class="pre">硬币可排列成以下几行:</span>
<span class="pre">¤</span>
<span class="pre">¤</span> <span class="pre">¤</span>
<span class="pre">¤</span> <span class="pre">¤</span> <span class="pre">¤</span>
<span class="pre">¤</span> <span class="pre">¤</span>
<span class="pre">因为第四行不完整，所以返回3.</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路     | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ——– | ———- | ———- |</div>
<div class="line">01   | 数学法   | O(1)       | O(1)       |</div>
<div class="line">02   | 迭代     | O(n^1/2)   | O(1)       |</div>
<div class="line">03   | 二分查找 | O(log(n))  | O(1)       |</div>
</div>
<p><a href="#id101"><span class="problematic" id="id102">``</span></a><a href="#id103"><span class="problematic" id="id104">`</span></a>go
func arrangeCoins(n int) int {</p>
<blockquote>
<div><p>return int(math.Sqrt(float64(2*n)+0.25) - 0.5)</p>
</div></blockquote>
<p>}</p>
<p>#
func arrangeCoins(n int) int {</p>
<blockquote>
<div><p>i := 1
for i &lt;= n{</p>
<blockquote>
<div><p>n = n - i
i++</p>
</div></blockquote>
<p>}
return i-1</p>
</div></blockquote>
<p>}</p>
<p>#
func arrangeCoins(n int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if n == 0{</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
left, right := 1, n
for left &lt; right{</p>
<blockquote>
<div><p>mid := left + (right-left)/2
if mid * (mid+1)/2 &lt; n{</p>
<blockquote>
<div><p>left = mid + 1</p>
</div></blockquote>
<dl class="simple">
<dt>}else {</dt><dd><p>right = mid</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
if left*(left+1)/2 == n{</p>
<blockquote>
<div><p>return left</p>
</div></blockquote>
<p>}
return left-1</p>
</div></blockquote>
</div>
<div class="section" id="id105">
<h1>}<a class="headerlink" href="#id105" title="永久链接至标题">¶</a></h1>
<p>## 443.压缩字符串(1)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id106"><span class="problematic" id="id107">``</span></a>`
给定一组字符，使用原地算法将其压缩。
压缩后的长度必须始终小于或等于原数组长度。
数组的每个元素应该是长度为1 的字符（不是 int 整数类型）。
在完成原地修改输入数组后，返回数组的新长度。
进阶：你能否仅使用O(1) 空间解决问题？</p>
<p>示例 1：输入：[“a”,”a”,”b”,”b”,”c”,”c”,”c”]
输出：返回6，输入数组的前6个字符应该是：[“a”,”2”,”b”,”2”,”c”,”3”]
说明：”aa”被”a2”替代。”bb”被”b2”替代。”ccc”被”c3”替代。</p>
<p>示例 2：输入：[“a”]
输出：返回1，输入数组的前1个字符应该是：[“a”]
说明：没有任何字符串被替代。</p>
<p>示例 3：输入：[“a”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”]
输出：返回4，输入数组的前4个字符应该是：[“a”,”b”,”1”,”2”]。
说明：由于字符”a”不重复，所以不会被压缩。”bbbbbbbbbbbb”被“b12”替代。
注意每个数字在数组中都有它自己的位置。
注意：</p>
<blockquote>
<div><p>所有字符都有一个ASCII值在[35, 126]区间内。
1 &lt;= len(chars) &lt;= 1000。</p>
</div></blockquote>
<p><a href="#id108"><span class="problematic" id="id109">``</span></a><a href="#id110"><span class="problematic" id="id111">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路   | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —— | ———- | ———- |</div>
<div class="line">01   | 双指针 | O(n)       | O(1)       |</div>
</div>
<p><a href="#id112"><span class="problematic" id="id113">``</span></a><a href="#id114"><span class="problematic" id="id115">`</span></a>go
func compress(chars []byte) int {</p>
<blockquote>
<div><p>j := 0
count := 1
for i := 0; i &lt; len(chars); i++ {</p>
<blockquote>
<div><p>char := chars[i]
if i+1 &lt; len(chars) &amp;&amp; char == chars[i+1] {</p>
<blockquote>
<div><p>count++</p>
</div></blockquote>
<dl>
<dt>} else {</dt><dd><p>chars[j] = char
j++
if count &gt; 1 {</p>
<blockquote>
<div><dl class="simple">
<dt>for _, num := range strconv.Itoa(count) {</dt><dd><p>chars[j] = byte(num)
j++</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
count = 1</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return j</p>
</div></blockquote>
</div>
<div class="section" id="id116">
<h1>}<a class="headerlink" href="#id116" title="永久链接至标题">¶</a></h1>
<p>## 447.回旋镖的数量(1)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id117"><span class="problematic" id="id118">``</span></a>`
给定平面上 n 对不同的点，“回旋镖” 是由点表示的元组 (i, j, k) ，
其中 i 和 j 之间的距离和 i 和 k 之间的距离相等（需要考虑元组的顺序）。</p>
<p>找到所有回旋镖的数量。你可以假设 n 最大为 500，所有点的坐标在闭区间 [-10000, 10000] 中。
示例:
输入:[[0,0],[1,0],[2,0]]
输出:2
解释:两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]]
<a href="#id119"><span class="problematic" id="id120">``</span></a><a href="#id121"><span class="problematic" id="id122">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路          | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ————- | ———- | ———- |</div>
<div class="line">01   | 哈希辅助+遍历 | O(n^2)     | O(n)       |</div>
</div>
<p><a href="#id123"><span class="problematic" id="id124">``</span></a><a href="#id125"><span class="problematic" id="id126">`</span></a>go
func numberOfBoomerangs(points [][]int) int {</p>
<blockquote>
<div><p>res := 0
size := len(points)
if size &lt; 3 {</p>
<blockquote>
<div><p>return 0</p>
</div></blockquote>
<p>}
for i := 0; i &lt; size; i++ {</p>
<blockquote>
<div><p>dMap := make(map[int]int, size)
for j := 0; j &lt; size; j++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if i == j {</dt><dd><p>continue</p>
</dd>
</dl>
<p>}
d := dSquare(points[i], points[j])
if _, ok := dMap[d]; ok {</p>
<blockquote>
<div><p>dMap[d]++</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>dMap[d] = 1</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
// 相同距离的v个点，总共有 v*(v-1)种排列
for _, v := range dMap {</p>
<blockquote>
<div><p>res = res + v*(v-1)</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>func dSquare(p1, p2 []int) int {</dt><dd><p>x := p2[0] - p1[0]
y := p2[1] - p1[1]
return x*x + y*y</p>
</dd>
</dl>
</div>
<div class="section" id="id127">
<h1>}<a class="headerlink" href="#id127" title="永久链接至标题">¶</a></h1>
<p>## 448.找到所有数组中消失的数字(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id128"><span class="problematic" id="id129">``</span></a>`
给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。
找到所有在 [1, n] 范围之间没有出现在数组中的数字。
您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p>
<p>示例:输入:[4,3,2,7,8,2,3,1]输出:[5,6]
<a href="#id130"><span class="problematic" id="id131">``</span></a><a href="#id132"><span class="problematic" id="id133">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路     | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ——– | ———- | ———- |</div>
<div class="line">01   | 遍历交换 | O(n)       | O(1)       |</div>
<div class="line">02   | 遍历置反 | O(n)       | O(1)       |</div>
<div class="line">03   | 哈希辅助 | O(n)       | O(n)       |</div>
</div>
<p><a href="#id134"><span class="problematic" id="id135">``</span></a><a href="#id136"><span class="problematic" id="id137">`</span></a>go
func findDisappearedNumbers(nums []int) []int {</p>
<blockquote>
<div><dl>
<dt>for i := 0; i &lt; len(nums); i++ {</dt><dd><dl class="simple">
<dt>for nums[i] != nums[nums[i]-1] {</dt><dd><p>nums[i], nums[nums[i]-1] = nums[nums[i]-1], nums[i]</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
res := make([]int, 0)
for i, n := range nums {</p>
<blockquote>
<div><dl class="simple">
<dt>if n != i+1 {</dt><dd><p>res = append(res, i+1)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
func findDisappearedNumbers(nums []int) []int {</p>
<blockquote>
<div><dl>
<dt>for i := 0; i &lt; len(nums); i++ {</dt><dd><p>value := nums[i]
if value &lt; 0{</p>
<blockquote>
<div><p>value = -value</p>
</div></blockquote>
<p>}
if nums[value-1] &gt; 0{</p>
<blockquote>
<div><p>nums[value-1] = -nums[value-1]</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}
res := make([]int, 0)
for key, value := range nums {</p>
<blockquote>
<div><dl class="simple">
<dt>if value &gt; 0{</dt><dd><p>res = append(res, key+1)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
func findDisappearedNumbers(nums []int) []int {</p>
<blockquote>
<div><p>m := make(map[int]int)
for i := 0; i &lt; len(nums); i++ {</p>
<blockquote>
<div><p>m[nums[i]] = 1</p>
</div></blockquote>
<p>}
res := make([]int, 0)
for i := 0; i &lt; len(nums); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if _, ok := m[i+1]; !ok {</dt><dd><p>res = append(res, i+1)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
</div>
<div class="section" id="id138">
<h1>}<a class="headerlink" href="#id138" title="永久链接至标题">¶</a></h1>
<p>## 453.最小移动次数使数组元素相等(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">给定一个长度为</span> <span class="pre">n</span> <span class="pre">的非空整数数组，找到让数组所有元素相等的最小移动次数。每次移动可以使</span> <span class="pre">n</span> <span class="pre">-</span> <span class="pre">1</span> <span class="pre">个元素增加</span> <span class="pre">1。</span>
<span class="pre">示例:输入:[1,2,3]输出:3</span>
<span class="pre">解释:只需要3次移动（注意每次移动会增加两个元素的值）：</span>
<span class="pre">[1,2,3]</span>&#160; <span class="pre">=&gt;</span>&#160; <span class="pre">[2,3,3]</span>&#160; <span class="pre">=&gt;</span>&#160; <span class="pre">[3,4,3]</span>&#160; <span class="pre">=&gt;</span>&#160; <span class="pre">[4,4,4]</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路     | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ——– | ———- | ———- |</div>
<div class="line">01   | 数学公式 | O(n)       | O(1)       |</div>
<div class="line">02   | 排序遍历 | O(nlog(n)) | O(1)       |</div>
</div>
<p><a href="#id139"><span class="problematic" id="id140">``</span></a><a href="#id141"><span class="problematic" id="id142">`</span></a>go
func minMoves(nums []int) int {</p>
<blockquote>
<div><p>sum := 0
min := nums[0]
for _, n := range nums {</p>
<blockquote>
<div><p>sum += n
if min &gt; n {</p>
<blockquote>
<div><p>min = n</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return sum - min*len(nums)</p>
</div></blockquote>
<p>}</p>
<p>#
func minMoves(nums []int) int {</p>
<blockquote>
<div><p>sum := 0
sort.Ints(nums)
for i := 1; i &lt; len(nums); i++{</p>
<blockquote>
<div><p>sum = sum + nums[i] - nums[0]</p>
</div></blockquote>
<p>}
return sum</p>
</div></blockquote>
</div>
<div class="section" id="id143">
<h1>}<a class="headerlink" href="#id143" title="永久链接至标题">¶</a></h1>
<p>## 455.分发饼干(1)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id144"><span class="problematic" id="id145">``</span></a>`
假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。
对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；
并且每块饼干 j ，都有一个尺寸 sj 。
如果 sj &gt;= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。
你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
<p>注意：你可以假设胃口值为正。一个小朋友最多只能拥有一块饼干。</p>
<p>示例 1:输入: [1,2,3], [1,1]  输出: 1
解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。</p>
<p>示例 2:输入: [1,2], [1,2,3] 输出: 2
解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2.
<a href="#id146"><span class="problematic" id="id147">``</span></a><a href="#id148"><span class="problematic" id="id149">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路       | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ———- | ———- | ———- |</div>
<div class="line">01   | 排序双指针 | O(nlog(n)) | O(1)       |</div>
</div>
<p><a href="#id150"><span class="problematic" id="id151">``</span></a><a href="#id152"><span class="problematic" id="id153">`</span></a>go
func findContentChildren(g []int, s []int) int {</p>
<blockquote>
<div><p>sort.Ints(g)
sort.Ints(s)
var i, j int
for i &lt; len(g) &amp;&amp; j &lt; len(s) {</p>
<blockquote>
<div><dl class="simple">
<dt>if g[i] &lt;= s[j] {</dt><dd><p>i++</p>
</dd>
</dl>
<p>}
j++</p>
</div></blockquote>
<p>}
return i</p>
</div></blockquote>
</div>
<div class="section" id="id154">
<h1>}<a class="headerlink" href="#id154" title="永久链接至标题">¶</a></h1>
<p>## 459.重复的子字符串(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。</span>
<span class="pre">给定的字符串只含有小写英文字母，并且长度不超过10000。</span>
<span class="pre">示例</span> <span class="pre">1:输入:</span> <span class="pre">&quot;abab&quot;输出:</span> <span class="pre">True</span>
<span class="pre">解释:</span> <span class="pre">可由子字符串</span> <span class="pre">&quot;ab&quot;</span> <span class="pre">重复两次构成。</span>
<span class="pre">示例</span> <span class="pre">2:输入:</span> <span class="pre">&quot;aba&quot;输出:</span> <span class="pre">False</span>
<span class="pre">示例</span> <span class="pre">3:输入:</span> <span class="pre">&quot;abcabcabcabc&quot;输出:</span> <span class="pre">True</span>
<span class="pre">解释:</span> <span class="pre">可由子字符串</span> <span class="pre">&quot;abc&quot;</span> <span class="pre">重复四次构成。</span> <span class="pre">(或者子字符串</span> <span class="pre">&quot;abcabc&quot;</span> <span class="pre">重复两次构成。)</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路            | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ————— | ———- | ———- |</div>
<div class="line">01   | 2倍去除首尾匹配 | O(n)       | O(1)       |</div>
<div class="line">02   | 暴力匹配        | O(n^2)     | I          |</div>
</div>
<p><a href="#id155"><span class="problematic" id="id156">``</span></a><a href="#id157"><span class="problematic" id="id158">`</span></a>go
func repeatedSubstringPattern(s string) bool {</p>
<blockquote>
<div><dl class="simple">
<dt>if len(s) == 0 {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}</p>
<p>size := len(s)
ss := (s + s)[1 : size*2-1]
return strings.Contains(ss, s)</p>
</div></blockquote>
<p>}</p>
<p>#
func repeatedSubstringPattern(s string) bool {</p>
<blockquote>
<div><dl class="simple">
<dt>if len(s) == 0 {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}
size := len(s)
for i := 1; i &lt; size; i++ {</p>
<blockquote>
<div><dl>
<dt>if size%i == 0 {</dt><dd><p>count := size / i
if strings.Repeat(s[0:i], count) == s {</p>
<blockquote>
<div><p>return true</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return false</p>
</div></blockquote>
</div>
<div class="section" id="id159">
<h1>}<a class="headerlink" href="#id159" title="永久链接至标题">¶</a></h1>
<p>## 461.汉明距离(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id160"><span class="problematic" id="id161">``</span></a>`
两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。
给出两个整数 x 和 y，计算它们之间的汉明距离。
注意：
0 ≤ x, y &lt; 231.
示例:
输入: x = 1, y = 4输出: 2
解释:
1   (0 0 0 1)
4   (0 1 0 0)</p>
<blockquote>
<div><p>↑   ↑</p>
</div></blockquote>
<p>上面的箭头指出了对应二进制位不同的位置。
<a href="#id162"><span class="problematic" id="id163">``</span></a><a href="#id164"><span class="problematic" id="id165">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路            | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ————— | ———- | ———- |</div>
<div class="line">01   | 位运算+遍历统计 | O(1)       | O(1)       |</div>
<div class="line">02   | 位运算          | O(1)       | O(1)       |</div>
<div class="line">03   | 内置函数        | O(1)       | O(1)       |</div>
</div>
<p><a href="#id166"><span class="problematic" id="id167">``</span></a><a href="#id168"><span class="problematic" id="id169">`</span></a>go
func hammingDistance(x int, y int) int {</p>
<blockquote>
<div><p>x = x ^ y
res := 0
for x &gt; 0 {</p>
<blockquote>
<div><dl class="simple">
<dt>if x&amp;1 == 1{</dt><dd><p>res++</p>
</dd>
</dl>
<p>}
x = x &gt;&gt; 1</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
func hammingDistance(x int, y int) int {</p>
<blockquote>
<div><p>x = x ^ y
res := 0
for x &gt; 0 {</p>
<blockquote>
<div><p>res++
x = x &amp; (x-1)</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
func hammingDistance(x int, y int) int {</p>
<blockquote>
<div><p>x = x ^ y
return bits.OnesCount(uint(x))</p>
</div></blockquote>
</div>
<div class="section" id="id170">
<h1>}<a class="headerlink" href="#id170" title="永久链接至标题">¶</a></h1>
<p>## 463.岛屿的周长(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id171"><span class="problematic" id="id172">``</span></a>`
给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。
网格中的格子水平和垂直方向相连（对角线方向不相连）。
整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。
岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。
网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。</p>
<p>示例 :
输入:
[[0,1,0,0],</p>
<blockquote>
<div><p>[1,1,1,0],
[0,1,0,0],
[1,1,0,0]]</p>
</div></blockquote>
<p>输出: 16
<a href="#id173"><span class="problematic" id="id174">``</span></a><a href="#id175"><span class="problematic" id="id176">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路         | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ———— | ———- | ———- |</div>
<div class="line">01   | 暴力法      | O(n^2)     | O(1)       |</div>
<div class="line">02   | 暴力法      | O(n^2)     | O(1)       |</div>
<div class="line">03   | 深度优先搜索 | O(n^2) | O(n^2) |</div>
</div>
<p><a href="#id177"><span class="problematic" id="id178">``</span></a><a href="#id179"><span class="problematic" id="id180">`</span></a>go
func islandPerimeter(grid [][]int) int {</p>
<blockquote>
<div><p>var dx = []int{-1, 1, 0, 0}
var dy = []int{0, 0, -1, 1}
m, n := len(grid), len(grid[0])
res := 0
for i := 0; i &lt; m; i++ {</p>
<blockquote>
<div><dl>
<dt>for j := 0; j &lt; n; j++ {</dt><dd><dl class="simple">
<dt>if grid[i][j] == 0 {</dt><dd><p>continue</p>
</dd>
</dl>
<p>}
res += 4
for k := 0; k &lt; 4; k++ {</p>
<blockquote>
<div><p>x := i + dx[k]
y := j + dy[k]
if (0 &lt;= x &amp;&amp; x &lt; m &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; n) &amp;&amp; grid[x][y] == 1 {</p>
<blockquote>
<div><p>res–</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
func islandPerimeter(grid [][]int) int {</p>
<blockquote>
<div><p>m, n := len(grid), len(grid[0])
res := 0
for i := 0; i &lt; m; i++ {</p>
<blockquote>
<div><dl>
<dt>for j := 0; j &lt; n; j++ {</dt><dd><dl class="simple">
<dt>if grid[i][j] == 0 {</dt><dd><p>continue</p>
</dd>
</dl>
<p>}
res += 4
if i &gt; 0 &amp;&amp; grid[i-1][j] == 1 {</p>
<blockquote>
<div><p>res -= 2</p>
</div></blockquote>
<p>}
if j &gt; 0 &amp;&amp; grid[i][j-1] == 1 {</p>
<blockquote>
<div><p>res -= 2</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
func islandPerimeter(grid [][]int) int {</p>
<blockquote>
<div><p>m, n := len(grid), len(grid[0])
for i := 0; i &lt; m; i++ {</p>
<blockquote>
<div><dl>
<dt>for j := 0; j &lt; n; j++ {</dt><dd><dl class="simple">
<dt>if grid[i][j] == 1 {</dt><dd><p>return dfs(grid, i, j)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return 0</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func dfs(grid [][]int, i, j int) int {</dt><dd><p>// 边界+1
if !(0 &lt;= i &amp;&amp; i &lt; len(grid) &amp;&amp; 0 &lt;= j &amp;&amp; j &lt; len(grid[0])) {</p>
<blockquote>
<div><p>return 1</p>
</div></blockquote>
<p>}
// 水域+1
if grid[i][j] == 0 {</p>
<blockquote>
<div><p>return 1</p>
</div></blockquote>
<p>}
if grid[i][j] != 1 {</p>
<blockquote>
<div><p>return 0</p>
</div></blockquote>
<p>}
grid[i][j] = 2
return dfs(grid, i-1, j) +</p>
<blockquote>
<div><p>dfs(grid, i+1, j) +
dfs(grid, i, j-1) +
dfs(grid, i, j+1)</p>
</div></blockquote>
</dd>
</dl>
</div>
<div class="section" id="id181">
<h1>}<a class="headerlink" href="#id181" title="永久链接至标题">¶</a></h1>
<p>## 475.供暖器(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id182"><span class="problematic" id="id183">``</span></a>`
冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。
现在，给出位于一条水平线上的房屋和供暖器的位置，找到可以覆盖所有房屋的最小加热半径。
所以，你的输入将会是房屋和供暖器的位置。你将输出供暖器的最小加热半径。
说明:</p>
<blockquote>
<div><p>给出的房屋和供暖器的数目是非负数且不会超过 25000。
给出的房屋和供暖器的位置均是非负数且不会超过10^9。
只要房屋位于供暖器的半径内(包括在边缘上)，它就可以得到供暖。
所有供暖器都遵循你的半径标准，加热的半径也一样。</p>
</div></blockquote>
<p>示例 1:输入: [1,2,3],[2] 输出: 1
解释: 仅在位置2上有一个供暖器。如果我们将加热半径设为1，那么所有房屋就都能得到供暖。</p>
<p>示例 2:输入: [1,2,3,4],[1,4] 输出: 1
解释: 在位置1, 4上有两个供暖器。我们需要将加热半径设为1，这样所有房屋就都能得到供暖。
<a href="#id184"><span class="problematic" id="id185">``</span></a><a href="#id186"><span class="problematic" id="id187">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路         | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ———— | ———- | ———- |</div>
<div class="line">01   | 排序双指针   | O(nlog(n)) | O(1)       |</div>
<div class="line">02   | 排序二分查找 | O(nlog(n)) | O(1)       |</div>
</div>
<p><a href="#id188"><span class="problematic" id="id189">``</span></a><a href="#id190"><span class="problematic" id="id191">`</span></a>go
func findRadius(houses []int, heaters []int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if len(heaters) == 0 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
sort.Ints(houses)
sort.Ints(heaters)
res := 0
j := 0
for i := 0; i &lt; len(houses); i++ {</p>
<blockquote>
<div><p>// 找到最近的一个供暖器, &gt;=确保出现重复的供暖器会往后走
for j &lt; len(heaters)-1 &amp;&amp;</p>
<blockquote>
<div><p>Abs(houses[i], heaters[j]) &gt;= Abs(houses[i], heaters[j+1]) {
j++</p>
</div></blockquote>
<p>}
res = Max(Abs(houses[i], heaters[j]), res)</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func Abs(a, b int) int {</dt><dd><dl class="simple">
<dt>if a &gt; b {</dt><dd><p>return a - b</p>
</dd>
</dl>
<p>}
return b - a</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func Max(a, b int) int {</dt><dd><dl class="simple">
<dt>if a &gt; b {</dt><dd><p>return a</p>
</dd>
</dl>
<p>}
return b</p>
</dd>
</dl>
<p>}</p>
<p>#
func findRadius(houses []int, heaters []int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if len(heaters) == 0 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
sort.Ints(houses)
sort.Ints(heaters)
res := 0
length := len(heaters)
for i := 0; i &lt; len(houses); i++ {</p>
<blockquote>
<div><p>left := 0
right := length - 1
for left &lt; right {</p>
<blockquote>
<div><p>mid := left + (right-left)/2
if heaters[mid] &lt; houses[i] {</p>
<blockquote>
<div><p>left = mid + 1</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>right = mid</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
dis := 0
if heaters[left] &lt; houses[i] {</p>
<blockquote>
<div><p>dis = houses[i] - heaters[left]</p>
</div></blockquote>
<dl>
<dt>} else if heaters[left] &gt; houses[i] {</dt><dd><dl class="simple">
<dt>if left == 0 {</dt><dd><p>dis = heaters[0] - houses[i]</p>
</dd>
<dt>} else {</dt><dd><p>dis = Min(heaters[left]-houses[i], houses[i]-heaters[left-1])</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
res = Max(res, dis)</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func Min(a, b int) int {</dt><dd><dl class="simple">
<dt>if a &gt; b {</dt><dd><p>return b</p>
</dd>
</dl>
<p>}
return a</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func Max(a, b int) int {</dt><dd><dl class="simple">
<dt>if a &gt; b {</dt><dd><p>return a</p>
</dd>
</dl>
<p>}
return b</p>
</dd>
</dl>
</div>
<div class="section" id="id192">
<h1>}<a class="headerlink" href="#id192" title="永久链接至标题">¶</a></h1>
<p>## 476.数字的补数(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id193"><span class="problematic" id="id194">``</span></a>`
给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。</p>
<p>示例 1:输入: 5 输出: 2
解释: 5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。
示例 2:输入: 1 输出: 0
解释: 1 的二进制表示为 1（没有前导零位），其补数为 0。所以你需要输出 0 。
注意:</p>
<blockquote>
<div><p>给定的整数保证在 32 位带符号整数的范围内。
你可以假定二进制数不包含前导零位。
本题与 1009 <a class="reference external" href="https://leetcode-cn.com/problems/complement-of-base-10-integer/">https://leetcode-cn.com/problems/complement-of-base-10-integer/</a> 相同</p>
</div></blockquote>
<p><a href="#id195"><span class="problematic" id="id196">``</span></a><a href="#id197"><span class="problematic" id="id198">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路   | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —— | ———- | ———- |</div>
<div class="line">01   | 位运算 | O(log(n))  | O(1)       |</div>
<div class="line">02   | 位运算 | O(log(n))  | O(1)       |</div>
<div class="line">03   | 遍历   | O(log(n))  | O(1)       |</div>
</div>
<p><a href="#id199"><span class="problematic" id="id200">``</span></a><a href="#id201"><span class="problematic" id="id202">`</span></a>go
func findComplement(num int) int {</p>
<blockquote>
<div><p>temp := 1
for num &gt;= temp {</p>
<blockquote>
<div><p>temp = temp &lt;&lt; 1</p>
</div></blockquote>
<p>}
return temp - 1 - num</p>
</div></blockquote>
<p>}</p>
<p>#
func findComplement(num int) int {</p>
<blockquote>
<div><p>temp := num
res := 0
for temp &gt; 0 {</p>
<blockquote>
<div><p>temp = temp &gt;&gt; 1
res = res &lt;&lt; 1
res++</p>
</div></blockquote>
<p>}
return res ^ num</p>
</div></blockquote>
<p>}</p>
<p>#
func findComplement(num int) int {</p>
<blockquote>
<div><p>res := 0
if num == 0 {</p>
<blockquote>
<div><p>return 1</p>
</div></blockquote>
<p>}
if num == 1 {</p>
<blockquote>
<div><p>return 0</p>
</div></blockquote>
<p>}</p>
<p>exp := 1
for num &gt; 0 {</p>
<blockquote>
<div><p>temp := num % 2
if temp == 0 {</p>
<blockquote>
<div><p>res = res + exp
exp = exp * 2</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>exp = exp * 2</p>
</dd>
</dl>
<p>}
num = num / 2</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
</div>
<div class="section" id="id203">
<h1>}<a class="headerlink" href="#id203" title="永久链接至标题">¶</a></h1>
<p>## 482.密钥格式化(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id204"><span class="problematic" id="id205">``</span></a>`
有一个密钥字符串 S ，只包含字母，数字以及 ‘-‘（破折号）。
其中， N 个 ‘-‘ 将字符串分成了 N+1 组。</p>
<p>给你一个数字 K，请你重新格式化字符串，除了第一个分组以外，每个分组要包含 K 个字符；
而第一个分组中，至少要包含 1 个字符。
两个分组之间需要用 ‘-‘（破折号）隔开，并且将所有的小写字母转换为大写字母。
给定非空字符串 S 和数字 K，按照上面描述的规则进行格式化。</p>
<p>示例 1：输入：S = “5F3Z-2e-9-w”, K = 4 输出：”5F3Z-2E9W”
解释：字符串 S 被分成了两个部分，每部分 4 个字符；注意，两个额外的破折号需要删掉。</p>
<p>示例 2：输入：S = “2-5g-3-J”, K = 2 输出：”2-5G-3J”
解释：字符串 S 被分成了 3 个部分，按照前面的规则描述，
第一部分的字符可以少于给定的数量，其余部分皆为 2 个字符。
提示:</p>
<blockquote>
<div><p>S 的长度可能很长，请按需分配大小。K 为正整数。
S 只包含字母数字（a-z，A-Z，0-9）以及破折号’-‘
S 非空</p>
</div></blockquote>
<p><a href="#id206"><span class="problematic" id="id207">``</span></a><a href="#id208"><span class="problematic" id="id209">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路     | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ——– | ———- | ———- |</div>
<div class="line">01   | 内置函数 | O(n)       | O(1)       |</div>
<div class="line">02   | 遍历     | O(n)       | O(1)       |</div>
</div>
<p><a href="#id210"><span class="problematic" id="id211">``</span></a><a href="#id212"><span class="problematic" id="id213">`</span></a>go
func licenseKeyFormatting(S string, K int) string {</p>
<blockquote>
<div><p>arr := strings.Join(strings.Split(strings.ToUpper(S), “-“), “”)
count := len(arr) / K
first := len(arr) % K
if first &gt; 0 {</p>
<blockquote>
<div><p>count++</p>
</div></blockquote>
<p>}
str := arr[:first]
if first != 0 {</p>
<blockquote>
<div><p>count = count - 1</p>
</div></blockquote>
<p>}
for i := 0; i &lt; count; i++ {</p>
<blockquote>
<div><p>str = str + “-” + arr[first+i*K:first+(i+1)*K]</p>
</div></blockquote>
<p>}
return strings.Trim(str, “-“)</p>
</div></blockquote>
<p>}</p>
<p>#
func licenseKeyFormatting(S string, K int) string {</p>
<blockquote>
<div><p>res := make([]rune, 0)
temp := []rune(S)
count := 0
for i := len(temp) - 1; i &gt;= 0; i– {</p>
<blockquote>
<div><p>value := temp[i]
if value &gt;= ‘a’ {</p>
<blockquote>
<div><p>value = value - ‘a’ + ‘A’</p>
</div></blockquote>
<p>}
if value == ‘-‘ {</p>
<blockquote>
<div><p>continue</p>
</div></blockquote>
<p>}
count++
res = append([]rune{value}, res…)
if count == K {</p>
<blockquote>
<div><p>res = append([]rune{‘-‘}, res…)
count = 0</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
if len(res) == 0 {</p>
<blockquote>
<div><p>return “”</p>
</div></blockquote>
<p>}
if res[0] == ‘-‘ {</p>
<blockquote>
<div><p>res = res[1:]</p>
</div></blockquote>
<p>}
return string(res)</p>
</div></blockquote>
</div>
<div class="section" id="id214">
<h1>}<a class="headerlink" href="#id214" title="永久链接至标题">¶</a></h1>
<p>## 485.最大连续1的个数(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id215"><span class="problematic" id="id216">``</span></a>`
给定一个二进制数组， 计算其中最大连续1的个数。
示例 1:输入: [1,1,0,1,1,1]输出: 3
解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3.
注意：</p>
<blockquote>
<div><p>输入的数组只包含 0 和1。
输入数组的长度是正整数，且不超过 10,000。</p>
</div></blockquote>
<p><a href="#id217"><span class="problematic" id="id218">``</span></a><a href="#id219"><span class="problematic" id="id220">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路   | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —— | ———- | ———- |</div>
<div class="line">01   | 双指针 | O(n)       | O(1)       |</div>
<div class="line">02   | 单指针 | O(n)       | O(1)       |</div>
</div>
<p><a href="#id221"><span class="problematic" id="id222">``</span></a><a href="#id223"><span class="problematic" id="id224">`</span></a>go
func findMaxConsecutiveOnes(nums []int) int {</p>
<blockquote>
<div><p>max := 0
for i, j := 0, -1; i &lt; len(nums); i++ {</p>
<blockquote>
<div><dl>
<dt>if nums[i] == 0 {</dt><dd><p>j = i</p>
</dd>
<dt>} else {</dt><dd><dl class="simple">
<dt>if max &lt; i-j {</dt><dd><p>max = i - j</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return max</p>
</div></blockquote>
<p>}</p>
<p>#
func findMaxConsecutiveOnes(nums []int) int {</p>
<blockquote>
<div><p>max := 0
count := 0
for _, v := range nums {</p>
<blockquote>
<div><dl>
<dt>if v == 1 {</dt><dd><p>count++</p>
</dd>
<dt>} else {</dt><dd><dl class="simple">
<dt>if count &gt; max {</dt><dd><p>max = count</p>
</dd>
</dl>
<p>}
count = 0</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
if count &gt; max {</p>
<blockquote>
<div><p>max = count</p>
</div></blockquote>
<p>}
return max</p>
</div></blockquote>
</div>
<div class="section" id="id225">
<h1>}<a class="headerlink" href="#id225" title="永久链接至标题">¶</a></h1>
<p>## 492.构造矩形(1)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id226"><span class="problematic" id="id227">``</span></a>`
作为一位web开发者， 懂得怎样去规划一个页面的尺寸是很重要的。
现给定一个具体的矩形页面面积，你的任务是设计一个长度为 L 和宽度为 W 且满足以下要求的矩形的页面。要求：</p>
<ol class="arabic simple">
<li><p>你设计的矩形页面必须等于给定的目标面积。</p></li>
<li><p>宽度 W 不应大于长度 L，换言之，要求 L &gt;= W 。</p></li>
<li><p>长度 L 和宽度 W 之间的差距应当尽可能小。</p></li>
</ol>
<p>你需要按顺序输出你设计的页面的长度 L 和宽度 W。
示例：
输入: 4 输出: [2, 2]
解释: 目标面积是 4， 所有可能的构造方案有 [1,4], [2,2], [4,1]。
但是根据要求2，[1,4] 不符合要求; 根据要求3，[2,2] 比 [4,1] 更能符合要求.
所以输出长度 L 为 2， 宽度 W 为 2。
说明:</p>
<blockquote>
<div><p>给定的面积不大于 10,000,000 且为正整数。
你设计的页面的长度和宽度必须都是正整数。</p>
</div></blockquote>
<p><a href="#id228"><span class="problematic" id="id229">``</span></a><a href="#id230"><span class="problematic" id="id231">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路         | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ———— | ———- | ———- |</div>
<div class="line">01   | 开方向下遍历 | O(n)       | O(1)       |</div>
</div>
<p><a href="#id232"><span class="problematic" id="id233">``</span></a><a href="#id234"><span class="problematic" id="id235">`</span></a>go
func constructRectangle(area int) []int {</p>
<blockquote>
<div><dl>
<dt>for i := int(math.Sqrt(float64(area))); i &gt; 1; i– {</dt><dd><dl class="simple">
<dt>if area%i == 0 {</dt><dd><p>return []int{area / i, i}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
return []int{area, 1}</p>
</div></blockquote>
</div>
<div class="section" id="id236">
<h1>}<a class="headerlink" href="#id236" title="永久链接至标题">¶</a></h1>
<p>## 496.下一个更大元素 I(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id237"><span class="problematic" id="id238">``</span></a>`
给定两个没有重复元素的数组nums1 和 nums2 ，其中nums1 是 nums2 的子集。
找到 nums1 中每个元素在 nums2 中的下一个比其大的值。
nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。
如果不存在，对应位置输出 -1 。
示例 1:
输入: nums1 = [4,1,2], nums2 = [1,3,4,2].
输出: [-1,3,-1]
解释:</p>
<blockquote>
<div><p>对于num1中的数字4，你无法在第二个数组中找到下一个更大的数字，因此输出 -1。
对于num1中的数字1，第二个数组中数字1右边的下一个较大数字是 3。
对于num1中的数字2，第二个数组中没有下一个更大的数字，因此输出 -1。</p>
</div></blockquote>
<p>示例 2:
输入: nums1 = [2,4], nums2 = [1,2,3,4].
输出: [3,-1]
解释:</p>
<blockquote>
<div><p>对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。
对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出 -1 。</p>
</div></blockquote>
<dl class="simple">
<dt>提示：</dt><dd><p>nums1和nums2中所有元素是唯一的。
nums1和nums2 的数组大小都不超过1000。</p>
</dd>
</dl>
<p><a href="#id239"><span class="problematic" id="id240">``</span></a><a href="#id241"><span class="problematic" id="id242">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路        | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ———– | ———- | ———- |</div>
<div class="line">01   | 哈希辅助    | O(n^2)     | O(n)       |</div>
<div class="line">02   | 哈希辅助    | O(n^2)     | O(n)       |</div>
<div class="line">02   | 栈+哈希辅助 | O(n)       | O(n)       |</div>
</div>
<p><a href="#id243"><span class="problematic" id="id244">``</span></a><a href="#id245"><span class="problematic" id="id246">`</span></a>go
func nextGreaterElement(nums1 []int, nums2 []int) []int {</p>
<blockquote>
<div><p>m := make(map[int]int)
for i, n := range nums2 {</p>
<blockquote>
<div><p>m[n] = i</p>
</div></blockquote>
<p>}
res := make([]int, len(nums1))
for i, n := range nums1 {</p>
<blockquote>
<div><p>res[i] = -1
for j := m[n] + 1; j &lt; len(nums2); j++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if n &lt; nums2[j] {</dt><dd><p>res[i] = nums2[j]
break</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
func nextGreaterElement(nums1 []int, nums2 []int) []int {</p>
<blockquote>
<div><p>m := make(map[int]int)
res := make([]int, len(nums1))
for i := 0; i &lt; len(nums2); i++ {</p>
<blockquote>
<div><dl>
<dt>for j := i + 1; j &lt; len(nums2); j++ {</dt><dd><dl class="simple">
<dt>if nums2[j] &gt; nums2[i] {</dt><dd><p>m[nums2[i]] = nums2[j]
break</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
for key, value := range nums1 {</p>
<blockquote>
<div><dl class="simple">
<dt>if _, ok := m[value]; ok {</dt><dd><p>res[key] = m[value]</p>
</dd>
<dt>} else {</dt><dd><p>res[key] = -1</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
func nextGreaterElement(nums1 []int, nums2 []int) []int {</p>
<blockquote>
<div><p>m := make(map[int]int)
res := make([]int, len(nums1))
stack := make([]int, 0)
for i := 0; i &lt; len(nums2); i++ {</p>
<blockquote>
<div><dl>
<dt>if len(stack) &gt; 0 {</dt><dd><dl class="simple">
<dt>for len(stack) &gt; 0 &amp;&amp; nums2[i] &gt; stack[len(stack)-1] {</dt><dd><p>top := stack[len(stack)-1]
m[top] = nums2[i]
stack = stack[:len(stack)-1]</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
stack = append(stack, nums2[i])</p>
</div></blockquote>
<p>}
for key, value := range nums1 {</p>
<blockquote>
<div><dl class="simple">
<dt>if _, ok := m[value]; ok {</dt><dd><p>res[key] = m[value]</p>
</dd>
<dt>} else {</dt><dd><p>res[key] = -1</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
</div>
<div class="section" id="id247">
<h1>}<a class="headerlink" href="#id247" title="永久链接至标题">¶</a></h1>
<p>## 500.键盘行(4)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id248"><span class="problematic" id="id249">``</span></a>`
给定一个单词列表，只返回可以使用在键盘同一行的字母打印出来的单词。键盘如下图所示。
示例：
输入: [“Hello”, “Alaska”, “Dad”, “Peace”]
输出: [“Alaska”, “Dad”]
注意：</p>
<blockquote>
<div><p>你可以重复使用键盘上同一字符。
你可以假设输入的字符串将只包含字母。</p>
</div></blockquote>
<p><a href="#id250"><span class="problematic" id="id251">``</span></a><a href="#id252"><span class="problematic" id="id253">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路     | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ——– | ———- | ———- |</div>
<div class="line">01   | 哈希辅助 | O(n^2)     | O(1)       |</div>
<div class="line">02   | 哈希辅助 | O(n^2)     | O(1)       |</div>
<div class="line">03   | 遍历     | O(n^2)     | O(1)       |</div>
<div class="line">04   | 内置函数 | O(n^2)     | O(1)       |</div>
</div>
<p><a href="#id254"><span class="problematic" id="id255">``</span></a><a href="#id256"><span class="problematic" id="id257">`</span></a>go
func findWords(words []string) []string {</p>
<blockquote>
<div><p>m := make(map[byte]int)
m[‘q’] = 1
m[‘w’] = 1
m[‘e’] = 1
m[‘r’] = 1
m[‘t’] = 1
m[‘y’] = 1
m[‘u’] = 1
m[‘i’] = 1
m[‘o’] = 1
m[‘p’] = 1
m[‘a’] = 2
m[‘s’] = 2
m[‘d’] = 2
m[‘f’] = 2
m[‘g’] = 2
m[‘h’] = 2
m[‘j’] = 2
m[‘k’] = 2
m[‘l’] = 2
m[‘z’] = 3
m[‘x’] = 3
m[‘c’] = 3
m[‘v’] = 3
m[‘b’] = 3
m[‘n’] = 3
m[‘m’] = 3</p>
<p>res := make([]string, 0)
for i := 0; i &lt; len(words); i++ {</p>
<blockquote>
<div><p>b := []byte(strings.ToLower(words[i]))
level := m[b[0]]
flag := true
for j := 1; j &lt; len(b); j++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if m[b[j]] != level {</dt><dd><p>flag = false
break</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
if flag {</p>
<blockquote>
<div><p>res = append(res, words[i])</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
var qRow = map[byte]bool{</p>
<blockquote>
<div><p>‘q’: true,
‘w’: true,
‘e’: true,
‘r’: true,
‘t’: true,
‘y’: true,
‘u’: true,
‘i’: true,
‘o’: true,
‘p’: true,</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>var aRow = map[byte]bool{</dt><dd><p>‘a’: true,
‘s’: true,
‘d’: true,
‘f’: true,
‘g’: true,
‘h’: true,
‘j’: true,
‘k’: true,
‘l’: true,</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>var zRow = map[byte]bool{</dt><dd><p>‘z’: true,
‘x’: true,
‘c’: true,
‘v’: true,
‘b’: true,
‘n’: true,
‘m’: true,</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func findWords(words []string) []string {</dt><dd><p>res := make([]string, 0, len(words))
for _, word := range words {</p>
<blockquote>
<div><p>w := strings.ToLower(word)
if isAllIn(w, qRow) || isAllIn(w, aRow) || isAllIn(w, zRow) {</p>
<blockquote>
<div><p>res = append(res, word)</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func isAllIn(s string, Row map[byte]bool) bool {</dt><dd><dl>
<dt>for i := range s {</dt><dd><dl class="simple">
<dt>if !Row[s[i]] {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
return true</p>
</dd>
</dl>
<p>}</p>
<p>#
func findWords(words []string) []string {</p>
<blockquote>
<div><p>res := make([]string, 0, len(words))
for _, word := range words {</p>
<blockquote>
<div><p>w := strings.ToLower(word)
flag := 0
for _, m := range w {</p>
<blockquote>
<div><p>switch m {
case ‘q’, ‘w’, ‘e’, ‘r’, ‘t’, ‘y’, ‘u’, ‘i’, ‘o’, ‘p’:</p>
<blockquote>
<div><dl class="simple">
<dt>if flag != 0 &amp;&amp; flag != 1 {</dt><dd><p>flag = 4
break</p>
</dd>
</dl>
<p>}
flag = 1</p>
</div></blockquote>
<dl>
<dt>case ‘a’, ‘s’, ‘d’, ‘f’, ‘g’, ‘h’, ‘j’, ‘k’, ‘l’:</dt><dd><dl class="simple">
<dt>if flag != 0 &amp;&amp; flag != 2 {</dt><dd><p>flag = 4
break</p>
</dd>
</dl>
<p>}
flag = 2</p>
</dd>
<dt>case ‘z’, ‘x’, ‘c’, ‘v’, ‘b’, ‘n’, ‘m’:</dt><dd><dl class="simple">
<dt>if flag != 0 &amp;&amp; flag != 3 {</dt><dd><p>flag = 4
break</p>
</dd>
</dl>
<p>}
flag = 3</p>
</dd>
<dt>default:</dt><dd><p>flag = 4</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
if flag != 0 &amp;&amp; flag != 4 {</p>
<blockquote>
<div><p>res = append(res, word)</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
func findWords(words []string) []string {</p>
<blockquote>
<div><p>res := make([]string, 0, len(words))
q := “qwertyuiopQWERTYUIOP”
a := “asdfghjklASDFGHJKL”
z := “zxcvbnmZXCVBNM”
for _, word := range words {</p>
<blockquote>
<div><p>qLen, aLen, zLen := 0, 0, 0
for i := 0; i &lt; len(word); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if strings.Contains(q, string(word[i])) {</dt><dd><p>qLen++</p>
</dd>
</dl>
<p>}
if strings.Contains(a, string(word[i])) {</p>
<blockquote>
<div><p>aLen++</p>
</div></blockquote>
<p>}
if strings.Contains(z, string(word[i])) {</p>
<blockquote>
<div><p>zLen++</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
if qLen == len(word) || aLen == len(word) || zLen == len(word) {</p>
<blockquote>
<div><p>res = append(res, word)</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
</div>
<div class="section" id="id258">
<h1>}<a class="headerlink" href="#id258" title="永久链接至标题">¶</a></h1>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="0501-0600.html" class="btn btn-neutral float-right" title="}" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="0301-0400.html" class="btn btn-neutral float-left" title="}" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, willshang

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>