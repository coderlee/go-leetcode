

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh-CN" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh-CN" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>} &mdash; go-leetcode v1.0.0 文档</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="}" href="0601-0700.html" />
    <link rel="prev" title="}" href="0401-0500.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> go-leetcode
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id20">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id31">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id42">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id53">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id86">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id111">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id114">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id119">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id122">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id127">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id138">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id149">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id160">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id171">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id182">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id193">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id204">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id215">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id226">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id249">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id260">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id279">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id24">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id25">]</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id48">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id65">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id80">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id95">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id112">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id115">]</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id120">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id131">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id142">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id153">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id164">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id175">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id192">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id219">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id250">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id261">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id272">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id283">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id294">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id305">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id316">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id327">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id350">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id18">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id23">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id34">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id51">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id62">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id73">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id138">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id157">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id168">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id217">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id234">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id253">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id266">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id277">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id296">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id301">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id312">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id323">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id334">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id345">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id356">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id367">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id378">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id20">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id25">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id36">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id47">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id58">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id69">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id74">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id79">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id90">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id101">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id106">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id111">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id124">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id26">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id37">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id42">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id45">]</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id50">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id55">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id66">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id71">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id100">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id105">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id116">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id127">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id138">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id143">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id154">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id159">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id170">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id181">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id192">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id203">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id214">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id225">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id236">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id247">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id258">}</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id24">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id35">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id40">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id51">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id62">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id73">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id98">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id109">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id138">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id149">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id170">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id181">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id192">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id207">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id218">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id235">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id246">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id273">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id284">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id295">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id306">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id323">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id328">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id339">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id350">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id28">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id51">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id62">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id67">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id84">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id95">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id106">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id133">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id144">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id155">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id166">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id185">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id204">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id209">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id220">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id231">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id242">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id267">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id280">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id287">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id298">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id309">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id328">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id46">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id85">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id96">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id111">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id122">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id133">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id146">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id157">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id170">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id181">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id192">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id203">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id214">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id225">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id252">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id263">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id274">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id285">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id22">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id33">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id44">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id55">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id66">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id77">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id82">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id93">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id104">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id115">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id126">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id137">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id148">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id159">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id170">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id181">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id186">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id221">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id232">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id255">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id266">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id277">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id288">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id299">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id310">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id321">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id356">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id22">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id33">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id44">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id55">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id66">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id77">}</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">go-leetcode</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>}</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/question/0501-0600.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <p># 0501-0600-Easy
* [0501-0600-Easy](#0501-0600-easy)</p>
<blockquote>
<div><ul class="simple">
<li><p>[501.二叉搜索树中的众数(2)](#501二叉搜索树中的众数2)</p></li>
<li><p>[504.七进制数(3)](#504七进制数3)</p></li>
<li><p>[506.相对名次(1)](#506相对名次1)</p></li>
<li><p>[507.完美数(1)](#507完美数1)</p></li>
<li><p>[509.斐波那契数(4)](#509斐波那契数4)</p></li>
<li><p>[520.检测大写字母(2)](#520检测大写字母2)</p></li>
<li><p>[521.最长特殊序列Ⅰ(1)](#521最长特殊序列ⅰ1)</p></li>
<li><p>[530.二叉搜索树的最小绝对差(2)](#530二叉搜索树的最小绝对差2)</p></li>
<li><p>[532.数组中的K-diff数对(3)](#532数组中的k-diff数对3)</p></li>
<li><p>[538.把二叉搜索树转换为累加树(2)](#538把二叉搜索树转换为累加树2)</p></li>
<li><p>[541.反转字符串II(2)](#541反转字符串ii2)</p></li>
<li><p>[543.二叉树的直径(2)](#543二叉树的直径2)</p></li>
<li><p>[551.学生出勤记录 I(2)](#551学生出勤记录-i2)</p></li>
<li><p>[557.反转字符串中的单词 III(2)](#557反转字符串中的单词-iii2)</p></li>
<li><p>[559.N叉树的最大深度(2)](#559n叉树的最大深度2)</p></li>
<li><p>[561.数组拆分 I(2)](#561数组拆分-i2)</p></li>
<li><p>[563.二叉树的坡度(2)](#563二叉树的坡度2)</p></li>
<li><p>[566.重塑矩阵(2)](#566重塑矩阵2)</p></li>
<li><p>[572.另一个树的子树(3)](#572另一个树的子树3)</p></li>
<li><p>[575.分糖果(2)](#575分糖果2)</p></li>
<li><p>[581.最短无序连续子数组(3)](#581最短无序连续子数组3)</p></li>
<li><p>[589.N叉树的前序遍历(2)](#589n叉树的前序遍历2)</p></li>
<li><p>[590.N叉树的后序遍历(2)](#590n叉树的后序遍历2)</p></li>
<li><p>[594.最长和谐子序列(2)](#594最长和谐子序列2)</p></li>
<li><p>[598.范围求和 II(1)](#598范围求和-ii1)</p></li>
<li><p>[599.两个列表的最小索引总和(2)](#599两个列表的最小索引总和2)</p></li>
</ul>
</div></blockquote>
<p>## 501.二叉搜索树中的众数(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">``</span></a>`
给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。
假定 BST 有如下定义：</p>
<blockquote>
<div><p>结点左子树中所含结点的值小于等于当前结点的值
结点右子树中所含结点的值大于等于当前结点的值
左子树和右子树都是二叉搜索树</p>
</div></blockquote>
<p>例如：
给定 BST [1,null,2,2],</p>
<blockquote>
<div><dl>
<dt>1</dt><dd><dl class="simple">
<dt></dt><dd><p>2</p>
</dd>
</dl>
<p>/</p>
</dd>
</dl>
<p>2</p>
</div></blockquote>
<p>返回[2].
提示：如果众数超过1个，不需考虑输出顺序
进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）
<a href="#id3"><span class="problematic" id="id4">``</span></a><a href="#id5"><span class="problematic" id="id6">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路          | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ————- | ———- | ———- |</div>
<div class="line">01   | 递归+哈希辅助 | O(n)       | O(n)       |</div>
<div class="line">02   | 递归+中序遍历 | O(n)       | O(log(n))  |</div>
</div>
<p><a href="#id7"><span class="problematic" id="id8">``</span></a><a href="#id9"><span class="problematic" id="id10">`</span></a>go
func findMode(root <a href="#id11"><span class="problematic" id="id12">*</span></a>TreeNode) []int {</p>
<blockquote>
<div><p>m := map[int]int{}
dfs(root, m)
max := -1
res := make([]int, 0)
for i, v := range m {</p>
<blockquote>
<div><dl>
<dt>if max &lt;= v {</dt><dd><dl class="simple">
<dt>if max &lt; v {</dt><dd><p>max = v
res = res[0:0]</p>
</dd>
</dl>
<p>}
res = append(res, i)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func dfs(root <a href="#id13"><span class="problematic" id="id14">*</span></a>TreeNode, rec map[int]int) {</dt><dd><dl class="simple">
<dt>if root == nil {</dt><dd><p>return</p>
</dd>
</dl>
<p>}
rec[root.Val]++
dfs(root.Left, rec)
dfs(root.Right, rec)</p>
</dd>
</dl>
<p>}</p>
<p>#
var max int
var res []int
var cur int
var count int</p>
<dl class="simple">
<dt>func findMode(root <a href="#id15"><span class="problematic" id="id16">*</span></a>TreeNode) []int {</dt><dd><p>res = make([]int, 0)
max, cur, count = 0, 0, 0
dfs(root)
return res</p>
</dd>
</dl>
<p>}</p>
<p>// 中序遍历保证利用二叉搜索树的性质，得到的结果是升序的
func dfs(root <a href="#id17"><span class="problematic" id="id18">*</span></a>TreeNode) {</p>
<blockquote>
<div><dl class="simple">
<dt>if root == nil {</dt><dd><p>return</p>
</dd>
</dl>
<p>}
dfs(root.Left)
if root.Val != cur {</p>
<blockquote>
<div><p>count = 0</p>
</div></blockquote>
<p>}
count++
if max &lt; count {</p>
<blockquote>
<div><p>max = count
res = []int{root.Val}</p>
</div></blockquote>
<dl class="simple">
<dt>} else if max == count {</dt><dd><p>res = append(res, root.Val)</p>
</dd>
</dl>
<p>}
cur = root.Val
dfs(root.Right)</p>
</div></blockquote>
<div class="section" id="id19">
<h1>}<a class="headerlink" href="#id19" title="永久链接至标题">¶</a></h1>
<p>## 504.七进制数(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">给定一个整数，将其转化为7进制，并以字符串形式输出。</span>
<span class="pre">示例</span> <span class="pre">1:输入:</span> <span class="pre">100</span> <span class="pre">输出:</span> <span class="pre">&quot;202&quot;</span>
<span class="pre">示例</span> <span class="pre">2:</span> <span class="pre">输入:</span> <span class="pre">-7</span> <span class="pre">输出:</span> <span class="pre">&quot;-10&quot;</span>
<span class="pre">注意:</span> <span class="pre">输入范围是</span> <span class="pre">[-1e7,</span> <span class="pre">1e7]</span> <span class="pre">。</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路     | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ——– | ———- | ———- |</div>
<div class="line">01   | 遍历     | O(log(n))  | O(1)       |</div>
<div class="line">02   | 内置函数 | O(log(n))  | O(1)       |</div>
<div class="line">03   | 递归     | O(log(n))  | O(log(n))  |</div>
</div>
<p><a href="#id20"><span class="problematic" id="id21">``</span></a><a href="#id22"><span class="problematic" id="id23">`</span></a>go
func convertToBase7(num int) string {</p>
<blockquote>
<div><dl class="simple">
<dt>if num == 0 {</dt><dd><p>return “0”</p>
</dd>
</dl>
<p>}</p>
<p>minus := “”
if num &lt; 0 {</p>
<blockquote>
<div><p>minus = “-”
num = -1 * num</p>
</div></blockquote>
<p>}</p>
<p>s := “”
for num &gt; 0 {</p>
<blockquote>
<div><p>s = fmt.Sprintf(“%d”, num%7) + s
num = num / 7</p>
</div></blockquote>
<p>}
return minus + s</p>
</div></blockquote>
<p>}</p>
<p>#
func convertToBase7(num int) string {</p>
<blockquote>
<div><p>return strconv.FormatInt(int64(num), 7)</p>
</div></blockquote>
<p>}</p>
<p>#
func convertToBase7(num int) string {</p>
<blockquote>
<div><dl class="simple">
<dt>if num &lt; 0 {</dt><dd><p>return “-” + convertToBase7(-1*num)</p>
</dd>
</dl>
<p>}
if num &lt; 7 {</p>
<blockquote>
<div><p>return strconv.Itoa(num)</p>
</div></blockquote>
<p>}
return convertToBase7(num/7) + strconv.Itoa(num%7)</p>
</div></blockquote>
</div>
<div class="section" id="id24">
<h1>}<a class="headerlink" href="#id24" title="永久链接至标题">¶</a></h1>
<p>## 506.相对名次(1)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id25"><span class="problematic" id="id26">``</span></a>`
给出 N 名运动员的成绩，找出他们的相对名次并授予前三名对应的奖牌。
前三名运动员将会被分别授予 “金牌”，“银牌” 和“ 铜牌”
（”Gold Medal”, “Silver Medal”, “Bronze Medal”）。
(注：分数越高的选手，排名越靠前。)</p>
<p>示例 1:
输入: [5, 4, 3, 2, 1]
输出: [“Gold Medal”, “Silver Medal”, “Bronze Medal”, “4”, “5”]
解释: 前三名运动员的成绩为前三高的，
因此将会分别被授予 “金牌”，“银牌”和“铜牌” (“Gold Medal”, “Silver Medal” and “Bronze Medal”).
余下的两名运动员，我们只需要通过他们的成绩计算将其相对名次即可。
提示:</p>
<blockquote>
<div><p>N 是一个正整数并且不会超过 10000。
所有运动员的成绩都不相同。</p>
</div></blockquote>
<p><a href="#id27"><span class="problematic" id="id28">``</span></a><a href="#id29"><span class="problematic" id="id30">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路      | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ——— | ———- | ———- |</div>
<div class="line">01   | 排序+遍历 | O(nlog(n)) | O(n)       |</div>
</div>
<p><a href="#id31"><span class="problematic" id="id32">``</span></a><a href="#id33"><span class="problematic" id="id34">`</span></a>go
func findRelativeRanks(nums []int) []string {</p>
<blockquote>
<div><p>temp := make([]int, len(nums))
copy(temp, nums)
sort.Ints(temp)
m := make(map[int]string)
for i := 0; i &lt; len(temp); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if i == len(temp)-1 {</dt><dd><p>m[temp[i]] = “Gold Medal”</p>
</dd>
<dt>} else if i == len(temp)-2 {</dt><dd><p>m[temp[i]] = “Silver Medal”</p>
</dd>
<dt>} else if i == len(temp)-3 {</dt><dd><p>m[temp[i]] = “Bronze Medal”</p>
</dd>
<dt>} else {</dt><dd><p>m[temp[i]] = strconv.Itoa(len(temp) - i)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
res := make([]string,0)
for i := 0; i &lt; len(nums); i++ {</p>
<blockquote>
<div><p>res = append(res, m[nums[i]])</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
</div>
<div class="section" id="id35">
<h1>}<a class="headerlink" href="#id35" title="永久链接至标题">¶</a></h1>
<p>## 507.完美数(1)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">对于一个</span> <span class="pre">正整数，如果它和除了它自身以外的所有正因子之和相等，我们称它为“完美数”。</span>
<span class="pre">给定一个</span> <span class="pre">整数</span> <span class="pre">n，</span> <span class="pre">如果他是完美数，返回</span> <span class="pre">True，否则返回</span> <span class="pre">False</span>
<span class="pre">示例：输入:</span> <span class="pre">28</span> <span class="pre">输出:</span> <span class="pre">True</span> <span class="pre">解释:</span> <span class="pre">28</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">2</span> <span class="pre">+</span> <span class="pre">4</span> <span class="pre">+</span> <span class="pre">7</span> <span class="pre">+</span> <span class="pre">14</span>
<span class="pre">提示：输入的数字</span> <span class="pre">n</span> <span class="pre">不会超过</span> <span class="pre">100,000,000.</span> <span class="pre">(1e8)</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路 | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —- | ———- | ———- |</div>
<div class="line">01   | 遍历 | O(n^1/2)   | O(1)       |</div>
</div>
<p><a href="#id36"><span class="problematic" id="id37">``</span></a><a href="#id38"><span class="problematic" id="id39">`</span></a>go
func checkPerfectNumber(num int) bool {</p>
<blockquote>
<div><dl class="simple">
<dt>if num == 1 {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}
sum := 1
for i := 2; i &lt;= num/i; i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if num%i == 0 {</dt><dd><p>sum = sum + i + (num / i)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return sum == num</p>
</div></blockquote>
</div>
<div class="section" id="id40">
<h1>}<a class="headerlink" href="#id40" title="永久链接至标题">¶</a></h1>
<p>## 509.斐波那契数(4)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id41"><span class="problematic" id="id42">``</span></a>`
斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。
该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：
F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.
给定 N，计算 F(N)。
示例 1：输入：2输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1.
示例 2：输入：3输出：2
解释：F(3) = F(2) + F(1) = 1 + 1 = 2.
示例 3：输入：4输出：3
解释：F(4) = F(3) + F(2) = 2 + 1 = 3.
提示：</p>
<blockquote>
<div><p>0 ≤ N ≤ 30</p>
</div></blockquote>
<p><a href="#id43"><span class="problematic" id="id44">``</span></a><a href="#id45"><span class="problematic" id="id46">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路      | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ——— | ———- | ———- |</div>
<div class="line">01   | 遍历      | O(n)       | O(1)       |</div>
<div class="line">02   | 遍历+数组 | O(n)       | O(n)       |</div>
<div class="line">03   | 递归      | O(2^n)     | O(n)       |</div>
<div class="line">04   | 公式法    | O(1)       | O(1)       |</div>
</div>
<p><a href="#id47"><span class="problematic" id="id48">``</span></a><a href="#id49"><span class="problematic" id="id50">`</span></a>go
func fib(N int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if N == 0 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
if N == 1 {</p>
<blockquote>
<div><p>return 1</p>
</div></blockquote>
<p>}
n1, n2 := 0, 1
for i := 2; i &lt;= N; i++ {</p>
<blockquote>
<div><p>n1, n2 = n2, n1+n2</p>
</div></blockquote>
<p>}
return n2</p>
</div></blockquote>
<p>}</p>
<p>#
func fib(N int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if N == 0 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
if N == 1 {</p>
<blockquote>
<div><p>return 1</p>
</div></blockquote>
<p>}
res := make([]int, N+1)
res[0] = 0
res[1] = 1
for i := 2; i &lt;= N; i++ {</p>
<blockquote>
<div><p>res[i] = res[i-1] + res[i-2]</p>
</div></blockquote>
<p>}
return res[N]</p>
</div></blockquote>
<p>}</p>
<p>#
func fib(N int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if N == 0 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
if N == 1 {</p>
<blockquote>
<div><p>return 1</p>
</div></blockquote>
<p>}
return fib(N-1) + fib(N-2)</p>
</div></blockquote>
<p>}</p>
<p>#
func fib(N int) int {</p>
<blockquote>
<div><p>temp1 := (1 + math.Sqrt(5)) / 2
temp2 := (1 - math.Sqrt(5)) / 2
fn := math.Round((math.Pow(temp1, float64(N))- math.Pow(temp2, float64(N)))/ math.Sqrt(5))
return int(fn)</p>
</div></blockquote>
</div>
<div class="section" id="id51">
<h1>}<a class="headerlink" href="#id51" title="永久链接至标题">¶</a></h1>
<p>## 520.检测大写字母(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id52"><span class="problematic" id="id53">``</span></a>`
给定一个单词，你需要判断单词的大写使用是否正确。
我们定义，在以下情况时，单词的大写用法是正确的：</p>
<blockquote>
<div><p>全部字母都是大写，比如”USA”。
单词中所有字母都不是大写，比如”leetcode”。
如果单词不只含有一个字母，只有首字母大写， 比如 “Google”。</p>
</div></blockquote>
<p>否则，我们定义这个单词没有正确使用大写字母。
示例 1:输入: “USA”输出: True
示例 2:输入: “FlaG”输出: False
注意: 输入是由大写和小写拉丁字母组成的非空单词。
<a href="#id54"><span class="problematic" id="id55">``</span></a><a href="#id56"><span class="problematic" id="id57">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路 | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —- | ———- | ———- |</div>
<div class="line">01   | 遍历 | O(n)       | O(1)       |</div>
<div class="line">02   | 正则 | O(n)       | O(1)       |</div>
</div>
<p><a href="#id58"><span class="problematic" id="id59">``</span></a><a href="#id60"><span class="problematic" id="id61">`</span></a>go
func detectCapitalUse(word string) bool {</p>
<blockquote>
<div><dl class="simple">
<dt>if word == “” {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}
count := 0
for i := 0; i &lt; len(word); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if word[i] &gt;= ‘A’ &amp;&amp; word[i] &lt;= ‘Z’ {</dt><dd><p>count++</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>if count == 0 || count == len(word) ||</dt><dd><p>(count == 1 &amp;&amp; word[0] &gt;= ‘A’ &amp;&amp; word[0] &lt;= ‘Z’) {
return true</p>
</dd>
</dl>
<p>}
return false</p>
</div></blockquote>
<p>}</p>
<p>#
func detectCapitalUse(word string) bool {</p>
<blockquote>
<div><p>pattern := “(^[a-z]+)$|(^[A-Z]+)$|(^[A-Z]{1}[a-z]*)$”
isMatch, _ := regexp.MatchString(pattern, word)
return isMatch</p>
</div></blockquote>
</div>
<div class="section" id="id62">
<h1>}<a class="headerlink" href="#id62" title="永久链接至标题">¶</a></h1>
<p>## 521.最长特殊序列Ⅰ(1)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id63"><span class="problematic" id="id64">``</span></a>`
给你两个字符串，请你从这两个字符串中找出最长的特殊序列。
「最长特殊序列」定义如下：该序列为某字符串独有的最长子序列（即不能是其他字符串的子序列）。</p>
<p>子序列 可以通过删去字符串中的某些字符实现，但不能改变剩余字符的相对顺序。空序列为所有字符串的子序列，任何字符串为其自身的子序列。</p>
<p>输入为两个字符串，输出最长特殊序列的长度。如果不存在，则返回 -1。</p>
<p>示例 1：输入: “aba”, “cdc” 输出: 3
解释: 最长特殊序列可为 “aba” (或 “cdc”)，两者均为自身的子序列且不是对方的子序列。
示例 2：输入：a = “aaa”, b = “bbb”输出：3
示例 3：输入：a = “aaa”, b = “aaa”输出：-1
提示：</p>
<blockquote>
<div><p>两个字符串长度均处于区间 [1 - 100] 。
字符串中的字符仅含有 ‘a’~’z’ 。</p>
</div></blockquote>
<p><a href="#id65"><span class="problematic" id="id66">``</span></a><a href="#id67"><span class="problematic" id="id68">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路 | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —- | ———- | ———- |</div>
<div class="line">01   | 比较 | O(1)       | O(1)       |</div>
</div>
<p><a href="#id69"><span class="problematic" id="id70">``</span></a><a href="#id71"><span class="problematic" id="id72">`</span></a>go
func findLUSlength(a string, b string) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if a == b {</dt><dd><p>return -1</p>
</dd>
</dl>
<p>}
return max(len(a), len(b))</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func max(a, b int) int {</dt><dd><dl class="simple">
<dt>if a &gt; b {</dt><dd><p>return a</p>
</dd>
</dl>
<p>}
return b</p>
</dd>
</dl>
</div>
<div class="section" id="id73">
<h1>}<a class="headerlink" href="#id73" title="永久链接至标题">¶</a></h1>
<p>## 530.二叉搜索树的最小绝对差(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id74"><span class="problematic" id="id75">``</span></a>`
给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。
示例：
输入：</p>
<blockquote>
<div><dl>
<dt>1</dt><dd><dl class="simple">
<dt></dt><dd><p>3</p>
</dd>
</dl>
<p>/</p>
</dd>
</dl>
<p>2</p>
</div></blockquote>
<p>输出：1
解释：
最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。
提示：</p>
<blockquote>
<div><p>树中至少有 2 个节点。
本题与 783 <a class="reference external" href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/">https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/</a> 相同</p>
</div></blockquote>
<p><a href="#id76"><span class="problematic" id="id77">``</span></a><a href="#id78"><span class="problematic" id="id79">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路          | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ————- | ———- | ———- |</div>
<div class="line">01   | 递归+中序遍历 | O(n)       | O(log(n))  |</div>
<div class="line">02   | 递归+遍历     | O(n)       | O(n)       |</div>
<div class="line">03   | 迭代          | O(n)       | O(n)         |</div>
</div>
<p><a href="#id80"><span class="problematic" id="id81">``</span></a><a href="#id82"><span class="problematic" id="id83">`</span></a>go
var minDiff, previous int
func getMinimumDifference(root <a href="#id84"><span class="problematic" id="id85">*</span></a>TreeNode) int {</p>
<blockquote>
<div><p>minDiff, previous  = math.MaxInt32, math.MaxInt32
dfs(root)
return minDiff</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func dfs(root <a href="#id86"><span class="problematic" id="id87">*</span></a>TreeNode) {</dt><dd><dl class="simple">
<dt>if root == nil {</dt><dd><p>return</p>
</dd>
</dl>
<p>}
dfs(root.Left)</p>
<p>newDiff := diff(previous, root.Val)
if minDiff &gt; newDiff {</p>
<blockquote>
<div><p>minDiff = newDiff</p>
</div></blockquote>
<p>}
previous = root.Val
dfs(root.Right)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func diff(a, b int) int {</dt><dd><dl class="simple">
<dt>if a &gt; b {</dt><dd><p>return a - b</p>
</dd>
</dl>
<p>}
return b - a</p>
</dd>
</dl>
<p>}</p>
<p>#
func getMinimumDifference(root <a href="#id88"><span class="problematic" id="id89">*</span></a>TreeNode) int {</p>
<blockquote>
<div><p>arr := make([]int, 0)
dfs(root, &amp;arr)
minDiff := arr[1] - arr[0]
for i := 2; i &lt; len(arr); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if minDiff &gt; arr[i]-arr[i-1] {</dt><dd><p>minDiff = arr[i] - arr[i-1]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return minDiff</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func dfs(root <a href="#id90"><span class="problematic" id="id91">*</span></a>TreeNode, arr <a href="#id92"><span class="problematic" id="id93">*</span></a>[]int) {</dt><dd><dl class="simple">
<dt>if root == nil {</dt><dd><p>return</p>
</dd>
</dl>
<p>}
dfs(root.Left, arr)
<a href="#id94"><span class="problematic" id="id95">*</span></a>arr = append(<a href="#id96"><span class="problematic" id="id97">*</span></a>arr, root.Val)
dfs(root.Right, arr)</p>
</dd>
</dl>
</div>
<div class="section" id="id98">
<h1>}<a class="headerlink" href="#id98" title="永久链接至标题">¶</a></h1>
<p>## 532.数组中的K-diff数对(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id99"><span class="problematic" id="id100">``</span></a>`
给定一个整数数组和一个整数 k, 你需要在数组里找到不同的 k-diff 数对。
这里将 k-diff 数对定义为一个整数对 (i, j), 其中 i 和 j 都是数组中的数字，且两数之差的绝对值是 k.</p>
<p>示例 1: 输入: [3, 1, 4, 1, 5], k = 2 输出: 2
解释: 数组中有两个 2-diff 数对, (1, 3) 和 (3, 5)。
尽管数组中有两个1，但我们只应返回不同的数对的数量。
示例 2:输入:[1, 2, 3, 4, 5], k = 1 输出: 4
解释: 数组中有四个 1-diff 数对, (1, 2), (2, 3), (3, 4) 和 (4, 5)。
示例 3:输入: [1, 3, 1, 5, 4], k = 0 输出: 1
解释: 数组中只有一个 0-diff 数对，(1, 1)。
注意:</p>
<blockquote>
<div><p>数对 (i, j) 和数对 (j, i) 被算作同一数对。
数组的长度不超过10,000。
所有输入的整数的范围在 [-1e7, 1e7]。</p>
</div></blockquote>
<p><a href="#id101"><span class="problematic" id="id102">``</span></a><a href="#id103"><span class="problematic" id="id104">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路       | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ———- | ———- | ———- |</div>
<div class="line">01   | 单哈希辅助 | O(n)       | O(n)       |</div>
<div class="line">02   | 双哈希辅助 | O(n)       | O(n)       |</div>
<div class="line">03   | 排序遍历   | O(nlog(n)) | O(1)       |</div>
</div>
<p><a href="#id105"><span class="problematic" id="id106">``</span></a><a href="#id107"><span class="problematic" id="id108">`</span></a>go
func findPairs(nums []int, k int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if k &lt; 0 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
record := make(map[int]int)
for _, num := range nums {</p>
<blockquote>
<div><p>record[num]++</p>
</div></blockquote>
<p>}
res := 0
if k == 0 {</p>
<blockquote>
<div><dl>
<dt>for _, count := range record {</dt><dd><dl class="simple">
<dt>if count &gt; 1 {</dt><dd><p>res++</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
return res</p>
</div></blockquote>
<dl>
<dt>} else {</dt><dd><dl>
<dt>for n := range record {</dt><dd><dl class="simple">
<dt>if record[n-k] &gt; 0 {</dt><dd><p>res++</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
return res</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>#
func findPairs(nums []int, k int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if k &lt; 0 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
m := make(map[int]bool)
res := make(map[int]bool)
for _, value := range nums {</p>
<blockquote>
<div><dl class="simple">
<dt>if m[value-k] {</dt><dd><p>res[value-k] = true</p>
</dd>
</dl>
<p>}
if m[value+k] {</p>
<blockquote>
<div><p>res[value] = true</p>
</div></blockquote>
<p>}
m[value] = true</p>
</div></blockquote>
<p>}
return len(res)</p>
</div></blockquote>
</div>
<div class="section" id="id109">
<h1>}<a class="headerlink" href="#id109" title="永久链接至标题">¶</a></h1>
<p>## 538.把二叉搜索树转换为累加树(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id110"><span class="problematic" id="id111">``</span></a>`
给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，
使得每个节点的值是原来的节点值加上所有大于它的节点值之和。
例如：
输入: 原始二叉搜索树:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>5</p>
</div></blockquote>
<p>/   </p>
</div></blockquote>
<p>2     13</p>
</div></blockquote>
<dl>
<dt>输出: 转换为累加树:</dt><dd><blockquote>
<div><blockquote>
<div><p>18</p>
</div></blockquote>
<p>/   </p>
</div></blockquote>
<p>20     13</p>
</dd>
</dl>
<p>注意：
本题和 1038: <a class="reference external" href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a> 相同
<a href="#id112"><span class="problematic" id="id113">``</span></a><a href="#id114"><span class="problematic" id="id115">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路   | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —— | ———- | ———- |</div>
<div class="line">01   | 递归   | O(n)       | O(log(n))  |</div>
<div class="line">02   | 栈辅助 | O(n)       | O(n)       |</div>
</div>
<p><a href="#id116"><span class="problematic" id="id117">``</span></a><a href="#id118"><span class="problematic" id="id119">`</span></a>go
func convertBST(root <a href="#id120"><span class="problematic" id="id121">*</span></a>TreeNode) <a href="#id122"><span class="problematic" id="id123">*</span></a>TreeNode {</p>
<blockquote>
<div><p>sum := 0
dfs(root, &amp;sum)
return root</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func dfs(root <a href="#id124"><span class="problematic" id="id125">*</span></a>TreeNode, sum <a href="#id126"><span class="problematic" id="id127">*</span></a>int) {</dt><dd><dl class="simple">
<dt>if root == nil {</dt><dd><p>return</p>
</dd>
</dl>
<p>}
dfs(root.Right, sum)
<a href="#id128"><span class="problematic" id="id129">*</span></a>sum = <a href="#id130"><span class="problematic" id="id131">*</span></a>sum + root.Val
root.Val = <a href="#id132"><span class="problematic" id="id133">*</span></a>sum
dfs(root.Left, sum)</p>
</dd>
</dl>
<p>}</p>
<p>#
func convertBST(root <a href="#id134"><span class="problematic" id="id135">*</span></a>TreeNode) <a href="#id136"><span class="problematic" id="id137">*</span></a>TreeNode {</p>
<blockquote>
<div><dl class="simple">
<dt>if root == nil {</dt><dd><p>return root</p>
</dd>
</dl>
<p>}
stack := make([]*TreeNode, 0)
temp := root
sum := 0
for {</p>
<blockquote>
<div><dl class="simple">
<dt>if temp != nil {</dt><dd><p>stack = append(stack, temp)
temp = temp.Right</p>
</dd>
<dt>} else if len(stack) != 0 {</dt><dd><p>temp = stack[len(stack)-1]
stack = stack[:len(stack)-1]
temp.Val = temp.Val + sum
sum = temp.Val
temp = temp.Left</p>
</dd>
<dt>} else {</dt><dd><p>break</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return root</p>
</div></blockquote>
</div>
<div class="section" id="id138">
<h1>}<a class="headerlink" href="#id138" title="永久链接至标题">¶</a></h1>
<p>## 541.反转字符串II(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id139"><span class="problematic" id="id140">``</span></a>`
给定一个字符串和一个整数 k，你需要对从字符串开头算起的每个 2k 个字符的前k个字符进行反转。
如果剩余少于 k 个字符，则将剩余的所有全部反转。
如果有小于 2k 但大于或等于 k 个字符，则反转前 k 个字符，并将剩余的字符保持原样。</p>
<p>示例:
输入: s = “abcdefg”, k = 2
输出: “bacdfeg”
要求:</p>
<blockquote>
<div><p>该字符串只包含小写的英文字母。
给定字符串的长度和 k 在[1, 10000]范围内。</p>
</div></blockquote>
<p><a href="#id141"><span class="problematic" id="id142">``</span></a><a href="#id143"><span class="problematic" id="id144">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路 | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —- | ———- | ———- |</div>
<div class="line">01   | 遍历 | O(n)       | O(1)       |</div>
<div class="line">02   | 遍历 | O(n)       | O(1)       |</div>
</div>
<p><a href="#id145"><span class="problematic" id="id146">``</span></a><a href="#id147"><span class="problematic" id="id148">`</span></a>go
func reverseStr(s string, k int) string {</p>
<blockquote>
<div><p>arr := []byte(s)
for i := 0; i &lt; len(s); i = i + 2*k {</p>
<blockquote>
<div><p>j := min(i+k, len(s))
reverse(arr[i:j])</p>
</div></blockquote>
<p>}
return string(arr)</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func reverse(arr []byte) {</dt><dd><p>i, j := 0, len(arr)-1
for i &lt; j {</p>
<blockquote>
<div><p>arr[i], arr[j] = arr[j], arr[i]
i++
j–</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func min(a, b int) int {</dt><dd><dl class="simple">
<dt>if a &lt; b {</dt><dd><p>return a</p>
</dd>
</dl>
<p>}
return b</p>
</dd>
</dl>
<p>}</p>
<p>#
func reverseStr(s string, k int) string {</p>
<blockquote>
<div><p>arr := []byte(s)
for i := 0; i &lt; len(s); i = i + k {</p>
<blockquote>
<div><dl>
<dt>if i%(2*k) == 0 {</dt><dd><p>j := i + k
if len(arr) &lt; j {</p>
<blockquote>
<div><p>j = len(arr)</p>
</div></blockquote>
<p>}
reverse(arr[i:j])</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return string(arr)</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func reverse(arr []byte) {</dt><dd><p>i, j := 0, len(arr)-1
for i &lt; j {</p>
<blockquote>
<div><p>arr[i], arr[j] = arr[j], arr[i]
i++
j–</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</div>
<div class="section" id="id149">
<h1>}<a class="headerlink" href="#id149" title="永久链接至标题">¶</a></h1>
<p>## 543.二叉树的直径(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id150"><span class="problematic" id="id151">``</span></a>`
给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。
这条路径可能穿过也可能不穿过根结点。
示例 :
给定二叉树</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><p>1</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<p>2   3</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<p>4   5</p>
</div></blockquote>
<p>返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。
注意：两结点之间的路径长度是以它们之间边的数目表示。
<a href="#id152"><span class="problematic" id="id153">``</span></a><a href="#id154"><span class="problematic" id="id155">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路   | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —— | ———- | ———- |</div>
<div class="line">01   | 递归   | O(n)       | O(log(n))  |</div>
<div class="line">02   | 栈辅助 | O(n)       | O(n)       |</div>
</div>
<p><a href="#id156"><span class="problematic" id="id157">``</span></a><a href="#id158"><span class="problematic" id="id159">`</span></a>go
var res int
func diameterOfBinaryTree(root <a href="#id160"><span class="problematic" id="id161">*</span></a>TreeNode) int {</p>
<blockquote>
<div><p>res = 0
dfs(root)
return res</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func dfs(root <a href="#id162"><span class="problematic" id="id163">*</span></a>TreeNode) int {</dt><dd><dl class="simple">
<dt>if root == nil {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
left := dfs(root.Left)
right := dfs(root.Right)
path := max(left, right)
res = max(left+right, res) // 当前节点最大直径与当前保存最大值比较
return path + 1 // 以该节点为根的最大深度</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func max(a, b int) int {</dt><dd><dl class="simple">
<dt>if a &gt; b {</dt><dd><p>return a</p>
</dd>
</dl>
<p>}
return b</p>
</dd>
</dl>
<p>}</p>
<p>#
func diameterOfBinaryTree(root <a href="#id164"><span class="problematic" id="id165">*</span></a>TreeNode) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if root == nil {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
max := 0
stack := make([]*TreeNode, 0)
m := make(map[<a href="#id166"><span class="problematic" id="id167">*</span></a>TreeNode]int)</p>
<p>cur := root
var prev <a href="#id168"><span class="problematic" id="id169">*</span></a>TreeNode
for cur != nil || len(stack) != 0 {</p>
<blockquote>
<div><dl class="simple">
<dt>for cur != nil {</dt><dd><p>stack = append(stack, cur)
cur = cur.Left</p>
</dd>
</dl>
<p>}
cur = stack[len(stack)-1]
if cur.Right == nil || cur.Right == prev {</p>
<blockquote>
<div><p>cur = stack[len(stack)-1]
stack = stack[:len(stack)-1]</p>
<p>leftLen := 0
rightLen := 0
if v, ok := m[cur.Left]; ok {</p>
<blockquote>
<div><p>leftLen = v</p>
</div></blockquote>
<p>}
if v, ok := m[cur.Right]; ok {</p>
<blockquote>
<div><p>rightLen = v</p>
</div></blockquote>
<p>}
if leftLen &gt; rightLen {</p>
<blockquote>
<div><p>m[cur] = leftLen + 1</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>m[cur] = rightLen + 1</p>
</dd>
</dl>
<p>}
if max &lt; leftLen+rightLen {</p>
<blockquote>
<div><p>max = leftLen + rightLen</p>
</div></blockquote>
<p>}
prev = cur
cur = nil</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>cur = cur.Right</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return max</p>
</div></blockquote>
</div>
<div class="section" id="id170">
<h1>}<a class="headerlink" href="#id170" title="永久链接至标题">¶</a></h1>
<p>## 551.学生出勤记录 I(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id171"><span class="problematic" id="id172">``</span></a>`
给定一个字符串来代表一个学生的出勤记录，这个记录仅包含以下三个字符：</p>
<blockquote>
<div><p>‘A’ : Absent，缺勤
‘L’ : Late，迟到
‘P’ : Present，到场</p>
</div></blockquote>
<p>如果一个学生的出勤记录中不超过一个’A’(缺勤)并且不超过两个连续的’L’(迟到),那么这个学生会被奖赏。
你需要根据这个学生的出勤记录判断他是否会被奖赏。</p>
<p>示例 1:输入: “PPALLP”输出: True
示例 2:输入: “PPALLL”输出: False
<a href="#id173"><span class="problematic" id="id174">``</span></a><a href="#id175"><span class="problematic" id="id176">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路     | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ——– | ———- | ———- |</div>
<div class="line">01   | 内置函数 | O(n)       | O(1)       |</div>
<div class="line">02   | 遍历     | O(n)       | O(1)       |</div>
</div>
<p><a href="#id177"><span class="problematic" id="id178">``</span></a><a href="#id179"><span class="problematic" id="id180">`</span></a>go
func checkRecord(s string) bool {</p>
<blockquote>
<div><dl class="simple">
<dt>if strings.Count(s, “A”) &lt;= 1 &amp;&amp; strings.Count(s, “LLL”) == 0 {</dt><dd><p>return true</p>
</dd>
</dl>
<p>}
return false</p>
</div></blockquote>
<p>}</p>
<p>#
func checkRecord(s string) bool {</p>
<blockquote>
<div><p>aNum := 0
lNum := 0
for i := 0; i &lt; len(s); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if s[i] == ‘A’ {</dt><dd><p>aNum++</p>
</dd>
</dl>
<p>}
if s[i] == ‘L’ {</p>
<blockquote>
<div><p>lNum++</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>lNum = 0</p>
</dd>
</dl>
<p>}
if aNum == 2 {</p>
<blockquote>
<div><p>return false</p>
</div></blockquote>
<p>}
if lNum == 3 {</p>
<blockquote>
<div><p>return false</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return true</p>
</div></blockquote>
</div>
<div class="section" id="id181">
<h1>}<a class="headerlink" href="#id181" title="永久链接至标题">¶</a></h1>
<p>## 557.反转字符串中的单词 III(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id182"><span class="problematic" id="id183">``</span></a>`
给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。
示例 1:
输入: “Let’s take LeetCode contest”
输出: “s’teL ekat edoCteeL tsetnoc”</p>
<p>注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。
<a href="#id184"><span class="problematic" id="id185">``</span></a><a href="#id186"><span class="problematic" id="id187">`</span></a></p>
<ul class="simple">
<li><p>解题思路分析</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路     | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ——– | ———- | ———- |</div>
<div class="line">01   | 内置函数 | O(n)       | O(n)       |</div>
<div class="line">02   | 遍历     | O(n)       | O(n)       |</div>
</div>
<p><a href="#id188"><span class="problematic" id="id189">``</span></a><a href="#id190"><span class="problematic" id="id191">`</span></a>go</p>
<dl>
<dt>func reverseWords(s string) string {</dt><dd><p>strS := strings.Split(s, ” “)
for i, s := range strS {</p>
<blockquote>
<div><p>strS[i] = reverse(s)</p>
</div></blockquote>
<p>}
return strings.Join(strS, ” “)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func reverse(s string) string {</dt><dd><p>arr := []byte(s)
i, j := 0, len(arr)-1
for i &lt; j {</p>
<blockquote>
<div><p>arr[i], arr[j] = arr[j], arr[i]
i++
j–</p>
</div></blockquote>
<p>}
return string(arr)</p>
</dd>
</dl>
<p>}</p>
<p>#
func reverseWords(s string) string {</p>
<blockquote>
<div><p>arr := []byte(s)
j := 0
for i := 0; i &lt; len(arr); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if arr[i] == ‘ ‘ {</dt><dd><p>reverse(arr, j, i-1)
j = i + 1</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
reverse(arr, j, len(arr)-1)
return string(arr)</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func reverse(arr []byte, i, j int) []byte {</dt><dd><dl class="simple">
<dt>for i &lt; j {</dt><dd><p>arr[i], arr[j] = arr[j], arr[i]
i++
j–</p>
</dd>
</dl>
<p>}
return arr</p>
</dd>
</dl>
</div>
<div class="section" id="id192">
<h1>}<a class="headerlink" href="#id192" title="永久链接至标题">¶</a></h1>
<p>## 559.N叉树的最大深度(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id193"><span class="problematic" id="id194">``</span></a>`
给定一个 N 叉树，找到其最大深度。
最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。
例如，给定一个 3叉树 :
我们应返回其最大深度，3。
说明:</p>
<blockquote>
<div><p>树的深度不会超过 1000。
树的节点总不会超过 5000。</p>
</div></blockquote>
<p><a href="#id195"><span class="problematic" id="id196">``</span></a><a href="#id197"><span class="problematic" id="id198">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路 | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —- | ———- | ———- |</div>
<div class="line">01   | 递归 | O(n)       | O(log(n))  |</div>
<div class="line">02   | 迭代 | O(n)       | O(n)       |</div>
</div>
<p><a href="#id199"><span class="problematic" id="id200">``</span></a><a href="#id201"><span class="problematic" id="id202">`</span></a>go
func maxDepth(root <a href="#id203"><span class="problematic" id="id204">*</span></a>Node) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if root == nil {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
depth := 0
for _, node := range root.Children {</p>
<blockquote>
<div><p>depth = max(depth, maxDepth(node))</p>
</div></blockquote>
<p>}
return depth + 1</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func max(a, b int) int {</dt><dd><dl class="simple">
<dt>if a &gt; b {</dt><dd><p>return a</p>
</dd>
</dl>
<p>}
return b</p>
</dd>
</dl>
<p>}</p>
<p>#
func maxDepth(root <a href="#id205"><span class="problematic" id="id206">*</span></a>Node) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if root == nil {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
queue := make([]*Node, 0)
depth := 0
queue = append(queue, root)
for len(queue) &gt; 0 {</p>
<blockquote>
<div><p>length := len(queue)
for i := 0; i &lt; length; i++ {</p>
<blockquote>
<div><p>temp := queue[0]
for _, node := range temp.Children {</p>
<blockquote>
<div><p>queue = append(queue, node)</p>
</div></blockquote>
<p>}
queue = queue[1:]</p>
</div></blockquote>
<p>}
depth++</p>
</div></blockquote>
<p>}
return depth</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func max(a, b int) int {</dt><dd><dl class="simple">
<dt>if a &gt; b {</dt><dd><p>return a</p>
</dd>
</dl>
<p>}
return b</p>
</dd>
</dl>
</div>
<div class="section" id="id207">
<h1>}<a class="headerlink" href="#id207" title="永久链接至标题">¶</a></h1>
<p>## 561.数组拆分 I(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id208"><span class="problematic" id="id209">``</span></a>`
给定长度为 2n 的数组, 你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，
使得从1 到 n 的 min(ai, bi) 总和最大。</p>
<p>示例 1:输入: [1,4,3,2]输出: 4
解释: n 等于 2, 最大总和为 4 = min(1, 2) + min(3, 4).
提示:</p>
<blockquote>
<div><p>n 是正整数,范围在 [1, 10000].
数组中的元素范围在 [-10000, 10000].</p>
</div></blockquote>
<p><a href="#id210"><span class="problematic" id="id211">``</span></a><a href="#id212"><span class="problematic" id="id213">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路     | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ——– | ———- | ———- |</div>
<div class="line">01   | 排序遍历 | O(nlog(n)) | P          |</div>
<div class="line">02   | 数组辅助 | O(n)       | O(1)       |</div>
</div>
<p><a href="#id214"><span class="problematic" id="id215">``</span></a><a href="#id216"><span class="problematic" id="id217">`</span></a>go
func arrayPairSum(nums []int) int {</p>
<blockquote>
<div><p>sort.Ints(nums)
sum := 0
for k, v := range nums {</p>
<blockquote>
<div><dl class="simple">
<dt>if k%2 == 0 {</dt><dd><p>sum = sum + v</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return sum</p>
</div></blockquote>
<p>}</p>
<p>#
func arrayPairSum(nums []int) int {</p>
<blockquote>
<div><p>var arr [20010]int
for _, num := range nums {</p>
<blockquote>
<div><p>arr[num+10000]++</p>
</div></blockquote>
<p>}
sum := 0
needAdd := true
for num, count := range arr {</p>
<blockquote>
<div><dl>
<dt>for count &gt; 0 {</dt><dd><dl class="simple">
<dt>if needAdd {</dt><dd><p>sum = sum + num - 10000</p>
</dd>
</dl>
<p>}
needAdd = !needAdd
count–</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return sum</p>
</div></blockquote>
</div>
<div class="section" id="id218">
<h1>}<a class="headerlink" href="#id218" title="永久链接至标题">¶</a></h1>
<p>## 563.二叉树的坡度(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id219"><span class="problematic" id="id220">``</span></a>`
给定一个二叉树，计算整个树的坡度。
一个树的节点的坡度定义即为，该节点左子树的结点之和和右子树结点之和的差的绝对值。空结点的的坡度是0。
整个树的坡度就是其所有节点的坡度之和。</p>
<p>示例:</p>
<dl>
<dt>输入:</dt><dd><blockquote>
<div><blockquote>
<div><p>1</p>
</div></blockquote>
<p>/   </p>
</div></blockquote>
<p>2     3</p>
</dd>
</dl>
<p>输出: 1
解释:
结点的坡度 2 : 0
结点的坡度 3 : 0
结点的坡度 1 : <a href="#id351"><span class="problematic" id="id352">|2-3|</span></a> = 1
树的坡度 : 0 + 0 + 1 = 1
注意:</p>
<blockquote>
<div><p>任何子树的结点的和不会超过32位整数的范围。
坡度的值不会超过32位整数的范围。</p>
</div></blockquote>
<p><a href="#id221"><span class="problematic" id="id222">``</span></a><a href="#id223"><span class="problematic" id="id224">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路 | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —- | ———- | ———- |</div>
<div class="line">01   | 递归 | O(n)       | O(log(n))  |</div>
<div class="line">02   | 迭代 | O(n)       | O(n)       |</div>
</div>
<p><a href="#id225"><span class="problematic" id="id226">``</span></a><a href="#id227"><span class="problematic" id="id228">`</span></a>go
var total int</p>
<dl class="simple">
<dt>func findTilt(root <a href="#id229"><span class="problematic" id="id230">*</span></a>TreeNode) int {</dt><dd><p>total = 0
dfs(root)
return total</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func dfs(root <a href="#id231"><span class="problematic" id="id232">*</span></a>TreeNode) int {</dt><dd><dl class="simple">
<dt>if root == nil {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
left := dfs(root.Left)
right := dfs(root.Right)
total = total + abs(left, right)
return left + right + root.Val // 返回节点之和</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func abs(a, b int) int {</dt><dd><dl class="simple">
<dt>if a &gt; b {</dt><dd><p>return a - b</p>
</dd>
</dl>
<p>}
return b - a</p>
</dd>
</dl>
<p>}</p>
<p>#
func findTilt(root <a href="#id233"><span class="problematic" id="id234">*</span></a>TreeNode) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if root == nil {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
stack := make([]*TreeNode, 0)
stack = append(stack, root)
list := make([]*TreeNode, 0)
total := 0
for len(stack) &gt; 0 {</p>
<blockquote>
<div><p>node := stack[len(stack)-1]
stack = stack[0 : len(stack)-1]
list = append([]*TreeNode{node}, list…)
if node.Left != nil {</p>
<blockquote>
<div><p>stack = append(stack, node.Left)</p>
</div></blockquote>
<p>}
if node.Right != nil {</p>
<blockquote>
<div><p>stack = append(stack, node.Right)</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
for i := range list {</p>
<blockquote>
<div><p>node := list[i]
left := 0
right := 0
if node.Left != nil {</p>
<blockquote>
<div><p>left = node.Left.Val</p>
</div></blockquote>
<p>}
if node.Right != nil {</p>
<blockquote>
<div><p>right = node.Right.Val</p>
</div></blockquote>
<p>}
total = total + abs(left, right)
node.Val = left + right + node.Val</p>
</div></blockquote>
<p>}
return total</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func abs(a, b int) int {</dt><dd><dl class="simple">
<dt>if a &gt; b {</dt><dd><p>return a - b</p>
</dd>
</dl>
<p>}
return b - a</p>
</dd>
</dl>
</div>
<div class="section" id="id235">
<h1>}<a class="headerlink" href="#id235" title="永久链接至标题">¶</a></h1>
<p>## 566.重塑矩阵(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id236"><span class="problematic" id="id237">``</span></a>`
在MATLAB中，有一个非常有用的函数 reshape，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。
给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。
重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。
如果具有给定参数的reshape操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。</p>
<p>示例 1:输入:
nums =
[[1,2],</p>
<blockquote>
<div><p>[3,4]]</p>
</div></blockquote>
<p>r = 1, c = 4
输出:
[[1,2,3,4]]
解释:行遍历nums的结果是 [1,2,3,4]。新的矩阵是 1 * 4 矩阵, 用之前的元素值一行一行填充新矩阵。</p>
<p>示例 2:输入:
nums =
[[1,2],</p>
<blockquote>
<div><p>[3,4]]</p>
</div></blockquote>
<p>r = 2, c = 4
输出:
[[1,2],</p>
<blockquote>
<div><p>[3,4]]</p>
</div></blockquote>
<p>解释:没有办法将 2 * 2 矩阵转化为 2 * 4 矩阵。 所以输出原矩阵。
注意：</p>
<blockquote>
<div><p>给定矩阵的宽和高范围在 [1, 100]。
给定的 r 和 c 都是正数。</p>
</div></blockquote>
<p><a href="#id238"><span class="problematic" id="id239">``</span></a><a href="#id240"><span class="problematic" id="id241">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路 | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —- | ———- | ———- |</div>
<div class="line">01   | 遍历 | O(n^2)     | O(n^2)     |</div>
<div class="line">02   | 遍历 | O(n^2)     | O(n^2)     |</div>
</div>
<p><a href="#id242"><span class="problematic" id="id243">``</span></a><a href="#id244"><span class="problematic" id="id245">`</span></a>go
func matrixReshape(nums [][]int, r int, c int) [][]int {</p>
<blockquote>
<div><p>row, col := len(nums), len(nums[0])
if (row*col != r*c) || (row == r &amp;&amp; col == c) {</p>
<blockquote>
<div><p>return nums</p>
</div></blockquote>
<p>}
res := make([][]int, r)
for i := 0; i &lt; len(res); i++ {</p>
<blockquote>
<div><p>res[i] = make([]int, c)</p>
</div></blockquote>
<p>}
for i := 0; i &lt; r*c; i++ {</p>
<blockquote>
<div><p>res[i/c][i%c] = nums[i/col][i%col]</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
func matrixReshape(nums [][]int, r int, c int) [][]int {</p>
<blockquote>
<div><p>row, col := len(nums), len(nums[0])
if (row*col != r*c) || (row == r &amp;&amp; col == c) {</p>
<blockquote>
<div><p>return nums</p>
</div></blockquote>
<p>}
res := make([][]int, 0)
arr := make([]int, 0)
count := 0
for _, num := range nums {</p>
<blockquote>
<div><dl>
<dt>for _, value := range num {</dt><dd><p>arr = append(arr, value)
count++
if count == c {</p>
<blockquote>
<div><p>res = append(res, arr)
arr = []int{}
count = 0</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
</div>
<div class="section" id="id246">
<h1>}<a class="headerlink" href="#id246" title="永久链接至标题">¶</a></h1>
<p>## 572.另一个树的子树(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id247"><span class="problematic" id="id248">``</span></a>`
给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。
s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。
示例 1:
给定的树 s:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><p>3</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<p>4   5</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<p>1   2</p>
</div></blockquote>
<dl>
<dt>给定的树 t：</dt><dd><blockquote>
<div><blockquote>
<div><p>4</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<p>1   2</p>
</dd>
</dl>
<p>返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。</p>
<p>示例 2:
给定的树 s：</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><p>3</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<p>4   5</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<dl>
<dt>1   2</dt><dd><blockquote>
<div><p>/</p>
</div></blockquote>
<p>0</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>给定的树 t：</dt><dd><blockquote>
<div><blockquote>
<div><p>4</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<p>1   2</p>
</dd>
</dl>
<p>返回 false。
<a href="#id249"><span class="problematic" id="id250">``</span></a><a href="#id251"><span class="problematic" id="id252">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路            | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ————— | ———- | ———- |</div>
<div class="line">01   | 递归            | O(n^2)     | O(log(n))  |</div>
<div class="line">02   | 递归+字符串辅助 | O(n)       | O(log(n))  |</div>
<div class="line">03   | 栈辅助          | O(n)       | O(n)       |</div>
</div>
<p><a href="#id253"><span class="problematic" id="id254">``</span></a><a href="#id255"><span class="problematic" id="id256">`</span></a>go
func isSubtree(s <a href="#id257"><span class="problematic" id="id258">*</span></a>TreeNode, t <a href="#id259"><span class="problematic" id="id260">*</span></a>TreeNode) bool {</p>
<blockquote>
<div><dl class="simple">
<dt>if s == nil {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}
return isSame(s, t) || isSubtree(s.Left, t) || isSubtree(s.Right, t)</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func isSame(s <a href="#id261"><span class="problematic" id="id262">*</span></a>TreeNode, t <a href="#id263"><span class="problematic" id="id264">*</span></a>TreeNode) bool {</dt><dd><dl class="simple">
<dt>if s == nil || t == nil{</dt><dd><p>return t == s</p>
</dd>
</dl>
<p>}
return isSame(s.Left, t.Left) &amp;&amp; isSame(s.Right, t.Right) &amp;&amp; s.Val == t.Val</p>
</dd>
</dl>
<p>}</p>
<p>#
func isSubtree(s <a href="#id265"><span class="problematic" id="id266">*</span></a>TreeNode, t <a href="#id267"><span class="problematic" id="id268">*</span></a>TreeNode) bool {</p>
<blockquote>
<div><p>sStr := dfs(s, “”)
tStr := dfs(t, “”)
return strings.Contains(sStr, tStr)</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func dfs(s <a href="#id269"><span class="problematic" id="id270">*</span></a>TreeNode, pre string) string {</dt><dd><dl class="simple">
<dt>if s == nil {</dt><dd><p>return pre</p>
</dd>
</dl>
<p>}
return fmt.Sprintf(“#%d%s%s”, s.Val, dfs(s.Left, “l”), dfs(s.Right, “r”))</p>
</dd>
</dl>
<p>}</p>
<p>#
func preOrder(root <a href="#id271"><span class="problematic" id="id272">*</span></a>TreeNode) string {</p>
<blockquote>
<div><dl class="simple">
<dt>if root == nil {</dt><dd><p>return “”</p>
</dd>
</dl>
<p>}
res := “!”
stack := make([]*TreeNode,0)
temp := root
for {</p>
<blockquote>
<div><dl class="simple">
<dt>for temp != nil{</dt><dd><p>res += strconv.Itoa(temp.Val)
res += “!”
stack = append(stack, temp)
temp = temp.Left</p>
</dd>
</dl>
<p>}
res += “#!”
if len(stack) &gt; 0{</p>
<blockquote>
<div><p>node := stack[len(stack)-1]
stack = stack[:len(stack)-1]
temp = node.Right</p>
</div></blockquote>
<dl class="simple">
<dt>}else {</dt><dd><p>break</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
</div>
<div class="section" id="id273">
<h1>}<a class="headerlink" href="#id273" title="永久链接至标题">¶</a></h1>
<p>## 575.分糖果(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id274"><span class="problematic" id="id275">``</span></a>`
给定一个偶数长度的数组，其中不同的数字代表着不同种类的糖果，每一个数字代表一个糖果。
你需要把这些糖果平均分给一个弟弟和一个妹妹。返回妹妹可以获得的最大糖果的种类数。</p>
<p>示例 1:输入: candies = [1,1,2,2,3,3] 输出: 3
解析: 一共有三种种类的糖果，每一种都有两个。</p>
<blockquote>
<div><p>最优分配方案：妹妹获得[1,2,3],弟弟也获得[1,2,3]。这样使妹妹获得糖果的种类数最多。</p>
</div></blockquote>
<p>示例 2 : 输入: candies = [1,1,2,3] 输出: 2
解析: 妹妹获得糖果[2,3],弟弟获得糖果[1,1]，妹妹有两种不同的糖果，弟弟只有一种。
这样使得妹妹可以获得的糖果种类数最多。</p>
<dl class="simple">
<dt>注意:</dt><dd><p>数组的长度为[2, 10,000]，并且确定为偶数。
数组中数字的大小在范围[-100,000, 100,000]内。</p>
</dd>
</dl>
<p><a href="#id276"><span class="problematic" id="id277">``</span></a><a href="#id278"><span class="problematic" id="id279">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路     | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ——– | ———- | ———- |</div>
<div class="line">01   | 哈希辅助 | O(n)       | O(n)       |</div>
<div class="line">02   | 排序遍历 | O(nlog(n)) | O(1)       |</div>
</div>
<p><a href="#id280"><span class="problematic" id="id281">``</span></a><a href="#id282"><span class="problematic" id="id283">`</span></a>go
func distributeCandies(candies []int) int {</p>
<blockquote>
<div><p>n := len(candies)
r := make(map[int]bool, n)
for _, c := range candies {</p>
<blockquote>
<div><p>r[c] = true</p>
</div></blockquote>
<p>}
return min(len(r), n/2)</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func min(a, b int) int {</dt><dd><dl class="simple">
<dt>if a &lt; b {</dt><dd><p>return a</p>
</dd>
</dl>
<p>}
return b</p>
</dd>
</dl>
<p>}</p>
<p>#
func distributeCandies(candies []int) int {</p>
<blockquote>
<div><p>length := len(candies)
half := length / 2
count := 1
sort.Ints(candies)
for i := 1; i &lt; length; i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if candies[i] != candies[i-1] {</dt><dd><p>count++</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
if count &gt;= half {</p>
<blockquote>
<div><p>return half</p>
</div></blockquote>
<p>}
return count</p>
</div></blockquote>
</div>
<div class="section" id="id284">
<h1>}<a class="headerlink" href="#id284" title="永久链接至标题">¶</a></h1>
<p>## 581.最短无序连续子数组(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id285"><span class="problematic" id="id286">``</span></a>`
给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。
你找到的子数组应是最短的，请输出它的长度。
示例 1:输入: [2, 6, 4, 8, 10, 9, 15] 输出: 5
解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。
说明 :</p>
<blockquote>
<div><p>输入的数组长度范围在 [1, 10,000]。
输入的数组可能包含重复元素 ，所以升序的意思是&lt;=。</p>
</div></blockquote>
<p><a href="#id287"><span class="problematic" id="id288">``</span></a><a href="#id289"><span class="problematic" id="id290">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路     | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ——– | ———- | ———- |</div>
<div class="line">01   | 双指针   | O(n)       | O(1)       |</div>
<div class="line">02   | 2次遍历  | O(n)       | O(1)       |</div>
<div class="line">03   | 排序遍历 | O(nlog(n)) | O(n)       |</div>
</div>
<p><a href="#id291"><span class="problematic" id="id292">``</span></a><a href="#id293"><span class="problematic" id="id294">`</span></a>go
func findUnsortedSubarray(nums []int) int {</p>
<blockquote>
<div><p>length := len(nums)
left, right := 0, -1
min, max := nums[length-1], nums[0]
for i := 1; i &lt; length; i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if max &lt;= nums[i] {</dt><dd><p>max = nums[i]</p>
</dd>
<dt>} else {</dt><dd><p>right = i</p>
</dd>
</dl>
<p>}
j := length - i - 1
if min &gt;= nums[j] {</p>
<blockquote>
<div><p>min = nums[j]</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>left = j</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return right - left + 1</p>
</div></blockquote>
<p>}</p>
<p>#
func findUnsortedSubarray(nums []int) int {</p>
<blockquote>
<div><p>length := len(nums)
right := -1
max := nums[0]
for i := 1; i &lt; length; i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if max &lt;= nums[i] {</dt><dd><p>max = nums[i]</p>
</dd>
<dt>} else {</dt><dd><p>right = i</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
if right == 0 {</p>
<blockquote>
<div><p>// 针对升序，特殊处理
// 如去掉判断
// 需要保证left,right初始值满足right-left+1=0
return 0</p>
</div></blockquote>
<p>}
left := 0
min := nums[length-1]
for i := length - 2; i &gt;= 0; i– {</p>
<blockquote>
<div><dl class="simple">
<dt>if min &gt;= nums[i] {</dt><dd><p>min = nums[i]</p>
</dd>
<dt>} else {</dt><dd><p>left = i</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return right - left + 1</p>
</div></blockquote>
<p>}</p>
<p>#
func findUnsortedSubarray(nums []int) int {</p>
<blockquote>
<div><p>temp := make([]int,len(nums))
copy(temp,nums)
sort.Ints(temp)
i, j := 0, len(nums)-1
for i &lt; len(nums) &amp;&amp; nums[i] == temp[i]{</p>
<blockquote>
<div><p>i++</p>
</div></blockquote>
<p>}
for i+1 &lt; j &amp;&amp; nums[j] == temp[j]{</p>
<blockquote>
<div><p>j–</p>
</div></blockquote>
<p>}
return j-i+1</p>
</div></blockquote>
</div>
<div class="section" id="id295">
<h1>}<a class="headerlink" href="#id295" title="永久链接至标题">¶</a></h1>
<p>## 589.N叉树的前序遍历(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">给定一个</span> <span class="pre">N</span> <span class="pre">叉树，返回其节点值的前序遍历。</span>
<span class="pre">例如，给定一个</span> <span class="pre">3叉树</span> <span class="pre">:</span>
<span class="pre">返回其前序遍历:</span> <span class="pre">[1,3,5,6,2,4]。</span>
<span class="pre">说明:</span> <span class="pre">递归法很简单，你可以使用迭代法完成此题吗?</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路 | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —- | ———- | ———- |</div>
<div class="line">01   | 递归 | O(n)       | O(log(n))  |</div>
<div class="line">02   | 迭代 | O(n)       | O(n)       |</div>
</div>
<p><a href="#id296"><span class="problematic" id="id297">``</span></a><a href="#id298"><span class="problematic" id="id299">`</span></a>go
var res []int</p>
<dl class="simple">
<dt>func preorder(root <a href="#id300"><span class="problematic" id="id301">*</span></a>Node) []int {</dt><dd><p>res = make([]int, 0)
dfs(root)
return res</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func dfs(root <a href="#id302"><span class="problematic" id="id303">*</span></a>Node) {</dt><dd><dl class="simple">
<dt>if root == nil {</dt><dd><p>return</p>
</dd>
</dl>
<p>}
res = append(res, root.Val)
for _, value := range root.Children {</p>
<blockquote>
<div><p>dfs(value)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>#
func preorder(root <a href="#id304"><span class="problematic" id="id305">*</span></a>Node) []int {</p>
<blockquote>
<div><p>res := make([]int, 0)
if root == nil {</p>
<blockquote>
<div><p>return res</p>
</div></blockquote>
<p>}
stack := make([]*Node, 0)
stack = append(stack, root)
for len(stack) &gt; 0 {</p>
<blockquote>
<div><p>temp := stack[len(stack)-1]
stack = stack[:len(stack)-1]
res = append(res, temp.Val)
for i := len(temp.Children) - 1; i &gt;= 0; i– {</p>
<blockquote>
<div><p>stack = append(stack, temp.Children[i])</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
</div>
<div class="section" id="id306">
<h1>}<a class="headerlink" href="#id306" title="永久链接至标题">¶</a></h1>
<p>## 590.N叉树的后序遍历(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id307"><span class="problematic" id="id308">``</span></a>`
给定一个 N 叉树，返回其节点值的后序遍历。</p>
<p>例如，给定一个 3叉树 :</p>
<p>返回其后序遍历: [5,6,3,2,4,1].
说明: 递归法很简单，你可以使用迭代法完成此题吗?
<a href="#id309"><span class="problematic" id="id310">``</span></a><a href="#id311"><span class="problematic" id="id312">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路 | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —- | ———- | ———- |</div>
<div class="line">01   | 递归 | O(n)       | O(log(n))  |</div>
<div class="line">02   | 迭代 | O(n)       | O(n)       |</div>
</div>
<p><a href="#id313"><span class="problematic" id="id314">``</span></a><a href="#id315"><span class="problematic" id="id316">`</span></a>go
var res []int
func postorder(root <a href="#id317"><span class="problematic" id="id318">*</span></a>Node) []int {</p>
<blockquote>
<div><p>res = make([]int, 0)
dfs(root)
return res</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func dfs(root <a href="#id319"><span class="problematic" id="id320">*</span></a>Node) {</dt><dd><dl class="simple">
<dt>if root == nil {</dt><dd><p>return</p>
</dd>
</dl>
<p>}
for _, value := range root.Children {</p>
<blockquote>
<div><p>dfs(value)</p>
</div></blockquote>
<p>}
res = append(res, root.Val)</p>
</dd>
</dl>
<p>}</p>
<p>#
// 后序：(左右)根
// 前序：根(左右)=&gt;根(右左)=&gt;左右根
func postorder(root <a href="#id321"><span class="problematic" id="id322">*</span></a>Node) []int {</p>
<blockquote>
<div><p>res := make([]int, 0)
if root == nil {</p>
<blockquote>
<div><p>return res</p>
</div></blockquote>
<p>}
stack := make([]*Node, 0)
stack = append(stack, root)
for len(stack) &gt; 0 {</p>
<blockquote>
<div><p>temp := stack[len(stack)-1]
stack = stack[:len(stack)-1]
res = append(res, temp.Val)
for i := 0; i &lt; len(temp.Children); i++ {</p>
<blockquote>
<div><p>stack = append(stack, temp.Children[i])</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
for i := 0; i &lt; len(res)/2; i++ {</p>
<blockquote>
<div><p>res[i], res[len(res)-1-i] = res[len(res)-1-i], res[i]</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
</div>
<div class="section" id="id323">
<h1>}<a class="headerlink" href="#id323" title="永久链接至标题">¶</a></h1>
<p>## 594.最长和谐子序列(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">和谐数组是指一个数组里元素的最大值和最小值之间的差别正好是1。</span>
<span class="pre">现在，给定一个整数数组，你需要在所有可能的子序列中找到最长的和谐子序列的长度。</span>
<span class="pre">示例</span> <span class="pre">1:输入:</span> <span class="pre">[1,3,2,2,5,2,3,7]输出:</span> <span class="pre">5</span>
<span class="pre">原因:</span> <span class="pre">最长的和谐数组是：[3,2,2,2,3].</span>
<span class="pre">说明:</span> <span class="pre">输入的数组长度最大不超过20,000.</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路     | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ——– | ———- | ———- |</div>
<div class="line">01   | 哈希辅助 | O(n)       | O(n)       |</div>
<div class="line">02   | 排序遍历 | O(nlog(n)) | O(1)       |</div>
</div>
<p><a href="#id324"><span class="problematic" id="id325">``</span></a><a href="#id326"><span class="problematic" id="id327">`</span></a>go
func findLHS(nums []int) int {</p>
<blockquote>
<div><p>m := make(map[int]int, len(nums))
for _, n := range nums {</p>
<blockquote>
<div><p>m[n]++</p>
</div></blockquote>
<p>}
res := 0
for key, value := range m {</p>
<blockquote>
<div><p>value2, ok := m[key+1]
if ok {</p>
<blockquote>
<div><p>t := value + value2
if res &lt; t {</p>
<blockquote>
<div><p>res = t</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
func findLHS(nums []int) int {</p>
<blockquote>
<div><p>sort.Ints(nums)
res := 0
left := 0
for i := 0; i &lt; len(nums); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>for nums[i]-nums[left] &gt; 1 {</dt><dd><p>left++</p>
</dd>
</dl>
<p>}
if nums[i]-nums[left] == 1 {</p>
<blockquote>
<div><dl class="simple">
<dt>if res &lt; i-left+1 {</dt><dd><p>res = i - left + 1</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
</div>
<div class="section" id="id328">
<h1>}<a class="headerlink" href="#id328" title="永久链接至标题">¶</a></h1>
<p>## 598.范围求和 II(1)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id329"><span class="problematic" id="id330">``</span></a>`
给定一个初始元素全部为 0，大小为 m*n 的矩阵 M 以及在 M 上的一系列更新操作。
操作用二维数组表示，其中的每个操作用一个含有两个正整数 a 和 b 的数组表示，
含义是将所有符合 0 &lt;= i &lt; a 以及 0 &lt;= j &lt; b 的元素 M[i][j] 的值都增加 1。
在执行给定的一系列操作后，你需要返回矩阵中含有最大整数的元素个数。</p>
<p>示例 1:输入: m = 3, n = 3operations = [[2,2],[3,3]] 输出: 4
解释: 初始状态, M =
[[0, 0, 0],</p>
<blockquote>
<div><p>[0, 0, 0],
[0, 0, 0]]</p>
</div></blockquote>
<p>执行完操作 [2,2] 后, M =
[[1, 1, 0],</p>
<blockquote>
<div><p>[1, 1, 0],
[0, 0, 0]]</p>
</div></blockquote>
<p>执行完操作 [3,3] 后, M =
[[2, 2, 1],</p>
<blockquote>
<div><p>[2, 2, 1],
[1, 1, 1]]</p>
</div></blockquote>
<p>M 中最大的整数是 2, 而且 M 中有4个值为2的元素。因此返回 4。
注意:</p>
<blockquote>
<div><p>m 和 n 的范围是 [1,40000]。
a 的范围是 [1,m]，b 的范围是 [1,n]。
操作数目不超过 10000。</p>
</div></blockquote>
<p><a href="#id331"><span class="problematic" id="id332">``</span></a><a href="#id333"><span class="problematic" id="id334">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路 | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —- | ———- | ———- |</div>
<div class="line">01   | 数学 | O(n)       | O(1)       |</div>
</div>
<p><a href="#id335"><span class="problematic" id="id336">``</span></a><a href="#id337"><span class="problematic" id="id338">`</span></a>go
func maxCount(m int, n int, ops [][]int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>for _, o := range ops {</dt><dd><p>m = min(m, o[0])
n = min(n, o[1])</p>
</dd>
</dl>
<p>}
return m * n</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func min(a, b int) int {</dt><dd><dl class="simple">
<dt>if a &lt; b {</dt><dd><p>return a</p>
</dd>
</dl>
<p>}
return b</p>
</dd>
</dl>
</div>
<div class="section" id="id339">
<h1>}<a class="headerlink" href="#id339" title="永久链接至标题">¶</a></h1>
<p>## 599.两个列表的最小索引总和(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id340"><span class="problematic" id="id341">``</span></a>`
假设Andy和Doris想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。
你需要帮助他们用最少的索引和找出他们共同喜爱的餐厅。 如果答案不止一个，则输出所有答案并且不考虑顺序。
你可以假设总是存在一个答案。</p>
<p>示例 1:输入:
[“Shogun”, “Tapioca Express”, “Burger King”, “KFC”]
[“Piatti”, “The Grill at Torrey Pines”, “Hungry Hunter Steakhouse”, “Shogun”]
输出: [“Shogun”]
解释: 他们唯一共同喜爱的餐厅是“Shogun”。</p>
<p>示例 2:
输入:
[“Shogun”, “Tapioca Express”, “Burger King”, “KFC”]
[“KFC”, “Shogun”, “Burger King”]
输出: [“Shogun”]
解释: 他们共同喜爱且具有最小索引和的餐厅是“Shogun”，它有最小的索引和1(0+1)。</p>
<dl class="simple">
<dt>提示:</dt><dd><p>两个列表的长度范围都在 [1, 1000]内。
两个列表中的字符串的长度将在[1，30]的范围内。
下标从0开始，到列表的长度减1。
两个列表都没有重复的元素。</p>
</dd>
</dl>
<p><a href="#id342"><span class="problematic" id="id343">``</span></a><a href="#id344"><span class="problematic" id="id345">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路     | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ——– | ———- | ———- |</div>
<div class="line">01   | 哈希辅助 | O(n)       | O(n)       |</div>
<div class="line">02   | 暴力法   | O(n^2)     | I          |</div>
</div>
<p><a href="#id346"><span class="problematic" id="id347">``</span></a><a href="#id348"><span class="problematic" id="id349">`</span></a>go
func findRestaurant(list1 []string, list2 []string) []string {</p>
<blockquote>
<div><dl class="simple">
<dt>if len(list1) &gt; len(list2) {</dt><dd><p>list1, list2 = list2, list1</p>
</dd>
</dl>
<p>}
m2 := make(map[string]int, len(list2))
for i := range list2 {</p>
<blockquote>
<div><p>m2[list2[i]] = i</p>
</div></blockquote>
<p>}
min := 2000
res := make([]string, 0, 1000)
for key, value := range list1 {</p>
<blockquote>
<div><dl>
<dt>if key2, ok := m2[value]; ok {</dt><dd><dl class="simple">
<dt>if min == key+key2 {</dt><dd><p>res = append(res, value)</p>
</dd>
</dl>
<p>}
if min &gt; key+key2 {</p>
<blockquote>
<div><p>min = key + key2
res = []string{value}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
func findRestaurant(list1 []string, list2 []string) []string {</p>
<blockquote>
<div><p>min := 2000
res := make([]string, 0, 1000)
for key1, value1 := range list1 {</p>
<blockquote>
<div><dl>
<dt>for key2, value2 := range list2{</dt><dd><dl>
<dt>if value1 == value2{</dt><dd><dl class="simple">
<dt>if min == key1+key2 {</dt><dd><p>res = append(res, value1)</p>
</dd>
</dl>
<p>}
if min &gt; key1+key2 {</p>
<blockquote>
<div><p>min = key1 + key2
res = []string{value1}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
</div>
<div class="section" id="id350">
<h1>}<a class="headerlink" href="#id350" title="永久链接至标题">¶</a></h1>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="0601-0700.html" class="btn btn-neutral float-right" title="}" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="0401-0500.html" class="btn btn-neutral float-left" title="}" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, willshang

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>