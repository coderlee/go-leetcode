

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh-CN" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh-CN" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>} &mdash; go-leetcode v1.0.0 文档</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="}" href="0601-0700.html" />
    <link rel="prev" title="}" href="0401-0500.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> go-leetcode
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id10">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id15">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id26">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id31">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id64">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id89">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id92">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id97">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id100">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id105">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id110">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id115">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id120">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id125">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id130">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id135">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id140">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id151">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id156">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id173">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id184">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id203">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id30">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id31">]</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id54">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id71">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id90">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id105">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id122">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id125">]</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id130">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id141">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id152">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id163">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id174">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id185">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id202">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id229">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id260">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id271">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id282">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id293">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id304">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id315">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id326">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id337">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id348">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id357">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id18">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id23">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id34">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id61">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id72">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id83">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id148">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id167">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id178">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id227">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id244">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id263">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id276">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id287">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id306">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id311">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id322">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id333">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id344">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id355">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id366">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id377">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id388">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id20">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id25">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id36">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id47">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id58">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id69">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id74">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id79">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id90">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id101">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id106">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id111">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id124">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id26">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id37">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id42">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id45">]</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id50">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id55">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id66">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id71">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id100">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id105">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id116">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id127">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id138">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id143">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id154">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id159">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id170">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id181">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id192">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id203">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id214">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id225">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id236">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id247">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id258">}</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id24">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id35">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id40">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id59">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id70">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id81">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id106">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id117">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id146">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id157">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id178">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id189">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id200">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id215">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id226">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id243">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id254">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id285">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id296">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id307">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id318">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id335">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id340">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id351">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id362">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id28">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id51">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id62">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id67">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id84">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id95">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id106">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id133">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id144">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id155">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id166">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id185">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id204">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id209">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id220">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id231">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id242">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id267">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id280">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id287">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id298">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id309">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id328">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id46">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id69">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id92">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id103">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id114">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id129">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id140">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id151">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id164">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id175">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id188">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id199">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id210">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id221">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id232">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id243">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id270">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id281">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id292">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id303">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id22">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id33">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id44">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id55">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id66">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id77">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id82">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id93">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id104">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id115">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id126">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id137">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id148">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id159">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id170">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id181">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id186">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id221">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id232">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id255">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id266">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id277">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id288">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id299">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id310">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id321">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id356">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id22">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id33">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id44">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id55">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id66">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id77">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id92">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id107">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id122">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id133">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id144">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id155">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id166">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id177">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id188">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id211">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id222">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id227">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id238">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id249">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id260">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id285">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id296">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id307">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1001-1100.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1001-1100.html#id20">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1001-1100.html#id35">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1001-1100.html#id46">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1001-1100.html#id57">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1001-1100.html#id68">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1001-1100.html#id79">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1001-1100.html#id98">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1001-1100.html#id109">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1001-1100.html#id120">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1001-1100.html#id131">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1001-1100.html#id142">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1001-1100.html#id153">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1001-1100.html#id164">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1001-1100.html#id193">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1001-1100.html#id204">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1001-1100.html#id215">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1001-1100.html#id226">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1001-1100.html#id237">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1001-1100.html#id248">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1101-1200.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1101-1200.html#id22">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1101-1200.html#id33">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1101-1200.html#id44">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1101-1200.html#id55">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1101-1200.html#id68">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1101-1200.html#id79">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1101-1200.html#id90">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1101-1200.html#id101">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1101-1200.html#id112">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1101-1200.html#id123">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1101-1200.html#id134">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1101-1200.html#id143">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1201-1300.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1201-1300.html#id24">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1201-1300.html#id35">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1201-1300.html#id46">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1201-1300.html#id57">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1201-1300.html#id68">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1201-1300.html#id79">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1201-1300.html#id90">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1201-1300.html#id101">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1201-1300.html#id112">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1201-1300.html#id123">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1201-1300.html#id140">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1201-1300.html#id151">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1201-1300.html#id162">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html#id22">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html#id33">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html#id44">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html#id55">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html#id66">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html#id79">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html#id90">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html#id95">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html#id106">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html#id117">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html#id128">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html#id139">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html#id150">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html#id161">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html#id166">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html#id177">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html#id212">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html#id223">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html#id234">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1301-1400.html#id239">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1401-1500.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1401-1500.html#id22">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1401-1500.html#id33">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1401-1500.html#id44">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1401-1500.html#id49">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1401-1500.html#id60">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1401-1500.html#id71">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1401-1500.html#id82">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1401-1500.html#id93">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1401-1500.html#id104">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1401-1500.html#id115">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1401-1500.html#id126">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1401-1500.html#id137">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1401-1500.html#id148">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1401-1500.html#id159">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1401-1500.html#id170">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="1401-1500.html#id181">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id16">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id21">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id38">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id59">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id92">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id115">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id126">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id137">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id148">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id159">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id170">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id175">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id180">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id191">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id202">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id221">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id232">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id291">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id322">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id349">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id374">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id401">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id420">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id437">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id442">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id469">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id480">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id511">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id542">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id575">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id586">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id605">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id650">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id655">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id660">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id689">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id752">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id763">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id768">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id775">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id786">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id791">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id802">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id813">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id818">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id823">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id828">#</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id857">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id862">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id867">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id888">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id903">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id922">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id935">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id946">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id951">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id956">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id967">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id972">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id1013">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id1038">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id1043">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id1048">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id1059">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id1064">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id1069">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id1080">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id1091">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="offer.html#id1102">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="lcp.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="lcp.html#id22">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="lcp.html#id33">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="lcp.html#id44">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="lcp.html#id55">}</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">go-leetcode</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>}</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/question/0501-0600.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <p># 0501-0600-Easy
* [0501-0600-Easy](#0501-0600-easy)</p>
<blockquote>
<div><ul class="simple">
<li><p>[501.二叉搜索树中的众数(2)](#501二叉搜索树中的众数2)</p></li>
<li><p>[504.七进制数(3)](#504七进制数3)</p></li>
<li><p>[506.相对名次(1)](#506相对名次1)</p></li>
<li><p>[507.完美数(1)](#507完美数1)</p></li>
<li><p>[509.斐波那契数(6)](#509斐波那契数6)</p></li>
<li><p>[520.检测大写字母(2)](#520检测大写字母2)</p></li>
<li><p>[521.最长特殊序列Ⅰ(1)](#521最长特殊序列ⅰ1)</p></li>
<li><p>[530.二叉搜索树的最小绝对差(3)](#530二叉搜索树的最小绝对差3)</p></li>
<li><p>[532.数组中的K-diff数对(3)](#532数组中的k-diff数对3)</p></li>
<li><p>[538.把二叉搜索树转换为累加树(2)](#538把二叉搜索树转换为累加树2)</p></li>
<li><p>[541.反转字符串II(2)](#541反转字符串ii2)</p></li>
<li><p>[543.二叉树的直径(2)](#543二叉树的直径2)</p></li>
<li><p>[551.学生出勤记录 I(2)](#551学生出勤记录-i2)</p></li>
<li><p>[557.反转字符串中的单词 III(2)](#557反转字符串中的单词-iii2)</p></li>
<li><p>[559.N叉树的最大深度(2)](#559n叉树的最大深度2)</p></li>
<li><p>[561.数组拆分 I(2)](#561数组拆分-i2)</p></li>
<li><p>[563.二叉树的坡度(2)](#563二叉树的坡度2)</p></li>
<li><p>[566.重塑矩阵(2)](#566重塑矩阵2)</p></li>
<li><p>[572.另一个树的子树(3)](#572另一个树的子树3)</p></li>
<li><p>[575.分糖果(2)](#575分糖果2)</p></li>
<li><p>[581.最短无序连续子数组(3)](#581最短无序连续子数组3)</p></li>
<li><p>[589.N叉树的前序遍历(2)](#589n叉树的前序遍历2)</p></li>
<li><p>[590.N叉树的后序遍历(2)](#590n叉树的后序遍历2)</p></li>
<li><p>[594.最长和谐子序列(2)](#594最长和谐子序列2)</p></li>
<li><p>[598.范围求和 II(1)](#598范围求和-ii1)</p></li>
<li><p>[599.两个列表的最小索引总和(2)](#599两个列表的最小索引总和2)</p></li>
</ul>
</div></blockquote>
<p>## 501.二叉搜索树中的众数(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">``</span></a>`
给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。
假定 BST 有如下定义：</p>
<blockquote>
<div><p>结点左子树中所含结点的值小于等于当前结点的值
结点右子树中所含结点的值大于等于当前结点的值
左子树和右子树都是二叉搜索树</p>
</div></blockquote>
<p>例如：
给定 BST [1,null,2,2],</p>
<blockquote>
<div><dl>
<dt>1</dt><dd><dl class="simple">
<dt></dt><dd><p>2</p>
</dd>
</dl>
<p>/</p>
</dd>
</dl>
<p>2</p>
</div></blockquote>
<p>返回[2].
提示：如果众数超过1个，不需考虑输出顺序
进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）
<a href="#id3"><span class="problematic" id="id4">``</span></a><a href="#id5"><span class="problematic" id="id6">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路          | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ————- | ———- | ———- |</div>
<div class="line">01   | 递归+哈希辅助 | O(n)       | O(n)       |</div>
<div class="line">02   | 递归+中序遍历 | O(n)       | O(log(n))  |</div>
</div>
<p><a href="#id7"><span class="problematic" id="id8">``</span></a><a href="#id9"><span class="problematic" id="id10">`</span></a>go
func findMode(root <a href="#id11"><span class="problematic" id="id12">*</span></a>TreeNode) []int {</p>
<blockquote>
<div><p>m := map[int]int{}
dfs(root, m)
max := -1
res := make([]int, 0)
for i, v := range m {</p>
<blockquote>
<div><dl>
<dt>if max &lt;= v {</dt><dd><dl class="simple">
<dt>if max &lt; v {</dt><dd><p>max = v
res = res[0:0]</p>
</dd>
</dl>
<p>}
res = append(res, i)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func dfs(root <a href="#id13"><span class="problematic" id="id14">*</span></a>TreeNode, rec map[int]int) {</dt><dd><dl class="simple">
<dt>if root == nil {</dt><dd><p>return</p>
</dd>
</dl>
<p>}
rec[root.Val]++
dfs(root.Left, rec)
dfs(root.Right, rec)</p>
</dd>
</dl>
<p>}</p>
<p>#
var max int
var res []int
var cur int
var count int</p>
<dl class="simple">
<dt>func findMode(root <a href="#id15"><span class="problematic" id="id16">*</span></a>TreeNode) []int {</dt><dd><p>res = make([]int, 0)
max, cur, count = 0, 0, 0
dfs(root)
return res</p>
</dd>
</dl>
<p>}</p>
<p>// 中序遍历保证利用二叉搜索树的性质，得到的结果是升序的
func dfs(root <a href="#id17"><span class="problematic" id="id18">*</span></a>TreeNode) {</p>
<blockquote>
<div><dl class="simple">
<dt>if root == nil {</dt><dd><p>return</p>
</dd>
</dl>
<p>}
dfs(root.Left)
if root.Val != cur {</p>
<blockquote>
<div><p>count = 0</p>
</div></blockquote>
<p>}
count++
if max &lt; count {</p>
<blockquote>
<div><p>max = count
res = []int{root.Val}</p>
</div></blockquote>
<dl class="simple">
<dt>} else if max == count {</dt><dd><p>res = append(res, root.Val)</p>
</dd>
</dl>
<p>}
cur = root.Val
dfs(root.Right)</p>
</div></blockquote>
<div class="section" id="id19">
<h1>}<a class="headerlink" href="#id19" title="永久链接至标题">¶</a></h1>
<p>## 504.七进制数(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">给定一个整数，将其转化为7进制，并以字符串形式输出。</span>
<span class="pre">示例</span> <span class="pre">1:输入:</span> <span class="pre">100</span> <span class="pre">输出:</span> <span class="pre">&quot;202&quot;</span>
<span class="pre">示例</span> <span class="pre">2:</span> <span class="pre">输入:</span> <span class="pre">-7</span> <span class="pre">输出:</span> <span class="pre">&quot;-10&quot;</span>
<span class="pre">注意:</span> <span class="pre">输入范围是</span> <span class="pre">[-1e7,</span> <span class="pre">1e7]</span> <span class="pre">。</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路     | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ——– | ———- | ———- |</div>
<div class="line">01   | 遍历     | O(log(n))  | O(1)       |</div>
<div class="line">02   | 内置函数 | O(log(n))  | O(1)       |</div>
<div class="line">03   | 递归     | O(log(n))  | O(log(n))  |</div>
</div>
<p><a href="#id20"><span class="problematic" id="id21">``</span></a><a href="#id22"><span class="problematic" id="id23">`</span></a>go
func convertToBase7(num int) string {</p>
<blockquote>
<div><dl class="simple">
<dt>if num == 0 {</dt><dd><p>return “0”</p>
</dd>
</dl>
<p>}</p>
<p>minus := “”
if num &lt; 0 {</p>
<blockquote>
<div><p>minus = “-”
num = -1 * num</p>
</div></blockquote>
<p>}</p>
<p>s := “”
for num &gt; 0 {</p>
<blockquote>
<div><p>s = fmt.Sprintf(“%d”, num%7) + s
num = num / 7</p>
</div></blockquote>
<p>}
return minus + s</p>
</div></blockquote>
<p>}</p>
<p>#
func convertToBase7(num int) string {</p>
<blockquote>
<div><p>return strconv.FormatInt(int64(num), 7)</p>
</div></blockquote>
<p>}</p>
<p>#
func convertToBase7(num int) string {</p>
<blockquote>
<div><dl class="simple">
<dt>if num &lt; 0 {</dt><dd><p>return “-” + convertToBase7(-1*num)</p>
</dd>
</dl>
<p>}
if num &lt; 7 {</p>
<blockquote>
<div><p>return strconv.Itoa(num)</p>
</div></blockquote>
<p>}
return convertToBase7(num/7) + strconv.Itoa(num%7)</p>
</div></blockquote>
</div>
<div class="section" id="id24">
<h1>}<a class="headerlink" href="#id24" title="永久链接至标题">¶</a></h1>
<p>## 506.相对名次(1)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id25"><span class="problematic" id="id26">``</span></a>`
给出 N 名运动员的成绩，找出他们的相对名次并授予前三名对应的奖牌。
前三名运动员将会被分别授予 “金牌”，“银牌” 和“ 铜牌”
（”Gold Medal”, “Silver Medal”, “Bronze Medal”）。
(注：分数越高的选手，排名越靠前。)</p>
<p>示例 1:
输入: [5, 4, 3, 2, 1]
输出: [“Gold Medal”, “Silver Medal”, “Bronze Medal”, “4”, “5”]
解释: 前三名运动员的成绩为前三高的，
因此将会分别被授予 “金牌”，“银牌”和“铜牌” (“Gold Medal”, “Silver Medal” and “Bronze Medal”).
余下的两名运动员，我们只需要通过他们的成绩计算将其相对名次即可。
提示:</p>
<blockquote>
<div><p>N 是一个正整数并且不会超过 10000。
所有运动员的成绩都不相同。</p>
</div></blockquote>
<p><a href="#id27"><span class="problematic" id="id28">``</span></a><a href="#id29"><span class="problematic" id="id30">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路      | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ——— | ———- | ———- |</div>
<div class="line">01   | 排序+遍历 | O(nlog(n)) | O(n)       |</div>
</div>
<p><a href="#id31"><span class="problematic" id="id32">``</span></a><a href="#id33"><span class="problematic" id="id34">`</span></a>go
func findRelativeRanks(nums []int) []string {</p>
<blockquote>
<div><p>temp := make([]int, len(nums))
copy(temp, nums)
sort.Ints(temp)
m := make(map[int]string)
for i := 0; i &lt; len(temp); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if i == len(temp)-1 {</dt><dd><p>m[temp[i]] = “Gold Medal”</p>
</dd>
<dt>} else if i == len(temp)-2 {</dt><dd><p>m[temp[i]] = “Silver Medal”</p>
</dd>
<dt>} else if i == len(temp)-3 {</dt><dd><p>m[temp[i]] = “Bronze Medal”</p>
</dd>
<dt>} else {</dt><dd><p>m[temp[i]] = strconv.Itoa(len(temp) - i)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
res := make([]string,0)
for i := 0; i &lt; len(nums); i++ {</p>
<blockquote>
<div><p>res = append(res, m[nums[i]])</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
</div>
<div class="section" id="id35">
<h1>}<a class="headerlink" href="#id35" title="永久链接至标题">¶</a></h1>
<p>## 507.完美数(1)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">对于一个</span> <span class="pre">正整数，如果它和除了它自身以外的所有正因子之和相等，我们称它为“完美数”。</span>
<span class="pre">给定一个</span> <span class="pre">整数</span> <span class="pre">n，</span> <span class="pre">如果他是完美数，返回</span> <span class="pre">True，否则返回</span> <span class="pre">False</span>
<span class="pre">示例：输入:</span> <span class="pre">28</span> <span class="pre">输出:</span> <span class="pre">True</span> <span class="pre">解释:</span> <span class="pre">28</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">2</span> <span class="pre">+</span> <span class="pre">4</span> <span class="pre">+</span> <span class="pre">7</span> <span class="pre">+</span> <span class="pre">14</span>
<span class="pre">提示：输入的数字</span> <span class="pre">n</span> <span class="pre">不会超过</span> <span class="pre">100,000,000.</span> <span class="pre">(1e8)</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路 | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —- | ———- | ———- |</div>
<div class="line">01   | 遍历 | O(n^1/2)   | O(1)       |</div>
</div>
<p><a href="#id36"><span class="problematic" id="id37">``</span></a><a href="#id38"><span class="problematic" id="id39">`</span></a>go
func checkPerfectNumber(num int) bool {</p>
<blockquote>
<div><dl class="simple">
<dt>if num == 1 {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}
sum := 1
for i := 2; i &lt;= num/i; i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if num%i == 0 {</dt><dd><p>sum = sum + i + (num / i)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return sum == num</p>
</div></blockquote>
</div>
<div class="section" id="id40">
<h1>}<a class="headerlink" href="#id40" title="永久链接至标题">¶</a></h1>
<p>## 509.斐波那契数(6)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id41"><span class="problematic" id="id42">``</span></a>`
斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。
该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：
F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.
给定 N，计算 F(N)。
示例 1：输入：2输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1.
示例 2：输入：3输出：2
解释：F(3) = F(2) + F(1) = 1 + 1 = 2.
示例 3：输入：4输出：3
解释：F(4) = F(3) + F(2) = 2 + 1 = 3.
提示：</p>
<blockquote>
<div><p>0 ≤ N ≤ 30</p>
</div></blockquote>
<p><a href="#id43"><span class="problematic" id="id44">``</span></a><a href="#id45"><span class="problematic" id="id46">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路       | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ———- | ———- | ———- |</div>
<div class="line">01   | 遍历       | O(n)       | O(1)       |</div>
<div class="line">02   | 遍历+数组  | O(n)       | O(n)       |</div>
<div class="line">03   | 递归       | O(2^n)     | O(n)       |</div>
<div class="line">04   | 公式法     | O(1)       | O(1)       |</div>
<div class="line">05   | 矩阵快速幂 | O(log(n))  | O(1)       |</div>
<div class="line">06   | 矩阵快速幂 | O(n)       | O(1)       |</div>
</div>
<p><a href="#id47"><span class="problematic" id="id48">``</span></a><a href="#id49"><span class="problematic" id="id50">`</span></a>go
func fib(N int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if N == 0 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
if N == 1 {</p>
<blockquote>
<div><p>return 1</p>
</div></blockquote>
<p>}
n1, n2 := 0, 1
for i := 2; i &lt;= N; i++ {</p>
<blockquote>
<div><p>n1, n2 = n2, n1+n2</p>
</div></blockquote>
<p>}
return n2</p>
</div></blockquote>
<p>}</p>
<p>#
func fib(N int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if N == 0 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
if N == 1 {</p>
<blockquote>
<div><p>return 1</p>
</div></blockquote>
<p>}
res := make([]int, N+1)
res[0] = 0
res[1] = 1
for i := 2; i &lt;= N; i++ {</p>
<blockquote>
<div><p>res[i] = res[i-1] + res[i-2]</p>
</div></blockquote>
<p>}
return res[N]</p>
</div></blockquote>
<p>}</p>
<p>#
func fib(N int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if N == 0 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
if N == 1 {</p>
<blockquote>
<div><p>return 1</p>
</div></blockquote>
<p>}
return fib(N-1) + fib(N-2)</p>
</div></blockquote>
<p>}</p>
<p>#
func fib(N int) int {</p>
<blockquote>
<div><p>temp1 := (1 + math.Sqrt(5)) / 2
temp2 := (1 - math.Sqrt(5)) / 2
fn := math.Round((math.Pow(temp1, float64(N))- math.Pow(temp2, float64(N)))/ math.Sqrt(5))
return int(fn)</p>
</div></blockquote>
<p>}</p>
<p># 5
func fib(N int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if N == 0 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
/*</p>
<blockquote>
<div><dl>
<dt>ans = [Fn+1 Fn</dt><dd><blockquote>
<div><p>Fn Fn-1]</p>
</div></blockquote>
<dl class="simple">
<dt>= [ 1 0</dt><dd><p>0 1]</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p><a href="#id51"><span class="problematic" id="id52">*</span></a>/
ans := matrix{</p>
<blockquote>
<div><p>a: 1,
b: 0,
c: 0,
d: 1,</p>
</div></blockquote>
<p>}
m := matrix{</p>
<blockquote>
<div><p>a: 1,
b: 1,
c: 1,
d: 0,</p>
</div></blockquote>
<p>}
for N &gt; 0 {</p>
<blockquote>
<div><dl class="simple">
<dt>if N%2 == 1 {</dt><dd><p>ans = multi(ans, m)</p>
</dd>
</dl>
<p>}
m = multi(m, m)
N = N &gt;&gt; 1</p>
</div></blockquote>
<p>}
return ans.b</p>
</div></blockquote>
<p>}</p>
<p>/*
a b
c d
<a href="#id53"><span class="problematic" id="id54">*</span></a>/
type matrix struct {</p>
<blockquote>
<div><p>a, b, c, d int</p>
</div></blockquote>
<p>}</p>
<p>// 矩阵乘法
func multi(x, y matrix) matrix {</p>
<blockquote>
<div><p>newA := x.a*y.a + x.b*y.c
newB := x.a*y.b + x.b*y.d
newC := x.c*y.a + x.d*y.c
newD := x.c*y.b + x.d*y.d
return matrix{</p>
<blockquote>
<div><p>a: newA,
b: newB,
c: newC,
d: newD,</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<p># 6
func fib(N int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if N == 0 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
/*</p>
<blockquote>
<div><dl>
<dt>ans = [Fn+1 Fn</dt><dd><blockquote>
<div><p>Fn Fn-1]</p>
</div></blockquote>
<dl class="simple">
<dt>= [ 1 0</dt><dd><p>0 1]</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p><a href="#id55"><span class="problematic" id="id56">*</span></a>/
ans := matrix{</p>
<blockquote>
<div><p>a: 1,
b: 0,
c: 0,
d: 1,</p>
</div></blockquote>
<p>}
m := matrix{</p>
<blockquote>
<div><p>a: 1,
b: 1,
c: 1,
d: 0,</p>
</div></blockquote>
<p>}
for N &gt; 0 {</p>
<blockquote>
<div><p>ans = multi(ans, m)
N–</p>
</div></blockquote>
<p>}
return ans.b</p>
</div></blockquote>
<p>}</p>
<p>/*
a b
c d
<a href="#id57"><span class="problematic" id="id58">*</span></a>/
type matrix struct {</p>
<blockquote>
<div><p>a, b, c, d int</p>
</div></blockquote>
<p>}</p>
<p>// 矩阵乘法
func multi(x, y matrix) matrix {</p>
<blockquote>
<div><p>newA := x.a*y.a + x.b*y.c
newB := x.a*y.b + x.b*y.d
newC := x.c*y.a + x.d*y.c
newD := x.c*y.b + x.d*y.d
return matrix{</p>
<blockquote>
<div><p>a: newA,
b: newB,
c: newC,
d: newD,</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
</div>
<div class="section" id="id59">
<h1>}<a class="headerlink" href="#id59" title="永久链接至标题">¶</a></h1>
<p>## 520.检测大写字母(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id60"><span class="problematic" id="id61">``</span></a>`
给定一个单词，你需要判断单词的大写使用是否正确。
我们定义，在以下情况时，单词的大写用法是正确的：</p>
<blockquote>
<div><p>全部字母都是大写，比如”USA”。
单词中所有字母都不是大写，比如”leetcode”。
如果单词不只含有一个字母，只有首字母大写， 比如 “Google”。</p>
</div></blockquote>
<p>否则，我们定义这个单词没有正确使用大写字母。
示例 1:输入: “USA”输出: True
示例 2:输入: “FlaG”输出: False
注意: 输入是由大写和小写拉丁字母组成的非空单词。
<a href="#id62"><span class="problematic" id="id63">``</span></a><a href="#id64"><span class="problematic" id="id65">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路 | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —- | ———- | ———- |</div>
<div class="line">01   | 遍历 | O(n)       | O(1)       |</div>
<div class="line">02   | 正则 | O(n)       | O(1)       |</div>
</div>
<p><a href="#id66"><span class="problematic" id="id67">``</span></a><a href="#id68"><span class="problematic" id="id69">`</span></a>go
func detectCapitalUse(word string) bool {</p>
<blockquote>
<div><dl class="simple">
<dt>if word == “” {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}
count := 0
for i := 0; i &lt; len(word); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if word[i] &gt;= ‘A’ &amp;&amp; word[i] &lt;= ‘Z’ {</dt><dd><p>count++</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>if count == 0 || count == len(word) ||</dt><dd><p>(count == 1 &amp;&amp; word[0] &gt;= ‘A’ &amp;&amp; word[0] &lt;= ‘Z’) {
return true</p>
</dd>
</dl>
<p>}
return false</p>
</div></blockquote>
<p>}</p>
<p>#
func detectCapitalUse(word string) bool {</p>
<blockquote>
<div><p>pattern := “(^[a-z]+)$|(^[A-Z]+)$|(^[A-Z]{1}[a-z]*)$”
isMatch, _ := regexp.MatchString(pattern, word)
return isMatch</p>
</div></blockquote>
</div>
<div class="section" id="id70">
<h1>}<a class="headerlink" href="#id70" title="永久链接至标题">¶</a></h1>
<p>## 521.最长特殊序列Ⅰ(1)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id71"><span class="problematic" id="id72">``</span></a>`
给你两个字符串，请你从这两个字符串中找出最长的特殊序列。
「最长特殊序列」定义如下：该序列为某字符串独有的最长子序列（即不能是其他字符串的子序列）。</p>
<p>子序列 可以通过删去字符串中的某些字符实现，但不能改变剩余字符的相对顺序。空序列为所有字符串的子序列，任何字符串为其自身的子序列。</p>
<p>输入为两个字符串，输出最长特殊序列的长度。如果不存在，则返回 -1。</p>
<p>示例 1：输入: “aba”, “cdc” 输出: 3
解释: 最长特殊序列可为 “aba” (或 “cdc”)，两者均为自身的子序列且不是对方的子序列。
示例 2：输入：a = “aaa”, b = “bbb”输出：3
示例 3：输入：a = “aaa”, b = “aaa”输出：-1
提示：</p>
<blockquote>
<div><p>两个字符串长度均处于区间 [1 - 100] 。
字符串中的字符仅含有 ‘a’~’z’ 。</p>
</div></blockquote>
<p><a href="#id73"><span class="problematic" id="id74">``</span></a><a href="#id75"><span class="problematic" id="id76">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路 | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —- | ———- | ———- |</div>
<div class="line">01   | 比较 | O(1)       | O(1)       |</div>
</div>
<p><a href="#id77"><span class="problematic" id="id78">``</span></a><a href="#id79"><span class="problematic" id="id80">`</span></a>go
func findLUSlength(a string, b string) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if a == b {</dt><dd><p>return -1</p>
</dd>
</dl>
<p>}
return max(len(a), len(b))</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func max(a, b int) int {</dt><dd><dl class="simple">
<dt>if a &gt; b {</dt><dd><p>return a</p>
</dd>
</dl>
<p>}
return b</p>
</dd>
</dl>
</div>
<div class="section" id="id81">
<h1>}<a class="headerlink" href="#id81" title="永久链接至标题">¶</a></h1>
<p>## 530.二叉搜索树的最小绝对差(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id82"><span class="problematic" id="id83">``</span></a>`
给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。
示例：
输入：</p>
<blockquote>
<div><dl>
<dt>1</dt><dd><dl class="simple">
<dt></dt><dd><p>3</p>
</dd>
</dl>
<p>/</p>
</dd>
</dl>
<p>2</p>
</div></blockquote>
<p>输出：1
解释：
最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。
提示：</p>
<blockquote>
<div><p>树中至少有 2 个节点。
本题与 783 <a class="reference external" href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/">https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/</a> 相同</p>
</div></blockquote>
<p><a href="#id84"><span class="problematic" id="id85">``</span></a><a href="#id86"><span class="problematic" id="id87">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路          | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ————- | ———- | ———- |</div>
<div class="line">01   | 递归+中序遍历 | O(n)       | O(log(n))  |</div>
<div class="line">02   | 递归+遍历     | O(n)       | O(n)       |</div>
<div class="line">03   | 迭代          | O(n)       | O(n)         |</div>
</div>
<p><a href="#id88"><span class="problematic" id="id89">``</span></a><a href="#id90"><span class="problematic" id="id91">`</span></a>go
var minDiff, previous int
func getMinimumDifference(root <a href="#id92"><span class="problematic" id="id93">*</span></a>TreeNode) int {</p>
<blockquote>
<div><p>minDiff, previous  = math.MaxInt32, math.MaxInt32
dfs(root)
return minDiff</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func dfs(root <a href="#id94"><span class="problematic" id="id95">*</span></a>TreeNode) {</dt><dd><dl class="simple">
<dt>if root == nil {</dt><dd><p>return</p>
</dd>
</dl>
<p>}
dfs(root.Left)</p>
<p>newDiff := diff(previous, root.Val)
if minDiff &gt; newDiff {</p>
<blockquote>
<div><p>minDiff = newDiff</p>
</div></blockquote>
<p>}
previous = root.Val
dfs(root.Right)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func diff(a, b int) int {</dt><dd><dl class="simple">
<dt>if a &gt; b {</dt><dd><p>return a - b</p>
</dd>
</dl>
<p>}
return b - a</p>
</dd>
</dl>
<p>}</p>
<p>#
func getMinimumDifference(root <a href="#id96"><span class="problematic" id="id97">*</span></a>TreeNode) int {</p>
<blockquote>
<div><p>arr := make([]int, 0)
dfs(root, &amp;arr)
minDiff := arr[1] - arr[0]
for i := 2; i &lt; len(arr); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if minDiff &gt; arr[i]-arr[i-1] {</dt><dd><p>minDiff = arr[i] - arr[i-1]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return minDiff</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func dfs(root <a href="#id98"><span class="problematic" id="id99">*</span></a>TreeNode, arr <a href="#id100"><span class="problematic" id="id101">*</span></a>[]int) {</dt><dd><dl class="simple">
<dt>if root == nil {</dt><dd><p>return</p>
</dd>
</dl>
<p>}
dfs(root.Left, arr)
<a href="#id102"><span class="problematic" id="id103">*</span></a>arr = append(<a href="#id104"><span class="problematic" id="id105">*</span></a>arr, root.Val)
dfs(root.Right, arr)</p>
</dd>
</dl>
</div>
<div class="section" id="id106">
<h1>}<a class="headerlink" href="#id106" title="永久链接至标题">¶</a></h1>
<p>## 532.数组中的K-diff数对(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id107"><span class="problematic" id="id108">``</span></a>`
给定一个整数数组和一个整数 k, 你需要在数组里找到不同的 k-diff 数对。
这里将 k-diff 数对定义为一个整数对 (i, j), 其中 i 和 j 都是数组中的数字，且两数之差的绝对值是 k.</p>
<p>示例 1: 输入: [3, 1, 4, 1, 5], k = 2 输出: 2
解释: 数组中有两个 2-diff 数对, (1, 3) 和 (3, 5)。
尽管数组中有两个1，但我们只应返回不同的数对的数量。
示例 2:输入:[1, 2, 3, 4, 5], k = 1 输出: 4
解释: 数组中有四个 1-diff 数对, (1, 2), (2, 3), (3, 4) 和 (4, 5)。
示例 3:输入: [1, 3, 1, 5, 4], k = 0 输出: 1
解释: 数组中只有一个 0-diff 数对，(1, 1)。
注意:</p>
<blockquote>
<div><p>数对 (i, j) 和数对 (j, i) 被算作同一数对。
数组的长度不超过10,000。
所有输入的整数的范围在 [-1e7, 1e7]。</p>
</div></blockquote>
<p><a href="#id109"><span class="problematic" id="id110">``</span></a><a href="#id111"><span class="problematic" id="id112">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路       | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ———- | ———- | ———- |</div>
<div class="line">01   | 单哈希辅助 | O(n)       | O(n)       |</div>
<div class="line">02   | 双哈希辅助 | O(n)       | O(n)       |</div>
<div class="line">03   | 排序遍历   | O(nlog(n)) | O(1)       |</div>
</div>
<p><a href="#id113"><span class="problematic" id="id114">``</span></a><a href="#id115"><span class="problematic" id="id116">`</span></a>go
func findPairs(nums []int, k int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if k &lt; 0 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
record := make(map[int]int)
for _, num := range nums {</p>
<blockquote>
<div><p>record[num]++</p>
</div></blockquote>
<p>}
res := 0
if k == 0 {</p>
<blockquote>
<div><dl>
<dt>for _, count := range record {</dt><dd><dl class="simple">
<dt>if count &gt; 1 {</dt><dd><p>res++</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
return res</p>
</div></blockquote>
<dl>
<dt>} else {</dt><dd><dl>
<dt>for n := range record {</dt><dd><dl class="simple">
<dt>if record[n-k] &gt; 0 {</dt><dd><p>res++</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
return res</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>#
func findPairs(nums []int, k int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if k &lt; 0 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
m := make(map[int]bool)
res := make(map[int]bool)
for _, value := range nums {</p>
<blockquote>
<div><dl class="simple">
<dt>if m[value-k] {</dt><dd><p>res[value-k] = true</p>
</dd>
</dl>
<p>}
if m[value+k] {</p>
<blockquote>
<div><p>res[value] = true</p>
</div></blockquote>
<p>}
m[value] = true</p>
</div></blockquote>
<p>}
return len(res)</p>
</div></blockquote>
</div>
<div class="section" id="id117">
<h1>}<a class="headerlink" href="#id117" title="永久链接至标题">¶</a></h1>
<p>## 538.把二叉搜索树转换为累加树(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id118"><span class="problematic" id="id119">``</span></a>`
给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，
使得每个节点的值是原来的节点值加上所有大于它的节点值之和。
例如：
输入: 原始二叉搜索树:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>5</p>
</div></blockquote>
<p>/   </p>
</div></blockquote>
<p>2     13</p>
</div></blockquote>
<dl>
<dt>输出: 转换为累加树:</dt><dd><blockquote>
<div><blockquote>
<div><p>18</p>
</div></blockquote>
<p>/   </p>
</div></blockquote>
<p>20     13</p>
</dd>
</dl>
<p>注意：
本题和 1038: <a class="reference external" href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a> 相同
<a href="#id120"><span class="problematic" id="id121">``</span></a><a href="#id122"><span class="problematic" id="id123">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路   | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —— | ———- | ———- |</div>
<div class="line">01   | 递归   | O(n)       | O(log(n))  |</div>
<div class="line">02   | 栈辅助 | O(n)       | O(n)       |</div>
</div>
<p><a href="#id124"><span class="problematic" id="id125">``</span></a><a href="#id126"><span class="problematic" id="id127">`</span></a>go
func convertBST(root <a href="#id128"><span class="problematic" id="id129">*</span></a>TreeNode) <a href="#id130"><span class="problematic" id="id131">*</span></a>TreeNode {</p>
<blockquote>
<div><p>sum := 0
dfs(root, &amp;sum)
return root</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func dfs(root <a href="#id132"><span class="problematic" id="id133">*</span></a>TreeNode, sum <a href="#id134"><span class="problematic" id="id135">*</span></a>int) {</dt><dd><dl class="simple">
<dt>if root == nil {</dt><dd><p>return</p>
</dd>
</dl>
<p>}
dfs(root.Right, sum)
<a href="#id136"><span class="problematic" id="id137">*</span></a>sum = <a href="#id138"><span class="problematic" id="id139">*</span></a>sum + root.Val
root.Val = <a href="#id140"><span class="problematic" id="id141">*</span></a>sum
dfs(root.Left, sum)</p>
</dd>
</dl>
<p>}</p>
<p>#
func convertBST(root <a href="#id142"><span class="problematic" id="id143">*</span></a>TreeNode) <a href="#id144"><span class="problematic" id="id145">*</span></a>TreeNode {</p>
<blockquote>
<div><dl class="simple">
<dt>if root == nil {</dt><dd><p>return root</p>
</dd>
</dl>
<p>}
stack := make([]*TreeNode, 0)
temp := root
sum := 0
for {</p>
<blockquote>
<div><dl class="simple">
<dt>if temp != nil {</dt><dd><p>stack = append(stack, temp)
temp = temp.Right</p>
</dd>
<dt>} else if len(stack) != 0 {</dt><dd><p>temp = stack[len(stack)-1]
stack = stack[:len(stack)-1]
temp.Val = temp.Val + sum
sum = temp.Val
temp = temp.Left</p>
</dd>
<dt>} else {</dt><dd><p>break</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return root</p>
</div></blockquote>
</div>
<div class="section" id="id146">
<h1>}<a class="headerlink" href="#id146" title="永久链接至标题">¶</a></h1>
<p>## 541.反转字符串II(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id147"><span class="problematic" id="id148">``</span></a>`
给定一个字符串和一个整数 k，你需要对从字符串开头算起的每个 2k 个字符的前k个字符进行反转。
如果剩余少于 k 个字符，则将剩余的所有全部反转。
如果有小于 2k 但大于或等于 k 个字符，则反转前 k 个字符，并将剩余的字符保持原样。</p>
<p>示例:
输入: s = “abcdefg”, k = 2
输出: “bacdfeg”
要求:</p>
<blockquote>
<div><p>该字符串只包含小写的英文字母。
给定字符串的长度和 k 在[1, 10000]范围内。</p>
</div></blockquote>
<p><a href="#id149"><span class="problematic" id="id150">``</span></a><a href="#id151"><span class="problematic" id="id152">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路 | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —- | ———- | ———- |</div>
<div class="line">01   | 遍历 | O(n)       | O(1)       |</div>
<div class="line">02   | 遍历 | O(n)       | O(1)       |</div>
</div>
<p><a href="#id153"><span class="problematic" id="id154">``</span></a><a href="#id155"><span class="problematic" id="id156">`</span></a>go
func reverseStr(s string, k int) string {</p>
<blockquote>
<div><p>arr := []byte(s)
for i := 0; i &lt; len(s); i = i + 2*k {</p>
<blockquote>
<div><p>j := min(i+k, len(s))
reverse(arr[i:j])</p>
</div></blockquote>
<p>}
return string(arr)</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func reverse(arr []byte) {</dt><dd><p>i, j := 0, len(arr)-1
for i &lt; j {</p>
<blockquote>
<div><p>arr[i], arr[j] = arr[j], arr[i]
i++
j–</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func min(a, b int) int {</dt><dd><dl class="simple">
<dt>if a &lt; b {</dt><dd><p>return a</p>
</dd>
</dl>
<p>}
return b</p>
</dd>
</dl>
<p>}</p>
<p>#
func reverseStr(s string, k int) string {</p>
<blockquote>
<div><p>arr := []byte(s)
for i := 0; i &lt; len(s); i = i + k {</p>
<blockquote>
<div><dl>
<dt>if i%(2*k) == 0 {</dt><dd><p>j := i + k
if len(arr) &lt; j {</p>
<blockquote>
<div><p>j = len(arr)</p>
</div></blockquote>
<p>}
reverse(arr[i:j])</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return string(arr)</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func reverse(arr []byte) {</dt><dd><p>i, j := 0, len(arr)-1
for i &lt; j {</p>
<blockquote>
<div><p>arr[i], arr[j] = arr[j], arr[i]
i++
j–</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</div>
<div class="section" id="id157">
<h1>}<a class="headerlink" href="#id157" title="永久链接至标题">¶</a></h1>
<p>## 543.二叉树的直径(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id158"><span class="problematic" id="id159">``</span></a>`
给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。
这条路径可能穿过也可能不穿过根结点。
示例 :
给定二叉树</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><p>1</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<p>2   3</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<p>4   5</p>
</div></blockquote>
<p>返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。
注意：两结点之间的路径长度是以它们之间边的数目表示。
<a href="#id160"><span class="problematic" id="id161">``</span></a><a href="#id162"><span class="problematic" id="id163">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路   | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —— | ———- | ———- |</div>
<div class="line">01   | 递归   | O(n)       | O(log(n))  |</div>
<div class="line">02   | 栈辅助 | O(n)       | O(n)       |</div>
</div>
<p><a href="#id164"><span class="problematic" id="id165">``</span></a><a href="#id166"><span class="problematic" id="id167">`</span></a>go
var res int
func diameterOfBinaryTree(root <a href="#id168"><span class="problematic" id="id169">*</span></a>TreeNode) int {</p>
<blockquote>
<div><p>res = 0
dfs(root)
return res</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func dfs(root <a href="#id170"><span class="problematic" id="id171">*</span></a>TreeNode) int {</dt><dd><dl class="simple">
<dt>if root == nil {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
left := dfs(root.Left)
right := dfs(root.Right)
path := max(left, right)
res = max(left+right, res) // 当前节点最大直径与当前保存最大值比较
return path + 1 // 以该节点为根的最大深度</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func max(a, b int) int {</dt><dd><dl class="simple">
<dt>if a &gt; b {</dt><dd><p>return a</p>
</dd>
</dl>
<p>}
return b</p>
</dd>
</dl>
<p>}</p>
<p>#
func diameterOfBinaryTree(root <a href="#id172"><span class="problematic" id="id173">*</span></a>TreeNode) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if root == nil {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
max := 0
stack := make([]*TreeNode, 0)
m := make(map[<a href="#id174"><span class="problematic" id="id175">*</span></a>TreeNode]int)</p>
<p>cur := root
var prev <a href="#id176"><span class="problematic" id="id177">*</span></a>TreeNode
for cur != nil || len(stack) != 0 {</p>
<blockquote>
<div><dl class="simple">
<dt>for cur != nil {</dt><dd><p>stack = append(stack, cur)
cur = cur.Left</p>
</dd>
</dl>
<p>}
cur = stack[len(stack)-1]
if cur.Right == nil || cur.Right == prev {</p>
<blockquote>
<div><p>cur = stack[len(stack)-1]
stack = stack[:len(stack)-1]</p>
<p>leftLen := 0
rightLen := 0
if v, ok := m[cur.Left]; ok {</p>
<blockquote>
<div><p>leftLen = v</p>
</div></blockquote>
<p>}
if v, ok := m[cur.Right]; ok {</p>
<blockquote>
<div><p>rightLen = v</p>
</div></blockquote>
<p>}
if leftLen &gt; rightLen {</p>
<blockquote>
<div><p>m[cur] = leftLen + 1</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>m[cur] = rightLen + 1</p>
</dd>
</dl>
<p>}
if max &lt; leftLen+rightLen {</p>
<blockquote>
<div><p>max = leftLen + rightLen</p>
</div></blockquote>
<p>}
prev = cur
cur = nil</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>cur = cur.Right</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return max</p>
</div></blockquote>
</div>
<div class="section" id="id178">
<h1>}<a class="headerlink" href="#id178" title="永久链接至标题">¶</a></h1>
<p>## 551.学生出勤记录 I(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id179"><span class="problematic" id="id180">``</span></a>`
给定一个字符串来代表一个学生的出勤记录，这个记录仅包含以下三个字符：</p>
<blockquote>
<div><p>‘A’ : Absent，缺勤
‘L’ : Late，迟到
‘P’ : Present，到场</p>
</div></blockquote>
<p>如果一个学生的出勤记录中不超过一个’A’(缺勤)并且不超过两个连续的’L’(迟到),那么这个学生会被奖赏。
你需要根据这个学生的出勤记录判断他是否会被奖赏。</p>
<p>示例 1:输入: “PPALLP”输出: True
示例 2:输入: “PPALLL”输出: False
<a href="#id181"><span class="problematic" id="id182">``</span></a><a href="#id183"><span class="problematic" id="id184">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路     | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ——– | ———- | ———- |</div>
<div class="line">01   | 内置函数 | O(n)       | O(1)       |</div>
<div class="line">02   | 遍历     | O(n)       | O(1)       |</div>
</div>
<p><a href="#id185"><span class="problematic" id="id186">``</span></a><a href="#id187"><span class="problematic" id="id188">`</span></a>go
func checkRecord(s string) bool {</p>
<blockquote>
<div><dl class="simple">
<dt>if strings.Count(s, “A”) &lt;= 1 &amp;&amp; strings.Count(s, “LLL”) == 0 {</dt><dd><p>return true</p>
</dd>
</dl>
<p>}
return false</p>
</div></blockquote>
<p>}</p>
<p>#
func checkRecord(s string) bool {</p>
<blockquote>
<div><p>aNum := 0
lNum := 0
for i := 0; i &lt; len(s); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if s[i] == ‘A’ {</dt><dd><p>aNum++</p>
</dd>
</dl>
<p>}
if s[i] == ‘L’ {</p>
<blockquote>
<div><p>lNum++</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>lNum = 0</p>
</dd>
</dl>
<p>}
if aNum == 2 {</p>
<blockquote>
<div><p>return false</p>
</div></blockquote>
<p>}
if lNum == 3 {</p>
<blockquote>
<div><p>return false</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return true</p>
</div></blockquote>
</div>
<div class="section" id="id189">
<h1>}<a class="headerlink" href="#id189" title="永久链接至标题">¶</a></h1>
<p>## 557.反转字符串中的单词 III(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id190"><span class="problematic" id="id191">``</span></a>`
给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。
示例 1:
输入: “Let’s take LeetCode contest”
输出: “s’teL ekat edoCteeL tsetnoc”</p>
<p>注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。
<a href="#id192"><span class="problematic" id="id193">``</span></a><a href="#id194"><span class="problematic" id="id195">`</span></a></p>
<ul class="simple">
<li><p>解题思路分析</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路     | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ——– | ———- | ———- |</div>
<div class="line">01   | 内置函数 | O(n)       | O(n)       |</div>
<div class="line">02   | 遍历     | O(n)       | O(n)       |</div>
</div>
<p><a href="#id196"><span class="problematic" id="id197">``</span></a><a href="#id198"><span class="problematic" id="id199">`</span></a>go</p>
<dl>
<dt>func reverseWords(s string) string {</dt><dd><p>strS := strings.Split(s, ” “)
for i, s := range strS {</p>
<blockquote>
<div><p>strS[i] = reverse(s)</p>
</div></blockquote>
<p>}
return strings.Join(strS, ” “)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func reverse(s string) string {</dt><dd><p>arr := []byte(s)
i, j := 0, len(arr)-1
for i &lt; j {</p>
<blockquote>
<div><p>arr[i], arr[j] = arr[j], arr[i]
i++
j–</p>
</div></blockquote>
<p>}
return string(arr)</p>
</dd>
</dl>
<p>}</p>
<p>#
func reverseWords(s string) string {</p>
<blockquote>
<div><p>arr := []byte(s)
j := 0
for i := 0; i &lt; len(arr); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if arr[i] == ‘ ‘ {</dt><dd><p>reverse(arr, j, i-1)
j = i + 1</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
reverse(arr, j, len(arr)-1)
return string(arr)</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func reverse(arr []byte, i, j int) []byte {</dt><dd><dl class="simple">
<dt>for i &lt; j {</dt><dd><p>arr[i], arr[j] = arr[j], arr[i]
i++
j–</p>
</dd>
</dl>
<p>}
return arr</p>
</dd>
</dl>
</div>
<div class="section" id="id200">
<h1>}<a class="headerlink" href="#id200" title="永久链接至标题">¶</a></h1>
<p>## 559.N叉树的最大深度(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id201"><span class="problematic" id="id202">``</span></a>`
给定一个 N 叉树，找到其最大深度。
最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。
例如，给定一个 3叉树 :
我们应返回其最大深度，3。
说明:</p>
<blockquote>
<div><p>树的深度不会超过 1000。
树的节点总不会超过 5000。</p>
</div></blockquote>
<p><a href="#id203"><span class="problematic" id="id204">``</span></a><a href="#id205"><span class="problematic" id="id206">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路 | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —- | ———- | ———- |</div>
<div class="line">01   | 递归 | O(n)       | O(log(n))  |</div>
<div class="line">02   | 迭代 | O(n)       | O(n)       |</div>
</div>
<p><a href="#id207"><span class="problematic" id="id208">``</span></a><a href="#id209"><span class="problematic" id="id210">`</span></a>go
func maxDepth(root <a href="#id211"><span class="problematic" id="id212">*</span></a>Node) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if root == nil {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
depth := 0
for _, node := range root.Children {</p>
<blockquote>
<div><p>depth = max(depth, maxDepth(node))</p>
</div></blockquote>
<p>}
return depth + 1</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func max(a, b int) int {</dt><dd><dl class="simple">
<dt>if a &gt; b {</dt><dd><p>return a</p>
</dd>
</dl>
<p>}
return b</p>
</dd>
</dl>
<p>}</p>
<p>#
func maxDepth(root <a href="#id213"><span class="problematic" id="id214">*</span></a>Node) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if root == nil {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
queue := make([]*Node, 0)
depth := 0
queue = append(queue, root)
for len(queue) &gt; 0 {</p>
<blockquote>
<div><p>length := len(queue)
for i := 0; i &lt; length; i++ {</p>
<blockquote>
<div><p>temp := queue[0]
for _, node := range temp.Children {</p>
<blockquote>
<div><p>queue = append(queue, node)</p>
</div></blockquote>
<p>}
queue = queue[1:]</p>
</div></blockquote>
<p>}
depth++</p>
</div></blockquote>
<p>}
return depth</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func max(a, b int) int {</dt><dd><dl class="simple">
<dt>if a &gt; b {</dt><dd><p>return a</p>
</dd>
</dl>
<p>}
return b</p>
</dd>
</dl>
</div>
<div class="section" id="id215">
<h1>}<a class="headerlink" href="#id215" title="永久链接至标题">¶</a></h1>
<p>## 561.数组拆分 I(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id216"><span class="problematic" id="id217">``</span></a>`
给定长度为 2n 的数组, 你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，
使得从1 到 n 的 min(ai, bi) 总和最大。</p>
<p>示例 1:输入: [1,4,3,2]输出: 4
解释: n 等于 2, 最大总和为 4 = min(1, 2) + min(3, 4).
提示:</p>
<blockquote>
<div><p>n 是正整数,范围在 [1, 10000].
数组中的元素范围在 [-10000, 10000].</p>
</div></blockquote>
<p><a href="#id218"><span class="problematic" id="id219">``</span></a><a href="#id220"><span class="problematic" id="id221">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路     | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ——– | ———- | ———- |</div>
<div class="line">01   | 排序遍历 | O(nlog(n)) | P          |</div>
<div class="line">02   | 数组辅助 | O(n)       | O(1)       |</div>
</div>
<p><a href="#id222"><span class="problematic" id="id223">``</span></a><a href="#id224"><span class="problematic" id="id225">`</span></a>go
func arrayPairSum(nums []int) int {</p>
<blockquote>
<div><p>sort.Ints(nums)
sum := 0
for k, v := range nums {</p>
<blockquote>
<div><dl class="simple">
<dt>if k%2 == 0 {</dt><dd><p>sum = sum + v</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return sum</p>
</div></blockquote>
<p>}</p>
<p>#
func arrayPairSum(nums []int) int {</p>
<blockquote>
<div><p>var arr [20010]int
for _, num := range nums {</p>
<blockquote>
<div><p>arr[num+10000]++</p>
</div></blockquote>
<p>}
sum := 0
needAdd := true
for num, count := range arr {</p>
<blockquote>
<div><dl>
<dt>for count &gt; 0 {</dt><dd><dl class="simple">
<dt>if needAdd {</dt><dd><p>sum = sum + num - 10000</p>
</dd>
</dl>
<p>}
needAdd = !needAdd
count–</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return sum</p>
</div></blockquote>
</div>
<div class="section" id="id226">
<h1>}<a class="headerlink" href="#id226" title="永久链接至标题">¶</a></h1>
<p>## 563.二叉树的坡度(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id227"><span class="problematic" id="id228">``</span></a>`
给定一个二叉树，计算整个树的坡度。
一个树的节点的坡度定义即为，该节点左子树的结点之和和右子树结点之和的差的绝对值。空结点的的坡度是0。
整个树的坡度就是其所有节点的坡度之和。</p>
<p>示例:</p>
<dl>
<dt>输入:</dt><dd><blockquote>
<div><blockquote>
<div><p>1</p>
</div></blockquote>
<p>/   </p>
</div></blockquote>
<p>2     3</p>
</dd>
</dl>
<p>输出: 1
解释:
结点的坡度 2 : 0
结点的坡度 3 : 0
结点的坡度 1 : <a href="#id363"><span class="problematic" id="id364">|2-3|</span></a> = 1
树的坡度 : 0 + 0 + 1 = 1
注意:</p>
<blockquote>
<div><p>任何子树的结点的和不会超过32位整数的范围。
坡度的值不会超过32位整数的范围。</p>
</div></blockquote>
<p><a href="#id229"><span class="problematic" id="id230">``</span></a><a href="#id231"><span class="problematic" id="id232">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路 | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —- | ———- | ———- |</div>
<div class="line">01   | 递归 | O(n)       | O(log(n))  |</div>
<div class="line">02   | 迭代 | O(n)       | O(n)       |</div>
</div>
<p><a href="#id233"><span class="problematic" id="id234">``</span></a><a href="#id235"><span class="problematic" id="id236">`</span></a>go
var total int</p>
<dl class="simple">
<dt>func findTilt(root <a href="#id237"><span class="problematic" id="id238">*</span></a>TreeNode) int {</dt><dd><p>total = 0
dfs(root)
return total</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func dfs(root <a href="#id239"><span class="problematic" id="id240">*</span></a>TreeNode) int {</dt><dd><dl class="simple">
<dt>if root == nil {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
left := dfs(root.Left)
right := dfs(root.Right)
total = total + abs(left, right)
return left + right + root.Val // 返回节点之和</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func abs(a, b int) int {</dt><dd><dl class="simple">
<dt>if a &gt; b {</dt><dd><p>return a - b</p>
</dd>
</dl>
<p>}
return b - a</p>
</dd>
</dl>
<p>}</p>
<p>#
func findTilt(root <a href="#id241"><span class="problematic" id="id242">*</span></a>TreeNode) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if root == nil {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
stack := make([]*TreeNode, 0)
stack = append(stack, root)
list := make([]*TreeNode, 0)
total := 0
for len(stack) &gt; 0 {</p>
<blockquote>
<div><p>node := stack[len(stack)-1]
stack = stack[0 : len(stack)-1]
list = append([]*TreeNode{node}, list…)
if node.Left != nil {</p>
<blockquote>
<div><p>stack = append(stack, node.Left)</p>
</div></blockquote>
<p>}
if node.Right != nil {</p>
<blockquote>
<div><p>stack = append(stack, node.Right)</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
for i := range list {</p>
<blockquote>
<div><p>node := list[i]
left := 0
right := 0
if node.Left != nil {</p>
<blockquote>
<div><p>left = node.Left.Val</p>
</div></blockquote>
<p>}
if node.Right != nil {</p>
<blockquote>
<div><p>right = node.Right.Val</p>
</div></blockquote>
<p>}
total = total + abs(left, right)
node.Val = left + right + node.Val</p>
</div></blockquote>
<p>}
return total</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func abs(a, b int) int {</dt><dd><dl class="simple">
<dt>if a &gt; b {</dt><dd><p>return a - b</p>
</dd>
</dl>
<p>}
return b - a</p>
</dd>
</dl>
</div>
<div class="section" id="id243">
<h1>}<a class="headerlink" href="#id243" title="永久链接至标题">¶</a></h1>
<p>## 566.重塑矩阵(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id244"><span class="problematic" id="id245">``</span></a>`
在MATLAB中，有一个非常有用的函数 reshape，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。
给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。
重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。
如果具有给定参数的reshape操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。</p>
<p>示例 1:输入:
nums =
[[1,2],</p>
<blockquote>
<div><p>[3,4]]</p>
</div></blockquote>
<p>r = 1, c = 4
输出:
[[1,2,3,4]]
解释:行遍历nums的结果是 [1,2,3,4]。新的矩阵是 1 * 4 矩阵, 用之前的元素值一行一行填充新矩阵。</p>
<p>示例 2:输入:
nums =
[[1,2],</p>
<blockquote>
<div><p>[3,4]]</p>
</div></blockquote>
<p>r = 2, c = 4
输出:
[[1,2],</p>
<blockquote>
<div><p>[3,4]]</p>
</div></blockquote>
<p>解释:没有办法将 2 * 2 矩阵转化为 2 * 4 矩阵。 所以输出原矩阵。
注意：</p>
<blockquote>
<div><p>给定矩阵的宽和高范围在 [1, 100]。
给定的 r 和 c 都是正数。</p>
</div></blockquote>
<p><a href="#id246"><span class="problematic" id="id247">``</span></a><a href="#id248"><span class="problematic" id="id249">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路 | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —- | ———- | ———- |</div>
<div class="line">01   | 遍历 | O(n^2)     | O(n^2)     |</div>
<div class="line">02   | 遍历 | O(n^2)     | O(n^2)     |</div>
</div>
<p><a href="#id250"><span class="problematic" id="id251">``</span></a><a href="#id252"><span class="problematic" id="id253">`</span></a>go
func matrixReshape(nums [][]int, r int, c int) [][]int {</p>
<blockquote>
<div><p>row, col := len(nums), len(nums[0])
if (row*col != r*c) || (row == r &amp;&amp; col == c) {</p>
<blockquote>
<div><p>return nums</p>
</div></blockquote>
<p>}
res := make([][]int, r)
for i := 0; i &lt; len(res); i++ {</p>
<blockquote>
<div><p>res[i] = make([]int, c)</p>
</div></blockquote>
<p>}
for i := 0; i &lt; r*c; i++ {</p>
<blockquote>
<div><p>res[i/c][i%c] = nums[i/col][i%col]</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
func matrixReshape(nums [][]int, r int, c int) [][]int {</p>
<blockquote>
<div><p>row, col := len(nums), len(nums[0])
if (row*col != r*c) || (row == r &amp;&amp; col == c) {</p>
<blockquote>
<div><p>return nums</p>
</div></blockquote>
<p>}
res := make([][]int, 0)
arr := make([]int, 0)
count := 0
for _, num := range nums {</p>
<blockquote>
<div><dl>
<dt>for _, value := range num {</dt><dd><p>arr = append(arr, value)
count++
if count == c {</p>
<blockquote>
<div><p>res = append(res, arr)
arr = []int{}
count = 0</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
</div>
<div class="section" id="id254">
<h1>}<a class="headerlink" href="#id254" title="永久链接至标题">¶</a></h1>
<p>## 572.另一个树的子树(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id255"><span class="problematic" id="id256">``</span></a>`
给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。
s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。
示例 1:
给定的树 s:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><p>3</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<p>4   5</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<p>1   2</p>
</div></blockquote>
<dl>
<dt>给定的树 t：</dt><dd><blockquote>
<div><blockquote>
<div><p>4</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<p>1   2</p>
</dd>
</dl>
<p>返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。</p>
<p>示例 2:
给定的树 s：</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><p>3</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<p>4   5</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<dl>
<dt>1   2</dt><dd><blockquote>
<div><p>/</p>
</div></blockquote>
<p>0</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>给定的树 t：</dt><dd><blockquote>
<div><blockquote>
<div><p>4</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<p>1   2</p>
</dd>
</dl>
<p>返回 false。
<a href="#id257"><span class="problematic" id="id258">``</span></a><a href="#id259"><span class="problematic" id="id260">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路            | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ————— | ———- | ———- |</div>
<div class="line">01   | 递归            | O(n^2)     | O(log(n))  |</div>
<div class="line">02   | 递归+字符串辅助 | O(n)       | O(log(n))  |</div>
<div class="line">03   | 栈辅助          | O(n)       | O(n)       |</div>
</div>
<p><a href="#id261"><span class="problematic" id="id262">``</span></a><a href="#id263"><span class="problematic" id="id264">`</span></a>go
func isSubtree(s <a href="#id265"><span class="problematic" id="id266">*</span></a>TreeNode, t <a href="#id267"><span class="problematic" id="id268">*</span></a>TreeNode) bool {</p>
<blockquote>
<div><dl class="simple">
<dt>if s == nil {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}
return isSame(s, t) || isSubtree(s.Left, t) || isSubtree(s.Right, t)</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func isSame(s <a href="#id269"><span class="problematic" id="id270">*</span></a>TreeNode, t <a href="#id271"><span class="problematic" id="id272">*</span></a>TreeNode) bool {</dt><dd><dl class="simple">
<dt>if s == nil || t == nil{</dt><dd><p>return t == s</p>
</dd>
</dl>
<p>}
return isSame(s.Left, t.Left) &amp;&amp; isSame(s.Right, t.Right) &amp;&amp; s.Val == t.Val</p>
</dd>
</dl>
<p>}</p>
<p>#
func isSubtree(s <a href="#id273"><span class="problematic" id="id274">*</span></a>TreeNode, t <a href="#id275"><span class="problematic" id="id276">*</span></a>TreeNode) bool {</p>
<blockquote>
<div><p>sStr := dfs(s, “”)
tStr := dfs(t, “”)
return strings.Contains(sStr, tStr)</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func dfs(s <a href="#id277"><span class="problematic" id="id278">*</span></a>TreeNode, pre string) string {</dt><dd><dl class="simple">
<dt>if s == nil {</dt><dd><p>return pre</p>
</dd>
</dl>
<p>}
return fmt.Sprintf(“#%d%s%s”, s.Val, dfs(s.Left, “l”), dfs(s.Right, “r”))</p>
</dd>
</dl>
<p>}</p>
<p>#
func isSubtree(s <a href="#id279"><span class="problematic" id="id280">*</span></a>TreeNode, t <a href="#id281"><span class="problematic" id="id282">*</span></a>TreeNode) bool {</p>
<blockquote>
<div><p>sStr := preOrder(s)
tStr := preOrder(t)
return strings.Contains(sStr, tStr)</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func preOrder(root <a href="#id283"><span class="problematic" id="id284">*</span></a>TreeNode) string {</dt><dd><dl class="simple">
<dt>if root == nil {</dt><dd><p>return “”</p>
</dd>
</dl>
<p>}
res := “!”
stack := make([]*TreeNode,0)
temp := root
for {</p>
<blockquote>
<div><dl class="simple">
<dt>for temp != nil{</dt><dd><p>res += strconv.Itoa(temp.Val)
res += “!”
stack = append(stack, temp)
temp = temp.Left</p>
</dd>
</dl>
<p>}
res += “#!”
if len(stack) &gt; 0{</p>
<blockquote>
<div><p>node := stack[len(stack)-1]
stack = stack[:len(stack)-1]
temp = node.Right</p>
</div></blockquote>
<dl class="simple">
<dt>}else {</dt><dd><p>break</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</dd>
</dl>
</div>
<div class="section" id="id285">
<h1>}<a class="headerlink" href="#id285" title="永久链接至标题">¶</a></h1>
<p>## 575.分糖果(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id286"><span class="problematic" id="id287">``</span></a>`
给定一个偶数长度的数组，其中不同的数字代表着不同种类的糖果，每一个数字代表一个糖果。
你需要把这些糖果平均分给一个弟弟和一个妹妹。返回妹妹可以获得的最大糖果的种类数。</p>
<p>示例 1:输入: candies = [1,1,2,2,3,3] 输出: 3
解析: 一共有三种种类的糖果，每一种都有两个。</p>
<blockquote>
<div><p>最优分配方案：妹妹获得[1,2,3],弟弟也获得[1,2,3]。这样使妹妹获得糖果的种类数最多。</p>
</div></blockquote>
<p>示例 2 : 输入: candies = [1,1,2,3] 输出: 2
解析: 妹妹获得糖果[2,3],弟弟获得糖果[1,1]，妹妹有两种不同的糖果，弟弟只有一种。
这样使得妹妹可以获得的糖果种类数最多。</p>
<dl class="simple">
<dt>注意:</dt><dd><p>数组的长度为[2, 10,000]，并且确定为偶数。
数组中数字的大小在范围[-100,000, 100,000]内。</p>
</dd>
</dl>
<p><a href="#id288"><span class="problematic" id="id289">``</span></a><a href="#id290"><span class="problematic" id="id291">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路     | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ——– | ———- | ———- |</div>
<div class="line">01   | 哈希辅助 | O(n)       | O(n)       |</div>
<div class="line">02   | 排序遍历 | O(nlog(n)) | O(1)       |</div>
</div>
<p><a href="#id292"><span class="problematic" id="id293">``</span></a><a href="#id294"><span class="problematic" id="id295">`</span></a>go
func distributeCandies(candies []int) int {</p>
<blockquote>
<div><p>n := len(candies)
r := make(map[int]bool, n)
for _, c := range candies {</p>
<blockquote>
<div><p>r[c] = true</p>
</div></blockquote>
<p>}
return min(len(r), n/2)</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func min(a, b int) int {</dt><dd><dl class="simple">
<dt>if a &lt; b {</dt><dd><p>return a</p>
</dd>
</dl>
<p>}
return b</p>
</dd>
</dl>
<p>}</p>
<p>#
func distributeCandies(candies []int) int {</p>
<blockquote>
<div><p>length := len(candies)
half := length / 2
count := 1
sort.Ints(candies)
for i := 1; i &lt; length; i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if candies[i] != candies[i-1] {</dt><dd><p>count++</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
if count &gt;= half {</p>
<blockquote>
<div><p>return half</p>
</div></blockquote>
<p>}
return count</p>
</div></blockquote>
</div>
<div class="section" id="id296">
<h1>}<a class="headerlink" href="#id296" title="永久链接至标题">¶</a></h1>
<p>## 581.最短无序连续子数组(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id297"><span class="problematic" id="id298">``</span></a>`
给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。
你找到的子数组应是最短的，请输出它的长度。
示例 1:输入: [2, 6, 4, 8, 10, 9, 15] 输出: 5
解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。
说明 :</p>
<blockquote>
<div><p>输入的数组长度范围在 [1, 10,000]。
输入的数组可能包含重复元素 ，所以升序的意思是&lt;=。</p>
</div></blockquote>
<p><a href="#id299"><span class="problematic" id="id300">``</span></a><a href="#id301"><span class="problematic" id="id302">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路     | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ——– | ———- | ———- |</div>
<div class="line">01   | 双指针   | O(n)       | O(1)       |</div>
<div class="line">02   | 2次遍历  | O(n)       | O(1)       |</div>
<div class="line">03   | 排序遍历 | O(nlog(n)) | O(n)       |</div>
</div>
<p><a href="#id303"><span class="problematic" id="id304">``</span></a><a href="#id305"><span class="problematic" id="id306">`</span></a>go
func findUnsortedSubarray(nums []int) int {</p>
<blockquote>
<div><p>length := len(nums)
left, right := 0, -1
min, max := nums[length-1], nums[0]
for i := 1; i &lt; length; i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if max &lt;= nums[i] {</dt><dd><p>max = nums[i]</p>
</dd>
<dt>} else {</dt><dd><p>right = i</p>
</dd>
</dl>
<p>}
j := length - i - 1
if min &gt;= nums[j] {</p>
<blockquote>
<div><p>min = nums[j]</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>left = j</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return right - left + 1</p>
</div></blockquote>
<p>}</p>
<p>#
func findUnsortedSubarray(nums []int) int {</p>
<blockquote>
<div><p>length := len(nums)
right := -1
max := nums[0]
for i := 1; i &lt; length; i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if max &lt;= nums[i] {</dt><dd><p>max = nums[i]</p>
</dd>
<dt>} else {</dt><dd><p>right = i</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
if right == 0 {</p>
<blockquote>
<div><p>// 针对升序，特殊处理
// 如去掉判断
// 需要保证left,right初始值满足right-left+1=0
return 0</p>
</div></blockquote>
<p>}
left := 0
min := nums[length-1]
for i := length - 2; i &gt;= 0; i– {</p>
<blockquote>
<div><dl class="simple">
<dt>if min &gt;= nums[i] {</dt><dd><p>min = nums[i]</p>
</dd>
<dt>} else {</dt><dd><p>left = i</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return right - left + 1</p>
</div></blockquote>
<p>}</p>
<p>#
func findUnsortedSubarray(nums []int) int {</p>
<blockquote>
<div><p>temp := make([]int,len(nums))
copy(temp,nums)
sort.Ints(temp)
i, j := 0, len(nums)-1
for i &lt; len(nums) &amp;&amp; nums[i] == temp[i]{</p>
<blockquote>
<div><p>i++</p>
</div></blockquote>
<p>}
for i+1 &lt; j &amp;&amp; nums[j] == temp[j]{</p>
<blockquote>
<div><p>j–</p>
</div></blockquote>
<p>}
return j-i+1</p>
</div></blockquote>
</div>
<div class="section" id="id307">
<h1>}<a class="headerlink" href="#id307" title="永久链接至标题">¶</a></h1>
<p>## 589.N叉树的前序遍历(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">给定一个</span> <span class="pre">N</span> <span class="pre">叉树，返回其节点值的前序遍历。</span>
<span class="pre">例如，给定一个</span> <span class="pre">3叉树</span> <span class="pre">:</span>
<span class="pre">返回其前序遍历:</span> <span class="pre">[1,3,5,6,2,4]。</span>
<span class="pre">说明:</span> <span class="pre">递归法很简单，你可以使用迭代法完成此题吗?</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路 | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —- | ———- | ———- |</div>
<div class="line">01   | 递归 | O(n)       | O(log(n))  |</div>
<div class="line">02   | 迭代 | O(n)       | O(n)       |</div>
</div>
<p><a href="#id308"><span class="problematic" id="id309">``</span></a><a href="#id310"><span class="problematic" id="id311">`</span></a>go
var res []int</p>
<dl class="simple">
<dt>func preorder(root <a href="#id312"><span class="problematic" id="id313">*</span></a>Node) []int {</dt><dd><p>res = make([]int, 0)
dfs(root)
return res</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func dfs(root <a href="#id314"><span class="problematic" id="id315">*</span></a>Node) {</dt><dd><dl class="simple">
<dt>if root == nil {</dt><dd><p>return</p>
</dd>
</dl>
<p>}
res = append(res, root.Val)
for _, value := range root.Children {</p>
<blockquote>
<div><p>dfs(value)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>#
func preorder(root <a href="#id316"><span class="problematic" id="id317">*</span></a>Node) []int {</p>
<blockquote>
<div><p>res := make([]int, 0)
if root == nil {</p>
<blockquote>
<div><p>return res</p>
</div></blockquote>
<p>}
stack := make([]*Node, 0)
stack = append(stack, root)
for len(stack) &gt; 0 {</p>
<blockquote>
<div><p>temp := stack[len(stack)-1]
stack = stack[:len(stack)-1]
res = append(res, temp.Val)
for i := len(temp.Children) - 1; i &gt;= 0; i– {</p>
<blockquote>
<div><p>stack = append(stack, temp.Children[i])</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
</div>
<div class="section" id="id318">
<h1>}<a class="headerlink" href="#id318" title="永久链接至标题">¶</a></h1>
<p>## 590.N叉树的后序遍历(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id319"><span class="problematic" id="id320">``</span></a>`
给定一个 N 叉树，返回其节点值的后序遍历。</p>
<p>例如，给定一个 3叉树 :</p>
<p>返回其后序遍历: [5,6,3,2,4,1].
说明: 递归法很简单，你可以使用迭代法完成此题吗?
<a href="#id321"><span class="problematic" id="id322">``</span></a><a href="#id323"><span class="problematic" id="id324">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路 | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —- | ———- | ———- |</div>
<div class="line">01   | 递归 | O(n)       | O(log(n))  |</div>
<div class="line">02   | 迭代 | O(n)       | O(n)       |</div>
</div>
<p><a href="#id325"><span class="problematic" id="id326">``</span></a><a href="#id327"><span class="problematic" id="id328">`</span></a>go
var res []int
func postorder(root <a href="#id329"><span class="problematic" id="id330">*</span></a>Node) []int {</p>
<blockquote>
<div><p>res = make([]int, 0)
dfs(root)
return res</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func dfs(root <a href="#id331"><span class="problematic" id="id332">*</span></a>Node) {</dt><dd><dl class="simple">
<dt>if root == nil {</dt><dd><p>return</p>
</dd>
</dl>
<p>}
for _, value := range root.Children {</p>
<blockquote>
<div><p>dfs(value)</p>
</div></blockquote>
<p>}
res = append(res, root.Val)</p>
</dd>
</dl>
<p>}</p>
<p>#
// 后序：(左右)根
// 前序：根(左右)=&gt;根(右左)=&gt;左右根
func postorder(root <a href="#id333"><span class="problematic" id="id334">*</span></a>Node) []int {</p>
<blockquote>
<div><p>res := make([]int, 0)
if root == nil {</p>
<blockquote>
<div><p>return res</p>
</div></blockquote>
<p>}
stack := make([]*Node, 0)
stack = append(stack, root)
for len(stack) &gt; 0 {</p>
<blockquote>
<div><p>temp := stack[len(stack)-1]
stack = stack[:len(stack)-1]
res = append(res, temp.Val)
for i := 0; i &lt; len(temp.Children); i++ {</p>
<blockquote>
<div><p>stack = append(stack, temp.Children[i])</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
for i := 0; i &lt; len(res)/2; i++ {</p>
<blockquote>
<div><p>res[i], res[len(res)-1-i] = res[len(res)-1-i], res[i]</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
</div>
<div class="section" id="id335">
<h1>}<a class="headerlink" href="#id335" title="永久链接至标题">¶</a></h1>
<p>## 594.最长和谐子序列(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">和谐数组是指一个数组里元素的最大值和最小值之间的差别正好是1。</span>
<span class="pre">现在，给定一个整数数组，你需要在所有可能的子序列中找到最长的和谐子序列的长度。</span>
<span class="pre">示例</span> <span class="pre">1:输入:</span> <span class="pre">[1,3,2,2,5,2,3,7]输出:</span> <span class="pre">5</span>
<span class="pre">原因:</span> <span class="pre">最长的和谐数组是：[3,2,2,2,3].</span>
<span class="pre">说明:</span> <span class="pre">输入的数组长度最大不超过20,000.</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路     | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ——– | ———- | ———- |</div>
<div class="line">01   | 哈希辅助 | O(n)       | O(n)       |</div>
<div class="line">02   | 排序遍历 | O(nlog(n)) | O(1)       |</div>
</div>
<p><a href="#id336"><span class="problematic" id="id337">``</span></a><a href="#id338"><span class="problematic" id="id339">`</span></a>go
func findLHS(nums []int) int {</p>
<blockquote>
<div><p>m := make(map[int]int, len(nums))
for _, n := range nums {</p>
<blockquote>
<div><p>m[n]++</p>
</div></blockquote>
<p>}
res := 0
for key, value := range m {</p>
<blockquote>
<div><p>value2, ok := m[key+1]
if ok {</p>
<blockquote>
<div><p>t := value + value2
if res &lt; t {</p>
<blockquote>
<div><p>res = t</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
func findLHS(nums []int) int {</p>
<blockquote>
<div><p>sort.Ints(nums)
res := 0
left := 0
for i := 0; i &lt; len(nums); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>for nums[i]-nums[left] &gt; 1 {</dt><dd><p>left++</p>
</dd>
</dl>
<p>}
if nums[i]-nums[left] == 1 {</p>
<blockquote>
<div><dl class="simple">
<dt>if res &lt; i-left+1 {</dt><dd><p>res = i - left + 1</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
</div>
<div class="section" id="id340">
<h1>}<a class="headerlink" href="#id340" title="永久链接至标题">¶</a></h1>
<p>## 598.范围求和 II(1)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id341"><span class="problematic" id="id342">``</span></a>`
给定一个初始元素全部为 0，大小为 m*n 的矩阵 M 以及在 M 上的一系列更新操作。
操作用二维数组表示，其中的每个操作用一个含有两个正整数 a 和 b 的数组表示，
含义是将所有符合 0 &lt;= i &lt; a 以及 0 &lt;= j &lt; b 的元素 M[i][j] 的值都增加 1。
在执行给定的一系列操作后，你需要返回矩阵中含有最大整数的元素个数。</p>
<p>示例 1:输入: m = 3, n = 3operations = [[2,2],[3,3]] 输出: 4
解释: 初始状态, M =
[[0, 0, 0],</p>
<blockquote>
<div><p>[0, 0, 0],
[0, 0, 0]]</p>
</div></blockquote>
<p>执行完操作 [2,2] 后, M =
[[1, 1, 0],</p>
<blockquote>
<div><p>[1, 1, 0],
[0, 0, 0]]</p>
</div></blockquote>
<p>执行完操作 [3,3] 后, M =
[[2, 2, 1],</p>
<blockquote>
<div><p>[2, 2, 1],
[1, 1, 1]]</p>
</div></blockquote>
<p>M 中最大的整数是 2, 而且 M 中有4个值为2的元素。因此返回 4。
注意:</p>
<blockquote>
<div><p>m 和 n 的范围是 [1,40000]。
a 的范围是 [1,m]，b 的范围是 [1,n]。
操作数目不超过 10000。</p>
</div></blockquote>
<p><a href="#id343"><span class="problematic" id="id344">``</span></a><a href="#id345"><span class="problematic" id="id346">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路 | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —- | ———- | ———- |</div>
<div class="line">01   | 数学 | O(n)       | O(1)       |</div>
</div>
<p><a href="#id347"><span class="problematic" id="id348">``</span></a><a href="#id349"><span class="problematic" id="id350">`</span></a>go
func maxCount(m int, n int, ops [][]int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>for _, o := range ops {</dt><dd><p>m = min(m, o[0])
n = min(n, o[1])</p>
</dd>
</dl>
<p>}
return m * n</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func min(a, b int) int {</dt><dd><dl class="simple">
<dt>if a &lt; b {</dt><dd><p>return a</p>
</dd>
</dl>
<p>}
return b</p>
</dd>
</dl>
</div>
<div class="section" id="id351">
<h1>}<a class="headerlink" href="#id351" title="永久链接至标题">¶</a></h1>
<p>## 599.两个列表的最小索引总和(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id352"><span class="problematic" id="id353">``</span></a>`
假设Andy和Doris想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。
你需要帮助他们用最少的索引和找出他们共同喜爱的餐厅。 如果答案不止一个，则输出所有答案并且不考虑顺序。
你可以假设总是存在一个答案。</p>
<p>示例 1:输入:
[“Shogun”, “Tapioca Express”, “Burger King”, “KFC”]
[“Piatti”, “The Grill at Torrey Pines”, “Hungry Hunter Steakhouse”, “Shogun”]
输出: [“Shogun”]
解释: 他们唯一共同喜爱的餐厅是“Shogun”。</p>
<p>示例 2:
输入:
[“Shogun”, “Tapioca Express”, “Burger King”, “KFC”]
[“KFC”, “Shogun”, “Burger King”]
输出: [“Shogun”]
解释: 他们共同喜爱且具有最小索引和的餐厅是“Shogun”，它有最小的索引和1(0+1)。</p>
<dl class="simple">
<dt>提示:</dt><dd><p>两个列表的长度范围都在 [1, 1000]内。
两个列表中的字符串的长度将在[1，30]的范围内。
下标从0开始，到列表的长度减1。
两个列表都没有重复的元素。</p>
</dd>
</dl>
<p><a href="#id354"><span class="problematic" id="id355">``</span></a><a href="#id356"><span class="problematic" id="id357">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路     | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ——– | ———- | ———- |</div>
<div class="line">01   | 哈希辅助 | O(n)       | O(n)       |</div>
<div class="line">02   | 暴力法   | O(n^2)     | I          |</div>
</div>
<p><a href="#id358"><span class="problematic" id="id359">``</span></a><a href="#id360"><span class="problematic" id="id361">`</span></a>go
func findRestaurant(list1 []string, list2 []string) []string {</p>
<blockquote>
<div><dl class="simple">
<dt>if len(list1) &gt; len(list2) {</dt><dd><p>list1, list2 = list2, list1</p>
</dd>
</dl>
<p>}
m2 := make(map[string]int, len(list2))
for i := range list2 {</p>
<blockquote>
<div><p>m2[list2[i]] = i</p>
</div></blockquote>
<p>}
min := 2000
res := make([]string, 0, 1000)
for key, value := range list1 {</p>
<blockquote>
<div><dl>
<dt>if key2, ok := m2[value]; ok {</dt><dd><dl class="simple">
<dt>if min == key+key2 {</dt><dd><p>res = append(res, value)</p>
</dd>
</dl>
<p>}
if min &gt; key+key2 {</p>
<blockquote>
<div><p>min = key + key2
res = []string{value}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
func findRestaurant(list1 []string, list2 []string) []string {</p>
<blockquote>
<div><p>min := 2000
res := make([]string, 0, 1000)
for key1, value1 := range list1 {</p>
<blockquote>
<div><dl>
<dt>for key2, value2 := range list2{</dt><dd><dl>
<dt>if value1 == value2{</dt><dd><dl class="simple">
<dt>if min == key1+key2 {</dt><dd><p>res = append(res, value1)</p>
</dd>
</dl>
<p>}
if min &gt; key1+key2 {</p>
<blockquote>
<div><p>min = key1 + key2
res = []string{value1}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
</div>
<div class="section" id="id362">
<h1>}<a class="headerlink" href="#id362" title="永久链接至标题">¶</a></h1>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="0601-0700.html" class="btn btn-neutral float-right" title="}" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="0401-0500.html" class="btn btn-neutral float-left" title="}" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, willshang

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>