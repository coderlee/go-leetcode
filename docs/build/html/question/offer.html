

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh-CN" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh-CN" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>} &mdash; go-leetcode v1.0.0 文档</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="prev" title="&lt;no title&gt;" href="1001-1100.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> go-leetcode
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id20">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id31">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id42">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id53">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id86">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id117">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id120">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id125">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id128">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id133">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id144">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id155">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id166">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id177">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id188">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id199">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id210">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id221">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id232">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id255">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id266">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id285">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id24">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id25">]</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id48">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id65">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id84">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id99">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id116">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id119">]</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id124">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id135">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id146">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id157">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id168">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id179">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id196">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id223">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id254">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id265">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id276">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id287">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id298">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id309">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id320">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id331">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id342">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id351">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id18">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id23">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id34">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id61">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id72">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id83">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id148">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id167">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id178">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id227">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id244">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id263">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id276">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id287">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id306">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id311">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id322">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id333">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id344">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id355">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id366">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id377">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html#id388">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id20">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id25">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id36">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id47">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id58">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id69">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id74">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id79">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id90">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id101">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id106">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id111">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id124">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id26">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id37">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id42">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id45">]</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id50">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id55">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id66">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id71">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id100">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id105">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id116">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id127">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id138">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id143">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id154">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id159">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id170">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id181">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id192">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id203">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id214">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id225">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id236">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id247">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id258">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id24">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id35">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id40">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id59">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id70">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id81">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id106">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id117">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id146">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id157">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id178">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id189">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id200">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id215">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id226">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id243">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id254">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id285">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id296">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id307">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id318">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id335">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id340">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id351">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id362">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id28">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id51">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id62">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id67">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id84">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id95">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id106">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id133">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id144">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id155">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id166">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id185">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id204">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id209">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id220">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id231">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id242">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id267">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id280">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id287">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id298">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id309">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id328">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id46">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id85">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id96">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id111">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id122">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id133">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id146">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id157">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id170">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id181">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id192">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id203">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id214">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id225">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id252">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id263">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id274">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id285">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id22">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id33">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id44">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id55">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id66">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id77">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id82">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id93">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id104">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id115">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id126">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id137">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id148">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id159">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id170">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id181">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id186">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id221">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id232">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id255">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id266">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id277">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id288">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id299">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id310">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id321">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id356">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id22">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id33">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id44">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id55">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id66">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id77">}</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id16">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id21">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id38">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id59">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id92">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id115">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id126">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id137">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id148">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id159">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id170">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id175">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id180">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id191">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id202">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id221">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id232">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id291">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id322">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id349">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id374">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id401">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id420">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id437">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id442">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id469">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id480">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id511">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id542">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id575">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id586">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id605">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id650">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id655">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id660">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id689">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id752">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id763">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id768">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id775">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id786">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id791">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id802">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id813">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id818">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id823">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id828">#</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id857">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id862">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id867">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id888">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id903">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id922">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id935">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id946">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id951">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id956">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id967">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id972">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id1013">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id1038">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id1043">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id1048">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id1059">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id1064">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id1069">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id1080">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id1091">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id1102">}</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">go-leetcode</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>}</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/question/offer.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <p># 剑指offer</p>
<ul class="simple">
<li><dl class="simple">
<dt>[剑指offer](#剑指offer)</dt><dd><ul>
<li><p>[参考资料](#参考资料)</p></li>
<li><p>[面试题03.数组中重复的数字(6)](#面试题03数组中重复的数字6)</p></li>
<li><p>[面试题04.二维数组中的查找(6)](#面试题04二维数组中的查找6)</p></li>
<li><p>[面试题05.替换空格(2)](#面试题05替换空格2)</p></li>
<li><p>[面试题06.从尾到头打印链表(5)](#面试题06从尾到头打印链表5)</p></li>
<li><p>[面试题07.重建二叉树(3)](#面试题07重建二叉树3)</p></li>
<li><p>[面试题09.用两个栈实现队列(1)](#面试题09用两个栈实现队列1)</p></li>
<li><p>[面试题10- I.斐波那契数列(5)](#面试题10–i斐波那契数列5)</p></li>
<li><p>[面试题10-II.青蛙跳台阶问题(3)](#面试题10-ii青蛙跳台阶问题3)</p></li>
<li><p>[面试题11.旋转数组的最小数字(4)](#面试题11旋转数组的最小数字4)</p></li>
<li><p>[面试题12.矩阵中的路径(2)](#面试题12矩阵中的路径2)</p></li>
<li><p>[面试题13.机器人的运动范围(3)](#面试题13机器人的运动范围3)</p></li>
<li><p>[面试题14- I.剪绳子(2)](#面试题14–i剪绳子2)</p></li>
<li><p>[面试题14-II.剪绳子 II(2)](#面试题14-ii剪绳子-ii2)</p></li>
<li><p>[面试题15.二进制中1的个数(4)](#面试题15二进制中1的个数4)</p></li>
<li><p>[面试题16.数值的整数次方(2)](#面试题16数值的整数次方2)</p></li>
<li><p>[面试题17.打印从1到最大的n位数(4)](#面试题17打印从1到最大的n位数4)</p></li>
<li><p>[面试题18.删除链表的节点(2)](#面试题18删除链表的节点2)</p></li>
<li><p>[面试题19.正则表达式匹配(2)](#面试题19正则表达式匹配2)</p></li>
<li><p>[面试题20.表示数值的字符串(1)](#面试题20表示数值的字符串1)</p></li>
<li><p>[面试题21.调整数组顺序使奇数位于偶数前面(4)](#面试题21调整数组顺序使奇数位于偶数前面4)</p></li>
<li><p>[面试题22.链表中倒数第k个节点(5)](#面试题22链表中倒数第k个节点5)</p></li>
<li><p>[面试题24.反转链表(4)](#面试题24反转链表4)</p></li>
<li><p>[面试题25.合并两个排序的链表(3)](#面试题25合并两个排序的链表3)</p></li>
<li><p>[面试题26.树的子结构(2)](#面试题26树的子结构2)</p></li>
<li><p>[面试题27.二叉树的镜像(2)](#面试题27二叉树的镜像2)</p></li>
<li><p>[面试题28.对称的二叉树(2)](#面试题28对称的二叉树2)</p></li>
<li><p>[面试题29.顺时针打印矩阵(2)](#面试题29顺时针打印矩阵2)</p></li>
<li><p>[面试题30.包含min函数的栈(2)](#面试题30包含min函数的栈2)</p></li>
<li><p>[面试题31.栈的压入弹出序列(2)](#面试题31栈的压入弹出序列2)</p></li>
<li><p>[面试题32-I.从上到下打印二叉树(2)](#面试题32-i从上到下打印二叉树2)</p></li>
<li><p>[面试题32-II.从上到下打印二叉树II(2)](#面试题32-ii从上到下打印二叉树ii2)</p></li>
<li><p>[面试题32-III.从上到下打印二叉树III(2)](#面试题32-iii从上到下打印二叉树iii2)</p></li>
<li><p>[面试题33.二叉搜索树的后序遍历序列(3)](#面试题33二叉搜索树的后序遍历序列3)</p></li>
<li><p>[面试题34.二叉树中和为某一值的路径(2)](#面试题34二叉树中和为某一值的路径2)</p></li>
<li><p>[面试题35.复杂链表的复制(3)](#面试题35复杂链表的复制3)</p></li>
<li><p>[面试题38.字符串的排列(2)](#面试题38字符串的排列2)</p></li>
<li><p>[面试题39.数组中出现次数超过一半的数字(5)](#面试题39数组中出现次数超过一半的数字5)</p></li>
<li><p>[面试题40.最小的k个数(4)](#面试题40最小的k个数4)</p></li>
<li><p>[面试题41.数据流中的中位数(1)](#面试题41数据流中的中位数1)</p></li>
<li><p>[面试题42.连续子数组的最大和(4)](#面试题42连续子数组的最大和4)</p></li>
<li><p>[面试题43.1～n整数中1出现的次数(3)](#面试题431n整数中1出现的次数3)</p></li>
<li><p>[面试题44.数字序列中某一位的数字(2)](#面试题44数字序列中某一位的数字2)</p></li>
<li><p>[面试题45.把数组排成最小的数(3)](#面试题45把数组排成最小的数3)</p></li>
<li><p>[面试题46.把数字翻译成字符串(4)](#面试题46把数字翻译成字符串4)</p></li>
<li><p>[面试题47.礼物的最大价值(2)](#面试题47礼物的最大价值2)</p></li>
<li><p>[面试题48.最长不含重复字符的子字符串(4)](#面试题48最长不含重复字符的子字符串4)</p></li>
<li><p>[面试题49.丑数(1)](#面试题49丑数1)</p></li>
<li><p>[面试题50.第一个只出现一次的字符(3)](#面试题50第一个只出现一次的字符3)</p></li>
<li><p>[面试题51.数组中的逆序对(1)](#面试题51数组中的逆序对1)</p></li>
<li><p>[面试题52.两个链表的第一个公共节点(4)](#面试题52两个链表的第一个公共节点4)</p></li>
<li><p>[面试题53-I.在排序数组中查找数字I(5)](#面试题53-i在排序数组中查找数字i5)</p></li>
<li><p>[面试题53-II.0～n-1中缺失的数字(6)](#面试题53-ii0n-1中缺失的数字6)</p></li>
<li><p>[面试题54.二叉搜索树的第k大节点(3)](#面试题54二叉搜索树的第k大节点3)</p></li>
<li><p>[面试题55-I.二叉树的深度(2)](#面试题55-i二叉树的深度2)</p></li>
<li><p>[面试题55-II.平衡二叉树(2)](#面试题55-ii平衡二叉树2)</p></li>
<li><p>[面试题56-I.数组中数字出现的次数(5)](#面试题56-i数组中数字出现的次数5)</p></li>
<li><p>[面试题56-II.数组中数字出现的次数II(5)](#面试题56-ii数组中数字出现的次数ii5)</p></li>
<li><p>[面试题57.和为s的两个数字(2)](#面试题57和为s的两个数字2)</p></li>
<li><p>[面试题57-II.和为s的连续正数序列(4)](#面试题57-ii和为s的连续正数序列4)</p></li>
<li><p>[面试题58-I.翻转单词顺序(3)](#面试题58-i翻转单词顺序3)</p></li>
<li><p>[面试题58-II.左旋转字符串(2)](#面试题58-ii左旋转字符串2)</p></li>
<li><p>[面试题59-I.滑动窗口的最大值(4)](#面试题59-i滑动窗口的最大值4)</p></li>
<li><p>[面试题59-II.队列的最大值(2)](#面试题59-ii队列的最大值2)</p></li>
<li><p>[面试题60.n个骰子的点数(2)](#面试题60n个骰子的点数2)</p></li>
<li><p>[面试题61.扑克牌中的顺子(3)](#面试题61扑克牌中的顺子3)</p></li>
<li><p>[面试题62.圆圈中最后剩下的数字(2)](#面试题62圆圈中最后剩下的数字2)</p></li>
<li><p>[面试题63.股票的最大利润(3)](#面试题63股票的最大利润3)</p></li>
<li><p>[面试题64.求1 2 … n(2)](#面试题64求12n2)</p></li>
<li><p>[面试题65.不用加减乘除做加法(2)](#面试题65不用加减乘除做加法2)</p></li>
<li><p>[面试题66.构建乘积数组(2)](#面试题66构建乘积数组2)</p></li>
<li><p>[面试题67.把字符串转换成整数(2)](#面试题67把字符串转换成整数2)</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>## 参考资料</p>
<ul class="simple">
<li><p>leetcode专栏链接 <a class="reference external" href="https://leetcode-cn.com/problemset/lcof/">https://leetcode-cn.com/problemset/lcof/</a></p></li>
<li><p><a class="reference external" href="http://zhedahht.blog.163.com/">http://zhedahht.blog.163.com/</a></p></li>
<li><p>《剑指Offer》第二版源代码 C++ <a class="reference external" href="https://github.com/zhedahht/CodingInterviewChinese2">https://github.com/zhedahht/CodingInterviewChinese2</a></p></li>
</ul>
<p>## 面试题03.数组中重复的数字(6)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">找出数组中重复的数字。</span>
<span class="pre">在一个长度为</span> <span class="pre">n</span> <span class="pre">的数组</span> <span class="pre">nums</span> <span class="pre">里的所有数字都在</span> <span class="pre">0～n-1</span> <span class="pre">的范围内。</span>
<span class="pre">数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。</span>
<span class="pre">请找出数组中任意一个重复的数字。</span>
<span class="pre">示例</span> <span class="pre">1：输入：[2,</span> <span class="pre">3,</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">2,</span> <span class="pre">5,</span> <span class="pre">3]</span> <span class="pre">输出：2</span> <span class="pre">或</span> <span class="pre">3</span>
<span class="pre">限制：</span>
<span class="pre">2</span> <span class="pre">&lt;=</span> <span class="pre">n</span> <span class="pre">&lt;=</span> <span class="pre">100000</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路     | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ——– | ———- | ———- |</div>
<div class="line">01   | 哈希辅助 | O(n)       | O(n)       |</div>
<div class="line">02   | 排序遍历 | O(nlog(n)) | O(1)         |</div>
<div class="line">03 | 暴力法 | O(n^2) | O(1) |</div>
<div class="line">04 | 遍历-置换 | O(n) | O(1) |</div>
<div class="line">05 | 遍历-置反 | O(n) | O(1) |</div>
<div class="line">06 | 遍历-置换(书上方法) | O(n) | O(1) |</div>
</div>
<p><a href="#id1"><span class="problematic" id="id2">``</span></a><a href="#id3"><span class="problematic" id="id4">`</span></a>go
func findRepeatNumber(nums []int) int {</p>
<blockquote>
<div><p>m := make(map[int]int)
for i := 0; i &lt; len(nums); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if _, ok := m[nums[i]]; ok {</dt><dd><p>return nums[i]</p>
</dd>
</dl>
<p>}
m[nums[i]]++</p>
</div></blockquote>
<p>}
return -1</p>
</div></blockquote>
<p>}</p>
<p>#
func findRepeatNumber(nums []int) int {</p>
<blockquote>
<div><p>sort.Ints(nums)
prev := nums[0]
for i := 1; i &lt; len(nums); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if nums[i] == prev {</dt><dd><p>return nums[i]</p>
</dd>
</dl>
<p>}
prev = nums[i]</p>
</div></blockquote>
<p>}
return -1</p>
</div></blockquote>
<p>}</p>
<p>#
func findRepeatNumber(nums []int) int {</p>
<blockquote>
<div><dl>
<dt>for i := 0; i &lt; len(nums); i++ {</dt><dd><dl>
<dt>for j := i + 1; j &lt; len(nums); j++ {</dt><dd><dl class="simple">
<dt>if nums[i] == nums[j] {</dt><dd><p>return nums[i]</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
return -1</p>
</div></blockquote>
<p>}</p>
<p>#
func findRepeatNumber(nums []int) int {</p>
<blockquote>
<div><dl>
<dt>for key, value := range nums {</dt><dd><dl class="simple">
<dt>if key == value {</dt><dd><p>continue</p>
</dd>
</dl>
<p>}
if value == nums[value] {</p>
<blockquote>
<div><p>return nums[value]</p>
</div></blockquote>
<p>}
nums[key], nums[value] = nums[value], nums[key]</p>
</dd>
</dl>
<p>}
return -1</p>
</div></blockquote>
<p>}</p>
<p>#
func findRepeatNumber(nums []int) int {</p>
<blockquote>
<div><p>countZero := 0
for _, value := range nums {</p>
<blockquote>
<div><dl>
<dt>if value == 0 {</dt><dd><dl class="simple">
<dt>if countZero &gt; 0 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
countZero++
continue</p>
</dd>
</dl>
<p>}
if value &lt; 0 {</p>
<blockquote>
<div><p>value = -value</p>
</div></blockquote>
<p>}
if nums[value] &lt; 0 {</p>
<blockquote>
<div><p>return value</p>
</div></blockquote>
<p>}
nums[value] = -1 * nums[value]</p>
</div></blockquote>
<p>}
return -1</p>
</div></blockquote>
<p>}</p>
<p>#
func findRepeatNumber(nums []int) int {</p>
<blockquote>
<div><dl>
<dt>for i := 0; i &lt; len(nums); i++ {</dt><dd><dl>
<dt>for nums[i] != i {</dt><dd><dl class="simple">
<dt>if nums[i] == nums[nums[i]] {</dt><dd><p>return nums[i]</p>
</dd>
</dl>
<p>}
nums[i], nums[nums[i]] = nums[nums[i]], nums[i]</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
return -1</p>
</div></blockquote>
<div class="section" id="id5">
<h1>}<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h1>
<p>## 面试题04.二维数组中的查找(6)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id6"><span class="problematic" id="id7">``</span></a>`
在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。
请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
示例:
现有矩阵 matrix 如下：
[</p>
<blockquote>
<div><p>[1,   4,  7, 11, 15],
[2,   5,  8, 12, 19],
[3,   6,  9, 16, 22],
[10, 13, 14, 17, 24],
[18, 21, 23, 26, 30]</p>
</div></blockquote>
<p>]
给定 target = 5，返回 true。
给定 target = 20，返回 false。
限制：
0 &lt;= n &lt;= 1000
0 &lt;= m &lt;= 1000
注意：本题与主站 240 题相同：<a class="reference external" href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/">https://leetcode-cn.com/problems/search-a-2d-matrix-ii/</a>
<a href="#id8"><span class="problematic" id="id9">``</span></a><a href="#id10"><span class="problematic" id="id11">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路                 | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ——————– | ———- | ———- |</div>
<div class="line">01   | 暴力法               | O(n^2)     | O(1)       |</div>
<div class="line">02   | 暴力法-优化          | O(n^2)     | O(1)       |</div>
<div class="line">03   | 二分查找             | O(nlog(n)) | O(1)       |</div>
<div class="line">04   | 左下角查找           | O(n)       | O(1)       |</div>
<div class="line">05   | 右上角查找(书上方法) | O(n)       | O(1)       |</div>
<div class="line">06   | 内置函数             | O(n^2)     | O(1)       |</div>
</div>
<p><a href="#id12"><span class="problematic" id="id13">``</span></a><a href="#id14"><span class="problematic" id="id15">`</span></a>go
func findNumberIn2DArray(matrix [][]int, target int) bool {</p>
<blockquote>
<div><dl class="simple">
<dt>if len(matrix) == 0 {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}
if len(matrix[0]) == 0 {</p>
<blockquote>
<div><p>return false</p>
</div></blockquote>
<p>}
for i := 0; i &lt; len(matrix); i++ {</p>
<blockquote>
<div><dl>
<dt>for j := 0; j &lt; len(matrix[i]); j++ {</dt><dd><dl class="simple">
<dt>if matrix[i][j] == target {</dt><dd><p>return true</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return false</p>
</div></blockquote>
<p>}</p>
<p># 2
func findNumberIn2DArray(matrix [][]int, target int) bool {</p>
<blockquote>
<div><dl class="simple">
<dt>if len(matrix) == 0 {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}
if len(matrix[0]) == 0 {</p>
<blockquote>
<div><p>return false</p>
</div></blockquote>
<p>}
for i := 0; i &lt; len(matrix); i++ {</p>
<blockquote>
<div><dl>
<dt>if matrix[i][0] &lt;= target &amp;&amp; matrix[i][len(matrix[i])-1] &gt;= target {</dt><dd><dl>
<dt>for j := 0; j &lt; len(matrix[i]); j++ {</dt><dd><dl class="simple">
<dt>if matrix[i][j] == target {</dt><dd><p>return true</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return false</p>
</div></blockquote>
<p>}</p>
<p># 3
func findNumberIn2DArray(matrix [][]int, target int) bool {</p>
<blockquote>
<div><dl class="simple">
<dt>if len(matrix) == 0 {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}
if len(matrix[0]) == 0 {</p>
<blockquote>
<div><p>return false</p>
</div></blockquote>
<p>}
for i := 0; i &lt; len(matrix); i++ {</p>
<blockquote>
<div><dl>
<dt>if matrix[i][0] &lt;= target &amp;&amp; matrix[i][len(matrix[i])-1] &gt;= target {</dt><dd><p>res := binarySearch(matrix[i], target)
if res == true {</p>
<blockquote>
<div><p>return true</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return false</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func binarySearch(arr []int, target int) bool {</dt><dd><p>left := 0
right := len(arr) - 1
for left &lt;= right {</p>
<blockquote>
<div><p>mid := left + (right-left)/2
if arr[mid] == target {</p>
<blockquote>
<div><p>return true</p>
</div></blockquote>
<dl class="simple">
<dt>} else if arr[mid] &gt; target {</dt><dd><p>right = mid - 1</p>
</dd>
<dt>} else {</dt><dd><p>left = mid + 1</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return false</p>
</dd>
</dl>
<p>}</p>
<p># 4
func findNumberIn2DArray(matrix [][]int, target int) bool {</p>
<blockquote>
<div><dl class="simple">
<dt>if len(matrix) == 0 {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}
if len(matrix[0]) == 0 {</p>
<blockquote>
<div><p>return false</p>
</div></blockquote>
<p>}
i := len(matrix) - 1
j := 0
for i &gt;= 0 &amp;&amp; j &lt; len(matrix[0]) {</p>
<blockquote>
<div><dl class="simple">
<dt>if matrix[i][j] == target {</dt><dd><p>return true</p>
</dd>
<dt>} else if matrix[i][j] &gt; target {</dt><dd><p>i–</p>
</dd>
<dt>} else {</dt><dd><p>j++</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return false</p>
</div></blockquote>
<p>}</p>
<p># 5
func findNumberIn2DArray(matrix [][]int, target int) bool {</p>
<blockquote>
<div><dl class="simple">
<dt>if len(matrix) == 0 {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}
if len(matrix[0]) == 0 {</p>
<blockquote>
<div><p>return false</p>
</div></blockquote>
<p>}
i := 0
j := len(matrix[0]) - 1
for j &gt;= 0 &amp;&amp; i &lt; len(matrix) {</p>
<blockquote>
<div><dl class="simple">
<dt>if matrix[i][j] == target {</dt><dd><p>return true</p>
</dd>
<dt>} else if matrix[i][j] &gt; target {</dt><dd><p>j–</p>
</dd>
<dt>} else {</dt><dd><p>i++</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return false</p>
</div></blockquote>
<p>}</p>
<p># 6
func findNumberIn2DArray(matrix [][]int, target int) bool {</p>
<blockquote>
<div><dl class="simple">
<dt>if len(matrix) == 0 {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}
if len(matrix[0]) == 0 {</p>
<blockquote>
<div><p>return false</p>
</div></blockquote>
<p>}
for i := 0; i &lt; len(matrix); i++ {</p>
<blockquote>
<div><p>index := sort.SearchInts(matrix[i], target)
if index &lt; len(matrix[i]) &amp;&amp; target == matrix[i][index] {</p>
<blockquote>
<div><p>return true</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return false</p>
</div></blockquote>
</div>
<div class="section" id="id16">
<h1>}<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h1>
<p>## 面试题05.替换空格(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">请实现一个函数，把字符串</span> <span class="pre">s</span> <span class="pre">中的每个空格替换成&quot;%20&quot;。</span>
<span class="pre">示例</span> <span class="pre">1：输入：s</span> <span class="pre">=</span> <span class="pre">&quot;We</span> <span class="pre">are</span> <span class="pre">happy.&quot;</span> <span class="pre">输出：&quot;We%20are%20happy.&quot;</span>
<span class="pre">限制：0</span> <span class="pre">&lt;=</span> <span class="pre">s</span> <span class="pre">的长度</span> <span class="pre">&lt;=</span> <span class="pre">10000</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路     | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ——– | ———- | ———- |</div>
<div class="line">01   | 内置函数 | O(n)       | O(n)       |</div>
<div class="line">02   | 遍历     | O(n)       | O(n)       |</div>
</div>
<p><a href="#id17"><span class="problematic" id="id18">``</span></a><a href="#id19"><span class="problematic" id="id20">`</span></a>go
func replaceSpace(s string) string {</p>
<blockquote>
<div><p>return strings.Replace(s,” “,”%20”,-1)
// return strings.ReplaceAll(s, ” “, “%20”)</p>
</div></blockquote>
<p>}</p>
<p>#
func replaceSpace(s string) string {</p>
<blockquote>
<div><p>res := “”
for i := 0; i &lt; len(s); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if s[i] == ‘ ‘ {</dt><dd><p>res = res + “%20”</p>
</dd>
<dt>} else {</dt><dd><p>res = res + string(s[i])</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
</div>
<div class="section" id="id21">
<h1>}<a class="headerlink" href="#id21" title="永久链接至标题">¶</a></h1>
<p>## 面试题06.从尾到头打印链表(5)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</span>
<span class="pre">示例</span> <span class="pre">1：输入：head</span> <span class="pre">=</span> <span class="pre">[1,3,2]</span> <span class="pre">输出：[2,3,1]</span>
<span class="pre">限制：0</span> <span class="pre">&lt;=</span> <span class="pre">链表长度</span> <span class="pre">&lt;=</span> <span class="pre">10000</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路             | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —————- | ———- | ———- |</div>
<div class="line">01   | 反转数组         | O(n)       | O(n)       |</div>
<div class="line">02   | 递归(书上方法)   | O(n)       | O(n)       |</div>
<div class="line">03   | 反转链表         | O(n)       | O(n)       |</div>
<div class="line">04   | 栈辅助(书上方法) | O(n)       | O(n)       |</div>
<div class="line">05   | 统计+遍历        | O(n)       | O(n)       |</div>
</div>
<p><a href="#id22"><span class="problematic" id="id23">``</span></a><a href="#id24"><span class="problematic" id="id25">`</span></a>go
func reversePrint(head <a href="#id26"><span class="problematic" id="id27">*</span></a>ListNode) []int {</p>
<blockquote>
<div><p>res := make([]int, 0)
for head != nil {</p>
<blockquote>
<div><p>res = append(res, head.Val)
head = head.Next</p>
</div></blockquote>
<p>}
i := 0
for i &lt; len(res)/2 {</p>
<blockquote>
<div><p>res[i], res[len(res)-1-i] = res[len(res)-1-i], res[i]
i++</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p># 2
func reversePrint(head <a href="#id28"><span class="problematic" id="id29">*</span></a>ListNode) []int {</p>
<blockquote>
<div><dl class="simple">
<dt>if head == nil {</dt><dd><p>return []int{}</p>
</dd>
</dl>
<p>}
res := reversePrint(head.Next)
res = append(res, head.Val)
return res</p>
</div></blockquote>
<p>}</p>
<p># 3
func reversePrint(head <a href="#id30"><span class="problematic" id="id31">*</span></a>ListNode) []int {</p>
<blockquote>
<div><p>res := make([]int, 0)
if head == nil {</p>
<blockquote>
<div><p>return res</p>
</div></blockquote>
<p>}
var newHead <a href="#id32"><span class="problematic" id="id33">*</span></a>ListNode
for head != nil {</p>
<blockquote>
<div><p>next := head.Next
head.Next = newHead
newHead = head
head = next</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>for newHead != nil {</dt><dd><p>res = append(res, newHead.Val)
newHead = newHead.Next</p>
</dd>
</dl>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p># 4
func reversePrint(head <a href="#id34"><span class="problematic" id="id35">*</span></a>ListNode) []int {</p>
<blockquote>
<div><p>res := make([]int,0)
if head == nil{</p>
<blockquote>
<div><p>return res</p>
</div></blockquote>
<p>}
stack := make([]*ListNode, 0)
for head != nil{</p>
<blockquote>
<div><p>stack = append(stack, head)
head = head.Next</p>
</div></blockquote>
<p>}
for len(stack) &gt; 0{</p>
<blockquote>
<div><p>node := stack[len(stack)-1]
stack = stack[:len(stack)-1]
res = append(res, node.Val)</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p># 5
func reversePrint(head <a href="#id36"><span class="problematic" id="id37">*</span></a>ListNode) []int {</p>
<blockquote>
<div><p>cur := head
count := 0
for head != nil {</p>
<blockquote>
<div><p>count++
head = head.Next</p>
</div></blockquote>
<p>}
res := make([]int, count)
for cur != nil {</p>
<blockquote>
<div><p>res[count-1] = cur.Val
count–
cur = cur.Next</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
</div>
<div class="section" id="id38">
<h1>}<a class="headerlink" href="#id38" title="永久链接至标题">¶</a></h1>
<p>## 面试题07.重建二叉树(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id39"><span class="problematic" id="id40">``</span></a>`
输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。
假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
例如，给出
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>3</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<dl>
<dt>9  20</dt><dd><blockquote>
<div><p>/  </p>
</div></blockquote>
<p>15   7</p>
</dd>
</dl>
</div></blockquote>
<p>限制：0 &lt;= 节点个数 &lt;= 5000
注意：本题与主站 105 题重复：
<a class="reference external" href="https://leetcode-cn.com/problems/">https://leetcode-cn.com/problems/</a>
construct-binary-tree-from-preorder-and-inorder-traversal/
<a href="#id41"><span class="problematic" id="id42">``</span></a><a href="#id43"><span class="problematic" id="id44">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路           | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ————– | ———- | ———- |</div>
<div class="line">01   | 递归           | O(n)       | O(n)       |</div>
<div class="line">02   | 迭代           | O(n)       | O(n)       |</div>
<div class="line">03   | 递归(书上方法) | O(n)       | O(n)       |</div>
</div>
<p><a href="#id45"><span class="problematic" id="id46">``</span></a><a href="#id47"><span class="problematic" id="id48">`</span></a>go
func buildTree(preorder []int, inorder []int) <a href="#id49"><span class="problematic" id="id50">*</span></a>TreeNode {</p>
<blockquote>
<div><dl>
<dt>for k := range inorder {</dt><dd><dl>
<dt>if inorder[k] == preorder[0] {</dt><dd><dl class="simple">
<dt>return &amp;TreeNode{</dt><dd><p>Val:   preorder[0],
Left:  buildTree(preorder[1:k+1], inorder[0:k]),
Right: buildTree(preorder[k+1:], inorder[k+1:]),</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
return nil</p>
</div></blockquote>
<p>}</p>
<p>#</p>
<dl>
<dt>func buildTree(preorder []int, inorder []int) <a href="#id51"><span class="problematic" id="id52">*</span></a>TreeNode {</dt><dd><dl class="simple">
<dt>if preorder == nil || len(preorder) == 0 {</dt><dd><p>return nil</p>
</dd>
</dl>
<p>}
root := &amp;TreeNode{</p>
<blockquote>
<div><p>Val: preorder[0],</p>
</div></blockquote>
<p>}
length := len(preorder)
stack := make([]*TreeNode, 0)
stack = append(stack, root)
index := 0
for i := 1; i &lt; length; i++ {</p>
<blockquote>
<div><p>value := preorder[i]
node := stack[len(stack)-1]
if node.Val != inorder[index] {</p>
<blockquote>
<div><p>node.Left = &amp;TreeNode{Val: value}
stack = append(stack, node.Left)</p>
</div></blockquote>
<dl>
<dt>} else {</dt><dd><dl class="simple">
<dt>for len(stack) &gt; 0 &amp;&amp; stack[len(stack)-1].Val == inorder[index] {</dt><dd><p>node = stack[len(stack)-1]
stack = stack[:len(stack)-1]
index++</p>
</dd>
</dl>
<p>}
node.Right = &amp;TreeNode{Val: value}
stack = append(stack, node.Right)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return root</p>
</dd>
</dl>
<p>}</p>
<p>#
func buildTree(preorder []int, inorder []int) <a href="#id53"><span class="problematic" id="id54">*</span></a>TreeNode {</p>
<blockquote>
<div><dl class="simple">
<dt>if len(preorder) == 0 {</dt><dd><p>return nil</p>
</dd>
</dl>
<p>}
return helper(preorder, inorder)</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func helper(preorder []int, inorder []int) <a href="#id55"><span class="problematic" id="id56">*</span></a>TreeNode {</dt><dd><p>var root <a href="#id57"><span class="problematic" id="id58">*</span></a>TreeNode
for k := range inorder {</p>
<blockquote>
<div><dl class="simple">
<dt>if inorder[k] == preorder[0] {</dt><dd><p>root = &amp;TreeNode{Val: preorder[0]}
root.Left = helper(preorder[1:k+1], inorder[0:k])
root.Right = helper(preorder[k+1:], inorder[k+1:])</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return root</p>
</dd>
</dl>
</div>
<div class="section" id="id59">
<h1>}<a class="headerlink" href="#id59" title="永久链接至标题">¶</a></h1>
<p>## 面试题09.用两个栈实现队列(1)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id60"><span class="problematic" id="id61">``</span></a>`
用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，
分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )
示例 1：输入： [“CQueue”,”appendTail”,”deleteHead”,”deleteHead”]
[[],[3],[],[]]
输出：[null,null,3,-1]
示例 2：输入：
[“CQueue”,”deleteHead”,”appendTail”,”appendTail”,”deleteHead”,”deleteHead”]
[[],[],[5],[2],[],[]]
输出：[null,-1,null,null,5,2]
提示：</p>
<blockquote>
<div><p>1 &lt;= values &lt;= 10000
最多会对 appendTail、deleteHead 进行 10000 次调用</p>
</div></blockquote>
<p><a href="#id62"><span class="problematic" id="id63">``</span></a><a href="#id64"><span class="problematic" id="id65">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路       | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ———- | ———- | ———- |</div>
<div class="line">01   | 栈模拟队列 | O(n)       | O(n)       |</div>
</div>
<p><a href="#id66"><span class="problematic" id="id67">``</span></a><a href="#id68"><span class="problematic" id="id69">`</span></a>go
type stack []int</p>
<dl class="simple">
<dt>func (s <a href="#id70"><span class="problematic" id="id71">*</span></a>stack) Push(value int) {</dt><dd><p><a href="#id72"><span class="problematic" id="id73">*</span></a>s = append(<a href="#id74"><span class="problematic" id="id75">*</span></a>s, value)</p>
</dd>
</dl>
<p>}
func (s <a href="#id76"><span class="problematic" id="id77">*</span></a>stack) Pop() int {</p>
<blockquote>
<div><p>value := (<a href="#id78"><span class="problematic" id="id79">*</span></a>s)[len(<a href="#id80"><span class="problematic" id="id81">*</span></a>s)-1]
<a href="#id82"><span class="problematic" id="id83">*</span></a>s = (<a href="#id84"><span class="problematic" id="id85">*</span></a>s)[:len(<a href="#id86"><span class="problematic" id="id87">*</span></a>s)-1]
return value</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>type CQueue struct {</dt><dd><p>tail stack
head stack</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>func Constructor() CQueue {</dt><dd><p>return CQueue{}</p>
</dd>
</dl>
<p>}</p>
<p>// 1.入队，tail栈保存
// 2.出队, head不为空，出head；head为空，tail出到head里，最后出head
func (this <a href="#id88"><span class="problematic" id="id89">*</span></a>CQueue) AppendTail(value int) {</p>
<blockquote>
<div><p>this.tail.Push(value)</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func (this <a href="#id90"><span class="problematic" id="id91">*</span></a>CQueue) DeleteHead() int {</dt><dd><dl>
<dt>if len(this.head) != 0 {</dt><dd><p>return this.head.Pop()</p>
</dd>
<dt>} else if len(this.tail) != 0 {</dt><dd><dl class="simple">
<dt>for len(this.tail) &gt; 0 {</dt><dd><p>this.head.Push(this.tail.Pop())</p>
</dd>
</dl>
<p>}
return this.head.Pop()</p>
</dd>
</dl>
<p>}
return -1</p>
</dd>
</dl>
</div>
<div class="section" id="id92">
<h1>}<a class="headerlink" href="#id92" title="永久链接至标题">¶</a></h1>
<p>## 面试题10- I.斐波那契数列(5)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id93"><span class="problematic" id="id94">``</span></a>`
写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：
F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.
斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。
答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
示例 1：输入：n = 2输出：1
示例 2：输入：n = 5输出：5
提示：</p>
<blockquote>
<div><p>0 &lt;= n &lt;= 100</p>
</div></blockquote>
<p>注意：本题与主站 509 题相同：<a class="reference external" href="https://leetcode-cn.com/problems/fibonacci-number/">https://leetcode-cn.com/problems/fibonacci-number/</a>
<a href="#id95"><span class="problematic" id="id96">``</span></a><a href="#id97"><span class="problematic" id="id98">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路                 | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ——————– | ———- | ———- |</div>
<div class="line">01   | 遍历(书上方法)       | O(n)       | O(1)       |</div>
<div class="line">02   | 遍历+数组            | O(n)       | O(n)       |</div>
<div class="line">03   | 矩阵快速幂(书上方法) | O(log(n))  | O(1)       |</div>
<div class="line">04   | 矩阵快速幂(书上方法) | O(n)       | O(1)       |</div>
<div class="line">05   | 递归                 | O(n)       | O(n)       |</div>
</div>
<p><a href="#id99"><span class="problematic" id="id100">``</span></a><a href="#id101"><span class="problematic" id="id102">`</span></a>go
func fib(n int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if n == 0 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
if n == 1 {</p>
<blockquote>
<div><p>return 1</p>
</div></blockquote>
<p>}
n1, n2 := 0, 1
for i := 2; i &lt;= n; i++ {</p>
<blockquote>
<div><p>n1, n2 = n2, (n1+n2)%1000000007</p>
</div></blockquote>
<p>}
return n2</p>
</div></blockquote>
<p>}</p>
<p>#
func fib(n int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if n == 0 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
if n == 1 {</p>
<blockquote>
<div><p>return 1</p>
</div></blockquote>
<p>}
res := make([]int, n+1)
res[0] = 0
res[1] = 1
for i := 2; i &lt;= n; i++ {</p>
<blockquote>
<div><p>res[i] = (res[i-1] + res[i-2]) % 1000000007</p>
</div></blockquote>
<p>}
return res[n]</p>
</div></blockquote>
<p>}</p>
<p>#
func fib(n int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if n == 0{</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
/*
ans = [Fn+1 Fn</p>
<blockquote>
<div><blockquote>
<div><p>Fn Fn-1]</p>
</div></blockquote>
<dl class="simple">
<dt>= [ 1 0</dt><dd><p>0 1]</p>
</dd>
</dl>
</div></blockquote>
<p><a href="#id103"><span class="problematic" id="id104">*</span></a>/
ans := matrix{</p>
<blockquote>
<div><p>a: 1,
b: 0,
c: 0,
d: 1,</p>
</div></blockquote>
<p>}
m := matrix{</p>
<blockquote>
<div><p>a: 1,
b: 1,
c: 1,
d: 0,</p>
</div></blockquote>
<p>}
for n &gt; 0{</p>
<blockquote>
<div><dl class="simple">
<dt>if n % 2 == 1{</dt><dd><p>ans = multi(ans, m)</p>
</dd>
</dl>
<p>}
m = multi(m, m)
n = n &gt;&gt; 1</p>
</div></blockquote>
<p>}
return ans.b</p>
</div></blockquote>
<p>}</p>
<p>/*
a b
c d
<a href="#id105"><span class="problematic" id="id106">*</span></a>/
type matrix struct {</p>
<blockquote>
<div><p>a, b, c, d int</p>
</div></blockquote>
<p>}</p>
<p>// 矩阵乘法
func multi(x, y matrix) matrix {</p>
<blockquote>
<div><p>newA := x.a*y.a + x.b*y.c
newB := x.a*y.b + x.b*y.d
newC := x.c*y.a + x.d*y.c
newD := x.c*y.b + x.d*y.d
return matrix{</p>
<blockquote>
<div><p>a: newA% 1000000007,
b: newB% 1000000007,
c: newC% 1000000007,
d: newD% 1000000007,</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>#
func fib(n int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if n == 0 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
/*</p>
<blockquote>
<div><dl>
<dt>ans = [Fn+1 Fn</dt><dd><blockquote>
<div><p>Fn Fn-1]</p>
</div></blockquote>
<dl class="simple">
<dt>= [ 1 0</dt><dd><p>0 1]</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p><a href="#id107"><span class="problematic" id="id108">*</span></a>/
ans := matrix{</p>
<blockquote>
<div><p>a: 1,
b: 0,
c: 0,
d: 1,</p>
</div></blockquote>
<p>}
m := matrix{</p>
<blockquote>
<div><p>a: 1,
b: 1,
c: 1,
d: 0,</p>
</div></blockquote>
<p>}
for n &gt; 0 {</p>
<blockquote>
<div><dl class="simple">
<dt>if n%2 == 1 {</dt><dd><p>ans = multi(ans, m)</p>
</dd>
</dl>
<p>}
m = multi(m, m)
n = n &gt;&gt; 1</p>
</div></blockquote>
<p>}
return ans.b</p>
</div></blockquote>
<p>}</p>
<p>/*
a b
c d
<a href="#id109"><span class="problematic" id="id110">*</span></a>/
type matrix struct {</p>
<blockquote>
<div><p>a, b, c, d int</p>
</div></blockquote>
<p>}</p>
<p>// 矩阵乘法
func multi(x, y matrix) matrix {</p>
<blockquote>
<div><p>newA := x.a*y.a + x.b*y.c
newB := x.a*y.b + x.b*y.d
newC := x.c*y.a + x.d*y.c
newD := x.c*y.b + x.d*y.d
return matrix{</p>
<blockquote>
<div><p>a: newA % 1000000007,
b: newB % 1000000007,
c: newC % 1000000007,
d: newD % 1000000007,</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<p># 4
func fib(n int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if n == 0 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
/*</p>
<blockquote>
<div><dl>
<dt>ans = [Fn+1 Fn</dt><dd><blockquote>
<div><p>Fn Fn-1]</p>
</div></blockquote>
<dl class="simple">
<dt>= [ 1 0</dt><dd><p>0 1]</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p><a href="#id111"><span class="problematic" id="id112">*</span></a>/
ans := matrix{</p>
<blockquote>
<div><p>a: 1,
b: 0,
c: 0,
d: 1,</p>
</div></blockquote>
<p>}
m := matrix{</p>
<blockquote>
<div><p>a: 1,
b: 1,
c: 1,
d: 0,</p>
</div></blockquote>
<p>}
for n &gt; 0 {</p>
<blockquote>
<div><p>ans = multi(ans, m)
n–</p>
</div></blockquote>
<p>}
return ans.b</p>
</div></blockquote>
<p>}</p>
<p>/*
a b
c d
<a href="#id113"><span class="problematic" id="id114">*</span></a>/
type matrix struct {</p>
<blockquote>
<div><p>a, b, c, d int</p>
</div></blockquote>
<p>}</p>
<p>// 矩阵乘法
func multi(x, y matrix) matrix {</p>
<blockquote>
<div><p>newA := x.a*y.a + x.b*y.c
newB := x.a*y.b + x.b*y.d
newC := x.c*y.a + x.d*y.c
newD := x.c*y.b + x.d*y.d
return matrix{</p>
<blockquote>
<div><p>a: newA % 1000000007,
b: newB % 1000000007,
c: newC % 1000000007,
d: newD % 1000000007,</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<p># 5
var m = make(map[int]int)</p>
<dl>
<dt>func fib(n int) int {</dt><dd><dl class="simple">
<dt>if n == 0 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
if n == 1 {</p>
<blockquote>
<div><p>return 1</p>
</div></blockquote>
<p>}
if m[n] &gt; 0 {</p>
<blockquote>
<div><p>return m[n]</p>
</div></blockquote>
<p>}
m[n] = (fib(n-1) + fib(n-2)) % 1000000007
return m[n]</p>
</dd>
</dl>
</div>
<div class="section" id="id115">
<h1>}<a class="headerlink" href="#id115" title="永久链接至标题">¶</a></h1>
<p>## 面试题10-II.青蛙跳台阶问题(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id116"><span class="problematic" id="id117">``</span></a>`
一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。
答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
示例 1：输入：n = 2输出：2
示例 2：输入：n = 7输出：21
提示：</p>
<blockquote>
<div><p>0 &lt;= n &lt;= 100</p>
</div></blockquote>
<p>注意：本题与主站 70 题相同：<a class="reference external" href="https://leetcode-cn.com/problems/climbing-stairs/">https://leetcode-cn.com/problems/climbing-stairs/</a>
<a href="#id118"><span class="problematic" id="id119">``</span></a><a href="#id120"><span class="problematic" id="id121">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路     | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ——– | ———- | ———- |</div>
<div class="line">01   | 动态规划 | O(n)       | O(n)       |</div>
<div class="line">02   | 斐波那契 | O(n)       | O(1)       |</div>
<div class="line">03   | 递归     | O(n)       | O(n)       |</div>
</div>
<p><a href="#id122"><span class="problematic" id="id123">``</span></a><a href="#id124"><span class="problematic" id="id125">`</span></a>go
func numWays(n int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if n &lt;= 1 {</dt><dd><p>return 1</p>
</dd>
</dl>
<p>}
if n == 2 {</p>
<blockquote>
<div><p>return 2</p>
</div></blockquote>
<p>}
dp := make([]int, n+1)
dp[1] = 1
dp[2] = 2
for i := 3; i &lt;= n; i++ {</p>
<blockquote>
<div><p>dp[i] = (dp[i-1] + dp[i-2]) % 1000000007</p>
</div></blockquote>
<p>}
return dp[n]</p>
</div></blockquote>
<p>}</p>
<p>#
func numWays(n int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if n &lt;= 1 {</dt><dd><p>return 1</p>
</dd>
</dl>
<p>}
first := 1
second := 2
for i := 3; i &lt;= n; i++ {</p>
<blockquote>
<div><p>third := (first + second) % 1000000007
first = second
second = third</p>
</div></blockquote>
<p>}
return second</p>
</div></blockquote>
<p>}</p>
<p># 3
var m = make(map[int]int)</p>
<dl>
<dt>func numWays(n int) int {</dt><dd><dl class="simple">
<dt>if n &lt;= 1 {</dt><dd><p>return 1</p>
</dd>
</dl>
<p>}
if m[n] &gt; 0 {</p>
<blockquote>
<div><p>return m[n]</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>m[n] = (numWays(n-1) + numWays(n-2)) % 1000000007</p>
</dd>
</dl>
<p>}
return m[n]</p>
</dd>
</dl>
</div>
<div class="section" id="id126">
<h1>}<a class="headerlink" href="#id126" title="永久链接至标题">¶</a></h1>
<p>## 面试题11.旋转数组的最小数字(4)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id127"><span class="problematic" id="id128">``</span></a>`
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。
例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。</p>
<p>示例 1：输入：[3,4,5,1,2]输出：1</p>
<p>示例 2：输入：[2,2,2,0,1]输出：0
注意：本题与主站 154 题相同：
<a class="reference external" href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/</a>
<a href="#id129"><span class="problematic" id="id130">``</span></a><a href="#id131"><span class="problematic" id="id132">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路               | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —————— | ———- | ———- |</div>
<div class="line">01   | 二分查找           | O(log(n))  | O(1)       |</div>
<div class="line">02   | 排序               | O(nlog(n)) | O(1)       |</div>
<div class="line">03   | 遍历               | O(n)       | O(1)       |</div>
<div class="line">04   | 二分查找(书上方法) | O(log(n))  | O(1)       |</div>
</div>
<p><a href="#id133"><span class="problematic" id="id134">``</span></a><a href="#id135"><span class="problematic" id="id136">`</span></a>go
func minArray(numbers []int) int {</p>
<blockquote>
<div><p>left := 0
right := len(numbers) - 1
for left &lt; right {</p>
<blockquote>
<div><dl class="simple">
<dt>if numbers[left] &lt; numbers[right] {</dt><dd><p>return numbers[left]</p>
</dd>
</dl>
<p>}
mid := left + (right-left)/2
if numbers[mid] &gt; numbers[left] {</p>
<blockquote>
<div><p>left = mid + 1</p>
</div></blockquote>
<dl class="simple">
<dt>} else if numbers[mid] &lt; numbers[left] {</dt><dd><p>right = mid</p>
</dd>
<dt>} else {</dt><dd><p>left++</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return numbers[left]</p>
</div></blockquote>
<p>}</p>
<p>#
func minArray(numbers []int) int {</p>
<blockquote>
<div><p>sort.Ints(numbers)
return numbers[0]</p>
</div></blockquote>
<p>}</p>
<p>#
func minArray(numbers []int) int {</p>
<blockquote>
<div><dl>
<dt>for i := 1; i &lt; len(numbers); i++ {</dt><dd><dl class="simple">
<dt>if numbers[i] &lt; numbers[i-1] {</dt><dd><p>return numbers[i]</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
return numbers[0]</p>
</div></blockquote>
<p>}</p>
<p>#
func minArray(numbers []int) int {</p>
<blockquote>
<div><p>left := 0
right := len(numbers) - 1
mid := left
for numbers[left] &gt;= numbers[right] {</p>
<blockquote>
<div><dl class="simple">
<dt>if right-left == 1 {</dt><dd><p>mid = right
break</p>
</dd>
</dl>
<p>}
mid = (left + right) / 2
if numbers[left] == numbers[right] &amp;&amp; numbers[mid] == numbers[left] {</p>
<blockquote>
<div><p>return minInorder(numbers, left, right)</p>
</div></blockquote>
<p>}
if numbers[mid] &gt;= numbers[left] {</p>
<blockquote>
<div><p>left = mid</p>
</div></blockquote>
<dl class="simple">
<dt>} else if numbers[mid] &lt;= numbers[right] {</dt><dd><p>right = mid</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return numbers[mid]</p>
</div></blockquote>
</div>
<div class="section" id="id137">
<h1>}<a class="headerlink" href="#id137" title="永久链接至标题">¶</a></h1>
<p>## 面试题12.矩阵中的路径(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id138"><span class="problematic" id="id139">``</span></a>`
请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。
路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。
如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。
例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p>
<p>[[“a”,”b”,”c”,”e”],
[“s”,”f”,”c”,”s”],
[“a”,”d”,”e”,”e”]]
但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，
路径不能再次进入这个格子。
示例 1：输入：board = [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]],
word = “ABCCED”
输出：true
示例 2：输入：board = [[“a”,”b”],[“c”,”d”]], word = “abcd” 输出：false
提示：</p>
<blockquote>
<div><p>1 &lt;= board.length &lt;= 200
1 &lt;= board[i].length &lt;= 200</p>
</div></blockquote>
<p>注意：本题与主站 79 题相同：<a class="reference external" href="https://leetcode-cn.com/problems/word-search/">https://leetcode-cn.com/problems/word-search/</a>
<a href="#id140"><span class="problematic" id="id141">``</span></a><a href="#id142"><span class="problematic" id="id143">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路                                 | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ———————————— | ———- | ———- |</div>
<div class="line">01   | 深度优先搜索+回溯                    | O(n^2)     | O(n)       |</div>
<div class="line">02   | 深度优先搜索+回溯+数组辅助(书上方法) | O(n^2)     | O(n^2)     |</div>
</div>
<p><a href="#id144"><span class="problematic" id="id145">``</span></a><a href="#id146"><span class="problematic" id="id147">`</span></a>go
func exist(board [][]byte, word string) bool {</p>
<blockquote>
<div><dl>
<dt>for i := 0; i &lt; len(board); i++ {</dt><dd><dl>
<dt>for j := 0; j &lt; len(board[0]); j++ {</dt><dd><dl class="simple">
<dt>if dfs(board, i, j, word, 0) {</dt><dd><p>return true</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
return false</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func dfs(board [][]byte, i, j int, word string, level int) bool {</dt><dd><dl class="simple">
<dt>if i &lt; 0 || i &gt;= len(board) || j &lt; 0 || j &gt;= len(board[0]) ||</dt><dd><p>board[i][j] != word[level] {
return false</p>
</dd>
</dl>
<p>}
if level == len(word)-1 {</p>
<blockquote>
<div><p>return true</p>
</div></blockquote>
<p>}
temp := board[i][j]
board[i][j] = ‘ ‘
res := dfs(board, i+1, j, word, level+1) ||</p>
<blockquote>
<div><p>dfs(board, i-1, j, word, level+1) ||
dfs(board, i, j+1, word, level+1) ||
dfs(board, i, j-1, word, level+1)</p>
</div></blockquote>
<p>board[i][j] = temp
return res</p>
</dd>
</dl>
<p>}</p>
<p>#
func exist(board [][]byte, word string) bool {</p>
<blockquote>
<div><p>visited := make([][]bool, len(board))
for i := 0; i &lt; len(board); i++ {</p>
<blockquote>
<div><p>visited[i] = make([]bool, len(board[0]))</p>
</div></blockquote>
<p>}
for i := 0; i &lt; len(board); i++ {</p>
<blockquote>
<div><dl>
<dt>for j := 0; j &lt; len(board[0]); j++ {</dt><dd><dl class="simple">
<dt>if dfs(board, i, j, word, 0, visited) {</dt><dd><p>return true</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return false</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func dfs(board [][]byte, i, j int, word string, level int, visited [][]bool) bool {</dt><dd><p>res := false
if i &gt;= 0 &amp;&amp; i &lt; len(board) &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; len(board[0]) &amp;&amp;</p>
<blockquote>
<div><p>visited[i][j] == false &amp;&amp; board[i][j] == word[level] {
if level == len(word)-1 {</p>
<blockquote>
<div><p>return true</p>
</div></blockquote>
<p>}
visited[i][j] = true
level = level + 1
res = dfs(board, i+1, j, word, level, visited) ||</p>
<blockquote>
<div><p>dfs(board, i-1, j, word, level, visited) ||
dfs(board, i, j+1, word, level, visited) ||
dfs(board, i, j-1, word, level, visited)</p>
</div></blockquote>
<dl class="simple">
<dt>if !res {</dt><dd><p>visited[i][j] = false
level = level - 1</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</dd>
</dl>
</div>
<div class="section" id="id148">
<h1>}<a class="headerlink" href="#id148" title="永久链接至标题">¶</a></h1>
<p>## 面试题13.机器人的运动范围(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id149"><span class="problematic" id="id150">``</span></a>`
地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。
一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），
也不能进入行坐标和列坐标的数位之和大于k的格子。
例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。
但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
<p>示例 1：输入：m = 2, n = 3, k = 1 输出：3
示例 2：输入：m = 3, n = 1, k = 0 输出：1
提示：</p>
<blockquote>
<div><p>1 &lt;= n,m &lt;= 100
0 &lt;= k &lt;= 20</p>
</div></blockquote>
<p><a href="#id151"><span class="problematic" id="id152">``</span></a><a href="#id153"><span class="problematic" id="id154">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路                   | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ———————- | ———- | ———- |</div>
<div class="line">01   | 深度优先搜索(书上方法) | O(n^2)     | O(n^2)     |</div>
<div class="line">02   | 暴力法                 | O(n^2)     | O(n^2)     |</div>
<div class="line">03   | 广度优先搜索           | O(n^2)     | O(n^2)     |</div>
</div>
<p><a href="#id155"><span class="problematic" id="id156">``</span></a><a href="#id157"><span class="problematic" id="id158">`</span></a>go
func movingCount(m int, n int, k int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if k &lt; 0 || m &lt;= 0 || n &lt;= 0 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
visited := make([]bool, m*n)
res := dfs(m, n, k, visited, 0, 0)
return res</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func dfs(m, n, k int, visited []bool, x, y int) int {</dt><dd><p>res := 0
if check(m, n, k, visited, x, y) {</p>
<blockquote>
<div><p>visited[x*n+y] = true
res = 1 + dfs(m, n, k, visited, x+1, y) +</p>
<blockquote>
<div><p>dfs(m, n, k, visited, x-1, y) +
dfs(m, n, k, visited, x, y+1) +
dfs(m, n, k, visited, x, y-1)</p>
</div></blockquote>
</div></blockquote>
<p>}
return res</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func check(m, n, k int, visited []bool, x, y int) bool {</dt><dd><dl class="simple">
<dt>if x &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n &amp;&amp;</dt><dd><p>getDigiSum(x)+getDigiSum(y) &lt;= k &amp;&amp; visited[x*n+y] == false {
return true</p>
</dd>
</dl>
<p>}
return false</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func getDigiSum(num int) int {</dt><dd><p>sum := 0
for num &gt; 0 {</p>
<blockquote>
<div><p>sum = sum + num%10
num = num / 10</p>
</div></blockquote>
<p>}
return sum</p>
</dd>
</dl>
<p>}</p>
<p>#
func movingCount(m int, n int, k int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if k &lt; 0 || m &lt;= 0 || n &lt;= 0 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
res := 1
visited := make([][]bool, m)
for i := 0; i &lt; m; i++ {</p>
<blockquote>
<div><p>visited[i] = make([]bool, n)</p>
</div></blockquote>
<p>}
visited[0][0] = true
for i := 0; i &lt; m; i++ {</p>
<blockquote>
<div><dl>
<dt>for j := 0; j &lt; n; j++ {</dt><dd><dl>
<dt>if (i-1 &gt;= 0 &amp;&amp; visited[i-1][j] == true) || (j-1 &gt;= 0 &amp;&amp; visited[i][j-1] == true) {</dt><dd><p>value := getDigiSum(i) + getDigiSum(j)
if value &lt;= k {</p>
<blockquote>
<div><p>res++
visited[i][j] = true</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func getDigiSum(num int) int {</dt><dd><p>sum := 0
for num &gt; 0 {</p>
<blockquote>
<div><p>sum = sum + num%10
num = num / 10</p>
</div></blockquote>
<p>}
return sum</p>
</dd>
</dl>
<p>}</p>
<p>#
func movingCount(m int, n int, k int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if k &lt; 0 || m &lt;= 0 || n &lt;= 0 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
res := 0
visited := make([][]bool, m)
for i := 0; i &lt; m; i++ {</p>
<blockquote>
<div><p>visited[i] = make([]bool, n)</p>
</div></blockquote>
<p>}
visited[0][0] = true
queue := make([][2]int, 0)
queue = append(queue, [2]int{0, 0})
for len(queue) &gt; 0 {</p>
<blockquote>
<div><p>node := queue[0]
queue = queue[1:]
x := node[0]
y := node[1]
if getDigiSum(x)+getDigiSum(y) &lt;= k {</p>
<blockquote>
<div><p>res++</p>
</div></blockquote>
<p>}
if x+1 &lt; m &amp;&amp; getDigiSum(x+1)+getDigiSum(y) &lt;= k &amp;&amp; visited[x+1][y] == false {</p>
<blockquote>
<div><p>queue = append(queue, [2]int{x + 1, y})
visited[x+1][y] = true</p>
</div></blockquote>
<p>}
if x-1 &gt;= 0 &amp;&amp; getDigiSum(x-1)+getDigiSum(y) &lt;= k &amp;&amp; visited[x-1][y] == false {</p>
<blockquote>
<div><p>queue = append(queue, [2]int{x - 1, y})
visited[x-1][y] = true</p>
</div></blockquote>
<p>}
if y+1 &lt; n &amp;&amp; getDigiSum(x)+getDigiSum(y+1) &lt;= k &amp;&amp; visited[x][y+1] == false {</p>
<blockquote>
<div><p>queue = append(queue, [2]int{x, y + 1})
visited[x][y+1] = true</p>
</div></blockquote>
<p>}
if y-1 &gt;= 0 &amp;&amp; getDigiSum(x)+getDigiSum(y-1) &lt;= k &amp;&amp; visited[x][y-1] == false {</p>
<blockquote>
<div><p>queue = append(queue, [2]int{x, y - 1})
visited[x][y-1] = true</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func getDigiSum(num int) int {</dt><dd><p>sum := 0
for num &gt; 0 {</p>
<blockquote>
<div><p>sum = sum + num%10
num = num / 10</p>
</div></blockquote>
<p>}
return sum</p>
</dd>
</dl>
</div>
<div class="section" id="id159">
<h1>}<a class="headerlink" href="#id159" title="永久链接至标题">¶</a></h1>
<p>## 面试题14- I.剪绳子(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id160"><span class="problematic" id="id161">``</span></a>`
给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），
每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]*k[1]*…*k[m-1] 可能的最大乘积是多少？
例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>示例 1： 输入: 2 输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1
示例 2: 输入: 10 输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
提示：2 &lt;= n &lt;= 58
注意：本题与主站 343 题相同：<a class="reference external" href="https://leetcode-cn.com/problems/integer-break/">https://leetcode-cn.com/problems/integer-break/</a>
<a href="#id162"><span class="problematic" id="id163">``</span></a><a href="#id164"><span class="problematic" id="id165">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路               | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —————— | ———- | ———- |</div>
<div class="line">01   | 动态规划(书上方法) | O(n^2)     | O(n)       |</div>
<div class="line">02   | 贪心法             | O(1)       | O(1)       |</div>
</div>
<p><a href="#id166"><span class="problematic" id="id167">``</span></a><a href="#id168"><span class="problematic" id="id169">`</span></a>go
func cuttingRope(n int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if n &lt; 2 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
if n == 2 {</p>
<blockquote>
<div><p>return 1</p>
</div></blockquote>
<p>}
if n == 3 {</p>
<blockquote>
<div><p>return 2</p>
</div></blockquote>
<p>}
dp := make([]int, n+1)
dp[0] = 0
dp[1] = 1
dp[2] = 2
dp[3] = 3
for i := 4; i &lt;= n; i++ {</p>
<blockquote>
<div><p>max := 0
for j := 1; j &lt;= i/2; j++ {</p>
<blockquote>
<div><p>length := dp[j] * dp[i-j]
if length &gt; max {</p>
<blockquote>
<div><p>max = length</p>
</div></blockquote>
<p>}
dp[i] = max</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return dp[n]</p>
</div></blockquote>
<p>}</p>
<p>#
func cuttingRope(n int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if n &lt; 2 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
if n == 2 {</p>
<blockquote>
<div><p>return 1</p>
</div></blockquote>
<p>}
if n == 3 {</p>
<blockquote>
<div><p>return 2</p>
</div></blockquote>
<p>}
timesOf3 := n / 3
if n-timesOf3*3 == 1 {</p>
<blockquote>
<div><p>timesOf3 = timesOf3 - 1</p>
</div></blockquote>
<p>}
timesOf2 := (n - timesOf3*3) / 2
return int(math.Pow(float64(2), float64(timesOf2))) *</p>
<blockquote>
<div><p>int(math.Pow(float64(3), float64(timesOf3)))</p>
</div></blockquote>
</div></blockquote>
</div>
<div class="section" id="id170">
<h1>}<a class="headerlink" href="#id170" title="永久链接至标题">¶</a></h1>
<p>## 面试题14-II.剪绳子 II(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">给你一根长度为</span> <span class="pre">n</span> <span class="pre">的绳子，请把绳子剪成整数长度的</span> <span class="pre">m</span> <span class="pre">段（m、n都是整数，n&gt;1并且m&gt;1），</span>
<span class="pre">每段绳子的长度记为</span> <span class="pre">k[0],k[1]...k[m]</span> <span class="pre">。请问</span> <span class="pre">k[0]*k[1]*...*k[m]</span> <span class="pre">可能的最大乘积是多少？</span>
<span class="pre">例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</span>
<span class="pre">答案需要取模</span> <span class="pre">1e9+7（1000000007），如计算初始结果为：1000000008，请返回</span> <span class="pre">1。</span>
<span class="pre">示例</span> <span class="pre">1：输入:</span> <span class="pre">2</span> <span class="pre">输出:</span> <span class="pre">1</span> <span class="pre">解释:</span> <span class="pre">2</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">1,</span> <span class="pre">1</span> <span class="pre">×</span> <span class="pre">1</span> <span class="pre">=</span> <span class="pre">1</span>
<span class="pre">示例</span> <span class="pre">2:输入:</span> <span class="pre">10</span> <span class="pre">输出:</span> <span class="pre">36</span> <span class="pre">解释:</span> <span class="pre">10</span> <span class="pre">=</span> <span class="pre">3</span> <span class="pre">+</span> <span class="pre">3</span> <span class="pre">+</span> <span class="pre">4,</span> <span class="pre">3</span> <span class="pre">×</span> <span class="pre">3</span> <span class="pre">×</span> <span class="pre">4</span> <span class="pre">=</span> <span class="pre">36</span>
<span class="pre">提示：2</span> <span class="pre">&lt;=</span> <span class="pre">n</span> <span class="pre">&lt;=</span> <span class="pre">1000</span>
<span class="pre">注意：本题与主站</span> <span class="pre">343</span> <span class="pre">题相同：https://leetcode-cn.com/problems/integer-break/</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路     | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ——– | ———- | ———- |</div>
<div class="line">01   | 动态规划 | O(n)       | O(n)       |</div>
<div class="line">02   | 贪心法   | O(n)       | O(1)       |</div>
</div>
<p><a href="#id171"><span class="problematic" id="id172">``</span></a><a href="#id173"><span class="problematic" id="id174">`</span></a>go
func cuttingRope(n int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if n &lt; 2 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
if n == 2 {</p>
<blockquote>
<div><p>return 1</p>
</div></blockquote>
<p>}
if n == 3 {</p>
<blockquote>
<div><p>return 2</p>
</div></blockquote>
<p>}
timesOf3 := n / 3
if n-timesOf3*3 == 1 {</p>
<blockquote>
<div><p>timesOf3 = timesOf3 - 1</p>
</div></blockquote>
<p>}
timesOf2 := (n - timesOf3*3) / 2
return int(math.Pow(float64(2), float64(timesOf2))) *</p>
<blockquote>
<div><p>myPow3(timesOf3) % 1000000007</p>
</div></blockquote>
</div></blockquote>
<p>}</p>
<dl>
<dt>func myPow3(n int) int {</dt><dd><p>res := 1
for i := 0; i &lt; n; i++{</p>
<blockquote>
<div><p>res = (res * 3) % 1000000007</p>
</div></blockquote>
<p>}
return res</p>
</dd>
</dl>
<p>}</p>
<p>#
func cuttingRope(n int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if n &lt; 2 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
if n == 2 {</p>
<blockquote>
<div><p>return 1</p>
</div></blockquote>
<p>}
if n == 3 {</p>
<blockquote>
<div><p>return 2</p>
</div></blockquote>
<p>}
timesOf3 := n / 3
if n-timesOf3*3 == 1 {</p>
<blockquote>
<div><p>timesOf3 = timesOf3 - 1</p>
</div></blockquote>
<p>}
timesOf2 := (n - timesOf3*3) / 2
return int(math.Pow(float64(2), float64(timesOf2))) *</p>
<blockquote>
<div><p>myPow3(timesOf3) % 1000000007</p>
</div></blockquote>
</div></blockquote>
<p>}</p>
<dl>
<dt>func myPow3(n int) int {</dt><dd><p>res := 1
for i := 0; i &lt; n; i++ {</p>
<blockquote>
<div><p>res = (res * 3) % 1000000007</p>
</div></blockquote>
<p>}
return res</p>
</dd>
</dl>
</div>
<div class="section" id="id175">
<h1>}<a class="headerlink" href="#id175" title="永久链接至标题">¶</a></h1>
<p>## 面试题15.二进制中1的个数(4)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">请实现一个函数，输入一个整数，输出该数二进制表示中</span> <span class="pre">1</span> <span class="pre">的个数。</span>
<span class="pre">例如，把</span> <span class="pre">9</span> <span class="pre">表示成二进制是</span> <span class="pre">1001，有</span> <span class="pre">2</span> <span class="pre">位是</span> <span class="pre">1。因此，如果输入</span> <span class="pre">9，则该函数输出</span> <span class="pre">2。</span>
<span class="pre">示例</span> <span class="pre">1：</span> <span class="pre">输入：00000000000000000000000000001011</span> <span class="pre">输出：3</span>
<span class="pre">解释：输入的二进制串</span> <span class="pre">00000000000000000000000000001011</span> <span class="pre">中，共有三位为</span> <span class="pre">'1'。</span>
<span class="pre">示例</span> <span class="pre">2：输入：00000000000000000000000010000000</span> <span class="pre">输出：1</span>
<span class="pre">解释：输入的二进制串</span> <span class="pre">00000000000000000000000010000000</span> <span class="pre">中，共有一位为</span> <span class="pre">'1'。</span>
<span class="pre">示例</span> <span class="pre">3：输入：11111111111111111111111111111101</span> <span class="pre">输出：31</span>
<span class="pre">解释：输入的二进制串</span> <span class="pre">11111111111111111111111111111101</span> <span class="pre">中，共有</span> <span class="pre">31</span> <span class="pre">位为</span> <span class="pre">'1'。</span>
<span class="pre">注意：本题与主站</span> <span class="pre">191</span> <span class="pre">题相同：https://leetcode-cn.com/problems/number-of-1-bits/</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路                                                 | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —————————————————- | ———- | ———- |</div>
<div class="line">01   | 循环位计算                                           | O(1)       | O(1)       |</div>
<div class="line">02   | 位计算 n&amp;(n-1)，会把该整数的最右边的1变成0(书上方法) | O(1)       | O(1)       |</div>
<div class="line">03   | 内置函数                                             | O(1)       | O(1)       |</div>
<div class="line">04   | 遍历(书上方法)                                       | O(1)       | O(1)       |</div>
</div>
<p><a href="#id176"><span class="problematic" id="id177">``</span></a><a href="#id178"><span class="problematic" id="id179">`</span></a>go
func hammingWeight(num uint32) int {</p>
<blockquote>
<div><p>count := 0
for num != 0 {</p>
<blockquote>
<div><dl class="simple">
<dt>if num&amp;1 == 1 {</dt><dd><p>count++</p>
</dd>
</dl>
<p>}
num = num &gt;&gt; 1</p>
</div></blockquote>
<p>}
return count</p>
</div></blockquote>
<p>}</p>
<p>#
func hammingWeight(num uint32) int {</p>
<blockquote>
<div><p>count := 0
for num != 0 {</p>
<blockquote>
<div><p>num = num &amp; (num - 1)
count++</p>
</div></blockquote>
<p>}
return count</p>
</div></blockquote>
<p>}</p>
<p>#
func hammingWeight(num uint32) int {</p>
<blockquote>
<div><p>return strings.Count(strconv.FormatInt(int64(num), 2), “1”)
// return strings.Count(fmt.Sprintf(“%b”,num),”1”)</p>
</div></blockquote>
<p>}</p>
<p>#
func hammingWeight(num uint32) int {</p>
<blockquote>
<div><p>count := 0
flag := uint32(1)
for flag != 0{</p>
<blockquote>
<div><dl class="simple">
<dt>if num &amp; flag == flag{</dt><dd><p>count++</p>
</dd>
</dl>
<p>}
flag = flag &lt;&lt; 1</p>
</div></blockquote>
<p>}
return count</p>
</div></blockquote>
</div>
<div class="section" id="id180">
<h1>}<a class="headerlink" href="#id180" title="永久链接至标题">¶</a></h1>
<p>## 面试题16.数值的整数次方(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id181"><span class="problematic" id="id182">``</span></a>`
实现函数double Power(double base, int exponent)，求base的exponent次方。
不得使用库函数，同时不需要考虑大数问题。
示例 1:输入: 2.00000, 10 输出: 1024.00000
示例 2:输入: 2.10000, 3 输出: 9.26100
示例 3:输入: 2.00000, -2 输出: 0.25000
解释: 2-2 = 1/22 = 1/4 = 0.25
说明:</p>
<blockquote>
<div><p>-100.0 &lt; x &lt; 100.0
n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。</p>
</div></blockquote>
<p>注意：本题与主站 50 题相同：
<a class="reference external" href="https://leetcode-cn.com/problems/powx-n/">https://leetcode-cn.com/problems/powx-n/</a>
<a href="#id183"><span class="problematic" id="id184">``</span></a><a href="#id185"><span class="problematic" id="id186">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路           | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ————– | ———- | ———- |</div>
<div class="line">01   | 递归(书上方法) | O(log(n))  | O(log(n))  |</div>
<div class="line">02   | 迭代           | O(log(n))  | O(1)       |</div>
</div>
<p><a href="#id187"><span class="problematic" id="id188">``</span></a><a href="#id189"><span class="problematic" id="id190">`</span></a>go
func myPow(x float64, n int) float64 {</p>
<blockquote>
<div><dl class="simple">
<dt>if n == 0 {</dt><dd><p>return 1</p>
</dd>
</dl>
<p>}
if n == 1 {</p>
<blockquote>
<div><p>return x</p>
</div></blockquote>
<p>}
res := 1.0
if n &gt; 0 {</p>
<blockquote>
<div><p>res = myPow(x, n/2)
return res * res * myPow(x, n%2)</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>res = myPow(x, -n/2)
res = res * res * myPow(x, -n%2)
return 1 / res</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
</div>
<div class="section" id="id191">
<h1>}<a class="headerlink" href="#id191" title="永久链接至标题">¶</a></h1>
<p>## 面试题17.打印从1到最大的n位数(4)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id192"><span class="problematic" id="id193">``</span></a>`
输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。
比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。
示例 1: 输入: n = 1 输出: [1,2,3,4,5,6,7,8,9]
说明：</p>
<blockquote>
<div><p>用返回一个整数列表来代替打印
n 为正整数</p>
</div></blockquote>
<p><a href="#id194"><span class="problematic" id="id195">``</span></a><a href="#id196"><span class="problematic" id="id197">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路                  | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ——————— | ———- | ———- |</div>
<div class="line">01   | 求最大                | O(10^n)    | O(10^n)    |</div>
<div class="line">02   | 求最大                | O(10^n)    | O(10^n)    |</div>
<div class="line">03   | 递归+全排列(书上方法) | O(10^n)    | O(10^n)    |</div>
<div class="line">04   | 模拟进位(书上方法)    | O(10^n)    | O(10^n)    |</div>
</div>
<p><a href="#id198"><span class="problematic" id="id199">``</span></a><a href="#id200"><span class="problematic" id="id201">`</span></a>go
func printNumbers(n int) []int {</p>
<blockquote>
<div><p>res := make([]int, 0)
maxValue := 0
for n &gt; 0 {</p>
<blockquote>
<div><p>maxValue = maxValue*10 + 9
n–</p>
</div></blockquote>
<p>}
for i := 1; i &lt;= maxValue; i++ {</p>
<blockquote>
<div><p>res = append(res, i)</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
func printNumbers(n int) []int {</p>
<blockquote>
<div><p>res := make([]int, 0)
maxValue := 1
for i := 1; i &lt;= n; i++ {</p>
<blockquote>
<div><p>maxValue = maxValue * 10</p>
</div></blockquote>
<p>}
maxValue = maxValue - 1
for i := 1; i &lt;= maxValue; i++ {</p>
<blockquote>
<div><p>res = append(res, i)</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p># 3
var temp []string</p>
<dl>
<dt>func printNumbers(n int) []int {</dt><dd><dl class="simple">
<dt>if n &lt;= 0 {</dt><dd><p>return nil</p>
</dd>
</dl>
<p>}
temp = make([]string, 0)
arr := make([]rune, n)
for i := 0; i &lt; 10; i++ {</p>
<blockquote>
<div><p>arr[0] = rune(i + ‘0’)
dfs(arr, n, 0)</p>
</div></blockquote>
<p>}</p>
<p>res := make([]int, 0)
for i := 0; i &lt; len(temp); i++ {</p>
<blockquote>
<div><p>value, _ := strconv.Atoi(temp[i])
res = append(res, value)</p>
</div></blockquote>
<p>}
return res</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func dfs(arr []rune, n int, index int) {</dt><dd><dl>
<dt>if index == n-1 {</dt><dd><dl class="simple">
<dt>if printNum(arr) != “” {</dt><dd><p>temp = append(temp, printNum(arr))</p>
</dd>
</dl>
<p>}
return</p>
</dd>
</dl>
<p>}
for i := 0; i &lt; 10; i++ {</p>
<blockquote>
<div><p>arr[index+1] = rune(i + ‘0’)
dfs(arr, n, index+1)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func printNum(arr []rune) string {</dt><dd><p>res := “”
isBeginning := true
for i := 0; i &lt; len(arr); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if isBeginning &amp;&amp; arr[i] != ‘0’ {</dt><dd><p>isBeginning = false</p>
</dd>
</dl>
<p>}
if !isBeginning {</p>
<blockquote>
<div><p>res = res + string(arr[i])</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</dd>
</dl>
<p>}</p>
<p># 4
func printNumbers(n int) []int {</p>
<blockquote>
<div><p>res := make([]int, 0)
if n &lt;= 0 {</p>
<blockquote>
<div><p>return nil</p>
</div></blockquote>
<p>}
temp := make([]string, 0)
arr := make([]rune, n)
for i := 0; i &lt; len(arr); i++ {</p>
<blockquote>
<div><p>arr[i] = ‘0’</p>
</div></blockquote>
<p>}
for !increment(arr) {</p>
<blockquote>
<div><dl class="simple">
<dt>if printNum(arr) != “” {</dt><dd><p>temp = append(temp, printNum(arr))</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
for i := 0; i &lt; len(temp); i++ {</p>
<blockquote>
<div><p>value, _ := strconv.Atoi(temp[i])
res = append(res, value)</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func increment(arr []rune) bool {</dt><dd><p>isOverflow := false
nTakeOver := 0
for i := len(arr) - 1; i &gt;= 0; i– {</p>
<blockquote>
<div><p>sum := int(arr[i]-‘0’) + nTakeOver
if i == len(arr)-1 {</p>
<blockquote>
<div><p>sum++</p>
</div></blockquote>
<p>}
if sum &gt;= 10 {</p>
<blockquote>
<div><dl class="simple">
<dt>if i == 0 {</dt><dd><p>isOverflow = true</p>
</dd>
<dt>} else {</dt><dd><p>sum = sum - 10
nTakeOver = 1
arr[i] = rune(‘0’ + sum)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>arr[i] = rune(‘0’ + sum)
break</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return isOverflow</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func printNum(arr []rune) string {</dt><dd><p>res := “”
isBeginning := true
for i := 0; i &lt; len(arr); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if isBeginning &amp;&amp; arr[i] != ‘0’ {</dt><dd><p>isBeginning = false</p>
</dd>
</dl>
<p>}
if !isBeginning {</p>
<blockquote>
<div><p>res = res + string(arr[i])</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</dd>
</dl>
</div>
<div class="section" id="id202">
<h1>}<a class="headerlink" href="#id202" title="永久链接至标题">¶</a></h1>
<p>## 面试题18.删除链表的节点(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id203"><span class="problematic" id="id204">``</span></a>`
给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。
返回删除后的链表的头节点。
注意：此题对比原题有改动
示例 1:输入: head = [4,5,1,9], val = 5 输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.
示例 2:输入: head = [4,5,1,9], val = 1 输出: [4,5,9]
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.
说明：</p>
<blockquote>
<div><p>题目保证链表中节点的值互不相同
若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点</p>
</div></blockquote>
<p><a href="#id205"><span class="problematic" id="id206">``</span></a><a href="#id207"><span class="problematic" id="id208">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路              | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —————– | ———- | ———- |</div>
<div class="line">01   | 哨兵结点+链表遍历 | O(n)       | O(1)       |</div>
<div class="line">02   | 递归              | O(n)       | O(n)       |</div>
</div>
<p><a href="#id209"><span class="problematic" id="id210">``</span></a><a href="#id211"><span class="problematic" id="id212">`</span></a>go
func deleteNode(head <a href="#id213"><span class="problematic" id="id214">*</span></a>ListNode, val int) <a href="#id215"><span class="problematic" id="id216">*</span></a>ListNode {</p>
<blockquote>
<div><p>headPre := &amp;ListNode{Next: head}
temp := headPre
for temp.Next != nil {</p>
<blockquote>
<div><dl class="simple">
<dt>if temp.Next.Val == val {</dt><dd><p>temp.Next = temp.Next.Next
break</p>
</dd>
<dt>} else {</dt><dd><p>temp = temp.Next</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return headPre.Next</p>
</div></blockquote>
<p>}</p>
<p>#
func deleteNode(head <a href="#id217"><span class="problematic" id="id218">*</span></a>ListNode, val int) <a href="#id219"><span class="problematic" id="id220">*</span></a>ListNode {</p>
<blockquote>
<div><dl class="simple">
<dt>if head == nil {</dt><dd><p>return nil</p>
</dd>
</dl>
<p>}
head.Next = deleteNode(head.Next, val)
if head.Val == val {</p>
<blockquote>
<div><p>return head.Next</p>
</div></blockquote>
<p>}
return head</p>
</div></blockquote>
</div>
<div class="section" id="id221">
<h1>}<a class="headerlink" href="#id221" title="永久链接至标题">¶</a></h1>
<p>## 面试题19.正则表达式匹配(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id222"><span class="problematic" id="id223">``</span></a>`
请实现一个函数用来匹配包含’. ‘和’*’的正则表达式。模式中的字符’.’表示任意一个字符，
而’*’表示它前面的字符可以出现任意次（含0次）。
在本题中，匹配是指字符串的所有字符匹配整个模式。
例如，字符串”aaa”与模式”a.a”和”ab*ac*a”匹配，但与”aa.a”和”ab*a”均不匹配。</p>
<p>示例 1:输入: s = “aa” p = “a” 输出: false
解释: “a” 无法匹配 “aa” 整个字符串。
示例 2:输入: s = “aa” p = “a*” 输出: true
解释: 因为 ‘*’ 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。
因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。
示例 3:输入:s = “ab” p = “.*” 输出: true
解释: “.*” 表示可匹配零个或多个（’*’）任意字符（’.’）。
示例 4: 输入:s = “aab” p = “c*a*b” 输出: true
解释: 因为 ‘*’ 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。
示例 5: 输入: s = “mississippi” p = “mis*is*p*.” 输出: false</p>
<blockquote>
<div><p>s 可能为空，且只包含从 a-z 的小写字母。
p 可能为空，且只包含从 a-z 的小写字母以及字符 . 和 <em>，无连续的 ‘</em>’。</p>
</div></blockquote>
<p>注意：本题与主站 10 题相同：
<a class="reference external" href="https://leetcode-cn.com/problems/regular-expression-matching/">https://leetcode-cn.com/problems/regular-expression-matching/</a>
<a href="#id224"><span class="problematic" id="id225">``</span></a><a href="#id226"><span class="problematic" id="id227">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路           | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ————– | ———- | ———- |</div>
<div class="line">01   | 递归(书上方法) | O(n)       | O(n)       |</div>
<div class="line">02   | 动态规划       | O(n^2)     | O(n^2)     |</div>
</div>
<p><a href="#id228"><span class="problematic" id="id229">``</span></a><a href="#id230"><span class="problematic" id="id231">`</span></a>go
func isMatch(s string, p string) bool {</p>
<blockquote>
<div><p>return dfs(s, p, 0, 0)</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func dfs(s string, p string, i, j int) bool {</dt><dd><dl class="simple">
<dt>if i &gt;= len(s) &amp;&amp; j &gt;= len(p) {</dt><dd><p>return true</p>
</dd>
</dl>
<p>}
if i &lt;= len(s) &amp;&amp; j &gt;= len(p) {</p>
<blockquote>
<div><p>return false</p>
</div></blockquote>
<p>}
if j+1 &lt; len(p) &amp;&amp; p[j+1] == ‘*’ {</p>
<blockquote>
<div><dl class="simple">
<dt>if (i &lt; len(s) &amp;&amp; p[j] == s[i]) || (p[j] == ‘.’ &amp;&amp; i &lt; len(s)) {</dt><dd><dl class="simple">
<dt>return dfs(s, p, i+1, j+2) ||</dt><dd><p>dfs(s, p, i+1, j) ||
dfs(s, p, i, j+2)</p>
</dd>
</dl>
</dd>
<dt>} else {</dt><dd><p>return dfs(s, p, i, j+2)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
if (i &lt; len(s) &amp;&amp; s[i] == p[j]) || (p[j] == ‘.’ &amp;&amp; i &lt; len(s)) {</p>
<blockquote>
<div><p>return dfs(s, p, i+1, j+1)</p>
</div></blockquote>
<p>}
return false</p>
</dd>
</dl>
<p>}</p>
<p>#
func isMatch(s string, p string) bool {</p>
<blockquote>
<div><p>// dp[i][j]表示p[:i]能否正则匹配s[:j]
dp := make([][]bool, len(p)+1)
for i := 0; i &lt; len(p)+1; i++ {</p>
<blockquote>
<div><p>dp[i] = make([]bool, len(s)+1)</p>
</div></blockquote>
<p>}
// 1.初始化
dp[0][0] = true
for i := 2; i &lt; len(p)+1; i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if i%2 == 0 &amp;&amp; p[i-1] == ‘*’ {</dt><dd><p>dp[i][0] = dp[i-2][0]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
// 2.dp状态转移
for i := 1; i &lt; len(p)+1; i++ {</p>
<blockquote>
<div><dl>
<dt>for j := 1; j &lt; len(s)+1; j++ {</dt><dd><p>// 2.1 相同或者 .
if p[i-1] == s[j-1] || p[i-1] == ‘.’ {</p>
<blockquote>
<div><p>dp[i][j] = dp[i-1][j-1]</p>
</div></blockquote>
<dl>
<dt>} else if p[i-1] == ‘*’ {</dt><dd><dl>
<dt>if i &gt; 1 {</dt><dd><dl class="simple">
<dt>if p[i-2] == s[j-1] || p[i-2] == ‘.’ {</dt><dd><p>dp[i][j] = dp[i][j-1] || dp[i-2][j-1] || dp[i-2][j]</p>
</dd>
<dt>} else {</dt><dd><p>dp[i][j] = dp[i-2][j]</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return dp[len(p)][len(s)]</p>
</div></blockquote>
</div>
<div class="section" id="id232">
<h1>}<a class="headerlink" href="#id232" title="永久链接至标题">¶</a></h1>
<p>## 面试题20.表示数值的字符串(1)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串&quot;+100&quot;、&quot;5e2&quot;、&quot;-123&quot;、&quot;3.1416&quot;、&quot;0123&quot;都表示数值，</span>
<span class="pre">但&quot;12e&quot;、&quot;1a3.14&quot;、&quot;1.2.3&quot;、&quot;+-5&quot;、&quot;-1E-16&quot;及&quot;12e+5.4&quot;都不是。</span>
<span class="pre">注意：本题与主站</span> <span class="pre">65</span> <span class="pre">题相同：https://leetcode-cn.com/problems/valid-number/</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路                  | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ——————— | ———- | ———- |</div>
<div class="line">01   | 遍历-找规律(书上方法) | O(n)       | O(1)       |</div>
</div>
<p><a href="#id233"><span class="problematic" id="id234">``</span></a><a href="#id235"><span class="problematic" id="id236">`</span></a>go
func isNumber(s string) bool {</p>
<blockquote>
<div><p>s = strings.Trim(s, ” “)
if s == “” || len(s) == 0 || len(s) == 0 {</p>
<blockquote>
<div><p>return false</p>
</div></blockquote>
<p>}
arr := []byte(s)
i := 0
numeric := scanInteger(&amp;arr, &amp;i)
if i &lt; len(arr) &amp;&amp; arr[i] == ‘.’ {</p>
<blockquote>
<div><p>i++
numeric = scanUnsignedInteger(&amp;arr, &amp;i) || numeric</p>
</div></blockquote>
<p>}
if i &lt; len(arr) &amp;&amp; (arr[i] == ‘e’ || arr[i] == ‘E’) {</p>
<blockquote>
<div><p>i++
numeric = numeric &amp;&amp; scanInteger(&amp;arr, &amp;i)</p>
</div></blockquote>
<p>}
return numeric &amp;&amp; len(arr) == i</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func scanInteger(arr <a href="#id237"><span class="problematic" id="id238">*</span></a>[]byte, index <a href="#id239"><span class="problematic" id="id240">*</span></a>int) bool {</dt><dd><dl class="simple">
<dt>if len(<a href="#id241"><span class="problematic" id="id242">*</span></a>arr) &lt;= <a href="#id243"><span class="problematic" id="id244">*</span></a>index {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}
if (<a href="#id245"><span class="problematic" id="id246">*</span></a>arr)[<a href="#id247"><span class="problematic" id="id248">*</span></a>index] == ‘+’ || (<a href="#id249"><span class="problematic" id="id250">*</span></a>arr)[<a href="#id251"><span class="problematic" id="id252">*</span></a>index] == ‘-‘ {</p>
<blockquote>
<div><p><a href="#id253"><span class="problematic" id="id254">*</span></a>index++</p>
</div></blockquote>
<p>}
return scanUnsignedInteger(arr, index)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func scanUnsignedInteger(arr <a href="#id255"><span class="problematic" id="id256">*</span></a>[]byte, index <a href="#id257"><span class="problematic" id="id258">*</span></a>int) bool {</dt><dd><p>j := <a href="#id259"><span class="problematic" id="id260">*</span></a>index
for <a href="#id261"><span class="problematic" id="id262">*</span></a>index &lt; len(<a href="#id263"><span class="problematic" id="id264">*</span></a>arr) {</p>
<blockquote>
<div><dl class="simple">
<dt>if (<a href="#id265"><span class="problematic" id="id266">*</span></a>arr)[<a href="#id267"><span class="problematic" id="id268">*</span></a>index] &lt; ‘0’ || (<a href="#id269"><span class="problematic" id="id270">*</span></a>arr)[<a href="#id271"><span class="problematic" id="id272">*</span></a>index] &gt; ‘9’ {</dt><dd><p>break</p>
</dd>
</dl>
<p>}
<a href="#id273"><span class="problematic" id="id274">*</span></a>index++</p>
</div></blockquote>
<p>}
return j &lt; <a href="#id275"><span class="problematic" id="id276">*</span></a>index</p>
</dd>
</dl>
<p>}</p>
<p>#</p>
<p><a href="#id277"><span class="problematic" id="id278">``</span></a><a href="#id279"><span class="problematic" id="id280">`</span></a></p>
<p>## 面试题21.调整数组顺序使奇数位于偶数前面(4)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id281"><span class="problematic" id="id282">``</span></a>`
输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，
所有偶数位于数组的后半部分。
示例：输入：nums = [1,2,3,4] 输出：[1,3,2,4]
注：[3,1,2,4] 也是正确的答案之一。
提示：</p>
<blockquote>
<div><p>1 &lt;= nums.length &lt;= 50000
1 &lt;= nums[i] &lt;= 10000</p>
</div></blockquote>
<p><a href="#id283"><span class="problematic" id="id284">``</span></a><a href="#id285"><span class="problematic" id="id286">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路             | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —————- | ———- | ———- |</div>
<div class="line">01   | 双指针           | O(n)       | O(1)       |</div>
<div class="line">02   | 双指针(书上方法) | O(n)       | O(1)       |</div>
<div class="line">03   | 遍历             | O(n)       | O(n)       |</div>
<div class="line">04   | 遍历             | O(n)       | O(1)       |</div>
</div>
<p><a href="#id287"><span class="problematic" id="id288">``</span></a><a href="#id289"><span class="problematic" id="id290">`</span></a>go
func exchange(nums []int) []int {</p>
<blockquote>
<div><p>i := 0
j := len(nums) - 1
for i &lt; j {</p>
<blockquote>
<div><dl class="simple">
<dt>if nums[i]%2 == 1 {</dt><dd><p>i++</p>
</dd>
<dt>} else if nums[j]%2 == 0 {</dt><dd><p>j–</p>
</dd>
<dt>} else {</dt><dd><p>nums[i], nums[j] = nums[j], nums[i]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return nums</p>
</div></blockquote>
<p>}</p>
<p>#
func exchange(nums []int) []int {</p>
<blockquote>
<div><p>i := 0
j := len(nums) - 1
for i &lt; j {</p>
<blockquote>
<div><dl class="simple">
<dt>for i &lt; j &amp;&amp; nums[i]%2 == 1 {</dt><dd><p>i++</p>
</dd>
</dl>
<p>}
for i &lt; j &amp;&amp; nums[j]%2 == 0 {</p>
<blockquote>
<div><p>j–</p>
</div></blockquote>
<p>}
nums[i], nums[j] = nums[j], nums[i]</p>
</div></blockquote>
<p>}
return nums</p>
</div></blockquote>
<p>}</p>
<p>#
func exchange(nums []int) []int {</p>
<blockquote>
<div><p>res := make([]int, 0)
for i := 0; i &lt; len(nums); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if nums[i]%2 == 1 {</dt><dd><p>res = append(res, nums[i])</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
for i := 0; i &lt; len(nums); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if nums[i]%2 == 0 {</dt><dd><p>res = append(res, nums[i])</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
func exchange(nums []int) []int {</p>
<blockquote>
<div><p>count := 0
for i := 0; i &lt; len(nums); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if nums[i]%2 == 1 {</dt><dd><p>nums[count], nums[i] = nums[i], nums[count]
count++</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return nums</p>
</div></blockquote>
</div>
<div class="section" id="id291">
<h1>}<a class="headerlink" href="#id291" title="永久链接至标题">¶</a></h1>
<p>## 面试题22.链表中倒数第k个节点(5)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，</span>
<span class="pre">即链表的尾节点是倒数第1个节点。</span>
<span class="pre">例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。</span>
<span class="pre">这个链表的倒数第3个节点是值为4的节点。</span>
<span class="pre">示例：给定一个链表:</span> <span class="pre">1-&gt;2-&gt;3-&gt;4-&gt;5,</span> <span class="pre">和</span> <span class="pre">k</span> <span class="pre">=</span> <span class="pre">2.</span> <span class="pre">返回链表</span> <span class="pre">4-&gt;5.</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路               | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —————— | ———- | ———- |</div>
<div class="line">01   | 数组辅助           | O(n)       | O(n)       |</div>
<div class="line">02   | 快慢指针(书上方法) | O(n)       | O(1)       |</div>
<div class="line">03   | 统计+遍历          | O(n)       | P          |</div>
<div class="line">04   | 递归               | O(n)       | O(n)       |</div>
<div class="line">05   | 递归               | O(n)       | O(n)       |</div>
</div>
<p><a href="#id292"><span class="problematic" id="id293">``</span></a><a href="#id294"><span class="problematic" id="id295">`</span></a>go
func getKthFromEnd(head <a href="#id296"><span class="problematic" id="id297">*</span></a>ListNode, k int) <a href="#id298"><span class="problematic" id="id299">*</span></a>ListNode {</p>
<blockquote>
<div><p>arr := make([]*ListNode, 0)
for head != nil {</p>
<blockquote>
<div><p>arr = append(arr, head)
head = head.Next</p>
</div></blockquote>
<p>}
if len(arr) &gt;= k {</p>
<blockquote>
<div><p>return arr[len(arr)-k]</p>
</div></blockquote>
<p>}
return nil</p>
</div></blockquote>
<p>}</p>
<p>#
func getKthFromEnd(head <a href="#id300"><span class="problematic" id="id301">*</span></a>ListNode, k int) <a href="#id302"><span class="problematic" id="id303">*</span></a>ListNode {</p>
<blockquote>
<div><p>fast := head
for k &gt; 0 &amp;&amp; head != nil {</p>
<blockquote>
<div><p>fast = fast.Next
k–</p>
</div></blockquote>
<p>}
if k &gt; 0 {</p>
<blockquote>
<div><p>return nil</p>
</div></blockquote>
<p>}
slow := head
for fast != nil {</p>
<blockquote>
<div><p>fast = fast.Next
slow = slow.Next</p>
</div></blockquote>
<p>}
return slow</p>
</div></blockquote>
<p>}</p>
<p>#
func getKthFromEnd(head <a href="#id304"><span class="problematic" id="id305">*</span></a>ListNode, k int) <a href="#id306"><span class="problematic" id="id307">*</span></a>ListNode {</p>
<blockquote>
<div><p>temp := head
count := 0
for temp != nil {</p>
<blockquote>
<div><p>count++
temp = temp.Next</p>
</div></blockquote>
<p>}
if count &lt; k {</p>
<blockquote>
<div><p>return nil</p>
</div></blockquote>
<p>}
for i := 0; i &lt; count-k; i++ {</p>
<blockquote>
<div><p>head = head.Next</p>
</div></blockquote>
<p>}
return head</p>
</div></blockquote>
<p>}</p>
<p>#
func getKthFromEnd(head <a href="#id308"><span class="problematic" id="id309">*</span></a>ListNode, k int) <a href="#id310"><span class="problematic" id="id311">*</span></a>ListNode {</p>
<blockquote>
<div><p>res, count := dfs(head, k)
if count &gt; 0 {</p>
<blockquote>
<div><p>return nil</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func dfs(node <a href="#id312"><span class="problematic" id="id313">*</span></a>ListNode, k int) (<a href="#id314"><span class="problematic" id="id315">*</span></a>ListNode, int) {</dt><dd><dl class="simple">
<dt>if node == nil {</dt><dd><p>return node, k</p>
</dd>
</dl>
<p>}
next, nextValue := dfs(node.Next, k)
if nextValue &lt;= 0 {</p>
<blockquote>
<div><p>return next, nextValue</p>
</div></blockquote>
<p>}
nextValue = nextValue - 1
return node, nextValue</p>
</dd>
</dl>
<p>}</p>
<p>#
var res <a href="#id316"><span class="problematic" id="id317">*</span></a>ListNode
var count int</p>
<dl>
<dt>func getKthFromEnd(head <a href="#id318"><span class="problematic" id="id319">*</span></a>ListNode, k int) <a href="#id320"><span class="problematic" id="id321">*</span></a>ListNode {</dt><dd><dl class="simple">
<dt>if head == nil {</dt><dd><p>count = 0
return nil</p>
</dd>
</dl>
<p>}
getKthFromEnd(head.Next, k)
count++
if count == k {</p>
<blockquote>
<div><p>res = head</p>
</div></blockquote>
<p>}
return res</p>
</dd>
</dl>
</div>
<div class="section" id="id322">
<h1>}<a class="headerlink" href="#id322" title="永久链接至标题">¶</a></h1>
<p>## 面试题24.反转链表(4)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</span>
<span class="pre">示例:</span>
<span class="pre">输入:</span> <span class="pre">1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span>
<span class="pre">输出:</span> <span class="pre">5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span>
<span class="pre">限制：0</span> <span class="pre">&lt;=</span> <span class="pre">节点个数</span> <span class="pre">&lt;=</span> <span class="pre">5000</span>
<span class="pre">注意：本题与主站</span> <span class="pre">206</span> <span class="pre">题相同：https://leetcode-cn.com/problems/reverse-linked-list/</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路           | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ————– | ———- | ———- |</div>
<div class="line">01   | 递归           | O(n)       | O(n)       |</div>
<div class="line">02   | 迭代(书上方法) | O(n)       | O(1)       |</div>
<div class="line">03   | 数组辅助       | O(n)       | O(n)       |</div>
<div class="line">04   | 迭代-新建节点  | O(n)       | O(1)       |</div>
</div>
<p><a href="#id323"><span class="problematic" id="id324">``</span></a><a href="#id325"><span class="problematic" id="id326">`</span></a>go
func reverseList(head <a href="#id327"><span class="problematic" id="id328">*</span></a>ListNode) <a href="#id329"><span class="problematic" id="id330">*</span></a>ListNode {</p>
<blockquote>
<div><dl class="simple">
<dt>if head == nil || head.Next == nil {</dt><dd><p>return head</p>
</dd>
</dl>
<p>}
result := reverseList(head.Next)
head.Next.Next = head
head.Next = nil
return result</p>
</div></blockquote>
<p>}</p>
<p>#
func reverseList(head <a href="#id331"><span class="problematic" id="id332">*</span></a>ListNode) <a href="#id333"><span class="problematic" id="id334">*</span></a>ListNode {</p>
<blockquote>
<div><p>var result <a href="#id335"><span class="problematic" id="id336">*</span></a>ListNode
var temp <a href="#id337"><span class="problematic" id="id338">*</span></a>ListNode
for head != nil {</p>
<blockquote>
<div><p>temp = head.Next
head.Next = result
result = head
head = temp</p>
</div></blockquote>
<p>}
return result</p>
</div></blockquote>
<p>}</p>
<p>#
func reverseList(head <a href="#id339"><span class="problematic" id="id340">*</span></a>ListNode) <a href="#id341"><span class="problematic" id="id342">*</span></a>ListNode {</p>
<blockquote>
<div><p>result := &amp;ListNode{}
arr := make([]*ListNode, 0)
for head != nil {</p>
<blockquote>
<div><p>arr = append(arr, head)
head = head.Next</p>
</div></blockquote>
<p>}
temp := result
for i := len(arr) - 1; i &gt;= 0; i– {</p>
<blockquote>
<div><p>arr[i].Next = nil
temp.Next = arr[i]
temp = temp.Next</p>
</div></blockquote>
<p>}
return result.Next</p>
</div></blockquote>
<p>}</p>
<p>#
func reverseList(head <a href="#id343"><span class="problematic" id="id344">*</span></a>ListNode) <a href="#id345"><span class="problematic" id="id346">*</span></a>ListNode {</p>
<blockquote>
<div><p>var res <a href="#id347"><span class="problematic" id="id348">*</span></a>ListNode
for {</p>
<blockquote>
<div><dl class="simple">
<dt>if head == nil {</dt><dd><p>break</p>
</dd>
</dl>
<p>}
res = &amp;ListNode{head.Val, res}
head = head.Next</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
</div>
<div class="section" id="id349">
<h1>}<a class="headerlink" href="#id349" title="永久链接至标题">¶</a></h1>
<p>## 面试题25.合并两个排序的链表(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</span>
<span class="pre">示例1：输入：1-&gt;2-&gt;4,</span> <span class="pre">1-&gt;3-&gt;4</span> <span class="pre">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span>
<span class="pre">限制：0</span> <span class="pre">&lt;=</span> <span class="pre">链表长度</span> <span class="pre">&lt;=</span> <span class="pre">1000</span>
<span class="pre">注意：本题与主站</span> <span class="pre">21</span> <span class="pre">题相同：https://leetcode-cn.com/problems/merge-two-sorted-lists/</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路           | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ————– | ———- | ———- |</div>
<div class="line">01   | 迭代遍历       | O(n)       | O(1)       |</div>
<div class="line">02   | 递归(书上方法) | O(n)       | O(n)       |</div>
<div class="line">03   | 迭代           | O(n)       | O(1)       |</div>
</div>
<p><a href="#id350"><span class="problematic" id="id351">``</span></a><a href="#id352"><span class="problematic" id="id353">`</span></a>go
func mergeTwoLists(l1 <a href="#id354"><span class="problematic" id="id355">*</span></a>ListNode, l2 <a href="#id356"><span class="problematic" id="id357">*</span></a>ListNode) <a href="#id358"><span class="problematic" id="id359">*</span></a>ListNode {</p>
<blockquote>
<div><dl class="simple">
<dt>if l1 == nil {</dt><dd><p>return l2</p>
</dd>
</dl>
<p>}
if l2 == nil {</p>
<blockquote>
<div><p>return l1</p>
</div></blockquote>
<p>}</p>
<p>var head, node <a href="#id360"><span class="problematic" id="id361">*</span></a>ListNode
if l1.Val &lt; l2.Val {</p>
<blockquote>
<div><p>head = l1
node = l1
l1 = l1.Next</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>head = l2
node = l2
l2 = l2.Next</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>for l1 != nil &amp;&amp; l2 != nil {</dt><dd><dl class="simple">
<dt>if l1.Val &lt; l2.Val {</dt><dd><p>node.Next = l1
l1 = l1.Next</p>
</dd>
<dt>} else {</dt><dd><p>node.Next = l2
l2 = l2.Next</p>
</dd>
</dl>
<p>}
node = node.Next</p>
</dd>
</dl>
<p>}
if l1 != nil {</p>
<blockquote>
<div><p>node.Next = l1</p>
</div></blockquote>
<p>}
if l2 != nil {</p>
<blockquote>
<div><p>node.Next = l2</p>
</div></blockquote>
<p>}
return head</p>
</div></blockquote>
<p>}</p>
<p>#
func mergeTwoLists(l1 <a href="#id362"><span class="problematic" id="id363">*</span></a>ListNode, l2 <a href="#id364"><span class="problematic" id="id365">*</span></a>ListNode) <a href="#id366"><span class="problematic" id="id367">*</span></a>ListNode {</p>
<blockquote>
<div><dl class="simple">
<dt>if l1 == nil {</dt><dd><p>return l2</p>
</dd>
</dl>
<p>}
if l2 == nil {</p>
<blockquote>
<div><p>return l1</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>if l1.Val &lt; l2.Val {</dt><dd><p>l1.Next = mergeTwoLists(l1.Next, l2)
return l1</p>
</dd>
<dt>} else {</dt><dd><p>l2.Next = mergeTwoLists(l1, l2.Next)
return l2</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>#
func mergeTwoLists(l1 <a href="#id368"><span class="problematic" id="id369">*</span></a>ListNode, l2 <a href="#id370"><span class="problematic" id="id371">*</span></a>ListNode) <a href="#id372"><span class="problematic" id="id373">*</span></a>ListNode {</p>
<blockquote>
<div><p>res := &amp;ListNode{}
temp := res
for l1 != nil &amp;&amp; l2 != nil {</p>
<blockquote>
<div><dl class="simple">
<dt>if l1.Val &lt; l2.Val {</dt><dd><p>temp.Next = l1
l1 = l1.Next</p>
</dd>
<dt>} else {</dt><dd><p>temp.Next = l2
l2 = l2.Next</p>
</dd>
</dl>
<p>}
temp = temp.Next</p>
</div></blockquote>
<p>}
if l1 != nil {</p>
<blockquote>
<div><p>temp.Next = l1</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>temp.Next = l2</p>
</dd>
</dl>
<p>}
return res.Next</p>
</div></blockquote>
</div>
<div class="section" id="id374">
<h1>}<a class="headerlink" href="#id374" title="永久链接至标题">¶</a></h1>
<p>## 面试题26.树的子结构(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id375"><span class="problematic" id="id376">``</span></a>`
输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)
B是A的子结构， 即 A中有出现和B相同的结构和节点值。
例如:给定的树 A:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><p>3</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<p>4   5</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<p>1   2</p>
</div></blockquote>
<dl>
<dt>给定的树 B：</dt><dd><blockquote>
<div><blockquote>
<div><p>4</p>
</div></blockquote>
<p>/</p>
</div></blockquote>
<p>1</p>
</dd>
</dl>
<p>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。
示例 1：输入：A = [1,2,3], B = [3,1]输出：false
示例 2：输入：A = [3,4,5,1,2], B = [4,1]输出：true
限制：0 &lt;= 节点个数 &lt;= 10000
<a href="#id377"><span class="problematic" id="id378">``</span></a><a href="#id379"><span class="problematic" id="id380">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路           | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ————– | ———- | ———- |</div>
<div class="line">01   | 递归(书上方法) | O(n^2)     | O(log(n))  |</div>
<div class="line">02   | 迭代+递归      | O(n^2)     | O(n)       |</div>
</div>
<p><a href="#id381"><span class="problematic" id="id382">``</span></a><a href="#id383"><span class="problematic" id="id384">`</span></a>go
func isSubStructure(A <a href="#id385"><span class="problematic" id="id386">*</span></a>TreeNode, B <a href="#id387"><span class="problematic" id="id388">*</span></a>TreeNode) bool {</p>
<blockquote>
<div><dl class="simple">
<dt>if A == nil || B == nil {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}
return dfs(A, B) || isSubStructure(A.Left, B) || isSubStructure(A.Right, B)</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func dfs(A <a href="#id389"><span class="problematic" id="id390">*</span></a>TreeNode, B <a href="#id391"><span class="problematic" id="id392">*</span></a>TreeNode) bool {</dt><dd><dl class="simple">
<dt>if B == nil {</dt><dd><p>return true</p>
</dd>
</dl>
<p>}
if A == nil {</p>
<blockquote>
<div><p>return false</p>
</div></blockquote>
<p>}
return dfs(A.Left, B.Left) &amp;&amp; dfs(A.Right, B.Right) &amp;&amp; A.Val == B.Val</p>
</dd>
</dl>
<p>}</p>
<p>#
func isSubStructure(A <a href="#id393"><span class="problematic" id="id394">*</span></a>TreeNode, B <a href="#id395"><span class="problematic" id="id396">*</span></a>TreeNode) bool {</p>
<blockquote>
<div><dl class="simple">
<dt>if A == nil || B == nil {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}</p>
<p>res := false
list := make([]*TreeNode, 0)
list = append(list, A)
for len(list) &gt; 0 {</p>
<blockquote>
<div><p>node := list[0]
list = list[1:]
if node.Val == B.Val {</p>
<blockquote>
<div><p>res = dfs(node, B)
if res == true {</p>
<blockquote>
<div><p>return true</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
if node.Left != nil {</p>
<blockquote>
<div><p>list = append(list, node.Left)</p>
</div></blockquote>
<p>}
if node.Right != nil {</p>
<blockquote>
<div><p>list = append(list, node.Right)</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func dfs(A <a href="#id397"><span class="problematic" id="id398">*</span></a>TreeNode, B <a href="#id399"><span class="problematic" id="id400">*</span></a>TreeNode) bool {</dt><dd><p>fmt.Println(A, B)
if B == nil {</p>
<blockquote>
<div><p>return true</p>
</div></blockquote>
<p>}
if A == nil {</p>
<blockquote>
<div><p>return false</p>
</div></blockquote>
<p>}
return dfs(A.Left, B.Left) &amp;&amp; dfs(A.Right, B.Right) &amp;&amp; A.Val == B.Val</p>
</dd>
</dl>
</div>
<div class="section" id="id401">
<h1>}<a class="headerlink" href="#id401" title="永久链接至标题">¶</a></h1>
<p>## 面试题27.二叉树的镜像(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id402"><span class="problematic" id="id403">``</span></a>`
请完成一个函数，输入一个二叉树，该函数输出它的镜像。
例如输入：</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><p>4</p>
</div></blockquote>
<p>/   </p>
</div></blockquote>
<p>2     7</p>
</div></blockquote>
<p>/   / </p>
</div></blockquote>
<p>1   3 6   9
镜像输出：</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><p>4</p>
</div></blockquote>
<p>/   </p>
</div></blockquote>
<p>7     2</p>
</div></blockquote>
<p>/   / </p>
</div></blockquote>
<p>9   6 3   1
示例 1：输入：root = [4,2,7,1,3,6,9] 输出：[4,7,2,9,6,3,1]
限制：0 &lt;= 节点个数 &lt;= 1000
注意：本题与主站 226 题相同：<a class="reference external" href="https://leetcode-cn.com/problems/invert-binary-tree/">https://leetcode-cn.com/problems/invert-binary-tree/</a>
<a href="#id404"><span class="problematic" id="id405">``</span></a><a href="#id406"><span class="problematic" id="id407">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路           | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ————– | ———- | ———- |</div>
<div class="line">01   | 递归(书上方法) | O(n)       | O(n)       |</div>
<div class="line">02   | 迭代           | O(n)       | O(n)       |</div>
</div>
<p><a href="#id408"><span class="problematic" id="id409">``</span></a><a href="#id410"><span class="problematic" id="id411">`</span></a>go
func mirrorTree(root <a href="#id412"><span class="problematic" id="id413">*</span></a>TreeNode) <a href="#id414"><span class="problematic" id="id415">*</span></a>TreeNode {</p>
<blockquote>
<div><dl class="simple">
<dt>if root == nil || (root.Left == nil &amp;&amp; root.Right == nil) {</dt><dd><p>return root</p>
</dd>
</dl>
<p>}
root.Left, root.Right = mirrorTree(root.Right), mirrorTree(root.Left)
return root</p>
</div></blockquote>
<p>}</p>
<p>#
func mirrorTree(root <a href="#id416"><span class="problematic" id="id417">*</span></a>TreeNode) <a href="#id418"><span class="problematic" id="id419">*</span></a>TreeNode {</p>
<blockquote>
<div><dl class="simple">
<dt>if root == nil {</dt><dd><p>return root</p>
</dd>
</dl>
<p>}
var queue []*TreeNode
queue = append(queue, root)
for len(queue) &gt; 0 {</p>
<blockquote>
<div><p>node := queue[0]
queue = queue[1:]
node.Left, node.Right = node.Right, node.Left
if node.Left != nil {</p>
<blockquote>
<div><p>queue = append(queue, node.Left)</p>
</div></blockquote>
<p>}
if node.Right != nil {</p>
<blockquote>
<div><p>queue = append(queue, node.Right)</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return root</p>
</div></blockquote>
</div>
<div class="section" id="id420">
<h1>}<a class="headerlink" href="#id420" title="永久链接至标题">¶</a></h1>
<p>## 面试题28.对称的二叉树(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id421"><span class="problematic" id="id422">``</span></a>`
请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。
例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><p>1</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<p>2   2</p>
</div></blockquote>
<p>/ / </p>
</div></blockquote>
<p>3  4 4  3
但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>1</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<dl class="simple">
<dt>2   2</dt><dd><p>  3    3</p>
</dd>
</dl>
</div></blockquote>
<p>示例 1：输入：root = [1,2,2,3,4,4,3] 输出：true
示例 2：输入：root = [1,2,2,null,3,null,3] 输出：false
限制：0 &lt;= 节点个数 &lt;= 1000
注意：本题与主站 101 题相同：<a class="reference external" href="https://leetcode-cn.com/problems/symmetric-tree/">https://leetcode-cn.com/problems/symmetric-tree/</a>
<a href="#id423"><span class="problematic" id="id424">``</span></a><a href="#id425"><span class="problematic" id="id426">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路           | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ————– | ———- | ———- |</div>
<div class="line">01   | 递归(书上方法) | O(n)       | O(n)       |</div>
<div class="line">02   | 迭代           | O(n)       | O(n)       |</div>
</div>
<p><a href="#id427"><span class="problematic" id="id428">``</span></a><a href="#id429"><span class="problematic" id="id430">`</span></a>go
func isSymmetric(root <a href="#id431"><span class="problematic" id="id432">*</span></a>TreeNode) bool {</p>
<blockquote>
<div><dl class="simple">
<dt>if root == nil {</dt><dd><p>return true</p>
</dd>
</dl>
<p>}
return recur(root.Left, root.Right)</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func recur(left, right <a href="#id433"><span class="problematic" id="id434">*</span></a>TreeNode) bool {</dt><dd><dl class="simple">
<dt>if left == nil &amp;&amp; right == nil {</dt><dd><p>return true</p>
</dd>
</dl>
<p>}
if left == nil || right == nil {</p>
<blockquote>
<div><p>return false</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>return left.Val == right.Val &amp;&amp;</dt><dd><p>recur(left.Left, right.Right) &amp;&amp;
recur(left.Right, right.Left)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>#
func isSymmetric(root <a href="#id435"><span class="problematic" id="id436">*</span></a>TreeNode) bool {</p>
<blockquote>
<div><p>leftQ := make([]*TreeNode, 0)
rightQ := make([]*TreeNode, 0)
leftQ = append(leftQ, root)
rightQ = append(rightQ, root)</p>
<dl>
<dt>for len(leftQ) != 0 &amp;&amp; len(rightQ) != 0 {</dt><dd><p>leftCur, rightCur := leftQ[0], rightQ[0]
leftQ, rightQ = leftQ[1:], rightQ[1:]</p>
<dl class="simple">
<dt>if leftCur == nil &amp;&amp; rightCur == nil {</dt><dd><p>continue</p>
</dd>
<dt>} else if leftCur != nil &amp;&amp; rightCur != nil &amp;&amp; leftCur.Val == rightCur.Val {</dt><dd><p>leftQ = append(leftQ, leftCur.Left, leftCur.Right)
rightQ = append(rightQ, rightCur.Right, rightCur.Left)</p>
</dd>
<dt>} else {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>if len(leftQ) == 0 &amp;&amp; len(rightQ) == 0 {</dt><dd><p>return true</p>
</dd>
<dt>} else {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
</div>
<div class="section" id="id437">
<h1>}<a class="headerlink" href="#id437" title="永久链接至标题">¶</a></h1>
<p>## 面试题29.顺时针打印矩阵(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</span>
<span class="pre">示例</span> <span class="pre">1：输入：matrix</span> <span class="pre">=</span> <span class="pre">[[1,2,3],[4,5,6],[7,8,9]]</span> <span class="pre">输出：[1,2,3,6,9,8,7,4,5]</span>
<span class="pre">示例</span> <span class="pre">2：输入：matrix</span> <span class="pre">=</span> <span class="pre">[[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span> <span class="pre">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span>
<span class="pre">限制：0</span> <span class="pre">&lt;=</span> <span class="pre">matrix.length</span> <span class="pre">&lt;=</span> <span class="pre">100</span>&#160; <span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">matrix[i].length</span> <span class="pre">&lt;=</span> <span class="pre">100</span>
<span class="pre">注意：本题与主站</span> <span class="pre">54</span> <span class="pre">题相同：https://leetcode-cn.com/problems/spiral-matrix/</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路           | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ————– | ———- | ———- |</div>
<div class="line">01   | 遍历(书上方法) | O(n^2)     | O(n^2)     |</div>
<div class="line">02   | 遍历           | O(n^2)     | O(n^2)     |</div>
</div>
<p><a href="#id438"><span class="problematic" id="id439">``</span></a><a href="#id440"><span class="problematic" id="id441">`</span></a>go
var res []int</p>
<dl>
<dt>func spiralOrder(matrix [][]int) []int {</dt><dd><p>res = make([]int, 0)
rows := len(matrix)
if rows == 0 {</p>
<blockquote>
<div><p>return res</p>
</div></blockquote>
<p>}
cols := len(matrix[0])
if cols == 0 {</p>
<blockquote>
<div><p>return res</p>
</div></blockquote>
<p>}
start := 0
for cols &gt; start*2 &amp;&amp; rows &gt; start*2 {</p>
<blockquote>
<div><p>printCircle(matrix, cols, rows, start)
start++</p>
</div></blockquote>
<p>}
return res</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func printCircle(matrix [][]int, cols, rows, start int) {</dt><dd><p>x := cols - 1 - start
y := rows - 1 - start
// 左到右
for i := start; i &lt;= x; i++ {</p>
<blockquote>
<div><p>res = append(res, matrix[start][i])</p>
</div></blockquote>
<p>}
// 上到下
if start &lt; y {</p>
<blockquote>
<div><dl class="simple">
<dt>for i := start + 1; i &lt;= y; i++ {</dt><dd><p>res = append(res, matrix[i][x])</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
// 右到左
if start &lt; x &amp;&amp; start &lt; y {</p>
<blockquote>
<div><dl class="simple">
<dt>for i := x - 1; i &gt;= start; i– {</dt><dd><p>res = append(res, matrix[y][i])</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
// 下到上
if start &lt; x &amp;&amp; start &lt; y-1 {</p>
<blockquote>
<div><dl class="simple">
<dt>for i := y - 1; i &gt;= start+1; i– {</dt><dd><p>res = append(res, matrix[i][start])</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>#
func spiralOrder(matrix [][]int) []int {</p>
<blockquote>
<div><p>res := make([]int, 0)
rows := len(matrix)
if rows == 0 {</p>
<blockquote>
<div><p>return res</p>
</div></blockquote>
<p>}
cols := len(matrix[0])
if cols == 0 {</p>
<blockquote>
<div><p>return res</p>
</div></blockquote>
<p>}
x1, x2, y1, y2 := 0, rows-1, 0, cols-1
direct := 0
for x1 &lt;= x2 &amp;&amp; y1 &lt;= y2 {</p>
<blockquote>
<div><p>direct = (direct + 4) % 4
if direct == 0 {</p>
<blockquote>
<div><dl class="simple">
<dt>for i := y1; i &lt;= y2; i++ {</dt><dd><p>res = append(res, matrix[x1][i])</p>
</dd>
</dl>
<p>}
x1++</p>
</div></blockquote>
<dl>
<dt>} else if direct == 1 {</dt><dd><dl class="simple">
<dt>for i := x1; i &lt;= x2; i++ {</dt><dd><p>res = append(res, matrix[i][y2])</p>
</dd>
</dl>
<p>}
y2–</p>
</dd>
<dt>} else if direct == 2 {</dt><dd><dl class="simple">
<dt>for i := y2; i &gt;= y1; i– {</dt><dd><p>res = append(res, matrix[x2][i])</p>
</dd>
</dl>
<p>}
x2–</p>
</dd>
<dt>} else if direct == 3 {</dt><dd><dl class="simple">
<dt>for i := x2; i &gt;= x1; i– {</dt><dd><p>res = append(res, matrix[i][y1])</p>
</dd>
</dl>
<p>}
y1++</p>
</dd>
</dl>
<p>}
direct++</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
</div>
<div class="section" id="id442">
<h1>}<a class="headerlink" href="#id442" title="永久链接至标题">¶</a></h1>
<p>## 面试题30.包含min函数的栈(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id443"><span class="problematic" id="id444">``</span></a>`
定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，
调用 min、push 及 pop 的时间复杂度都是 O(1)。
示例:
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.min();   –&gt; 返回 -3.
minStack.pop();
minStack.top();      –&gt; 返回 0.
minStack.min();   –&gt; 返回 -2.
提示：</p>
<blockquote>
<div><p>各函数的调用总次数不超过 20000 次</p>
</div></blockquote>
<p>注意：本题与主站 155 题相同：<a class="reference external" href="https://leetcode-cn.com/problems/min-stack/">https://leetcode-cn.com/problems/min-stack/</a>
<a href="#id445"><span class="problematic" id="id446">``</span></a><a href="#id447"><span class="problematic" id="id448">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路                                               | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ————————————————– | ———- | ———- |</div>
<div class="line">01   | 使用数组模拟栈，保存数据的时候同时保存当前的最小值 | O(1)       | O(n)       |</div>
<div class="line">02   | 使用双栈(书上方法)                                 | O(1)       | O(n)       |</div>
</div>
<p><a href="#id449"><span class="problematic" id="id450">``</span></a><a href="#id451"><span class="problematic" id="id452">`</span></a>go
type item struct {</p>
<blockquote>
<div><p>min, x int</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>type MinStack struct {</dt><dd><p>stack []item</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>func Constructor() MinStack {</dt><dd><p>return MinStack{}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func (m <a href="#id453"><span class="problematic" id="id454">*</span></a>MinStack) Push(x int) {</dt><dd><p>min := x
if len(m.stack) &gt; 0 &amp;&amp; m.Min() &lt; x {</p>
<blockquote>
<div><p>min = m.Min()</p>
</div></blockquote>
<p>}
m.stack = append(m.stack, item{</p>
<blockquote>
<div><p>min: min,
x:   x,</p>
</div></blockquote>
<p>})</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>func (m <a href="#id455"><span class="problematic" id="id456">*</span></a>MinStack) Pop() {</dt><dd><p>m.stack = m.stack[:len(m.stack)-1]</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func (m <a href="#id457"><span class="problematic" id="id458">*</span></a>MinStack) Top() int {</dt><dd><dl class="simple">
<dt>if len(m.stack) == 0 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
return m.stack[len(m.stack)-1].x</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func (m <a href="#id459"><span class="problematic" id="id460">*</span></a>MinStack) Min() int {</dt><dd><dl class="simple">
<dt>if len(m.stack) == 0 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
return m.stack[len(m.stack)-1].min</p>
</dd>
</dl>
<p>}</p>
<p>#
type MinStack struct {</p>
<blockquote>
<div><p>data []int
min  []int</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>func Constructor() MinStack {</dt><dd><p>return MinStack{[]int{}, []int{}}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func (m <a href="#id461"><span class="problematic" id="id462">*</span></a>MinStack) Push(x int) {</dt><dd><dl class="simple">
<dt>if len(m.data) == 0 || x &lt;= m.Min() {</dt><dd><p>m.min = append(m.min, x)</p>
</dd>
</dl>
<p>}
m.data = append(m.data, x)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func (m <a href="#id463"><span class="problematic" id="id464">*</span></a>MinStack) Pop() {</dt><dd><p>x := m.data[len(m.data)-1]
m.data = m.data[:len(m.data)-1]
if x == m.Min() {</p>
<blockquote>
<div><p>m.min = m.min[:len(m.min)-1]</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func (m <a href="#id465"><span class="problematic" id="id466">*</span></a>MinStack) Top() int {</dt><dd><dl class="simple">
<dt>if len(m.data) == 0 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
return m.data[len(m.data)-1]</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>func (m <a href="#id467"><span class="problematic" id="id468">*</span></a>MinStack) Min() int {</dt><dd><p>return m.min[len(m.min)-1]</p>
</dd>
</dl>
</div>
<div class="section" id="id469">
<h1>}<a class="headerlink" href="#id469" title="永久链接至标题">¶</a></h1>
<p>## 面试题31.栈的压入弹出序列(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id470"><span class="problematic" id="id471">``</span></a>`
输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。
假设压入栈的所有数字均不相等。
例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，
但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。
示例 1：输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1] 输出：true
解释：我们可以按以下顺序执行：
push(1), push(2), push(3), push(4), pop() -&gt; 4,
push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1
示例 2：输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2] 输出：false
解释：1 不能在 2 之前弹出。
提示：</p>
<blockquote>
<div><p>0 &lt;= pushed.length == popped.length &lt;= 1000
0 &lt;= pushed[i], popped[i] &lt; 1000
pushed 是 popped 的排列。</p>
</div></blockquote>
<p>注意：本题与主站 946 题相同：<a class="reference external" href="https://leetcode-cn.com/problems/validate-stack-sequences/">https://leetcode-cn.com/problems/validate-stack-sequences/</a>
<a href="#id472"><span class="problematic" id="id473">``</span></a><a href="#id474"><span class="problematic" id="id475">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路             | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —————- | ———- | ———- |</div>
<div class="line">01   | 栈辅助           | O(n)       | O(n)       |</div>
<div class="line">02   | 栈辅助(书上方法) | O(n)       | O(n)       |</div>
</div>
<p><a href="#id476"><span class="problematic" id="id477">``</span></a><a href="#id478"><span class="problematic" id="id479">`</span></a>go
func validateStackSequences(pushed []int, popped []int) bool {</p>
<blockquote>
<div><p>stack := make([]int, 0)
j := 0
for i := 0; i &lt; len(pushed); i++ {</p>
<blockquote>
<div><p>stack = append(stack, pushed[i])
for len(stack) &gt; 0 &amp;&amp; stack[len(stack)-1] == popped[j] {</p>
<blockquote>
<div><p>stack = stack[:len(stack)-1]
j++</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
if len(stack) == 0 {</p>
<blockquote>
<div><p>return true</p>
</div></blockquote>
<p>}
return false</p>
</div></blockquote>
<p>}</p>
<p>#
func validateStackSequences(pushed []int, popped []int) bool {</p>
<blockquote>
<div><p>stack := make([]int, 0)
res := false
i := 0
j := 0
for j &lt; len(popped) {</p>
<blockquote>
<div><dl>
<dt>for len(stack) == 0 || stack[len(stack)-1] != popped[j] {</dt><dd><dl class="simple">
<dt>if i == len(pushed) {</dt><dd><p>break</p>
</dd>
</dl>
<p>}
stack = append(stack, pushed[i])
i++</p>
</dd>
</dl>
<p>}
if stack[len(stack)-1] != popped[j] {</p>
<blockquote>
<div><p>break</p>
</div></blockquote>
<p>}
stack = stack[:len(stack)-1]
j++</p>
</div></blockquote>
<p>}
if len(stack) == 0 &amp;&amp; j == len(popped) {</p>
<blockquote>
<div><p>res = true</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
</div>
<div class="section" id="id480">
<h1>}<a class="headerlink" href="#id480" title="永久链接至标题">¶</a></h1>
<p>## 面试题32-I.从上到下打印二叉树(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id481"><span class="problematic" id="id482">``</span></a>`
从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。
例如:给定二叉树: [3,9,20,null,null,15,7],</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>3</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<dl>
<dt>9  20</dt><dd><blockquote>
<div><p>/  </p>
</div></blockquote>
<p>15   7</p>
</dd>
</dl>
</div></blockquote>
<p>返回：[3,9,20,15,7]
提示：节点总数 &lt;= 1000
<a href="#id483"><span class="problematic" id="id484">``</span></a><a href="#id485"><span class="problematic" id="id486">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路               | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —————— | ———- | ———- |</div>
<div class="line">01   | 层序遍历(书上方法) | O(n)       | O(n)       |</div>
<div class="line">02   | 递归               | O(n)       | O(n)       |</div>
</div>
<p><a href="#id487"><span class="problematic" id="id488">``</span></a><a href="#id489"><span class="problematic" id="id490">`</span></a>go
func levelOrder(root <a href="#id491"><span class="problematic" id="id492">*</span></a>TreeNode) []int {</p>
<blockquote>
<div><p>res := make([]int, 0)
if root == nil {</p>
<blockquote>
<div><p>return res</p>
</div></blockquote>
<p>}
list := make([]*TreeNode, 0)
list = append(list, root)
for len(list) &gt; 0 {</p>
<blockquote>
<div><p>length := len(list)
for i := 0; i &lt; length; i++ {</p>
<blockquote>
<div><p>node := list[i]
res = append(res, node.Val)
if node.Left != nil {</p>
<blockquote>
<div><p>list = append(list, node.Left)</p>
</div></blockquote>
<p>}
if node.Right != nil {</p>
<blockquote>
<div><p>list = append(list, node.Right)</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
list = list[length:]</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
func levelOrder(root <a href="#id493"><span class="problematic" id="id494">*</span></a>TreeNode) []int {</p>
<blockquote>
<div><p>res := make([]int, 0)
if root == nil {</p>
<blockquote>
<div><p>return res</p>
</div></blockquote>
<p>}
arr := levelArr(root)
for i := 0; i &lt; len(arr); i++ {</p>
<blockquote>
<div><p>res = append(res, arr[i]…)</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>func levelArr(root <a href="#id495"><span class="problematic" id="id496">*</span></a>TreeNode) [][]int {</dt><dd><p>temp := make([][]int, 0)
dfs(root, &amp;temp, 0)
return temp</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func dfs(root <a href="#id497"><span class="problematic" id="id498">*</span></a>TreeNode, temp <a href="#id499"><span class="problematic" id="id500">*</span></a>[][]int, level int) {</dt><dd><dl class="simple">
<dt>if root == nil {</dt><dd><p>return</p>
</dd>
</dl>
<p>}
if len(<a href="#id501"><span class="problematic" id="id502">*</span></a>temp)-1 &lt; level {</p>
<blockquote>
<div><p><a href="#id503"><span class="problematic" id="id504">*</span></a>temp = append(<a href="#id505"><span class="problematic" id="id506">*</span></a>temp, make([]int, 0))</p>
</div></blockquote>
<p>}
(<a href="#id507"><span class="problematic" id="id508">*</span></a>temp)[level] = append((<a href="#id509"><span class="problematic" id="id510">*</span></a>temp)[level], root.Val)
level = level + 1
dfs(root.Left, temp, level)
dfs(root.Right, temp, level)</p>
</dd>
</dl>
</div>
<div class="section" id="id511">
<h1>}<a class="headerlink" href="#id511" title="永久链接至标题">¶</a></h1>
<p>## 面试题32-II.从上到下打印二叉树II(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id512"><span class="problematic" id="id513">``</span></a>`
从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。
例如:
给定二叉树: [3,9,20,null,null,15,7],</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>3</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<dl>
<dt>9  20</dt><dd><blockquote>
<div><p>/  </p>
</div></blockquote>
<p>15   7</p>
</dd>
</dl>
</div></blockquote>
<p>返回其层次遍历结果：
[</p>
<blockquote>
<div><p>[3],
[9,20],
[15,7]</p>
</div></blockquote>
<p>]
提示：节点总数 &lt;= 1000
注意：本题与主站 102 题相同：
<a class="reference external" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">https://leetcode-cn.com/problems/binary-tree-level-order-traversal/</a>
<a href="#id514"><span class="problematic" id="id515">``</span></a><a href="#id516"><span class="problematic" id="id517">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路               | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —————— | ———- | ———- |</div>
<div class="line">01   | 层序遍历(书上方法) | O(n)       | O(n)       |</div>
<div class="line">02   | 递归               | O(n)       | O(n)       |</div>
</div>
<p><a href="#id518"><span class="problematic" id="id519">``</span></a><a href="#id520"><span class="problematic" id="id521">`</span></a>go
func levelOrder(root <a href="#id522"><span class="problematic" id="id523">*</span></a>TreeNode) [][]int {</p>
<blockquote>
<div><p>res := make([][]int, 0)
if root == nil {</p>
<blockquote>
<div><p>return res</p>
</div></blockquote>
<p>}
list := make([]*TreeNode, 0)
list = append(list, root)
for len(list) &gt; 0 {</p>
<blockquote>
<div><p>length := len(list)
temp := make([]int,0)
for i := 0; i &lt; length; i++ {</p>
<blockquote>
<div><p>node := list[i]
temp = append(temp, node.Val)
if node.Left != nil {</p>
<blockquote>
<div><p>list = append(list, node.Left)</p>
</div></blockquote>
<p>}
if node.Right != nil {</p>
<blockquote>
<div><p>list = append(list, node.Right)</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
list = list[length:]
res = append(res, temp)</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
func levelOrder(root <a href="#id524"><span class="problematic" id="id525">*</span></a>TreeNode) [][]int {</p>
<blockquote>
<div><p>res := make([][]int, 0)
if root == nil {</p>
<blockquote>
<div><p>return res</p>
</div></blockquote>
<p>}
return levelArr(root)</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>func levelArr(root <a href="#id526"><span class="problematic" id="id527">*</span></a>TreeNode) [][]int {</dt><dd><p>temp := make([][]int, 0)
dfs(root, &amp;temp, 0)
return temp</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func dfs(root <a href="#id528"><span class="problematic" id="id529">*</span></a>TreeNode, temp <a href="#id530"><span class="problematic" id="id531">*</span></a>[][]int, level int) {</dt><dd><dl class="simple">
<dt>if root == nil {</dt><dd><p>return</p>
</dd>
</dl>
<p>}
if len(<a href="#id532"><span class="problematic" id="id533">*</span></a>temp)-1 &lt; level {</p>
<blockquote>
<div><p><a href="#id534"><span class="problematic" id="id535">*</span></a>temp = append(<a href="#id536"><span class="problematic" id="id537">*</span></a>temp, make([]int, 0))</p>
</div></blockquote>
<p>}
(<a href="#id538"><span class="problematic" id="id539">*</span></a>temp)[level] = append((<a href="#id540"><span class="problematic" id="id541">*</span></a>temp)[level], root.Val)
level = level + 1
dfs(root.Left, temp, level)
dfs(root.Right, temp, level)</p>
</dd>
</dl>
</div>
<div class="section" id="id542">
<h1>}<a class="headerlink" href="#id542" title="永久链接至标题">¶</a></h1>
<p>## 面试题32-III.从上到下打印二叉树III(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id543"><span class="problematic" id="id544">``</span></a>`
请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，
第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。
例如:给定二叉树: [3,9,20,null,null,15,7],</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>3</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<dl>
<dt>9  20</dt><dd><blockquote>
<div><p>/  </p>
</div></blockquote>
<p>15   7</p>
</dd>
</dl>
</div></blockquote>
<p>返回其层次遍历结果：
[</p>
<blockquote>
<div><p>[3],
[20,9],
[15,7]</p>
</div></blockquote>
<p>]
提示：节点总数 &lt;= 1000
<a href="#id545"><span class="problematic" id="id546">``</span></a><a href="#id547"><span class="problematic" id="id548">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路               | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —————— | ———- | ———- |</div>
<div class="line">01   | 层序遍历(书上方法) | O(n)       | O(n)       |</div>
<div class="line">02   | 递归               | O(n)       | O(n)       |</div>
</div>
<p><a href="#id549"><span class="problematic" id="id550">``</span></a><a href="#id551"><span class="problematic" id="id552">`</span></a>go
func levelOrder(root <a href="#id553"><span class="problematic" id="id554">*</span></a>TreeNode) [][]int {</p>
<blockquote>
<div><p>res := make([][]int, 0)
if root == nil {</p>
<blockquote>
<div><p>return res</p>
</div></blockquote>
<p>}
list := make([]*TreeNode, 0)
list = append(list, root)
level := 0
for len(list) &gt; 0 {</p>
<blockquote>
<div><p>length := len(list)
temp := make([]int, 0)
for i := 0; i &lt; length; i++ {</p>
<blockquote>
<div><p>node := list[i]
if node.Left != nil {</p>
<blockquote>
<div><p>list = append(list, node.Left)</p>
</div></blockquote>
<p>}
if node.Right != nil {</p>
<blockquote>
<div><p>list = append(list, node.Right)</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
if level%2 == 0 {</p>
<blockquote>
<div><dl class="simple">
<dt>for i := 0; i &lt; length; i++ {</dt><dd><p>temp = append(temp, list[i].Val)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl>
<dt>} else {</dt><dd><dl class="simple">
<dt>for i := length - 1; i &gt;= 0; i– {</dt><dd><p>temp = append(temp, list[i].Val)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
list = list[length:]
res = append(res, temp)
level++</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
func levelOrder(root <a href="#id555"><span class="problematic" id="id556">*</span></a>TreeNode) [][]int {</p>
<blockquote>
<div><dl class="simple">
<dt>if root == nil {</dt><dd><p>return nil</p>
</dd>
</dl>
<p>}
temp := make([][]int, 0)
dfs(root, &amp;temp, 0)
return temp</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func dfs(root <a href="#id557"><span class="problematic" id="id558">*</span></a>TreeNode, temp <a href="#id559"><span class="problematic" id="id560">*</span></a>[][]int, level int) {</dt><dd><dl class="simple">
<dt>if root == nil {</dt><dd><p>return</p>
</dd>
</dl>
<p>}
if len(<a href="#id561"><span class="problematic" id="id562">*</span></a>temp)-1 &lt; level {</p>
<blockquote>
<div><p><a href="#id563"><span class="problematic" id="id564">*</span></a>temp = append(<a href="#id565"><span class="problematic" id="id566">*</span></a>temp, make([]int, 0))</p>
</div></blockquote>
<p>}
if level%2 == 0 {</p>
<blockquote>
<div><p>(<a href="#id567"><span class="problematic" id="id568">*</span></a>temp)[level] = append((<a href="#id569"><span class="problematic" id="id570">*</span></a>temp)[level], root.Val)</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>(<a href="#id571"><span class="problematic" id="id572">*</span></a>temp)[level] = append([]int{root.Val}, (<a href="#id573"><span class="problematic" id="id574">*</span></a>temp)[level]…)</p>
</dd>
</dl>
<p>}
level = level + 1
dfs(root.Left, temp, level)
dfs(root.Right, temp, level)</p>
</dd>
</dl>
</div>
<div class="section" id="id575">
<h1>}<a class="headerlink" href="#id575" title="永久链接至标题">¶</a></h1>
<p>## 面试题33.二叉搜索树的后序遍历序列(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id576"><span class="problematic" id="id577">``</span></a>`
输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。
假设输入的数组的任意两个数字都互不相同。
参考以下这颗二叉搜索树：</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><p>5</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<p>2   6</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<p>1   3</p>
</div></blockquote>
<p>示例 1：输入: [1,6,3,2,5]输出: false
示例 2：输入: [1,3,2,6,5]输出: true
提示：</p>
<blockquote>
<div><p>数组长度 &lt;= 1000</p>
</div></blockquote>
<p><a href="#id578"><span class="problematic" id="id579">``</span></a><a href="#id580"><span class="problematic" id="id581">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路           | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ————– | ———- | ———- |</div>
<div class="line">01   | 递归(书上方法) | O(n^2)     | O(n)       |</div>
<div class="line">02   | 迭代           | O(n^2)     | O(1)       |</div>
<div class="line">03   | 栈辅助         | O(n)       | O(n)       |</div>
</div>
<p><a href="#id582"><span class="problematic" id="id583">``</span></a><a href="#id584"><span class="problematic" id="id585">`</span></a>go
func verifyPostorder(postorder []int) bool {</p>
<blockquote>
<div><p>return dfs(postorder, 0, len(postorder)-1)</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func dfs(postorder []int, start, end int) bool {</dt><dd><dl class="simple">
<dt>if start &gt;= end {</dt><dd><p>return true</p>
</dd>
</dl>
<p>}
i := 0
for i = start; i &lt; end; i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if postorder[i] &gt; postorder[end] {</dt><dd><p>break</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
for j := i + 1; j &lt; end; j++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if postorder[j] &lt; postorder[end] {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return dfs(postorder, start, i-1) &amp;&amp; dfs(postorder, i, end-1)</p>
</dd>
</dl>
<p>}</p>
<p>#
func verifyPostorder(postorder []int) bool {</p>
<blockquote>
<div><dl class="simple">
<dt>if len(postorder) &lt;= 2 {</dt><dd><p>return true</p>
</dd>
</dl>
<p>}
last := len(postorder) - 1
for last &gt; 0 {</p>
<blockquote>
<div><p>i := 0
for postorder[i] &lt; postorder[last] {</p>
<blockquote>
<div><p>i++</p>
</div></blockquote>
<p>}
for postorder[i] &gt; postorder[last] {</p>
<blockquote>
<div><p>i++</p>
</div></blockquote>
<p>}
if i != last {</p>
<blockquote>
<div><p>return false</p>
</div></blockquote>
<p>}
last–</p>
</div></blockquote>
<p>}
return true</p>
</div></blockquote>
<p>}</p>
<p>#
func verifyPostorder(postorder []int) bool {</p>
<blockquote>
<div><dl class="simple">
<dt>if len(postorder) &lt;= 2 {</dt><dd><p>return true</p>
</dd>
</dl>
<p>}
stack := make([]int, 0)
rootValue := math.MaxInt32
for i := len(postorder) - 1; i &gt;= 0; i– {</p>
<blockquote>
<div><dl class="simple">
<dt>if postorder[i] &gt; rootValue {</dt><dd><p>// 左子树元素必须要小于递增栈根节点
return false</p>
</dd>
</dl>
<p>}
// 数组元素小于单调栈的元素了，表示往左子树走了，记录上个根节点
for len(stack) &gt; 0 &amp;&amp; postorder[i] &lt; stack[len(stack)-1] {</p>
<blockquote>
<div><p>rootValue = stack[len(stack)-1]
stack = stack[:len(stack)-1]</p>
</div></blockquote>
<p>}
stack = append(stack, postorder[i])</p>
</div></blockquote>
<p>}
return true</p>
</div></blockquote>
</div>
<div class="section" id="id586">
<h1>}<a class="headerlink" href="#id586" title="永久链接至标题">¶</a></h1>
<p>## 面试题34.二叉树中和为某一值的路径(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id587"><span class="problematic" id="id588">``</span></a>`
输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。
从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。
示例:给定如下二叉树，以及目标和 sum = 22，</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><p>5</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<p>4   8</p>
</div></blockquote>
<p>/   / </p>
</div></blockquote>
<p>11  13  4</p>
</div></blockquote>
<p>/     / </p>
</div></blockquote>
<p>7    2  5   1</p>
</div></blockquote>
<p>返回:
[</p>
<blockquote>
<div><p>[5,4,11,2],
[5,8,4,5]</p>
</div></blockquote>
<p>]
提示：节点总数 &lt;= 10000
注意：本题与主站 113 题相同：<a class="reference external" href="https://leetcode-cn.com/problems/path-sum-ii/">https://leetcode-cn.com/problems/path-sum-ii/</a>
<a href="#id589"><span class="problematic" id="id590">``</span></a><a href="#id591"><span class="problematic" id="id592">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路           | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ————– | ———- | ———- |</div>
<div class="line">01   | 递归(书上方法) | O(n)       | O(log(n))  |</div>
<div class="line">02   | 迭代           | O(n)       | O(n)       |</div>
</div>
<p><a href="#id593"><span class="problematic" id="id594">``</span></a><a href="#id595"><span class="problematic" id="id596">`</span></a>go
var res [][]int</p>
<dl>
<dt>func pathSum(root <a href="#id597"><span class="problematic" id="id598">*</span></a>TreeNode, sum int) [][]int {</dt><dd><dl class="simple">
<dt>if root == nil {</dt><dd><p>return nil</p>
</dd>
</dl>
<p>}
res = make([][]int, 0)
var arr []int
dfs(root, sum, arr)
return res</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func dfs(root <a href="#id599"><span class="problematic" id="id600">*</span></a>TreeNode, sum int, arr []int) {</dt><dd><dl class="simple">
<dt>if root == nil {</dt><dd><p>return</p>
</dd>
</dl>
<p>}
arr = append(arr, root.Val)
if root.Val == sum &amp;&amp; root.Left == nil &amp;&amp; root.Right == nil {</p>
<blockquote>
<div><p>temp := make([]int, len(arr))
copy(temp, arr)
res = append(res, temp)</p>
</div></blockquote>
<p>}
dfs(root.Left, sum-root.Val, arr)
dfs(root.Right, sum-root.Val, arr)
arr = arr[:len(arr)-1]</p>
</dd>
</dl>
<p>}</p>
<p>#
func pathSum(root <a href="#id601"><span class="problematic" id="id602">*</span></a>TreeNode, sum int) [][]int {</p>
<blockquote>
<div><p>res := make([][]int, 0)
if root == nil {</p>
<blockquote>
<div><p>return res</p>
</div></blockquote>
<p>}
temp := make([]int, 0)
stack := make([]*TreeNode, 0)
visited := make(map[<a href="#id603"><span class="problematic" id="id604">*</span></a>TreeNode]bool)
curSum := 0
for root != nil || len(stack) &gt; 0 {</p>
<blockquote>
<div><dl class="simple">
<dt>for root != nil {</dt><dd><p>temp = append(temp, root.Val)
curSum = curSum + root.Val
visited[root] = true
stack = append(stack, root)
root = root.Left</p>
</dd>
</dl>
<p>}
node := stack[len(stack)-1]
if node.Right == nil || visited[node.Right] {</p>
<blockquote>
<div><dl class="simple">
<dt>if node.Left == nil &amp;&amp; node.Right == nil &amp;&amp; curSum == sum {</dt><dd><p>tmp := make([]int, len(temp))
copy(tmp, temp)
res = append(res, tmp)</p>
</dd>
</dl>
<p>}
stack = stack[:len(stack)-1]
temp = temp[:len(temp)-1]
curSum = curSum - node.Val
root = nil</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>root = node.Right</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
</div>
<div class="section" id="id605">
<h1>}<a class="headerlink" href="#id605" title="永久链接至标题">¶</a></h1>
<p>## 面试题35.复杂链表的复制(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id606"><span class="problematic" id="id607">``</span></a>`
请实现 copyRandomList 函数，复制一个复杂链表。
在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，
还有一个 random 指针指向链表中的任意节点或者 null。
示例 1： 输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
示例 2：输入：head = [[1,1],[2,1]] 输出：[[1,1],[2,1]]
示例 3：输入：head = [[3,null],[3,0],[3,null]]
输出：[[3,null],[3,0],[3,null]]
示例 4：输入：head = [] 输出：[]
解释：给定的链表为空（空指针），因此返回 null。
提示：</p>
<blockquote>
<div><p>-10000 &lt;= Node.val &lt;= 10000
Node.random 为空（null）或指向链表中的节点。
节点数目不超过 1000 。</p>
</div></blockquote>
<p>注意：本题与主站 138 题相同：
<a class="reference external" href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/">https://leetcode-cn.com/problems/copy-list-with-random-pointer/</a>
<a href="#id608"><span class="problematic" id="id609">``</span></a><a href="#id610"><span class="problematic" id="id611">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路                | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ——————- | ———- | ———- |</div>
<div class="line">01   | 哈希辅助-递归       | O(n)       | O(n)       |</div>
<div class="line">02   | 哈希辅助            | O(n)       | O(n)       |</div>
<div class="line">03   | 复制-删除(书上方法) | O(n)       | O(1)       |</div>
</div>
<p><a href="#id612"><span class="problematic" id="id613">``</span></a><a href="#id614"><span class="problematic" id="id615">`</span></a>go
var m map[<a href="#id616"><span class="problematic" id="id617">*</span></a>Node]*Node</p>
<dl class="simple">
<dt>func copyRandomList(head <a href="#id618"><span class="problematic" id="id619">*</span></a>Node) <a href="#id620"><span class="problematic" id="id621">*</span></a>Node {</dt><dd><p>m = make(map[<a href="#id622"><span class="problematic" id="id623">*</span></a>Node]*Node)
return copyList(head)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func copyList(head <a href="#id624"><span class="problematic" id="id625">*</span></a>Node) <a href="#id626"><span class="problematic" id="id627">*</span></a>Node {</dt><dd><dl class="simple">
<dt>if head == nil {</dt><dd><p>return head</p>
</dd>
</dl>
<p>}
if node, ok := m[head]; ok {</p>
<blockquote>
<div><p>return node</p>
</div></blockquote>
<p>}
temp := &amp;Node{</p>
<blockquote>
<div><p>Val:    head.Val,
Next:   nil,
Random: nil,</p>
</div></blockquote>
<p>}
m[head] = temp
temp.Next = copyList(head.Next)
temp.Random = copyList(head.Random)
return temp</p>
</dd>
</dl>
<p>}</p>
<p>#
func copyRandomList(head <a href="#id628"><span class="problematic" id="id629">*</span></a>Node) <a href="#id630"><span class="problematic" id="id631">*</span></a>Node {</p>
<blockquote>
<div><dl class="simple">
<dt>if head == nil {</dt><dd><p>return nil</p>
</dd>
</dl>
<p>}
res := new(Node)
m := make(map[<a href="#id632"><span class="problematic" id="id633">*</span></a>Node]*Node)
temp := head
p := res
for temp != nil {</p>
<blockquote>
<div><dl class="simple">
<dt>node := &amp;Node{</dt><dd><p>Val:    temp.Val,
Next:   nil,
Random: nil,</p>
</dd>
</dl>
<p>}
m[temp] = node
p.Next = node
p = p.Next
temp = temp.Next</p>
</div></blockquote>
<p>}
temp = head
p = res.Next
for temp != nil {</p>
<blockquote>
<div><p>p.Random = m[temp.Random]
p = p.Next
temp = temp.Next</p>
</div></blockquote>
<p>}
return res.Next</p>
</div></blockquote>
<p>}</p>
<p>#
func copyRandomList(head <a href="#id634"><span class="problematic" id="id635">*</span></a>Node) <a href="#id636"><span class="problematic" id="id637">*</span></a>Node {</p>
<blockquote>
<div><dl class="simple">
<dt>if head == nil {</dt><dd><p>return nil</p>
</dd>
</dl>
<p>}
res := copyNext(head)
res = copyRandom(res)
res = cutEven(res)
return res</p>
</div></blockquote>
<p>}</p>
<p>// 原1-复制1-原2-复制2
func copyNext(head <a href="#id638"><span class="problematic" id="id639">*</span></a>Node) <a href="#id640"><span class="problematic" id="id641">*</span></a>Node {</p>
<blockquote>
<div><p>temp := new(Node)
temp.Next = head
p := head
for p != nil {</p>
<blockquote>
<div><p>node := new(Node)
node.Val = p.Val
node.Next = p.Next
p.Next = node
p = p.Next.Next</p>
</div></blockquote>
<p>}
return temp.Next</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func copyRandom(head <a href="#id642"><span class="problematic" id="id643">*</span></a>Node) <a href="#id644"><span class="problematic" id="id645">*</span></a>Node {</dt><dd><p>temp := new(Node)
temp.Next = head
p := head
for p != nil {</p>
<blockquote>
<div><dl class="simple">
<dt>if p.Random != nil {</dt><dd><p>p.Next.Random = p.Random.Next</p>
</dd>
</dl>
<p>}
p = p.Next.Next</p>
</div></blockquote>
<p>}
return temp.Next</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func cutEven(head <a href="#id646"><span class="problematic" id="id647">*</span></a>Node) <a href="#id648"><span class="problematic" id="id649">*</span></a>Node {</dt><dd><p>temp := new(Node)
res := head
p := head
for p != nil {</p>
<blockquote>
<div><p>res.Next = p.Next
p.Next = p.Next.Next
p = p.Next
res = res.Next</p>
</div></blockquote>
<p>}
return temp.Next</p>
</dd>
</dl>
</div>
<div class="section" id="id650">
<h1>}<a class="headerlink" href="#id650" title="永久链接至标题">¶</a></h1>
<p>## 面试题38.字符串的排列(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">输入一个字符串，打印出该字符串中字符的所有排列。</span>
<span class="pre">你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</span>
<span class="pre">示例:输入：s</span> <span class="pre">=</span> <span class="pre">&quot;abc&quot;</span> <span class="pre">输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span>
<span class="pre">限制：1</span> <span class="pre">&lt;=</span> <span class="pre">s</span> <span class="pre">的长度</span> <span class="pre">&lt;=</span> <span class="pre">8</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路                    | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ———————– | ———- | ———- |</div>
<div class="line">01   | 回溯算法                | O(n!)      | O(n!)      |</div>
<div class="line">02   | 回溯算法-交换(书上方法) | O(n!)      | O(n!)      |</div>
</div>
<p><a href="#id651"><span class="problematic" id="id652">``</span></a><a href="#id653"><span class="problematic" id="id654">`</span></a>go
var m map[string]bool</p>
<dl>
<dt>func permutation(s string) []string {</dt><dd><p>m = make(map[string]bool)
dfs(s, “”)
res := make([]string, 0)
for key := range m {</p>
<blockquote>
<div><p>res = append(res, key)</p>
</div></blockquote>
<p>}
return res</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func dfs(s string, str string) {</dt><dd><dl class="simple">
<dt>if len(s) == 0 {</dt><dd><p>m[str] = true</p>
</dd>
</dl>
<p>}
for i := 0; i &lt; len(s); i++ {</p>
<blockquote>
<div><p>arr := []byte(s)
temp := arr[i]
if len(arr)-1 == i {</p>
<blockquote>
<div><p>arr = arr[:len(arr)-1]</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>arr = append(arr[:i], arr[i+1:]…)</p>
</dd>
</dl>
<p>}
dfs(string(arr), str+string(temp))</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>#
var res []string</p>
<dl class="simple">
<dt>func permutation(s string) []string {</dt><dd><p>res = make([]string, 0)
dfs([]byte(s), 0)
return res</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func dfs(arr []byte, index int) {</dt><dd><dl class="simple">
<dt>if len(arr)-1 == index {</dt><dd><p>res = append(res, string(arr))
return</p>
</dd>
</dl>
<p>}
m := make(map[byte]bool)
for i := index; i &lt; len(arr); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if _, ok := m[arr[i]]; ok {</dt><dd><p>continue</p>
</dd>
</dl>
<p>}
m[arr[i]] = true
arr[i], arr[index] = arr[index], arr[i]
dfs(arr, index+1)
arr[i], arr[index] = arr[index], arr[i]</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</div>
<div class="section" id="id655">
<h1>}<a class="headerlink" href="#id655" title="永久链接至标题">¶</a></h1>
<p>## 面试题39.数组中出现次数超过一半的数字(5)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</span>
<span class="pre">你可以假设数组是非空的，并且给定的数组总是存在多数元素。</span>
<span class="pre">示例</span> <span class="pre">1:输入:</span> <span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">2,</span> <span class="pre">2,</span> <span class="pre">2,</span> <span class="pre">5,</span> <span class="pre">4,</span> <span class="pre">2]</span> <span class="pre">输出:</span> <span class="pre">2</span>
<span class="pre">限制：1</span> <span class="pre">&lt;=</span> <span class="pre">数组长度</span> <span class="pre">&lt;=</span> <span class="pre">50000</span>
<span class="pre">注意：本题与主站</span> <span class="pre">169</span> <span class="pre">题相同：https://leetcode-cn.com/problems/majority-element/</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路                          | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —————————– | ———- | ———- |</div>
<div class="line">01   | 排序取半                      | O(nlog(n)) | O(1)       |</div>
<div class="line">02   | 哈希遍历                      | O(n)       | O(n)       |</div>
<div class="line">03   | Boyer-Moore投票算法(书上方法) | O(n)       | O(1)       |</div>
<div class="line">04   | 位运算                        | O(n)       | O(1)       |</div>
<div class="line">05   | 分治法                        | O(nlog(n)) | O(log(n))  |</div>
</div>
<p><a href="#id656"><span class="problematic" id="id657">``</span></a><a href="#id658"><span class="problematic" id="id659">`</span></a>go
func majorityElement(nums []int) int {</p>
<blockquote>
<div><p>sort.Ints(nums)
return nums[len(nums)/2]</p>
</div></blockquote>
<p>}</p>
<p># 2
func majorityElement(nums []int) int {</p>
<blockquote>
<div><p>m := make(map[int]int)
result := 0
for _, v := range nums{</p>
<blockquote>
<div><dl class="simple">
<dt>if _,ok := m[v];ok{</dt><dd><p>m[v]++</p>
</dd>
<dt>}else {</dt><dd><p>m[v]=1</p>
</dd>
</dl>
<p>}
if m[v] &gt; (len(nums)/2){</p>
<blockquote>
<div><p>result = v</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return result</p>
</div></blockquote>
<p>}</p>
<p># 3
func majorityElement(nums []int) int {</p>
<blockquote>
<div><p>result, count := 0, 0
for i := 0; i &lt; len(nums); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if count == 0 {</dt><dd><p>result = nums[i]
count++</p>
</dd>
<dt>} else if result == nums[i] {</dt><dd><p>count++</p>
</dd>
<dt>} else {</dt><dd><p>count–</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return result</p>
</div></blockquote>
<p>}</p>
<p># 4
func majorityElement(nums []int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if len(nums) == 1 {</dt><dd><p>return nums[0]</p>
</dd>
</dl>
<p>}
result := int32(0)
// 64位有坑
mask := int32(1)
for i := 0; i &lt; 32; i++ {</p>
<blockquote>
<div><p>count := 0
for j := 0; j &lt; len(nums); j++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if mask&amp;int32(nums[j]) == mask {</dt><dd><p>count++</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
if count &gt; len(nums)/2 {</p>
<blockquote>
<div><p>result = result | mask</p>
</div></blockquote>
<p>}
mask = mask &lt;&lt; 1</p>
</div></blockquote>
<p>}
return int(result)</p>
</div></blockquote>
<p>}</p>
<p># 5
func majority(nums []int, start, end int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if start == end {</dt><dd><p>return nums[start]</p>
</dd>
</dl>
<p>}</p>
<p>mid := (start + end) / 2</p>
<p>left := majority(nums, start, mid)
right := majority(nums, mid+1, end)
if left == right {</p>
<blockquote>
<div><p>return left</p>
</div></blockquote>
<p>}</p>
<p>leftCount := count(nums, left, start, end)
rightCount := count(nums, right, start, end)
if leftCount &gt; rightCount {</p>
<blockquote>
<div><p>return left</p>
</div></blockquote>
<p>}
return right</p>
</div></blockquote>
</div>
<div class="section" id="id660">
<h1>}<a class="headerlink" href="#id660" title="永久链接至标题">¶</a></h1>
<p>## 面试题40.最小的k个数(4)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id661"><span class="problematic" id="id662">``</span></a>`
输入整数数组 arr ，找出其中最小的 k 个数。
例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。
示例 1：输入：arr = [3,2,1], k = 2 输出：[1,2] 或者 [2,1]
示例 2：输入：arr = [0,1,2,1], k = 1 输出：[0]
限制：</p>
<blockquote>
<div><p>0 &lt;= k &lt;= arr.length &lt;= 10000
0 &lt;= arr[i] &lt;= 10000</p>
</div></blockquote>
<p><a href="#id663"><span class="problematic" id="id664">``</span></a><a href="#id665"><span class="problematic" id="id666">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路               | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —————— | ———- | ———- |</div>
<div class="line">01   | 排序               | O(nlog(n)) | O(1)       |</div>
<div class="line">02   | 堆                 | O(nlog(n)) | O(n)       |</div>
<div class="line">03   | 计数统计           | O(n)       | O(n)       |</div>
<div class="line">04   | 快排切分(书上方法) | O(n)       | O(1)       |</div>
</div>
<p><a href="#id667"><span class="problematic" id="id668">``</span></a><a href="#id669"><span class="problematic" id="id670">`</span></a>go
func getLeastNumbers(arr []int, k int) []int {</p>
<blockquote>
<div><dl class="simple">
<dt>if len(arr) == 0 || k == 0 {</dt><dd><p>return nil</p>
</dd>
</dl>
<p>}
sort.Ints(arr)
return arr[:k]</p>
</div></blockquote>
<p>}</p>
<p>#
type IntHeap []int</p>
<dl class="simple">
<dt>func (i IntHeap) Len() int {</dt><dd><p>return len(i)</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>func (i IntHeap) Less(x, y int) bool {</dt><dd><p>return i[x] &gt; i[y]</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>func (i IntHeap) Swap(x, y int) {</dt><dd><p>i[x], i[y] = i[y], i[x]</p>
</dd>
</dl>
<p>}
func (i <a href="#id671"><span class="problematic" id="id672">*</span></a>IntHeap) Push(v interface{}) {</p>
<blockquote>
<div><p><a href="#id673"><span class="problematic" id="id674">*</span></a>i = append(<a href="#id675"><span class="problematic" id="id676">*</span></a>i, v.(int))</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>func (i <a href="#id677"><span class="problematic" id="id678">*</span></a>IntHeap) Pop() interface{} {</dt><dd><p>value := (<a href="#id679"><span class="problematic" id="id680">*</span></a>i)[len(<a href="#id681"><span class="problematic" id="id682">*</span></a>i)-1]
<a href="#id683"><span class="problematic" id="id684">*</span></a>i = (<a href="#id685"><span class="problematic" id="id686">*</span></a>i)[:len(<a href="#id687"><span class="problematic" id="id688">*</span></a>i)-1]
return value</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func getLeastNumbers(arr []int, k int) []int {</dt><dd><dl class="simple">
<dt>if len(arr) == 0 || k == 0 {</dt><dd><p>return nil</p>
</dd>
</dl>
<p>}
intHeap := make(IntHeap, 0, k)
heap.Init(&amp;intHeap)</p>
<dl>
<dt>for i := 0; i &lt; len(arr); i++ {</dt><dd><dl>
<dt>if len(intHeap) &lt; k {</dt><dd><p>heap.Push(&amp;intHeap, arr[i])</p>
</dd>
<dt>} else if len(intHeap) == k {</dt><dd><dl class="simple">
<dt>if arr[i] &lt; intHeap[0] {</dt><dd><p>heap.Pop(&amp;intHeap)
heap.Push(&amp;intHeap, arr[i])</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
return intHeap</p>
</dd>
</dl>
<p>}</p>
<p>#
func getLeastNumbers(arr []int, k int) []int {</p>
<blockquote>
<div><dl class="simple">
<dt>if len(arr) == 0 || k == 0 {</dt><dd><p>return nil</p>
</dd>
</dl>
<p>}
a := make([]int, 10001)
for _, v := range arr {</p>
<blockquote>
<div><p>a[v]++</p>
</div></blockquote>
<p>}
res := make([]int, 0)
for key, value := range a {</p>
<blockquote>
<div><dl>
<dt>if value &gt; 0 {</dt><dd><dl>
<dt>for i := 0; i &lt; value; i++ {</dt><dd><p>res = append(res, key)
k–
if k &lt;= 0 {</p>
<blockquote>
<div><p>return res</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
func getLeastNumbers(arr []int, k int) []int {</p>
<blockquote>
<div><dl class="simple">
<dt>if len(arr) == 0 || k == 0 {</dt><dd><p>return nil</p>
</dd>
</dl>
<p>}
left := 0
right := len(arr) - 1
for {</p>
<blockquote>
<div><p>index := partition(arr, left, right)
if index+1 == k {</p>
<blockquote>
<div><p>break</p>
</div></blockquote>
<dl class="simple">
<dt>} else if index+1 &lt; k {</dt><dd><p>left = index + 1</p>
</dd>
<dt>} else {</dt><dd><p>right = index - 1</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return arr[:k]</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func partition(arr []int, left, right int) int {</dt><dd><dl class="simple">
<dt>if left == right {</dt><dd><p>return left</p>
</dd>
</dl>
<p>}
value := arr[left]
i := left
j := right
for {</p>
<blockquote>
<div><dl class="simple">
<dt>for arr[j] &gt;= value &amp;&amp; i &lt; j {</dt><dd><p>j–</p>
</dd>
</dl>
<p>}
for arr[i] &lt;= value &amp;&amp; i &lt; j {</p>
<blockquote>
<div><p>i++</p>
</div></blockquote>
<p>}
if i &gt;= j {</p>
<blockquote>
<div><p>break</p>
</div></blockquote>
<p>}
arr[i], arr[j] = arr[j], arr[i]</p>
</div></blockquote>
<p>}
arr[left] = arr[i]
arr[i] = value
return i</p>
</dd>
</dl>
</div>
<div class="section" id="id689">
<h1>}<a class="headerlink" href="#id689" title="永久链接至标题">¶</a></h1>
<p>## 面试题41.数据流中的中位数(1)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id690"><span class="problematic" id="id691">``</span></a>`
如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。
如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。
例如，
[2,3,4] 的中位数是 3
[2,3] 的中位数是 (2 + 3) / 2 = 2.5
设计一个支持以下两种操作的数据结构：</p>
<blockquote>
<div><p>void addNum(int num) - 从数据流中添加一个整数到数据结构中。
double findMedian() - 返回目前所有元素的中位数。</p>
</div></blockquote>
<p>示例 1：输入：
[“MedianFinder”,”addNum”,”addNum”,”findMedian”,”addNum”,”findMedian”]
[[],[1],[2],[],[3],[]]
输出：[null,null,null,1.50000,null,2.00000]</p>
<p>示例 2： 输入：
[“MedianFinder”,”addNum”,”findMedian”,”addNum”,”findMedian”]
[[],[2],[],[3],[]]
输出：[null,null,2.00000,null,2.50000]</p>
<p>限制：最多会对 addNum、findMedia进行 50000 次调用。
注意：本题与主站 295 题相同：
<a class="reference external" href="https://leetcode-cn.com/problems/find-median-from-data-stream/">https://leetcode-cn.com/problems/find-median-from-data-stream/</a>
<a href="#id692"><span class="problematic" id="id693">``</span></a><a href="#id694"><span class="problematic" id="id695">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路                  | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ——————— | ———- | ———- |</div>
<div class="line">01   | 大小根堆-内置heap接口 | O(log(n))  | O(n)       |</div>
</div>
<p><a href="#id696"><span class="problematic" id="id697">``</span></a><a href="#id698"><span class="problematic" id="id699">`</span></a>go
type MinHeap []int</p>
<dl class="simple">
<dt>func (i MinHeap) Len() int {</dt><dd><p>return len(i)</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>func (i MinHeap) Less(x, y int) bool {</dt><dd><p>return i[x] &lt; i[y]</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>func (i MinHeap) Swap(x, y int) {</dt><dd><p>i[x], i[y] = i[y], i[x]</p>
</dd>
</dl>
<p>}
func (i <a href="#id700"><span class="problematic" id="id701">*</span></a>MinHeap) Push(v interface{}) {</p>
<blockquote>
<div><p><a href="#id702"><span class="problematic" id="id703">*</span></a>i = append(<a href="#id704"><span class="problematic" id="id705">*</span></a>i, v.(int))</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>func (i <a href="#id706"><span class="problematic" id="id707">*</span></a>MinHeap) Pop() interface{} {</dt><dd><p>value := (<a href="#id708"><span class="problematic" id="id709">*</span></a>i)[len(<a href="#id710"><span class="problematic" id="id711">*</span></a>i)-1]
<a href="#id712"><span class="problematic" id="id713">*</span></a>i = (<a href="#id714"><span class="problematic" id="id715">*</span></a>i)[:len(<a href="#id716"><span class="problematic" id="id717">*</span></a>i)-1]
return value</p>
</dd>
</dl>
<p>}</p>
<p>type MaxHeap []int</p>
<dl class="simple">
<dt>func (i MaxHeap) Len() int {</dt><dd><p>return len(i)</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>func (i MaxHeap) Less(x, y int) bool {</dt><dd><p>return i[x] &gt; i[y]</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>func (i MaxHeap) Swap(x, y int) {</dt><dd><p>i[x], i[y] = i[y], i[x]</p>
</dd>
</dl>
<p>}
func (i <a href="#id718"><span class="problematic" id="id719">*</span></a>MaxHeap) Push(v interface{}) {</p>
<blockquote>
<div><p><a href="#id720"><span class="problematic" id="id721">*</span></a>i = append(<a href="#id722"><span class="problematic" id="id723">*</span></a>i, v.(int))</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>func (i <a href="#id724"><span class="problematic" id="id725">*</span></a>MaxHeap) Pop() interface{} {</dt><dd><p>value := (<a href="#id726"><span class="problematic" id="id727">*</span></a>i)[len(<a href="#id728"><span class="problematic" id="id729">*</span></a>i)-1]
<a href="#id730"><span class="problematic" id="id731">*</span></a>i = (<a href="#id732"><span class="problematic" id="id733">*</span></a>i)[:len(<a href="#id734"><span class="problematic" id="id735">*</span></a>i)-1]
return value</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>type MedianFinder struct {</dt><dd><p>minArr <a href="#id736"><span class="problematic" id="id737">*</span></a>MinHeap
maxArr <a href="#id738"><span class="problematic" id="id739">*</span></a>MaxHeap</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>func Constructor() MedianFinder {</dt><dd><p>res := new(MedianFinder)
res.minArr = new(MinHeap)
res.maxArr = new(MaxHeap)
heap.Init(res.minArr)
heap.Init(res.maxArr)
return <a href="#id740"><span class="problematic" id="id741">*</span></a>res</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func (this <a href="#id742"><span class="problematic" id="id743">*</span></a>MedianFinder) AddNum(num int) {</dt><dd><dl class="simple">
<dt>if this.maxArr.Len() == this.minArr.Len() {</dt><dd><p>heap.Push(this.minArr, num)
heap.Push(this.maxArr, heap.Pop(this.minArr))</p>
</dd>
<dt>} else {</dt><dd><p>heap.Push(this.maxArr, num)
heap.Push(this.minArr, heap.Pop(this.maxArr))</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func (this <a href="#id744"><span class="problematic" id="id745">*</span></a>MedianFinder) FindMedian() float64 {</dt><dd><dl class="simple">
<dt>if this.minArr.Len() == this.maxArr.Len() {</dt><dd><p>return (float64((<a href="#id746"><span class="problematic" id="id747">*</span></a>this.maxArr)[0]) + float64((<a href="#id748"><span class="problematic" id="id749">*</span></a>this.minArr)[0])) / 2</p>
</dd>
<dt>} else {</dt><dd><p>return float64((<a href="#id750"><span class="problematic" id="id751">*</span></a>this.maxArr)[0])</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</div>
<div class="section" id="id752">
<h1>}<a class="headerlink" href="#id752" title="永久链接至标题">¶</a></h1>
<p>## 面试题42.连续子数组的最大和(4)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id753"><span class="problematic" id="id754">``</span></a>`
输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。
要求时间复杂度为O(n)。
示例1:输入: nums = [-2,1,-3,4,-1,2,1,-5,4]输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
提示：</p>
<blockquote>
<div><p>1 &lt;= arr.length &lt;= 10^5
-100 &lt;= arr[i] &lt;= 100</p>
</div></blockquote>
<p>注意：本题与主站 53 题相同：<a class="reference external" href="https://leetcode-cn.com/problems/maximum-subarray/">https://leetcode-cn.com/problems/maximum-subarray/</a>
<a href="#id755"><span class="problematic" id="id756">``</span></a><a href="#id757"><span class="problematic" id="id758">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路               | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —————— | ———- | ———- |</div>
<div class="line">01   | 贪心法(书上方法)   | O(n)       | O(1)       |</div>
<div class="line">03   | 动态规划(书上方法) | O(n)       | O(n)       |</div>
<div class="line">04   | 动态规划           | O(n)       | O(1)       |</div>
<div class="line">05   | 分治               | O(nlog(n)) | O(log(n))  |</div>
</div>
<p><a href="#id759"><span class="problematic" id="id760">``</span></a><a href="#id761"><span class="problematic" id="id762">`</span></a>go
func maxSubArray(nums []int) int {</p>
<blockquote>
<div><p>result := nums[0]
sum := 0
for i := 0; i &lt; len(nums); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if sum &gt; 0 {</dt><dd><p>sum += nums[i]</p>
</dd>
<dt>} else {</dt><dd><p>sum = nums[i]</p>
</dd>
</dl>
<p>}
if sum &gt; result {</p>
<blockquote>
<div><p>result = sum</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return result</p>
</div></blockquote>
<p>}</p>
<p>#
func maxSubArray(nums []int) int {</p>
<blockquote>
<div><p>dp := make([]int, len(nums))
dp[0] = nums[0]
result := nums[0]</p>
<dl>
<dt>for i := 1; i &lt; len(nums); i++ {</dt><dd><dl class="simple">
<dt>if dp[i-1]+nums[i] &gt; nums[i] {</dt><dd><p>dp[i] = dp[i-1] + nums[i]</p>
</dd>
<dt>} else {</dt><dd><p>dp[i] = nums[i]</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>if dp[i] &gt; result {</dt><dd><p>result = dp[i]</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
return result</p>
</div></blockquote>
<p>}</p>
<p>#
func maxSubArray(nums []int) int {</p>
<blockquote>
<div><p>dp := nums[0]
result := dp
for i := 1; i &lt; len(nums); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if dp+nums[i] &gt; nums[i] {</dt><dd><p>dp = dp + nums[i]</p>
</dd>
<dt>} else {</dt><dd><p>dp = nums[i]</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>if dp &gt; result {</dt><dd><p>result = dp</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return result</p>
</div></blockquote>
<p>}</p>
<p>#
func maxSubArray(nums []int) int {</p>
<blockquote>
<div><p>result := maxSubArr(nums, 0, len(nums)-1)
return result</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func maxSubArr(nums []int, left, right int) int {</dt><dd><dl class="simple">
<dt>if left == right {</dt><dd><p>return nums[left]</p>
</dd>
</dl>
<p>}</p>
<p>mid := (left + right) / 2
leftSum := maxSubArr(nums, left, mid)        // 最大子序在左边
rightSum := maxSubArr(nums, mid+1, right)    // 最大子序在右边
midSum := findMaxArr(nums, left, mid, right) // 跨中心
result := max(leftSum, rightSum)
result = max(result, midSum)
return result</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func findMaxArr(nums []int, left, mid, right int) int {</dt><dd><p>leftSum := math.MinInt32
sum := 0
// 从右到左
for i := mid; i &gt;= left; i– {</p>
<blockquote>
<div><p>sum += nums[i]
leftSum = max(leftSum, sum)</p>
</div></blockquote>
<p>}</p>
<p>rightSum := math.MinInt32
sum = 0
// 从左到右
for i := mid + 1; i &lt;= right; i++ {</p>
<blockquote>
<div><p>sum += nums[i]
rightSum = max(rightSum, sum)</p>
</div></blockquote>
<p>}
return leftSum + rightSum</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func max(a, b int) int {</dt><dd><dl class="simple">
<dt>if a &gt; b {</dt><dd><p>return a</p>
</dd>
</dl>
<p>}
return b</p>
</dd>
</dl>
</div>
<div class="section" id="id763">
<h1>}<a class="headerlink" href="#id763" title="永久链接至标题">¶</a></h1>
<p>## 面试题43.1～n整数中1出现的次数(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">输入一个整数</span> <span class="pre">n</span> <span class="pre">，求1～n这n个整数的十进制表示中1出现的次数。</span>
<span class="pre">例如，输入12，1～12这些整数中包含1</span> <span class="pre">的数字有1、10、11和12，1一共出现了5次。</span>
<span class="pre">示例</span> <span class="pre">1：输入：n</span> <span class="pre">=</span> <span class="pre">12</span> <span class="pre">出：5</span>
<span class="pre">示例</span> <span class="pre">2：输入：n</span> <span class="pre">=</span> <span class="pre">13</span> <span class="pre">出：6</span>
<span class="pre">限制：</span> <span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">n</span> <span class="pre">&lt;</span> <span class="pre">2^31</span>
<span class="pre">注意：本题与主站</span> <span class="pre">233</span> <span class="pre">题相同：</span>
<span class="pre">https://leetcode-cn.com/problems/number-of-digit-one/</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路                  | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ——————— | ———- | ———- |</div>
<div class="line">01   | 找规律-遍历           | O(log(n))  | O(1)       |</div>
<div class="line">02   | 找规律-递归(书上方法) | O(log(n))  | O(log(n))  |</div>
<div class="line">03   | 找规律                | O(log(n))  | O(1)       |</div>
</div>
<p><a href="#id764"><span class="problematic" id="id765">``</span></a><a href="#id766"><span class="problematic" id="id767">`</span></a>go
func countDigitOne(n int) int {</p>
<blockquote>
<div><p>res := 0
digit := 1
high := n / 10
cur := n % 10
low := 0
for high != 0 || cur != 0 {</p>
<blockquote>
<div><dl class="simple">
<dt>if cur == 0 {</dt><dd><p>res = res + high*digit</p>
</dd>
<dt>} else if cur == 1 {</dt><dd><p>res = res + high*digit + low + 1</p>
</dd>
<dt>} else {</dt><dd><p>res = res + (high+1)*digit</p>
</dd>
</dl>
<p>}
low = low + cur*digit
cur = high % 10
high = high / 10
digit = digit * 10</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
func dfs(str string) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if str == “” {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
first := int(str[0] - ‘0’)
if len(str) == 1 &amp;&amp; first == 0 {</p>
<blockquote>
<div><p>return 0</p>
</div></blockquote>
<p>}
if len(str) == 1 &amp;&amp; first &gt;= 1 {</p>
<blockquote>
<div><p>return 1</p>
</div></blockquote>
<p>}
count := 0
if first &gt; 1 {</p>
<blockquote>
<div><p>count = int(math.Pow(float64(10), float64(len(str)-1)))</p>
</div></blockquote>
<dl class="simple">
<dt>} else if first == 1 {</dt><dd><p>count, _ = strconv.Atoi(str[1:])
count = count + 1</p>
</dd>
</dl>
<p>}
other := first * (len(str) - 1) * int(math.Pow(float64(10), float64(len(str)-2)))
numLeft := dfs(str[1:])
return count + numLeft + other</p>
</div></blockquote>
<p>}</p>
<p>#
func countDigitOne(n int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if n &lt;= 0 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
res := 0
for i := 1; i &lt;= n; i = i * 10 {</p>
<blockquote>
<div><p>left := n / i
right := n % i
res = res + (left+8)/10*i
if left%10 == 1 {</p>
<blockquote>
<div><p>res = res + right + 1</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
</div>
<div class="section" id="id768">
<h1>}<a class="headerlink" href="#id768" title="永久链接至标题">¶</a></h1>
<p>## 面试题44.数字序列中某一位的数字(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">数字以0123456789101112131415…的格式序列化到一个字符序列中。</span>
<span class="pre">在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</span>
<span class="pre">请写一个函数，求任意第n位对应的数字。</span>
<span class="pre">示例</span> <span class="pre">1：输入：n</span> <span class="pre">=</span> <span class="pre">3</span> <span class="pre">输出：3</span>
<span class="pre">示例</span> <span class="pre">2：输入：n</span> <span class="pre">=</span> <span class="pre">11</span> <span class="pre">输出：0</span>
<span class="pre">限制：</span> <span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">n</span> <span class="pre">&lt;</span> <span class="pre">2^31</span>
<span class="pre">注意：本题与主站</span> <span class="pre">400</span> <span class="pre">题相同：https://leetcode-cn.com/problems/nth-digit/</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路             | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —————- | ———- | ———- |</div>
<div class="line">01   | 找规律(书上方法) | O(log(n))  | O(1)       |</div>
<div class="line">02   | 找规律           | O(log(n))  | P          |</div>
</div>
<p><a href="#id769"><span class="problematic" id="id770">``</span></a><a href="#id771"><span class="problematic" id="id772">`</span></a>go
func findNthDigit(n int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if n &lt; 0 {</dt><dd><p>return -1</p>
</dd>
</dl>
<p>}
digits := 1
for {</p>
<blockquote>
<div><p>numbers := countOfIntegers(digits)
if n &lt; numbers*digits {</p>
<blockquote>
<div><p>return digitAtIndex(n, digits)</p>
</div></blockquote>
<p>}
n = n - numbers*digits
digits++</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func countOfIntegers(n int) int {</dt><dd><dl class="simple">
<dt>if n == 1 {</dt><dd><p>return 10</p>
</dd>
</dl>
<p>}
count := math.Pow(float64(10), float64(n-1))
return 9 * int(count)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func digitAtIndex(n, digits int) int {</dt><dd><p>number := beginNumber(digits) + n/digits
indexFromRight := digits - n%digits
for i := 1; i &lt; indexFromRight; i++ {</p>
<blockquote>
<div><p>number = number / 10</p>
</div></blockquote>
<p>}
return number % 10</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func beginNumber(digits int) int {</dt><dd><dl class="simple">
<dt>if digits == 1 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
return int(math.Pow(float64(10), float64(digits-1)))</p>
</dd>
</dl>
<p>}</p>
<p>#
/*
1-9     9*1 1位
10-99   90*2 2位
100-999 900*3 3位
<a href="#id773"><span class="problematic" id="id774">*</span></a>/
func findNthDigit(n int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if n &lt; 10 {</dt><dd><p>return n</p>
</dd>
</dl>
<p>}
digits := 1
count := 9
number := 1
for n-digits*count &gt; 0 {</p>
<blockquote>
<div><p>n = n - digits*count
digits++
count = count * 10
number = number * 10</p>
</div></blockquote>
<p>}
number = number + (n-1)/digits
index := (n - 1) % digits
str := strconv.Itoa(number)
return int(str[index] - ‘0’)</p>
</div></blockquote>
</div>
<div class="section" id="id775">
<h1>}<a class="headerlink" href="#id775" title="永久链接至标题">¶</a></h1>
<p>## 面试题45.把数组排成最小的数(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id776"><span class="problematic" id="id777">``</span></a>`
输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。
示例 1:输入: [10,2] 输出: “102”
示例 2:输入: [3,30,34,5,9] 输出: “3033459”
提示:0 &lt; nums.length &lt;= 100
说明:</p>
<blockquote>
<div><p>输出结果可能非常大，所以你需要返回一个字符串而不是整数
拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0</p>
</div></blockquote>
<p><a href="#id778"><span class="problematic" id="id779">``</span></a><a href="#id780"><span class="problematic" id="id781">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路           | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ————– | ———- | ———- |</div>
<div class="line">01   | 自定义排序     | O(nlog(n)) | O(n)       |</div>
<div class="line">02   | 快排(书上方法) | O(nlog(n)) | O(n)       |</div>
<div class="line">03   | 实现sort接口   | O(nlog(n)) | O(n)       |</div>
</div>
<p><a href="#id782"><span class="problematic" id="id783">``</span></a><a href="#id784"><span class="problematic" id="id785">`</span></a>go
func minNumber(nums []int) string {</p>
<blockquote>
<div><dl>
<dt>sort.Slice(nums, func(i, j int) bool {</dt><dd><dl class="simple">
<dt>if fmt.Sprintf(“%d%d”, nums[i], nums[j]) &lt;</dt><dd><p>fmt.Sprintf(“%d%d”, nums[j], nums[i]) {
return true</p>
</dd>
</dl>
<p>}
return false</p>
</dd>
</dl>
<p>})
str := “”
for i := 0; i &lt; len(nums); i++ {</p>
<blockquote>
<div><p>str = str + fmt.Sprintf(“%d”, nums[i])</p>
</div></blockquote>
<p>}
return str</p>
</div></blockquote>
<p>}</p>
<p>#
var arr []string</p>
<dl>
<dt>func minNumber(nums []int) string {</dt><dd><p>arr = make([]string, 0)
for i := 0; i &lt; len(nums); i++ {</p>
<blockquote>
<div><p>arr = append(arr, strconv.Itoa(nums[i]))</p>
</div></blockquote>
<p>}
quickSort(0, len(arr)-1)
str := “”
for i := 0; i &lt; len(arr); i++ {</p>
<blockquote>
<div><p>str = str + arr[i]</p>
</div></blockquote>
<p>}
return str</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func quickSort(start, end int) {</dt><dd><dl class="simple">
<dt>if start &gt;= end {</dt><dd><p>return</p>
</dd>
</dl>
<p>}
temp := arr[start]
i := start
j := end
for i &lt; j {</p>
<blockquote>
<div><dl class="simple">
<dt>for i &lt; j &amp;&amp; arr[j]+temp &gt;= temp+arr[j] {</dt><dd><p>j–</p>
</dd>
</dl>
<p>}
for i &lt; j &amp;&amp; arr[i]+temp &lt;= temp+arr[i] {</p>
<blockquote>
<div><p>i++</p>
</div></blockquote>
<p>}
arr[i], arr[j] = arr[j], arr[i]</p>
</div></blockquote>
<p>}
arr[start], arr[i] = arr[i], temp
quickSort(start, i-1)
quickSort(i+1, end)</p>
</dd>
</dl>
<p>}</p>
<p>#
type Arr []string</p>
<dl class="simple">
<dt>func (a Arr) Len() int {</dt><dd><p>return len(a)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func (a Arr) Less(i, j int) bool {</dt><dd><dl class="simple">
<dt>if a[i]+a[j] &lt; a[j]+a[i] {</dt><dd><p>return true</p>
</dd>
</dl>
<p>}
return false</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>func (a Arr) Swap(i, j int) {</dt><dd><p>a[i], a[j] = a[j], a[i]</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func minNumber(nums []int) string {</dt><dd><p>var arr Arr
for i := 0; i &lt; len(nums); i++ {</p>
<blockquote>
<div><p>arr = append(arr, strconv.Itoa(nums[i]))</p>
</div></blockquote>
<p>}
sort.Sort(arr)
str := “”
for i := 0; i &lt; len(arr); i++ {</p>
<blockquote>
<div><p>str = str + arr[i]</p>
</div></blockquote>
<p>}
return str</p>
</dd>
</dl>
</div>
<div class="section" id="id786">
<h1>}<a class="headerlink" href="#id786" title="永久链接至标题">¶</a></h1>
<p>## 面试题46.把数字翻译成字符串(4)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">给定一个数字，我们按照如下规则把它翻译为字符串：0</span> <span class="pre">翻译成</span> <span class="pre">“a”</span> <span class="pre">，1</span> <span class="pre">翻译成</span> <span class="pre">“b”，……，</span>
<span class="pre">11</span> <span class="pre">翻译成</span> <span class="pre">“l”，……，25</span> <span class="pre">翻译成</span> <span class="pre">“z”。</span>
<span class="pre">一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</span>
<span class="pre">示例</span> <span class="pre">1:输入:</span> <span class="pre">12258</span> <span class="pre">输出:</span> <span class="pre">5</span>
<span class="pre">解释:</span> <span class="pre">12258有5种不同的翻译，分别是&quot;bccfi&quot;,</span> <span class="pre">&quot;bwfi&quot;,</span> <span class="pre">&quot;bczi&quot;,</span> <span class="pre">&quot;mcfi&quot;和&quot;mzi&quot;</span>
<span class="pre">提示：</span> <span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">num</span> <span class="pre">&lt;</span> <span class="pre">231</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路              | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —————– | ———- | ———- |</div>
<div class="line">01   | 遍历(书上方法)    | O(log(n))  | O(log(n))  |</div>
<div class="line">02   | 递归              | O(log(n))  | O(log(n))  |</div>
<div class="line">03   | 遍历-从后往前     | O(log(n))  | O(1)       |</div>
<div class="line">04   | 动态规划-一维数组 | O(log(n))  | O(log(n))  |</div>
</div>
<p><a href="#id787"><span class="problematic" id="id788">``</span></a><a href="#id789"><span class="problematic" id="id790">`</span></a>go
func translateNum(num int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if num &lt; 0 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
return getTranslateNum(strconv.Itoa(num))</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func getTranslateNum(str string) int {</dt><dd><p>length := len(str)
arr := make([]int, length)
count := 0
for i := length - 1; i &gt;= 0; i– {</p>
<blockquote>
<div><p>count = 0
if i &lt; length-1 {</p>
<blockquote>
<div><p>count = arr[i+1]</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>count = 1</p>
</dd>
</dl>
<p>}
if i &lt; length-1 {</p>
<blockquote>
<div><p>digit1 := str[i] - ‘0’
digit2 := str[i+1] - ‘0’
value := digit1*10 + digit2
if value &gt;= 10 &amp;&amp; value &lt;= 25 {</p>
<blockquote>
<div><dl class="simple">
<dt>if i &lt; length-2 {</dt><dd><p>count += arr[i+2]</p>
</dd>
<dt>} else {</dt><dd><p>count += 1</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
arr[i] = count</p>
</div></blockquote>
<p>}
return arr[0]</p>
</dd>
</dl>
<p>}</p>
<p>#
func translateNum(num int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if num &lt; 10 {</dt><dd><p>return 1</p>
</dd>
</dl>
<p>}
var res int
if num%100 &lt;= 25 &amp;&amp; num%100 &gt; 9 {</p>
<blockquote>
<div><p>res = res + translateNum(num/100)
res = res + translateNum(num/10)</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>res = res + translateNum(num/10)</p>
</dd>
</dl>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
// f(i)=f(i-2)+f(i-1)
// f(i)=f(i-1)
func translateNum(num int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if num &lt; 0 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
arr := make([]int, 1)
arr[0] = 1
i := 0
prev := -1
for num &gt; 0 {</p>
<blockquote>
<div><p>i++
arr = append(arr, 0)
arr[i] = arr[i-1]
digit1 := num % 10
num = num / 10
if digit1 != 0 &amp;&amp; prev &gt;= 0 &amp;&amp; digit1*10+prev &lt;= 25 {</p>
<blockquote>
<div><p>arr[i] = arr[i] + arr[i-2]</p>
</div></blockquote>
<p>}
prev = digit1</p>
</div></blockquote>
<p>}
return arr[i]</p>
</div></blockquote>
<p>}</p>
<p>#
// f(i)=f(i-2)+f(i-1)
// f(i)=f(i-1)
func translateNum(num int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if num &lt; 0 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
str := strconv.Itoa(num)
arr := make([]int, len(str))
for i := 0; i &lt; len(str); i++ {</p>
<blockquote>
<div><p>arr[i] = int(str[i] - ‘0’)</p>
</div></blockquote>
<p>}
dp := make([]int, len(str)+1)
dp[0] = 1
dp[1] = 1
for i := 2; i &lt; len(str)+1; i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if arr[i-2] != 0 &amp;&amp; (arr[i-2]*10+arr[i-1] &lt;= 25) {</dt><dd><p>dp[i] = dp[i-1] + dp[i-2]</p>
</dd>
<dt>} else {</dt><dd><p>dp[i] = dp[i-1]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return dp[len(str)]</p>
</div></blockquote>
</div>
<div class="section" id="id791">
<h1>}<a class="headerlink" href="#id791" title="永久链接至标题">¶</a></h1>
<p>## 面试题47.礼物的最大价值(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id792"><span class="problematic" id="id793">``</span></a>`
在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。
你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。
给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？
示例 1:输入:
[</p>
<blockquote>
<div><p>[1,3,1],
[1,5,1],
[4,2,1]</p>
</div></blockquote>
<p>]
输出: 12 解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物
提示：</p>
<blockquote>
<div><p>0 &lt; grid.length &lt;= 200
0 &lt; grid[0].length &lt;= 200</p>
</div></blockquote>
<p><a href="#id794"><span class="problematic" id="id795">``</span></a><a href="#id796"><span class="problematic" id="id797">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路               | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —————— | ———- | ———- |</div>
<div class="line">01   | 动态规划(书上方法) | O(n^2)     | O(n^2)     |</div>
<div class="line">02   | 动态规划(书上方法) | O(n^2)     | O(n)       |</div>
</div>
<p><a href="#id798"><span class="problematic" id="id799">``</span></a><a href="#id800"><span class="problematic" id="id801">`</span></a>go
func maxValue(grid [][]int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if len(grid) == 0 || len(grid[0]) == 0 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
dp := make([][]int, len(grid))
for i := 0; i &lt; len(grid); i++ {</p>
<blockquote>
<div><p>dp[i] = make([]int, len(grid[0]))</p>
</div></blockquote>
<p>}
for i := 0; i &lt; len(grid); i++ {</p>
<blockquote>
<div><dl>
<dt>for j := 0; j &lt; len(grid[0]); j++ {</dt><dd><p>left := 0
up := 0
if i &gt; 0 {</p>
<blockquote>
<div><p>left = dp[i-1][j]</p>
</div></blockquote>
<p>}
if j &gt; 0 {</p>
<blockquote>
<div><p>up = dp[i][j-1]</p>
</div></blockquote>
<p>}
// dp[i][j]=grid[i-1][j-1]+max(dp[i][j-1],dp[i-1][j])
dp[i][j] = max(left, up) + grid[i][j]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return dp[len(grid)-1][len(grid[0])-1]</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func max(a, b int) int {</dt><dd><dl class="simple">
<dt>if a &gt; b {</dt><dd><p>return a</p>
</dd>
</dl>
<p>}
return b</p>
</dd>
</dl>
<p>}</p>
<p>#
func maxValue(grid [][]int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if len(grid) == 0 || len(grid[0]) == 0 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
dp := make([]int, len(grid))
for i := 0; i &lt; len(grid); i++ {</p>
<blockquote>
<div><dl>
<dt>for j := 0; j &lt; len(grid[0]); j++ {</dt><dd><p>left := 0
up := 0
if i &gt; 0 {</p>
<blockquote>
<div><p>left = dp[j]</p>
</div></blockquote>
<p>}
if j &gt; 0 {</p>
<blockquote>
<div><p>up = dp[j-1]</p>
</div></blockquote>
<p>}
// dp[j]=grid[i-1][j-1]+max(dp[j-1],dp[j])
dp[j] = max(left, up) + grid[i][j]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return dp[len(grid[0])-1]</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func max(a, b int) int {</dt><dd><dl class="simple">
<dt>if a &gt; b {</dt><dd><p>return a</p>
</dd>
</dl>
<p>}
return b</p>
</dd>
</dl>
</div>
<div class="section" id="id802">
<h1>}<a class="headerlink" href="#id802" title="永久链接至标题">¶</a></h1>
<p>## 面试题48.最长不含重复字符的子字符串(4)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id803"><span class="problematic" id="id804">``</span></a>`
请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。
示例 1:输入: “abcabcbb” 输出: 3
解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。
示例 2:输入: “bbbbb” 输出: 1
解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。
示例 3:输入: “pwwkew” 输出: 3
解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。</p>
<blockquote>
<div><p>请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p>
</div></blockquote>
<p>提示：s.length &lt;= 40000
注意：本题与主站 3 题相同：
<a class="reference external" href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/</a>
<a href="#id805"><span class="problematic" id="id806">``</span></a><a href="#id807"><span class="problematic" id="id808">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路               | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —————— | ———- | ———- |</div>
<div class="line">01   | 遍历+滑动窗口      | O(n)       | O(n)       |</div>
<div class="line">02   | 双指针             | O(n)       | O(1)       |</div>
<div class="line">03   | 动态规划           | O(n)       | O(n)       |</div>
<div class="line">04   | 动态规划(书上方法) | O(n)       | O(1)       |</div>
</div>
<p><a href="#id809"><span class="problematic" id="id810">``</span></a><a href="#id811"><span class="problematic" id="id812">`</span></a>go
func lengthOfLongestSubstring(s string) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if len(s) &lt; 1 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
m := make(map[int32]int)
arr := make([]int32, 0)
res := 0
for _, value := range s {</p>
<blockquote>
<div><dl>
<dt>if v, ok := m[value]; ok &amp;&amp; v &gt; 0 {</dt><dd><dl class="simple">
<dt>for len(arr) &gt; 0 &amp;&amp; arr[0] != value {</dt><dd><p>m[arr[0]]–
arr = arr[1:]</p>
</dd>
</dl>
<p>}
m[arr[0]]–
arr = arr[1:]</p>
</dd>
</dl>
<p>}
m[value]++
arr = append(arr, value)
if len(arr) &gt; res {</p>
<blockquote>
<div><p>res = len(arr)</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
func lengthOfLongestSubstring(s string) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if len(s) &lt; 1 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
left := 0
right := 0
res := 0
for left &lt;= right {</p>
<blockquote>
<div><p>m := make(map[byte]int)
for i := left; i &lt; right; i++ {</p>
<blockquote>
<div><p>m[s[i]]++</p>
</div></blockquote>
<p>}
for right &lt; len(s) {</p>
<blockquote>
<div><dl>
<dt>if value, ok := m[s[right]]; ok &amp;&amp; value &gt; 0 {</dt><dd><dl class="simple">
<dt>if right-left &gt; res {</dt><dd><p>res = right - left</p>
</dd>
</dl>
<p>}
left++
break</p>
</dd>
<dt>} else {</dt><dd><p>m[s[right]]++
right++</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
if right-left &gt; res {</p>
<blockquote>
<div><p>res = right - left</p>
</div></blockquote>
<p>}
if right &gt;= len(s)-1 {</p>
<blockquote>
<div><p>break</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
// dp[n]=dp[n-1]+1
// dp[n]=n-lastIndex
func lengthOfLongestSubstring(s string) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if len(s) &lt; 1 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
dp := make([]int, len(s))
dp[0] = 1
res := 1
m := make(map[byte]int)
m[s[0]] = 0
for i := 1; i &lt; len(s); i++ {</p>
<blockquote>
<div><p>index := -1
if value, ok := m[s[i]]; ok {</p>
<blockquote>
<div><p>index = value</p>
</div></blockquote>
<p>}
if i-index &gt; dp[i-1] {</p>
<blockquote>
<div><p>dp[i] = dp[i-1] + 1</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>dp[i] = i - index</p>
</dd>
</dl>
<p>}
m[s[i]] = i
if dp[i] &gt; res {</p>
<blockquote>
<div><p>res = dp[i]</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
func lengthOfLongestSubstring(s string) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if len(s) &lt; 1 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
res := 1
arr := make(map[byte]int)
curLength := 0
for i := 0; i &lt; len(s); i++ {</p>
<blockquote>
<div><dl>
<dt>if preIndex, ok := arr[s[i]]; !ok || i-preIndex &gt; curLength {</dt><dd><p>curLength++</p>
</dd>
<dt>} else {</dt><dd><dl class="simple">
<dt>if curLength &gt; res {</dt><dd><p>res = curLength</p>
</dd>
</dl>
<p>}
curLength = i - preIndex</p>
</dd>
</dl>
<p>}
arr[s[i]] = i</p>
</div></blockquote>
<p>}
if curLength &gt; res {</p>
<blockquote>
<div><p>res = curLength</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
</div>
<div class="section" id="id813">
<h1>}<a class="headerlink" href="#id813" title="永久链接至标题">¶</a></h1>
<p>## 面试题49.丑数(1)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">我们把只包含因子</span> <span class="pre">2、3</span> <span class="pre">和</span> <span class="pre">5</span> <span class="pre">的数称作丑数（Ugly</span> <span class="pre">Number）。求按从小到大的顺序的第</span> <span class="pre">n</span> <span class="pre">个丑数。</span>
<span class="pre">示例:输入:</span> <span class="pre">n</span> <span class="pre">=</span> <span class="pre">10</span> <span class="pre">输出:</span> <span class="pre">12</span>
<span class="pre">解释:</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">5,</span> <span class="pre">6,</span> <span class="pre">8,</span> <span class="pre">9,</span> <span class="pre">10,</span> <span class="pre">12</span> <span class="pre">是前</span> <span class="pre">10</span> <span class="pre">个丑数。</span>
<span class="pre">说明:</span> <span class="pre">1</span> <span class="pre">是丑数。n</span> <span class="pre">不超过1690。</span>
<span class="pre">注意：本题与主站</span> <span class="pre">264</span> <span class="pre">题相同：https://leetcode-cn.com/problems/ugly-number-ii/</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路               | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —————— | ———- | ———- |</div>
<div class="line">01   | 动态规划(书上方法) | O(n)       | O(n)       |</div>
</div>
<p><a href="#id814"><span class="problematic" id="id815">``</span></a><a href="#id816"><span class="problematic" id="id817">`</span></a>go
func nthUglyNumber(n int) int {</p>
<blockquote>
<div><blockquote>
<div><p>dp := make([]int, n)
dp[0] = 1</p>
</div></blockquote>
<dl>
<dt>// 丑数*2或3或5之后还是丑数</dt><dd><p>idx2, idx3, idx5 := 0, 0, 0
for i := 1; i &lt; n; i++ {</p>
<blockquote>
<div><p>dp[i] = min(dp[idx2]*2, min(dp[idx3]*3, dp[idx5]*5))
if dp[i] == dp[idx2]*2 {</p>
<blockquote>
<div><p>idx2++</p>
</div></blockquote>
<p>}
if dp[i] == dp[idx3]*3 {</p>
<blockquote>
<div><p>idx3++</p>
</div></blockquote>
<p>}
if dp[i] == dp[idx5]*5 {</p>
<blockquote>
<div><p>idx5++</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return dp[n-1]</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<dl>
<dt>func min(a, b int) int {</dt><dd><dl class="simple">
<dt>if a &gt; b {</dt><dd><p>return b</p>
</dd>
</dl>
<p>}go
return a</p>
</dd>
</dl>
</div>
<div class="section" id="id818">
<h1>}<a class="headerlink" href="#id818" title="永久链接至标题">¶</a></h1>
<p>## 面试题50.第一个只出现一次的字符(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">在字符串</span> <span class="pre">s</span> <span class="pre">中找出第一个只出现一次的字符。如果没有，返回一个单空格。</span> <span class="pre">s</span> <span class="pre">只包含小写字母。</span>
<span class="pre">示例:</span>
<span class="pre">s</span> <span class="pre">=</span> <span class="pre">&quot;abaccdeff&quot;</span> <span class="pre">返回</span> <span class="pre">&quot;b&quot;</span>
<span class="pre">s</span> <span class="pre">=</span> <span class="pre">&quot;&quot;</span> <span class="pre">返回</span> <span class="pre">&quot;</span> <span class="pre">&quot;</span>
<span class="pre">限制：0</span> <span class="pre">&lt;=</span> <span class="pre">s</span> <span class="pre">的长度</span> <span class="pre">&lt;=</span> <span class="pre">50000</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路               | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —————— | ———- | ———- |</div>
<div class="line">01   | 哈希辅助(书上方法) | O(n)       | O(1)       |</div>
<div class="line">02   | 数组辅助           | O(n)       | O(1)       |</div>
<div class="line">03   | 暴力法             | O(n^2)     | O(1)       |</div>
</div>
<p><a href="#id819"><span class="problematic" id="id820">``</span></a><a href="#id821"><span class="problematic" id="id822">`</span></a>go
func firstUniqChar(s string) byte {</p>
<blockquote>
<div><p>res := byte(‘ ‘)
m := make(map[byte]int)
for i := 0; i &lt; len(s); i++ {</p>
<blockquote>
<div><p>m[s[i]]++</p>
</div></blockquote>
<p>}
for i := 0; i &lt; len(s); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if m[s[i]] == 1 {</dt><dd><p>return s[i]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
func firstUniqChar(s string) byte {</p>
<blockquote>
<div><p>res := byte(‘ ‘)
m := [26]int{}
for i := 0; i &lt; len(s); i++ {</p>
<blockquote>
<div><p>m[s[i]-‘a’]++</p>
</div></blockquote>
<p>}
for i := 0; i &lt; len(s); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if m[s[i]-‘a’] == 1 {</dt><dd><p>return s[i]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
func firstUniqChar(s string) byte {</p>
<blockquote>
<div><p>res := byte(‘ ‘)
for i := 0; i &lt; len(s); i++ {</p>
<blockquote>
<div><p>flag := true
for j := 0; j &lt; len(s); j++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if s[i] == s[j] &amp;&amp; i != j {</dt><dd><p>flag = false
break</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
if flag {</p>
<blockquote>
<div><p>return s[i]</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
</div>
<div class="section" id="id823">
<h1>}<a class="headerlink" href="#id823" title="永久链接至标题">¶</a></h1>
<p>## 面试题51.数组中的逆序对(1)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。</span>
<span class="pre">输入一个数组，求出这个数组中的逆序对的总数。</span>
<span class="pre">示例</span> <span class="pre">1:输入:</span> <span class="pre">[7,5,6,4]</span> <span class="pre">输出:</span> <span class="pre">5</span>
<span class="pre">限制：0</span> <span class="pre">&lt;=</span> <span class="pre">数组长度</span> <span class="pre">&lt;=</span> <span class="pre">50000</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路               | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —————— | ———- | ———- |</div>
<div class="line">01   | 归并排序(书上方法) | O(nlog(n)) | O(n)       |</div>
</div>
<p><a href="#id824"><span class="problematic" id="id825">``</span></a><a href="#id826"><span class="problematic" id="id827">`</span></a>go
var res int</p>
<dl>
<dt>func reversePairs(nums []int) int {</dt><dd><p>res = 0
if len(nums) &lt;= 1 {</p>
<blockquote>
<div><p>return res</p>
</div></blockquote>
<p>}
merge(nums, 0, len(nums)-1)
return res</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func merge(nums []int, left, right int) {</dt><dd><dl class="simple">
<dt>if left &gt;= right {</dt><dd><p>return</p>
</dd>
</dl>
<p>}
mid := (left + right) / 2
i, j := left, mid+1
merge(nums, left, mid)
merge(nums, mid+1, right)</p>
<p>temp := make([]int, 0)
for i &lt;= mid &amp;&amp; j &lt;= right {</p>
<blockquote>
<div><dl class="simple">
<dt>if nums[i] &lt;= nums[j] {</dt><dd><p>temp = append(temp, nums[i])
i++</p>
</dd>
<dt>} else {</dt><dd><p>res = res + mid - i + 1
temp = append(temp, nums[j])
j++</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
temp = append(temp, nums[i:mid+1]…)
temp = append(temp, nums[j:right+1]…)
for key, value := range temp {</p>
<blockquote>
<div><p>nums[left+key] = value</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div>
<div class="section" id="id828">
<h1>#<a class="headerlink" href="#id828" title="永久链接至标题">¶</a></h1>
<p>## 面试题52.两个链表的第一个公共节点(4)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id829"><span class="problematic" id="id830">``</span></a>`
输入两个链表，找出它们的第一个公共节点。
如下面的两个链表：
在节点 c1 开始相交。
示例 1：
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
示例 2：
输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Reference of the node with value = 2
输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
示例 3：
输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
解释：这两个链表不相交，因此返回 null。
注意：</p>
<blockquote>
<div><p>如果两个链表没有交点，返回 null.
在返回结果后，两个链表仍须保持原有的结构。
可假定整个链表结构中没有循环。
程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。
本题与主站 160 题相同：<a class="reference external" href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a></p>
</div></blockquote>
<p><a href="#id831"><span class="problematic" id="id832">``</span></a><a href="#id833"><span class="problematic" id="id834">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路                                 | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ———————————— | ———- | ———- |</div>
<div class="line">01   | 计算长度后，对齐长度再比较(书上方法) | O(n)       | O(1)       |</div>
<div class="line">02   | 交换后相连，再比较                   | O(n)       | O(1)       |</div>
<div class="line">03   | 暴力法                               | O(n^2)     | O(1)       |</div>
<div class="line">04   | 哈希法                               | O(n)       | O(n)       |</div>
</div>
<p><a href="#id835"><span class="problematic" id="id836">``</span></a><a href="#id837"><span class="problematic" id="id838">`</span></a>go
func getIntersectionNode(headA, headB <a href="#id839"><span class="problematic" id="id840">*</span></a>ListNode) <a href="#id841"><span class="problematic" id="id842">*</span></a>ListNode {</p>
<blockquote>
<div><p>ALength := 0
A := headA
for A != nil {</p>
<blockquote>
<div><p>ALength++
A = A.Next</p>
</div></blockquote>
<p>}
BLength := 0
B := headB
for B != nil {</p>
<blockquote>
<div><p>BLength++
B = B.Next</p>
</div></blockquote>
<p>}</p>
<p>pA := headA
pB := headB
if ALength &gt; BLength {</p>
<blockquote>
<div><p>n := ALength - BLength
for n &gt; 0 {</p>
<blockquote>
<div><p>pA = pA.Next
n–</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<dl>
<dt>} else {</dt><dd><p>n := BLength - ALength
for n &gt; 0 {</p>
<blockquote>
<div><p>pB = pB.Next
n–</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>for pA != pB {</dt><dd><p>pA = pA.Next
pB = pB.Next</p>
</dd>
</dl>
<p>}
return pA</p>
</div></blockquote>
<p>}</p>
<p>#
func getIntersectionNode(headA, headB <a href="#id843"><span class="problematic" id="id844">*</span></a>ListNode) <a href="#id845"><span class="problematic" id="id846">*</span></a>ListNode {</p>
<blockquote>
<div><p>A, B := headA, headB
for A != B {</p>
<blockquote>
<div><dl class="simple">
<dt>if A != nil {</dt><dd><p>A = A.Next</p>
</dd>
<dt>} else {</dt><dd><p>A = headB</p>
</dd>
</dl>
<p>}
if B != nil {</p>
<blockquote>
<div><p>B = B.Next</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>B = headA</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return A</p>
</div></blockquote>
<p>}</p>
<p>#
func getIntersectionNode(headA, headB <a href="#id847"><span class="problematic" id="id848">*</span></a>ListNode) <a href="#id849"><span class="problematic" id="id850">*</span></a>ListNode {</p>
<blockquote>
<div><p>A, B := headA, headB
for A != nil {</p>
<blockquote>
<div><dl>
<dt>for B != nil {</dt><dd><dl class="simple">
<dt>if A == B {</dt><dd><p>return A</p>
</dd>
</dl>
<p>}
B = B.Next</p>
</dd>
</dl>
<p>}
A = A.Next
B = headB</p>
</div></blockquote>
<p>}
return nil</p>
</div></blockquote>
<p>}</p>
<p># 4
func getIntersectionNode(headA, headB <a href="#id851"><span class="problematic" id="id852">*</span></a>ListNode) <a href="#id853"><span class="problematic" id="id854">*</span></a>ListNode {</p>
<blockquote>
<div><p>m := make(map[<a href="#id855"><span class="problematic" id="id856">*</span></a>ListNode]bool)
for headA != nil {</p>
<blockquote>
<div><p>m[headA] = true
headA = headA.Next</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>for headB != nil {</dt><dd><dl class="simple">
<dt>if _, ok := m[headB]; ok {</dt><dd><p>return headB</p>
</dd>
</dl>
<p>}
headB = headB.Next</p>
</dd>
</dl>
<p>}
return nil</p>
</div></blockquote>
</div>
<div class="section" id="id857">
<h1>}<a class="headerlink" href="#id857" title="永久链接至标题">¶</a></h1>
<p>## 面试题53-I.在排序数组中查找数字I(5)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">统计一个数字在排序数组中出现的次数。</span>
<span class="pre">示例</span> <span class="pre">1:输入:</span> <span class="pre">nums</span> <span class="pre">=</span> <span class="pre">[5,7,7,8,8,10],</span> <span class="pre">target</span> <span class="pre">=</span> <span class="pre">8</span> <span class="pre">输出:</span> <span class="pre">2</span>
<span class="pre">示例</span> <span class="pre">2:输入:</span> <span class="pre">nums</span> <span class="pre">=</span> <span class="pre">[5,7,7,8,8,10],</span> <span class="pre">target</span> <span class="pre">=</span> <span class="pre">6</span> <span class="pre">输出:</span> <span class="pre">0</span>
<span class="pre">限制：0</span> <span class="pre">&lt;=</span> <span class="pre">数组长度</span> <span class="pre">&lt;=</span> <span class="pre">50000</span>
<span class="pre">注意：本题与主站</span> <span class="pre">34</span> <span class="pre">题相同（仅返回值不同）：</span>
<span class="pre">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路               | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —————— | ———- | ———- |</div>
<div class="line">01   | 哈希辅助 | O(n)       | O(1)       |</div>
<div class="line">02   | 遍历               | O(n)          | O(1) |</div>
<div class="line">03 | 双指针遍历 | O(n) | O(1) |</div>
<div class="line">04 | 二分查找 | O(log(n)) | O(1) |</div>
<div class="line">04 | 二分查找(书上方法) | O(log(n)) | O(1) |</div>
</div>
<p><a href="#id858"><span class="problematic" id="id859">``</span></a><a href="#id860"><span class="problematic" id="id861">`</span></a>go
func search(nums []int, target int) int {</p>
<blockquote>
<div><p>m := make(map[int]int)
for i := 0; i &lt; len(nums); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if nums[i] == target {</dt><dd><p>m[target]++</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return m[target]</p>
</div></blockquote>
<p>}</p>
<p>#
func search(nums []int, target int) int {</p>
<blockquote>
<div><p>count := 0
for i := 0; i &lt; len(nums); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if nums[i] == target {</dt><dd><p>count++</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return count</p>
</div></blockquote>
<p>}</p>
<p>#
func search(nums []int, target int) int {</p>
<blockquote>
<div><p>i := 0
j := len(nums) - 1
for i &lt; len(nums) &amp;&amp; nums[i] != target {</p>
<blockquote>
<div><p>i++</p>
</div></blockquote>
<p>}
for j &gt;= 0 &amp;&amp; nums[j] != target {</p>
<blockquote>
<div><p>j–</p>
</div></blockquote>
<p>}
if i &gt; j {</p>
<blockquote>
<div><p>return 0</p>
</div></blockquote>
<p>}
return j - i + 1</p>
</div></blockquote>
<p>}</p>
<p>#
func search(nums []int, target int) int {</p>
<blockquote>
<div><p>left := 0
right := len(nums) - 1
count := 0
for left &lt;= right{</p>
<blockquote>
<div><p>mid := left+(right-left)/2
if nums[mid] == target{</p>
<blockquote>
<div><p>count++
for i := mid+1; i &lt; len(nums); i++{</p>
<blockquote>
<div><dl class="simple">
<dt>if nums[i] == target{</dt><dd><p>count++</p>
</dd>
<dt>}else {</dt><dd><p>break</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
for i := mid-1; i &gt;= 0; i–{</p>
<blockquote>
<div><dl class="simple">
<dt>if nums[i] == target{</dt><dd><p>count++</p>
</dd>
<dt>}else {</dt><dd><p>break</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return count</p>
</div></blockquote>
<p>}
if nums[mid] &gt; target{</p>
<blockquote>
<div><p>right = mid-1</p>
</div></blockquote>
<dl class="simple">
<dt>}else {</dt><dd><p>left = mid+1</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return count</p>
</div></blockquote>
<p>}</p>
<p>#
func search(nums []int, target int) int {</p>
<blockquote>
<div><p>count := 0
if len(nums) &gt; 0 {</p>
<blockquote>
<div><p>first := getFirstK(nums, target, 0, len(nums)-1)
last := getLastK(nums, target, 0, len(nums)-1)
if first &gt; -1 &amp;&amp; last &gt; -1 {</p>
<blockquote>
<div><p>count = last - first + 1</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return count</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func getFirstK(nums []int, target int, start, end int) int {</dt><dd><dl class="simple">
<dt>if start &gt; end {</dt><dd><p>return -1</p>
</dd>
</dl>
<p>}
mid := start + (end-start)/2
if nums[mid] == target {</p>
<blockquote>
<div><dl class="simple">
<dt>if (mid &gt; 0 &amp;&amp; nums[mid-1] != target) || mid == 0 {</dt><dd><p>return mid</p>
</dd>
<dt>} else {</dt><dd><p>end = mid - 1</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl class="simple">
<dt>} else if nums[mid] &gt; target {</dt><dd><p>end = mid - 1</p>
</dd>
<dt>} else {</dt><dd><p>start = mid + 1</p>
</dd>
</dl>
<p>}
return getFirstK(nums, target, start, end)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func getLastK(nums []int, target int, start, end int) int {</dt><dd><dl class="simple">
<dt>if start &gt; end {</dt><dd><p>return -1</p>
</dd>
</dl>
<p>}
mid := start + (end-start)/2
if nums[mid] == target {</p>
<blockquote>
<div><dl class="simple">
<dt>if (mid &lt; len(nums)-1 &amp;&amp; nums[mid+1] != target) || mid == len(nums)-1 {</dt><dd><p>return mid</p>
</dd>
<dt>} else {</dt><dd><p>start = mid + 1</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl class="simple">
<dt>} else if nums[mid] &lt; target {</dt><dd><p>start = mid + 1</p>
</dd>
<dt>} else {</dt><dd><p>end = mid - 1</p>
</dd>
</dl>
<p>}
return getLastK(nums, target, start, end)</p>
</dd>
</dl>
</div>
<div class="section" id="id862">
<h1>}<a class="headerlink" href="#id862" title="永久链接至标题">¶</a></h1>
<p>## 面试题53-II.0～n-1中缺失的数字(6)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。</span>
<span class="pre">在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</span>
<span class="pre">示例</span> <span class="pre">1:输入:</span> <span class="pre">[0,1,3]</span> <span class="pre">输出:</span> <span class="pre">2</span>
<span class="pre">示例</span> <span class="pre">2:输入:</span> <span class="pre">[0,1,2,3,4,5,6,7,9]</span> <span class="pre">输出:</span> <span class="pre">8</span>
<span class="pre">限制：1</span> <span class="pre">&lt;=</span> <span class="pre">数组长度</span> <span class="pre">&lt;=</span> <span class="pre">10000</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路               | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —————— | ———- | ———- |</div>
<div class="line">01   | 数学计算           | O(n)       | O(1)       |</div>
<div class="line">02   | 遍历               | O(n)       | O(1)       |</div>
<div class="line">03   | 异或-位运算        | O(n)       | O(1)       |</div>
<div class="line">04   | 哈希辅助           | O(n)       | O(n)       |</div>
<div class="line">05   | 二分查找(书上方法) | O(log(n))  | O(1)       |</div>
<div class="line">06   | 内置函数           | O(n)       | O(1)       |</div>
</div>
<p><a href="#id863"><span class="problematic" id="id864">``</span></a><a href="#id865"><span class="problematic" id="id866">`</span></a>go
func missingNumber(nums []int) int {</p>
<blockquote>
<div><p>n := len(nums)
sum := n * (n + 1) / 2
for i := 0; i &lt; n; i++ {</p>
<blockquote>
<div><p>sum = sum - nums[i]</p>
</div></blockquote>
<p>}
return sum</p>
</div></blockquote>
<p>}</p>
<p># 2
func missingNumber(nums []int) int {</p>
<blockquote>
<div><dl>
<dt>for i := 0; i &lt; len(nums); i++ {</dt><dd><dl class="simple">
<dt>if nums[i] != i {</dt><dd><p>return i</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
return len(nums)</p>
</div></blockquote>
<p>}</p>
<p># 3
func missingNumber(nums []int) int {</p>
<blockquote>
<div><p>res := 0
for i := 0; i &lt; len(nums); i++ {</p>
<blockquote>
<div><p>res = res ^ (i+1) ^ nums[i]</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p># 4
func missingNumber(nums []int) int {</p>
<blockquote>
<div><p>m := make(map[int]bool)
for i := range nums{</p>
<blockquote>
<div><p>m[nums[i]] = true</p>
</div></blockquote>
<p>}
for i := 0; i &lt;= len(nums); i++{</p>
<blockquote>
<div><dl class="simple">
<dt>if m[i] == false{</dt><dd><p>return i</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return 0</p>
</div></blockquote>
<p>}</p>
<p># 5
func missingNumber(nums []int) int {</p>
<blockquote>
<div><p>left := 0
right := len(nums) - 1
for left &lt;= right {</p>
<blockquote>
<div><p>mid := left + (right-left)/2
if nums[mid] != mid {</p>
<blockquote>
<div><p>right = mid - 1</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>left = mid + 1</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return left</p>
</div></blockquote>
<p>}</p>
<p>#
func missingNumber(nums []int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>return sort.Search(len(nums), func(i int) bool {</dt><dd><p>return nums[i] != i</p>
</dd>
</dl>
<p>})</p>
</div></blockquote>
</div>
<div class="section" id="id867">
<h1>}<a class="headerlink" href="#id867" title="永久链接至标题">¶</a></h1>
<p>## 面试题54.二叉搜索树的第k大节点(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id868"><span class="problematic" id="id869">``</span></a>`
给定一棵二叉搜索树，请找出其中第k大的节点。
示例 1:
输入: root = [3,1,4,null,2], k = 1</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>3</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<dl class="simple">
<dt>1   4</dt><dd><dl class="simple">
<dt></dt><dd><p>2</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>输出: 4
示例 2:输入: root = [5,3,6,2,4,null,null,1], k = 3</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><p>5</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<p>3   6</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<p>2   4</p>
</div></blockquote>
<p>/</p>
</div></blockquote>
<p>1</p>
</div></blockquote>
<p>输出: 4
限制：1 ≤ k ≤ 二叉搜索树元素个数
<a href="#id870"><span class="problematic" id="id871">``</span></a><a href="#id872"><span class="problematic" id="id873">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路      | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ——— | ———- | ———- |</div>
<div class="line">01   | 递归(书上方法) | O(n)       | O(log(n)) |</div>
<div class="line">02   | 递归+数组 |  O(n)          | O(n) |</div>
<div class="line">03 | 迭代 | O(n) | O(n) |</div>
</div>
<p><a href="#id874"><span class="problematic" id="id875">``</span></a><a href="#id876"><span class="problematic" id="id877">`</span></a>go
var count int
var res int</p>
<dl class="simple">
<dt>func kthLargest(root <a href="#id878"><span class="problematic" id="id879">*</span></a>TreeNode, k int) int {</dt><dd><p>count = k
res = 0
dfs(root)
return res</p>
</dd>
</dl>
<p>}
func dfs(root <a href="#id880"><span class="problematic" id="id881">*</span></a>TreeNode) {</p>
<blockquote>
<div><dl class="simple">
<dt>if root == nil {</dt><dd><p>return</p>
</dd>
</dl>
<p>}
dfs(root.Right)
count–
if count == 0 {</p>
<blockquote>
<div><p>res = root.Val
return</p>
</div></blockquote>
<p>}
dfs(root.Left)</p>
</div></blockquote>
<p>}</p>
<p>#
var arr []int</p>
<dl class="simple">
<dt>func kthLargest(root <a href="#id882"><span class="problematic" id="id883">*</span></a>TreeNode, k int) int {</dt><dd><p>arr = make([]int, 0)
dfs(root)
return arr[k-1]</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func dfs(root <a href="#id884"><span class="problematic" id="id885">*</span></a>TreeNode) {</dt><dd><dl class="simple">
<dt>if root == nil {</dt><dd><p>return</p>
</dd>
</dl>
<p>}
dfs(root.Right)
arr = append(arr, root.Val)
dfs(root.Left)</p>
</dd>
</dl>
<p>}</p>
<p>#
func kthLargest(root <a href="#id886"><span class="problematic" id="id887">*</span></a>TreeNode, k int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if root == nil {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
arr := make([]int, 0)
stack := make([]*TreeNode, 0)
cur := root
for len(stack) &gt; 0 || cur != nil {</p>
<blockquote>
<div><dl class="simple">
<dt>for cur != nil {</dt><dd><p>stack = append(stack, cur)
cur = cur.Left</p>
</dd>
</dl>
<p>}
node := stack[len(stack)-1]
arr = append(arr, node.Val)
stack = stack[:len(stack)-1]
cur = node.Right</p>
</div></blockquote>
<p>}
return arr[len(arr)-k]</p>
</div></blockquote>
</div>
<div class="section" id="id888">
<h1>}<a class="headerlink" href="#id888" title="永久链接至标题">¶</a></h1>
<p>## 面试题55-I.二叉树的深度(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id889"><span class="problematic" id="id890">``</span></a>`
输入一棵二叉树的根节点，求该树的深度。
从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。
例如：
给定二叉树 [3,9,20,null,null,15,7]，</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>3</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<dl>
<dt>9  20</dt><dd><blockquote>
<div><p>/  </p>
</div></blockquote>
<p>15   7</p>
</dd>
</dl>
</div></blockquote>
<p>返回它的最大深度 3 。
提示：节点总数 &lt;= 10000
注意：本题与主站 104 题相同：
<a class="reference external" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/</a>
<a href="#id891"><span class="problematic" id="id892">``</span></a><a href="#id893"><span class="problematic" id="id894">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路           | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ————– | ———- | ———- |</div>
<div class="line">01   | 递归(书上方法) | O(n)       | O(log(n))  |</div>
<div class="line">02   | 迭代           | O(n)       | O(n)       |</div>
</div>
<p><a href="#id895"><span class="problematic" id="id896">``</span></a><a href="#id897"><span class="problematic" id="id898">`</span></a>go
func maxDepth(root <a href="#id899"><span class="problematic" id="id900">*</span></a>TreeNode) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if root == nil {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
left := maxDepth(root.Left)
right := maxDepth(root.Right)</p>
<p>return max(left, right) + 1</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func max(a, b int) int {</dt><dd><dl class="simple">
<dt>if a &gt; b {</dt><dd><p>return a</p>
</dd>
</dl>
<p>}
return b</p>
</dd>
</dl>
<p>}</p>
<p>#
func maxDepth(root <a href="#id901"><span class="problematic" id="id902">*</span></a>TreeNode) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if root == nil {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
queue := make([]*TreeNode, 0)
queue = append(queue, root)
depth := 0
for len(queue) &gt; 0 {</p>
<blockquote>
<div><p>length := len(queue)
for i := 0; i &lt; length; i++ {</p>
<blockquote>
<div><p>node := queue[0]
queue = queue[1:]
if node.Left != nil {</p>
<blockquote>
<div><p>queue = append(queue, node.Left)</p>
</div></blockquote>
<p>}
if node.Right != nil {</p>
<blockquote>
<div><p>queue = append(queue, node.Right)</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
depth++</p>
</div></blockquote>
<p>}
return depth</p>
</div></blockquote>
</div>
<div class="section" id="id903">
<h1>}<a class="headerlink" href="#id903" title="永久链接至标题">¶</a></h1>
<p>## 面试题55-II.平衡二叉树(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id904"><span class="problematic" id="id905">``</span></a>`
输入一棵二叉树的根节点，判断该树是不是平衡二叉树。
如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。
示例 1:给定二叉树 [3,9,20,null,null,15,7]</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>3</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<dl>
<dt>9  20</dt><dd><blockquote>
<div><p>/  </p>
</div></blockquote>
<p>15   7</p>
</dd>
</dl>
</div></blockquote>
<p>返回 true 。
示例 2:给定二叉树 [1,2,2,3,3,null,null,4,4]</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><p>1</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<p>2   2</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<p>3   3</p>
</div></blockquote>
<p>/ </p>
</div></blockquote>
<p>4   4</p>
</div></blockquote>
<p>返回 false 。
限制：1 &lt;= 树的结点个数 &lt;= 10000
注意：本题与主站 110 题相同：
<a class="reference external" href="https://leetcode-cn.com/problems/balanced-binary-tree/">https://leetcode-cn.com/problems/balanced-binary-tree/</a>
<a href="#id906"><span class="problematic" id="id907">``</span></a><a href="#id908"><span class="problematic" id="id909">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路           | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ————– | ———- | ———- |</div>
<div class="line">01   | 递归           | O(n)       | O(log(n))  |</div>
<div class="line">02   | 递归(书上方法) | O(n)       | O(log(n))  |</div>
</div>
<p><a href="#id910"><span class="problematic" id="id911">``</span></a><a href="#id912"><span class="problematic" id="id913">`</span></a>go
func isBalanced(root <a href="#id914"><span class="problematic" id="id915">*</span></a>TreeNode) bool {</p>
<blockquote>
<div><p>_, isBalanced := recur(root)
return isBalanced</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func recur(root <a href="#id916"><span class="problematic" id="id917">*</span></a>TreeNode) (int, bool) {</dt><dd><dl class="simple">
<dt>if root == nil {</dt><dd><p>return 0, true</p>
</dd>
</dl>
<p>}
leftDepth, leftIsBalanced := recur(root.Left)
if leftIsBalanced == false {</p>
<blockquote>
<div><p>return 0, false</p>
</div></blockquote>
<p>}
rightDepth, rightIsBalanced := recur(root.Right)
if rightIsBalanced == false {</p>
<blockquote>
<div><p>return 0, false</p>
</div></blockquote>
<p>}
if -1 &lt;= leftDepth-rightDepth &amp;&amp;</p>
<blockquote>
<div><p>leftDepth-rightDepth &lt;= 1 {
return max(leftDepth, rightDepth) + 1, true</p>
</div></blockquote>
<p>}
return 0, false</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func max(a, b int) int {</dt><dd><dl class="simple">
<dt>if a &gt; b {</dt><dd><p>return a</p>
</dd>
</dl>
<p>}
return b</p>
</dd>
</dl>
<p>}</p>
<p>#
func isBalanced(root <a href="#id918"><span class="problematic" id="id919">*</span></a>TreeNode) bool {</p>
<blockquote>
<div><p>return dfs(root) != -1</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func dfs(root <a href="#id920"><span class="problematic" id="id921">*</span></a>TreeNode) int {</dt><dd><dl class="simple">
<dt>if root == nil {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
left := dfs(root.Left)
right := dfs(root.Right)
if left != -1 &amp;&amp; right != -1 &amp;&amp;</p>
<blockquote>
<div><p>abs(left, right) &lt;= 1 {
return max(left, right) + 1</p>
</div></blockquote>
<p>}
return -1</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func max(a, b int) int {</dt><dd><dl class="simple">
<dt>if a &gt; b {</dt><dd><p>return a</p>
</dd>
</dl>
<p>}
return b</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func abs(a, b int) int {</dt><dd><dl class="simple">
<dt>if a &gt; b {</dt><dd><p>return a - b</p>
</dd>
</dl>
<p>}
return b - a</p>
</dd>
</dl>
</div>
<div class="section" id="id922">
<h1>}<a class="headerlink" href="#id922" title="永久链接至标题">¶</a></h1>
<p>## 面试题56-I.数组中数字出现的次数(5)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id923"><span class="problematic" id="id924">``</span></a>`
一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。
请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。
示例 1： 输入：nums = [4,1,4,6]输出：[1,6] 或 [6,1]
示例 2：输入：nums = [1,2,10,4,1,4,3,3] 输出：[2,10] 或 [10,2]
限制：</p>
<blockquote>
<div><p>2 &lt;= nums.length &lt;= 10000</p>
</div></blockquote>
<p><a href="#id925"><span class="problematic" id="id926">``</span></a><a href="#id927"><span class="problematic" id="id928">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路             | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —————- | ———- | ———- |</div>
<div class="line">01   | 哈希辅助         | O(n)       | O(n)       |</div>
<div class="line">02   | 排序             | O(nlog(n)) | O(1)       |</div>
<div class="line">03   | 位运算           | O(n)       | O(1)       |</div>
<div class="line">04   | 位运算           | O(n)       | O(1)       |</div>
<div class="line">05   | 位运算(书上方法) | O(n)       | O(1)       |</div>
</div>
<p><a href="#id929"><span class="problematic" id="id930">``</span></a><a href="#id931"><span class="problematic" id="id932">`</span></a>go
func singleNumbers(nums []int) []int {</p>
<blockquote>
<div><p>m := make(map[int]int)
for i := 0; i &lt; len(nums); i++ {</p>
<blockquote>
<div><p>m[nums[i]]++</p>
</div></blockquote>
<p>}
res := make([]int, 0)
for i := range m {</p>
<blockquote>
<div><dl class="simple">
<dt>if m[i] == 1 {</dt><dd><p>res = append(res, i)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
func singleNumbers(nums []int) []int {</p>
<blockquote>
<div><p>res := make([]int, 0)
sort.Ints(nums)
count := 0
for i := 0; i &lt; len(nums)-2; {</p>
<blockquote>
<div><dl class="simple">
<dt>if nums[i] == nums[i+1] {</dt><dd><p>i = i + 2</p>
</dd>
</dl>
<p>}
if i == len(nums)-1 {</p>
<blockquote>
<div><p>res = append(res, nums[i])
return res</p>
</div></blockquote>
<p>}
if nums[i] != nums[i+1] {</p>
<blockquote>
<div><p>res = append(res, nums[i])
i++
count++
if count == 2 {</p>
<blockquote>
<div><p>return res</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
/*
a = 10
1.a   00001010
2.取反 11110101
3.取反+1 11110110
4. a &amp; (-a)
00001010
11110110
00000010
<a href="#id933"><span class="problematic" id="id934">*</span></a>/
func singleNumbers(nums []int) []int {</p>
<blockquote>
<div><p>res := make([]int, 2)
temp := 0
for i := 0; i &lt; len(nums); i++ {</p>
<blockquote>
<div><p>temp = temp ^ nums[i]</p>
</div></blockquote>
<p>}
last := temp &amp; (-temp)
for i := 0; i &lt; len(nums); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if nums[i]&amp;last == 0 {</dt><dd><p>res[0] = res[0] ^ nums[i]</p>
</dd>
<dt>} else {</dt><dd><p>res[1] = res[1] ^ nums[i]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
func singleNumbers(nums []int) []int {</p>
<blockquote>
<div><p>res := make([]int, 2)
temp := 0
for i := 0; i &lt; len(nums); i++ {</p>
<blockquote>
<div><p>temp = temp ^ nums[i]</p>
</div></blockquote>
<p>}
last := 1
for temp&amp;last == 0 {</p>
<blockquote>
<div><p>last = last &lt;&lt; 1</p>
</div></blockquote>
<p>}
for i := 0; i &lt; len(nums); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if nums[i]&amp;last == 0 {</dt><dd><p>res[0] = res[0] ^ nums[i]</p>
</dd>
<dt>} else {</dt><dd><p>res[1] = res[1] ^ nums[i]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
func singleNumbers(nums []int) []int {</p>
<blockquote>
<div><p>res := make([]int, 2)
temp := 0
for i := 0; i &lt; len(nums); i++ {</p>
<blockquote>
<div><p>temp = temp ^ nums[i]</p>
</div></blockquote>
<p>}
index := firstBit(temp)
for i := 0; i &lt; len(nums); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if isBit(nums[i], index) {</dt><dd><p>res[0] = res[0] ^ nums[i]</p>
</dd>
<dt>} else {</dt><dd><p>res[1] = res[1] ^ nums[i]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func firstBit(num int) int {</dt><dd><p>res := 0
for num&amp;1 == 0 {</p>
<blockquote>
<div><p>res++
num = num &gt;&gt; 1</p>
</div></blockquote>
<p>}
return res</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>func isBit(num int, index int) bool {</dt><dd><p>num = num &gt;&gt; index
return num&amp;1 == 1</p>
</dd>
</dl>
</div>
<div class="section" id="id935">
<h1>}<a class="headerlink" href="#id935" title="永久链接至标题">¶</a></h1>
<p>## 面试题56-II.数组中数字出现的次数II(5)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id936"><span class="problematic" id="id937">``</span></a>`
在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。
示例 1：输入：nums = [3,4,3,3] 输出：4
示例 2：输入：nums = [9,1,7,9,7,9,7] 输出：1
限制：</p>
<blockquote>
<div><p>1 &lt;= nums.length &lt;= 10000
1 &lt;= nums[i] &lt; 2^31</p>
</div></blockquote>
<p><a href="#id938"><span class="problematic" id="id939">``</span></a><a href="#id940"><span class="problematic" id="id941">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路                    | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ———————– | ———- | ———- |</div>
<div class="line">01   | 哈希辅助                | O(n)       | O(n)       |</div>
<div class="line">02   | 统计1的位求余(书上方法) | O(n)       | O(1)       |</div>
<div class="line">03   | 排序遍历                | O(nlog(n)) | O(1)       |</div>
<div class="line">04   | 求和遍历                | O(n)       | O(n)       |</div>
<div class="line">05   | 位运算(有限状态自动机)  | O(n)       | O(1)       |</div>
</div>
<p><a href="#id942"><span class="problematic" id="id943">``</span></a><a href="#id944"><span class="problematic" id="id945">`</span></a>go
func singleNumber(nums []int) int {</p>
<blockquote>
<div><p>m := make(map[int]int)
for i := 0; i &lt; len(nums); i++ {</p>
<blockquote>
<div><p>m[nums[i]]++</p>
</div></blockquote>
<p>}
for i := 0; i &lt; len(nums); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if m[nums[i]] == 1 {</dt><dd><p>return nums[i]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return 0</p>
</div></blockquote>
<p>}</p>
<p># 2
func singleNumber(nums []int) int {</p>
<blockquote>
<div><p>arr := make([]int, 32)
for i := 0; i &lt; len(nums); i++ {</p>
<blockquote>
<div><p>value := nums[i]
for j := 31; j &gt;= 0; j– {</p>
<blockquote>
<div><p>arr[j] = arr[j] + value&amp;1
value = value / 2</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
res := 0
for i := 0; i &lt; 32; i++ {</p>
<blockquote>
<div><p>res = res &lt;&lt; 1
res = res + arr[i]%3</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p># 3
func singleNumber(nums []int) int {</p>
<blockquote>
<div><p>sort.Ints(nums)
if len(nums) == 1 {</p>
<blockquote>
<div><p>return nums[0]</p>
</div></blockquote>
<p>}
i := 0
for i &lt; len(nums) {</p>
<blockquote>
<div><dl class="simple">
<dt>if i == len(nums)-1 {</dt><dd><p>return nums[len(nums)-1]</p>
</dd>
</dl>
<p>}
if nums[i] == nums[i+1] {</p>
<blockquote>
<div><p>i = i + 3</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>return nums[i]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return nums[i]</p>
</div></blockquote>
<p>}</p>
<p># 4
func singleNumber(nums []int) int {</p>
<blockquote>
<div><p>m := make(map[int]int)
sum1 := 0
sum2 := 0
for i := 0; i &lt; len(nums); i++ {</p>
<blockquote>
<div><p>sum1 = sum1 + nums[i]
if _, ok := m[nums[i]]; !ok {</p>
<blockquote>
<div><p>sum2 = sum2 + nums[i]</p>
</div></blockquote>
<p>}
m[nums[i]]++</p>
</div></blockquote>
<p>}
return (sum2*3 - sum1) / 2</p>
</div></blockquote>
<p>}</p>
<p># 5
func singleNumber(nums []int) int {</p>
<blockquote>
<div><p>res, temp := 0, 0
for i := 0; i &lt; len(nums); i++ {</p>
<blockquote>
<div><p>res = (res ^ nums[i]) &amp; ^temp
temp = (temp ^ nums[i]) &amp; ^res</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
</div>
<div class="section" id="id946">
<h1>}<a class="headerlink" href="#id946" title="永久链接至标题">¶</a></h1>
<p>## 面试题57.和为s的两个数字(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。</span>
<span class="pre">如果有多对数字的和等于s，则输出任意一对即可。</span>
<span class="pre">示例</span> <span class="pre">1：输入：nums</span> <span class="pre">=</span> <span class="pre">[2,7,11,15],</span> <span class="pre">target</span> <span class="pre">=</span> <span class="pre">9</span> <span class="pre">输出：[2,7]</span> <span class="pre">或者</span> <span class="pre">[7,2]</span>
<span class="pre">示例</span> <span class="pre">2：输入：nums</span> <span class="pre">=</span> <span class="pre">[10,26,30,31,47,60],</span> <span class="pre">target</span> <span class="pre">=</span> <span class="pre">40</span> <span class="pre">输出：[10,30]</span> <span class="pre">或者</span> <span class="pre">[30,10]</span>
<span class="pre">限制：</span>
<span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">nums.length</span> <span class="pre">&lt;=</span> <span class="pre">10^5</span>
<span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">nums[i]</span> <span class="pre">&lt;=</span> <span class="pre">10^6</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路             | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —————- | ———- | ———- |</div>
<div class="line">01   | 双指针(书上方法) | O(n)       | O(1)       |</div>
<div class="line">02   | 哈希辅助         | O(n)       | O(n)       |</div>
</div>
<p><a href="#id947"><span class="problematic" id="id948">``</span></a><a href="#id949"><span class="problematic" id="id950">`</span></a>go
func twoSum(nums []int, target int) []int {</p>
<blockquote>
<div><p>i := 0
j := len(nums) - 1
for i &lt; j {</p>
<blockquote>
<div><p>sum := nums[i] + nums[j]
if sum == target {</p>
<blockquote>
<div><p>return []int{nums[i], nums[j]}</p>
</div></blockquote>
<dl class="simple">
<dt>} else if sum &gt; target {</dt><dd><p>j–</p>
</dd>
<dt>} else {</dt><dd><p>i++</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return nil</p>
</div></blockquote>
<p>}</p>
<p>#
func twoSum(nums []int, target int) []int {</p>
<blockquote>
<div><p>m := make(map[int]int, len(nums))
for i, b := range nums {</p>
<blockquote>
<div><dl class="simple">
<dt>if j, ok := m[target-b]; ok {</dt><dd><p>return []int{nums[j], nums[i]}</p>
</dd>
</dl>
<p>}
m[b] = i</p>
</div></blockquote>
<p>}
return nil</p>
</div></blockquote>
</div>
<div class="section" id="id951">
<h1>}<a class="headerlink" href="#id951" title="永久链接至标题">¶</a></h1>
<p>## 面试题57-II.和为s的连续正数序列(4)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">输入一个正整数</span> <span class="pre">target</span> <span class="pre">，输出所有和为</span> <span class="pre">target</span> <span class="pre">的连续正整数序列（至少含有两个数）。</span>
<span class="pre">序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</span>
<span class="pre">示例</span> <span class="pre">1：输入：target</span> <span class="pre">=</span> <span class="pre">9</span> <span class="pre">输出：[[2,3,4],[4,5]]</span>
<span class="pre">示例</span> <span class="pre">2：输入：target</span> <span class="pre">=</span> <span class="pre">15</span> <span class="pre">输出：[[1,2,3,4,5],[4,5,6],[7,8]]</span>
<span class="pre">限制：1</span> <span class="pre">&lt;=</span> <span class="pre">target</span> <span class="pre">&lt;=</span> <span class="pre">10^5</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路             | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —————- | ———- | ———- |</div>
<div class="line">01   | 双指针           | O(n)       | O(1)       |</div>
<div class="line">02   | 双指针(书上方法) | O(n)       | O(1)       |</div>
<div class="line">03   | 前缀和-暴力法    | O(n^2)     | O(n)       |</div>
<div class="line">04   | 数学法           | O(n)       | O(1)       |</div>
</div>
<p><a href="#id952"><span class="problematic" id="id953">``</span></a><a href="#id954"><span class="problematic" id="id955">`</span></a>go
func findContinuousSequence(target int) [][]int {</p>
<blockquote>
<div><p>res := make([][]int, 0)
i := 1
j := 2
for i &lt; j {</p>
<blockquote>
<div><p>sum := (i + j) * (j - i + 1) / 2
if sum == target {</p>
<blockquote>
<div><p>arr := make([]int, 0)
for k := i; k &lt;= j; k++ {</p>
<blockquote>
<div><p>arr = append(arr, k)</p>
</div></blockquote>
<p>}
res = append(res, arr)
i++</p>
</div></blockquote>
<dl class="simple">
<dt>} else if sum &lt; target {</dt><dd><p>j++</p>
</dd>
<dt>} else {</dt><dd><p>i++</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
func findContinuousSequence(target int) [][]int {</p>
<blockquote>
<div><p>res := make([][]int, 0)
i := 1
j := 2
mid := (1 + target) / 2
curSum := i + j
for i &lt; mid {</p>
<blockquote>
<div><dl>
<dt>if curSum == target {</dt><dd><p>arr := make([]int, 0)
for k := i; k &lt;= j; k++ {</p>
<blockquote>
<div><p>arr = append(arr, k)</p>
</div></blockquote>
<p>}
res = append(res, arr)</p>
</dd>
</dl>
<p>}
for curSum &gt; target &amp;&amp; i &lt; mid {</p>
<blockquote>
<div><p>curSum = curSum - i
i++
if curSum == target {</p>
<blockquote>
<div><p>arr := make([]int, 0)
for k := i; k &lt;= j; k++ {</p>
<blockquote>
<div><p>arr = append(arr, k)</p>
</div></blockquote>
<p>}
res = append(res, arr)</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
j++
curSum = curSum + j</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
func findContinuousSequence(target int) [][]int {</p>
<blockquote>
<div><p>res := make([][]int, 0)
arr := make([]int, target+1)
for i := 1; i &lt;= target; i++ {</p>
<blockquote>
<div><p>arr[i] = arr[i-1] + i</p>
</div></blockquote>
<p>}
for i := 1; i &lt;= (target+1)/2; i++ {</p>
<blockquote>
<div><dl>
<dt>for j := i + 1; j &lt;= target &amp;&amp; arr[j]-arr[i-1] &lt;= target; j++ {</dt><dd><dl>
<dt>if arr[j]-arr[i-1] == target {</dt><dd><p>temp := make([]int, 0)
for k := i; k &lt;= j; k++ {</p>
<blockquote>
<div><p>temp = append(temp, k)</p>
</div></blockquote>
<p>}
res = append(res, temp)
break</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
// target = nA1 + n(n-1)/2
func findContinuousSequence(target int) [][]int {</p>
<blockquote>
<div><p>res := make([][]int, 0)
for i := (target + 1) / 2; i &gt;= 2; i– {</p>
<blockquote>
<div><p>nA1 := target - i*(i-1)/2
if nA1 &lt;= 0 {</p>
<blockquote>
<div><p>continue</p>
</div></blockquote>
<p>}
if nA1%i == 0 {</p>
<blockquote>
<div><p>start := nA1 / i
arr := make([]int, 0)
for j := 0; j &lt; i; j++ {</p>
<blockquote>
<div><p>arr = append(arr, start+j)</p>
</div></blockquote>
<p>}
res = append(res, arr)</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
</div>
<div class="section" id="id956">
<h1>}<a class="headerlink" href="#id956" title="永久链接至标题">¶</a></h1>
<p>## 面试题58-I.翻转单词顺序(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id957"><span class="problematic" id="id958">``</span></a>`
输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。
为简单起见，标点符号和普通字母一样处理。
例如输入字符串”I am a student. “，则输出”student. a am I”。
示例 1：输入: “the sky is blue”  输出: “blue is sky the”
示例 2：输入: ”  hello world!  ” 输出: “world! hello”
解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。
示例 3：输入: “a good   example” 输出: “example good a”
解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。
说明：</p>
<blockquote>
<div><p>无空格字符构成一个单词。
输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。
如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p>
</div></blockquote>
<p>注意：本题与主站 151 题相同：<a class="reference external" href="https://leetcode-cn.com/problems/reverse-words-in-a-string/">https://leetcode-cn.com/problems/reverse-words-in-a-string/</a>
注意：此题对比原题有改动
<a href="#id959"><span class="problematic" id="id960">``</span></a><a href="#id961"><span class="problematic" id="id962">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路                   | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ———————- | ———- | ———- |</div>
<div class="line">01   | 内置函数               | O(n)       | O(n)       |</div>
<div class="line">02   | 遍历-2次反转(书上方法) | O(n)       | O(n)       |</div>
<div class="line">03   | 遍历                   | O(n)       | O(n)       |</div>
</div>
<p><a href="#id963"><span class="problematic" id="id964">``</span></a><a href="#id965"><span class="problematic" id="id966">`</span></a>go
func reverseWords(s string) string {</p>
<blockquote>
<div><p>s = strings.Trim(s, ” “)
arr := strings.Fields(s)
for i := 0; i &lt; len(arr)/2; i++ {</p>
<blockquote>
<div><p>arr[i], arr[len(arr)-1-i] = arr[len(arr)-1-i], arr[i]</p>
</div></blockquote>
<p>}
return strings.Join(arr, ” “)</p>
</div></blockquote>
<p>}</p>
<p>#
func reverseWords(s string) string {</p>
<blockquote>
<div><p>arr := []byte(s)
arr = reverse(arr)
i := 0
j := 0
res := “”
flag := false
for i &lt; len(arr) {</p>
<blockquote>
<div><dl>
<dt>if arr[i] == ‘ ‘ {</dt><dd><dl class="simple">
<dt>if flag == true {</dt><dd><p>res = res + ” ” + string(reverse(arr[j:i]))
flag = false</p>
</dd>
</dl>
<p>}
i++
j = i</p>
</dd>
<dt>} else {</dt><dd><p>i++
if i == len(arr) {</p>
<blockquote>
<div><p>res = res + ” ” + string(reverse(arr[j:i]))</p>
</div></blockquote>
<p>}
flag = true</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
if len(res) &gt; 0 {</p>
<blockquote>
<div><p>return res[1:]</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func reverse(arr []byte) []byte {</dt><dd><p>start := 0
end := len(arr) - 1
for start &lt; end {</p>
<blockquote>
<div><p>arr[start], arr[end] = arr[end], arr[start]
start++
end–</p>
</div></blockquote>
<p>}
return arr</p>
</dd>
</dl>
<p>}</p>
<p>#
func reverseWords(s string) string {</p>
<blockquote>
<div><p>arr := []byte(s)
i := len(arr) - 1
j := len(arr)
res := “”
flag := false
for i &gt;= 0 {</p>
<blockquote>
<div><dl>
<dt>if arr[i] == ‘ ‘ {</dt><dd><dl class="simple">
<dt>if flag == true {</dt><dd><p>res = res + ” ” + string(arr[i+1:j])
flag = false</p>
</dd>
</dl>
<p>}
j = i
i–</p>
</dd>
<dt>} else {</dt><dd><dl class="simple">
<dt>if i == 0 {</dt><dd><p>res = res + ” ” + string(arr[i:j])</p>
</dd>
</dl>
<p>}
i–
flag = true</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
if len(res) &gt; 0 {</p>
<blockquote>
<div><p>return res[1:]</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
</div>
<div class="section" id="id967">
<h1>}<a class="headerlink" href="#id967" title="永久链接至标题">¶</a></h1>
<p>## 面试题58-II.左旋转字符串(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。</span>
<span class="pre">比如，输入字符串&quot;abcdefg&quot;和数字2，该函数将返回左旋转两位得到的结果&quot;cdefgab&quot;。</span>
<span class="pre">示例</span> <span class="pre">1：输入:</span> <span class="pre">s</span> <span class="pre">=</span> <span class="pre">&quot;abcdefg&quot;,</span> <span class="pre">k</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">输出:</span> <span class="pre">&quot;cdefgab&quot;</span>
<span class="pre">示例</span> <span class="pre">2：输入:</span> <span class="pre">s</span> <span class="pre">=</span> <span class="pre">&quot;lrloseumgh&quot;,</span> <span class="pre">k</span> <span class="pre">=</span> <span class="pre">6</span> <span class="pre">输出:</span> <span class="pre">&quot;umghlrlose&quot;</span>
<span class="pre">限制：</span> <span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">k</span> <span class="pre">&lt;</span> <span class="pre">s.length</span> <span class="pre">&lt;=</span> <span class="pre">10000</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路               | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —————— | ———- | ———- |</div>
<div class="line">01   | 切片               | O(n)       | O(n)       |</div>
<div class="line">02   | 三次反转(书上方法) | O(n)       | O(n)       |</div>
</div>
<p><a href="#id968"><span class="problematic" id="id969">``</span></a><a href="#id970"><span class="problematic" id="id971">`</span></a>go
func reverseLeftWords(s string, n int) string {</p>
<blockquote>
<div><p>n = n % len(s)
return s[n:] + s[:n]</p>
</div></blockquote>
<p>}</p>
<p>#
func reverseLeftWords(s string, n int) string {</p>
<blockquote>
<div><p>n = n % len(s)
arr := []byte(s)
reverse(arr, 0, n-1)
reverse(arr, n, len(arr)-1)
reverse(arr, 0, len(arr)-1)
return string(arr)</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func reverse(arr []byte, start, end int) []byte {</dt><dd><dl class="simple">
<dt>for start &lt; end {</dt><dd><p>arr[start], arr[end] = arr[end], arr[start]
start++
end–</p>
</dd>
</dl>
<p>}
return arr</p>
</dd>
</dl>
</div>
<div class="section" id="id972">
<h1>}<a class="headerlink" href="#id972" title="永久链接至标题">¶</a></h1>
<p>## 面试题59-I.滑动窗口的最大值(4)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id973"><span class="problematic" id="id974">``</span></a>`
给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。
示例:输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3 输出: [3,3,5,5,6,7]
解释:</p>
<blockquote>
<div><p>滑动窗口的位置                最大值</p>
</div></blockquote>
<p>—————               —–
[1  3  -1] -3  5  3  6  7       3</p>
<blockquote>
<div><p>1 [3  -1  -3] 5  3  6  7       3
1  3 [-1  -3  5] 3  6  7       5
1  3  -1 [-3  5  3] 6  7       5
1  3  -1  -3 [5  3  6] 7       6
1  3  -1  -3  5 [3  6  7]      7</p>
</div></blockquote>
<p>提示：你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。
注意：本题与主站 239 题相同：<a class="reference external" href="https://leetcode-cn.com/problems/sliding-window-maximum/">https://leetcode-cn.com/problems/sliding-window-maximum/</a>
<a href="#id975"><span class="problematic" id="id976">``</span></a><a href="#id977"><span class="problematic" id="id978">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路                    | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ———————– | ———- | ———- |</div>
<div class="line">01   | 暴力法                  | O(n^2)     | O(n)       |</div>
<div class="line">02   | 暴力法-有条件更新最大值 | O(n^2)     | O(n)       |</div>
<div class="line">03   | 双端队列(书上方法)      | O(n)       | O(n)       |</div>
<div class="line">04   | 堆排序                  | O(nlog(n)) | O(n)       |</div>
</div>
<p><a href="#id979"><span class="problematic" id="id980">``</span></a><a href="#id981"><span class="problematic" id="id982">`</span></a>go
func maxSlidingWindow(nums []int, k int) []int {</p>
<blockquote>
<div><p>res := make([]int, 0)
if len(nums) == 0 {</p>
<blockquote>
<div><p>return res</p>
</div></blockquote>
<p>}
for i := 0; i &lt; len(nums)-k+1; i++ {</p>
<blockquote>
<div><p>max := nums[i]
for j := i; j &lt; i+k; j++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if nums[j] &gt; max {</dt><dd><p>max = nums[j]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
res = append(res, max)</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
func maxSlidingWindow(nums []int, k int) []int {</p>
<blockquote>
<div><p>res := make([]int, 0)
if len(nums) == 0 {</p>
<blockquote>
<div><p>return res</p>
</div></blockquote>
<p>}
max := math.MaxInt32
for i := 0; i &lt; len(nums)-k+1; i++ {</p>
<blockquote>
<div><dl>
<dt>if i == 0 || nums[i-1] == max {</dt><dd><p>max = nums[i]
for j := i; j &lt; i+k; j++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if nums[j] &gt; max {</dt><dd><p>max = nums[j]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
<dt>} else {</dt><dd><dl class="simple">
<dt>if nums[i+k-1] &gt; max {</dt><dd><p>max = nums[i+k-1]</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
res = append(res, max)</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
func maxSlidingWindow(nums []int, k int) []int {</p>
<blockquote>
<div><p>res := make([]int, 0)
if len(nums) == 0 {</p>
<blockquote>
<div><p>return res</p>
</div></blockquote>
<p>}
deque := make([]int, 0)
for i := 0; i &lt; k; i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>for len(deque) &gt; 0 &amp;&amp; nums[i] &gt;= nums[deque[len(deque)-1]] {</dt><dd><p>deque = deque[:len(deque)-1]</p>
</dd>
</dl>
<p>}
deque = append(deque, i)</p>
</div></blockquote>
<p>}
for i := k; i &lt; len(nums); i++ {</p>
<blockquote>
<div><p>res = append(res, nums[deque[0]])
for len(deque) &gt; 0 &amp;&amp; nums[i] &gt;= nums[deque[len(deque)-1]] {</p>
<blockquote>
<div><p>deque = deque[:len(deque)-1]</p>
</div></blockquote>
<p>}
if len(deque) &gt; 0 &amp;&amp; deque[0] &lt;= i-k {</p>
<blockquote>
<div><p>deque = deque[1:]</p>
</div></blockquote>
<p>}
deque = append(deque, i)</p>
</div></blockquote>
<p>}
res = append(res, nums[deque[0]])
return res</p>
</div></blockquote>
<p>}</p>
<p>#
func maxSlidingWindow(nums []int, k int) []int {</p>
<blockquote>
<div><p>res := make([]int, 0)
if len(nums) == 0 {</p>
<blockquote>
<div><p>return res</p>
</div></blockquote>
<p>}
intHeap := make(IntHeap, 0, k)
heap.Init(&amp;intHeap)
for i := 0; i &lt; k; i++ {</p>
<blockquote>
<div><p>heap.Push(&amp;intHeap, nums[i])</p>
</div></blockquote>
<p>}
for i := k; i &lt; len(nums); i++ {</p>
<blockquote>
<div><p>temp := heap.Pop(&amp;intHeap).(int)
res = append(res, temp)
if temp != nums[i-k] {</p>
<blockquote>
<div><p>intHeap.Remove(nums[i-k])
heap.Push(&amp;intHeap, temp)
heap.Push(&amp;intHeap, nums[i])</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>heap.Push(&amp;intHeap, nums[i])</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
res = append(res, heap.Pop(&amp;intHeap).(int))
return res</p>
</div></blockquote>
<p>}</p>
<p>type IntHeap []int</p>
<dl class="simple">
<dt>func (i IntHeap) Len() int {</dt><dd><p>return len(i)</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>func (i IntHeap) Less(x, y int) bool {</dt><dd><p>return i[x] &gt; i[y]</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>func (i IntHeap) Swap(x, y int) {</dt><dd><p>i[x], i[y] = i[y], i[x]</p>
</dd>
</dl>
<p>}
func (i <a href="#id983"><span class="problematic" id="id984">*</span></a>IntHeap) Push(v interface{}) {</p>
<blockquote>
<div><p><a href="#id985"><span class="problematic" id="id986">*</span></a>i = append(<a href="#id987"><span class="problematic" id="id988">*</span></a>i, v.(int))</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>func (i <a href="#id989"><span class="problematic" id="id990">*</span></a>IntHeap) Pop() interface{} {</dt><dd><p>value := (<a href="#id991"><span class="problematic" id="id992">*</span></a>i)[len(<a href="#id993"><span class="problematic" id="id994">*</span></a>i)-1]
<a href="#id995"><span class="problematic" id="id996">*</span></a>i = (<a href="#id997"><span class="problematic" id="id998">*</span></a>i)[:len(<a href="#id999"><span class="problematic" id="id1000">*</span></a>i)-1]
return value</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func (i <a href="#id1001"><span class="problematic" id="id1002">*</span></a>IntHeap) Remove(x interface{}) {</dt><dd><dl>
<dt>for j := 0; j &lt; len(<a href="#id1003"><span class="problematic" id="id1004">*</span></a>i); j++ {</dt><dd><dl class="simple">
<dt>if (<a href="#id1005"><span class="problematic" id="id1006">*</span></a>i)[j] == x {</dt><dd><p><a href="#id1007"><span class="problematic" id="id1008">*</span></a>i = append((<a href="#id1009"><span class="problematic" id="id1010">*</span></a>i)[:j], (<a href="#id1011"><span class="problematic" id="id1012">*</span></a>i)[j+1:]…)
break</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
heap.Init(i)</p>
</dd>
</dl>
</div>
<div class="section" id="id1013">
<h1>}<a class="headerlink" href="#id1013" title="永久链接至标题">¶</a></h1>
<p>## 面试题59-II.队列的最大值(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id1014"><span class="problematic" id="id1015">``</span></a>`
请定义一个队列并实现函数 max_value 得到队列里的最大值，
要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。
若队列为空，pop_front 和 max_value 需要返回 -1
示例 1：输入:
[“MaxQueue”,”push_back”,”push_back”,”max_value”,”pop_front”,”max_value”]
[[],[1],[2],[],[],[]]
输出: [null,null,null,2,1,2]</p>
<p>示例 2：输入:
[“MaxQueue”,”pop_front”,”max_value”]
[[],[],[]]
输出: [null,-1,-1]
限制：</p>
<blockquote>
<div><p>1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000
1 &lt;= value &lt;= 10^5</p>
</div></blockquote>
<p><a href="#id1016"><span class="problematic" id="id1017">``</span></a><a href="#id1018"><span class="problematic" id="id1019">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路             | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —————- | ———- | ———- |</div>
<div class="line">01   | 双队列(书上方法) | O(1)       | O(n)       |</div>
<div class="line">02   | 内置list         | O(1)       | O(n)       |</div>
</div>
<p><a href="#id1020"><span class="problematic" id="id1021">``</span></a><a href="#id1022"><span class="problematic" id="id1023">`</span></a>go
type MaxQueue struct {</p>
<blockquote>
<div><p>data []int
max  []int</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func Constructor() MaxQueue {</dt><dd><dl class="simple">
<dt>return MaxQueue{</dt><dd><p>data: make([]int, 0),
max:  make([]int, 0),</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func (this <a href="#id1024"><span class="problematic" id="id1025">*</span></a>MaxQueue) Max_value() int {</dt><dd><dl class="simple">
<dt>if len(this.max) == 0 {</dt><dd><p>return -1</p>
</dd>
</dl>
<p>}
return this.max[0]</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func (this <a href="#id1026"><span class="problematic" id="id1027">*</span></a>MaxQueue) Push_back(value int) {</dt><dd><p>this.data = append(this.data, value)
for len(this.max) &gt; 0 &amp;&amp; value &gt; this.max[len(this.max)-1] {</p>
<blockquote>
<div><p>this.max = this.max[:len(this.max)-1]</p>
</div></blockquote>
<p>}
this.max = append(this.max, value)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func (this <a href="#id1028"><span class="problematic" id="id1029">*</span></a>MaxQueue) Pop_front() int {</dt><dd><p>res := -1
if len(this.data) &gt; 0 {</p>
<blockquote>
<div><p>res = this.data[0]
this.data = this.data[1:]
if res == this.max[0] {</p>
<blockquote>
<div><p>this.max = this.max[1:]</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</dd>
</dl>
<p>}</p>
<p>#
type MaxQueue struct {</p>
<blockquote>
<div><p>data <a href="#id1030"><span class="problematic" id="id1031">*</span></a>list.List
max  []int</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func Constructor() MaxQueue {</dt><dd><dl class="simple">
<dt>return MaxQueue{</dt><dd><p><a class="reference external" href="data:list">data:list</a>.New(),
max:  make([]int, 0),</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func (this <a href="#id1032"><span class="problematic" id="id1033">*</span></a>MaxQueue) Max_value() int {</dt><dd><dl class="simple">
<dt>if len(this.max) == 0 {</dt><dd><p>return -1</p>
</dd>
</dl>
<p>}
return this.max[0]</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func (this <a href="#id1034"><span class="problematic" id="id1035">*</span></a>MaxQueue) Push_back(value int) {</dt><dd><p>this.data.PushBack(value)
for len(this.max) &gt; 0 &amp;&amp; value &gt; this.max[len(this.max)-1] {</p>
<blockquote>
<div><p>this.max = this.max[:len(this.max)-1]</p>
</div></blockquote>
<p>}
this.max = append(this.max, value)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func (this <a href="#id1036"><span class="problematic" id="id1037">*</span></a>MaxQueue) Pop_front() int {</dt><dd><p>res := -1
if this.data.Len() &gt; 0 {</p>
<blockquote>
<div><p>res = this.data.Front().Value.(int)
this.data.Remove(this.data.Front())
if res == this.max[0] {</p>
<blockquote>
<div><p>this.max = this.max[1:]</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</dd>
</dl>
</div>
<div class="section" id="id1038">
<h1>}<a class="headerlink" href="#id1038" title="永久链接至标题">¶</a></h1>
<p>## 面试题60.n个骰子的点数(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</span>
<span class="pre">你需要用一个浮点数数组返回答案，其中第</span> <span class="pre">i</span> <span class="pre">个元素代表这</span> <span class="pre">n</span> <span class="pre">个骰子所能掷出的点数集合中第</span> <span class="pre">i</span> <span class="pre">小的那个的概率。</span>
<span class="pre">示例</span> <span class="pre">1:输入:</span> <span class="pre">1</span>
<span class="pre">输出:</span> <span class="pre">[0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]</span>
<span class="pre">示例</span> <span class="pre">2:输入:</span> <span class="pre">2</span> <span class="pre">输出:</span>
<span class="pre">[0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,</span>
<span class="pre">0.08333,0.05556,0.02778]</span>
<span class="pre">限制：</span>
<span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">n</span> <span class="pre">&lt;=</span> <span class="pre">11</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路                    | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ———————– | ———- | ———- |</div>
<div class="line">01   | 递推-数组辅助(书上方法) | O(n)       | O(n)       |</div>
<div class="line">02   | 递推-动态规划           | O(n)       | O(n)       |</div>
<div class="line">03   | 递归-超时(书上方法)     | O(6^n)     | O(n)       |</div>
</div>
<p><a href="#id1039"><span class="problematic" id="id1040">``</span></a><a href="#id1041"><span class="problematic" id="id1042">`</span></a>go
func twoSum(n int) []float64 {</p>
<blockquote>
<div><p>res := make([]float64, 0)
if n &lt; 1 {</p>
<blockquote>
<div><p>return res</p>
</div></blockquote>
<p>}
arr := [2][]int{}
arr[0] = make([]int, 6*n+1)
arr[1] = make([]int, 6*n+1)
flag := 0
for i := 1; i &lt;= 6; i++ {</p>
<blockquote>
<div><p>arr[flag][i] = 1</p>
</div></blockquote>
<p>}
for k := 2; k &lt;= n; k++ {</p>
<blockquote>
<div><dl class="simple">
<dt>for i := 0; i &lt; k; i++ {</dt><dd><p>arr[1-flag][i] = 0</p>
</dd>
</dl>
<p>}
for i := k; i &lt;= 6*n; i++ {</p>
<blockquote>
<div><p>arr[1-flag][i] = 0
// 当前轮的第N位等于前一个数组第N-1,N-2,N-3,N-4,N-5,N-6位之和
for j := 1; j &lt;= i &amp;&amp; j &lt;= 6; j++ {</p>
<blockquote>
<div><p>arr[1-flag][i] += arr[flag][i-j]</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
flag = 1 - flag</p>
</div></blockquote>
<p>}
total := math.Pow(float64(6), float64(n))
for i := n; i &lt;= 6*n; i++ {</p>
<blockquote>
<div><p>ratio := float64(arr[flag][i]) / total
res = append(res, ratio)</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
// f(n,k)=f(n−1,k−1)+f(n−1,k−2)+f(n−1,k−3)+f(n−1,k−4)+f(n−1,k−5)+f(n−1,k−6)
func twoSum(n int) []float64 {</p>
<blockquote>
<div><p>res := make([]float64, 0)
if n &lt; 1 {</p>
<blockquote>
<div><p>return res</p>
</div></blockquote>
<p>}
arr := make([]int, 6*n+1)
for i := 1; i &lt;= 6; i++ {</p>
<blockquote>
<div><p>arr[i] = 1</p>
</div></blockquote>
<p>}
for i := 2; i &lt;= n; i++ {</p>
<blockquote>
<div><dl>
<dt>for j := 6 * i; j &gt;= i; j– {</dt><dd><p>arr[j] = 0
for k := 1; k &lt;= 6; k++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if j-k &gt;= i-1 {</dt><dd><p>arr[j] = arr[j] + arr[j-k]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
total := math.Pow(float64(6), float64(n))
for i := n; i &lt;= 6*n; i++ {</p>
<blockquote>
<div><p>ratio := float64(arr[i]) / total
res = append(res, ratio)</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
var arr []int
var start int</p>
<dl>
<dt>func twoSum(n int) []float64 {</dt><dd><p>res := make([]float64, 0)
if n &lt; 1 {</p>
<blockquote>
<div><p>return res</p>
</div></blockquote>
<p>}
start = n
arr = make([]int, 5*n+1)
for i := 1; i &lt;= 6; i++ {</p>
<blockquote>
<div><p>dfs(n, i)</p>
</div></blockquote>
<p>}
total := math.Pow(float64(6), float64(n))
for i := n; i &lt;= 6*n; i++ {</p>
<blockquote>
<div><p>ratio := float64(arr[i-n]) / total
res = append(res, ratio)</p>
</div></blockquote>
<p>}
return res</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func dfs(current, sum int) {</dt><dd><dl>
<dt>if current == 1 {</dt><dd><p>arr[sum-start]++</p>
</dd>
<dt>} else {</dt><dd><dl class="simple">
<dt>for i := 1; i &lt;= 6; i++ {</dt><dd><p>dfs(current-1, sum+i)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</div>
<div class="section" id="id1043">
<h1>}<a class="headerlink" href="#id1043" title="永久链接至标题">¶</a></h1>
<p>## 面试题61.扑克牌中的顺子(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。</span>
<span class="pre">2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为</span> <span class="pre">0</span> <span class="pre">，可以看成任意数字。A</span> <span class="pre">不能视为</span> <span class="pre">14。</span>
<span class="pre">示例</span> <span class="pre">1:输入:</span> <span class="pre">[1,2,3,4,5]</span> <span class="pre">输出:</span> <span class="pre">True</span>
<span class="pre">示例</span> <span class="pre">2:输入:</span> <span class="pre">[0,0,1,2,5]</span> <span class="pre">输出:</span> <span class="pre">True</span>
<span class="pre">限制：数组长度为</span> <span class="pre">5</span> <span class="pre">数组的数取值为</span> <span class="pre">[0,</span> <span class="pre">13]</span> <span class="pre">.</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路               | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —————— | ———- | ———- |</div>
<div class="line">01   | 排序遍历           | O(1)       | O(1)       |</div>
<div class="line">02   | 哈希辅助           | O(1)       | O(1)       |</div>
<div class="line">03   | 排序遍历(书上方法) | O(1)       | O(1)       |</div>
</div>
<p><a href="#id1044"><span class="problematic" id="id1045">``</span></a><a href="#id1046"><span class="problematic" id="id1047">`</span></a>go
func isStraight(nums []int) bool {</p>
<blockquote>
<div><p>sort.Ints(nums)
sum := 0
for i := 0; i &lt; 4; i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if nums[i] == 0 {</dt><dd><p>continue</p>
</dd>
</dl>
<p>}
// 非王重复
if nums[i] == nums[i+1] {</p>
<blockquote>
<div><p>return false</p>
</div></blockquote>
<p>}
sum = sum + nums[i+1] - nums[i]</p>
</div></blockquote>
<p>}
return sum &lt;= 4</p>
</div></blockquote>
<p>}</p>
<p>#
func isStraight(nums []int) bool {</p>
<blockquote>
<div><p>m := make(map[int]bool)
max, min := -1, 14
countZero := 0
for i := 0; i &lt; 5; i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if nums[i] == 0 {</dt><dd><p>countZero++
continue</p>
</dd>
</dl>
<p>}
if m[nums[i]] {</p>
<blockquote>
<div><p>return false</p>
</div></blockquote>
<p>}
m[nums[i]] = true
if nums[i] &gt; max {</p>
<blockquote>
<div><p>max = nums[i]</p>
</div></blockquote>
<p>}
if nums[i] &lt; min {</p>
<blockquote>
<div><p>min = nums[i]</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
if countZero == 0 {</p>
<blockquote>
<div><p>return max-min == 4</p>
</div></blockquote>
<p>}
return max-min &lt;= 4</p>
</div></blockquote>
<p>}</p>
<p>#
func isStraight(nums []int) bool {</p>
<blockquote>
<div><p>sort.Ints(nums)
zero := 0
gap := 0
for i := 0; i &lt; len(nums); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if nums[i] == 0 {</dt><dd><p>zero++</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
small := zero
big := small + 1
for big &lt; len(nums) {</p>
<blockquote>
<div><dl class="simple">
<dt>if nums[small] == nums[big] {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}
gap = gap + nums[big] - nums[small] - 1
small++
big++</p>
</div></blockquote>
<p>}
if gap &gt; zero {</p>
<blockquote>
<div><p>return false</p>
</div></blockquote>
<p>}
return true</p>
</div></blockquote>
</div>
<div class="section" id="id1048">
<h1>}<a class="headerlink" href="#id1048" title="永久链接至标题">¶</a></h1>
<p>## 面试题62.圆圈中最后剩下的数字(2)</p>
<ul class="simple">
<li><p>约瑟夫环理解参考： <a class="reference external" href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/huan-ge-jiao-du-ju-li-jie-jue-yue-se-fu-huan-by-as/">https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/huan-ge-jiao-du-ju-li-jie-jue-yue-se-fu-huan-by-as/</a></p></li>
<li><p>题目</p></li>
</ul>
<p><a href="#id1049"><span class="problematic" id="id1050">``</span></a>`
0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。
求出这个圆圈里剩下的最后一个数字。
例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，
则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。
示例 1：输入: n = 5, m = 3 输出: 3
示例 2：输入: n = 10, m = 17 输出: 2
限制：</p>
<blockquote>
<div><p>1 &lt;= n &lt;= 10^5
1 &lt;= m &lt;= 10^6</p>
</div></blockquote>
<p><a href="#id1051"><span class="problematic" id="id1052">``</span></a><a href="#id1053"><span class="problematic" id="id1054">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路           | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ————– | ———- | ———- |</div>
<div class="line">01   | 递归           | O(n)       | O(n)       |</div>
<div class="line">02   | 递推(书上方法) | O(n)       | O(1)       |</div>
<div class="line">03   | 模拟-超时      | O(n^2)     | O(n)       |</div>
</div>
<p><a href="#id1055"><span class="problematic" id="id1056">``</span></a><a href="#id1057"><span class="problematic" id="id1058">`</span></a>go
func lastRemaining(n int, m int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if n == 1 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
return (lastRemaining(n-1, m) + m) % n</p>
</div></blockquote>
<p>}</p>
<p>#
func lastRemaining(n int, m int) int {</p>
<blockquote>
<div><p>res := 0
for i := 2; i &lt;= n; i++ {</p>
<blockquote>
<div><p>res = (res + m) % i</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p># 超时
func lastRemaining(n int, m int) int {</p>
<blockquote>
<div><p>arr := make([]int, n)
for i := 0; i &lt; n; i++ {</p>
<blockquote>
<div><p>arr[i] = i</p>
</div></blockquote>
<p>}
last := 0
for len(arr) &gt; 1 {</p>
<blockquote>
<div><p>index := (last + m - 1) % len(arr)
arr = remove(arr, index)
last = index</p>
</div></blockquote>
<p>}
return arr[0]</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func remove(arr []int, index int) []int {</dt><dd><dl class="simple">
<dt>if index == 0 {</dt><dd><p>return arr[1:]</p>
</dd>
</dl>
<p>}
if index == len(arr)-1 {</p>
<blockquote>
<div><p>return arr[:len(arr)-1]</p>
</div></blockquote>
<p>}
return append(arr[:index], arr[index+1:]…)</p>
</dd>
</dl>
</div>
<div class="section" id="id1059">
<h1>}<a class="headerlink" href="#id1059" title="永久链接至标题">¶</a></h1>
<p>## 面试题63.股票的最大利润(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</span>
<span class="pre">示例</span> <span class="pre">1:输入:</span> <span class="pre">[7,1,5,3,6,4]</span> <span class="pre">输出:</span> <span class="pre">5</span>
<span class="pre">解释:</span> <span class="pre">在第</span> <span class="pre">2</span> <span class="pre">天（股票价格</span> <span class="pre">=</span> <span class="pre">1）的时候买入，在第</span> <span class="pre">5</span> <span class="pre">天（股票价格</span> <span class="pre">=</span> <span class="pre">6）的时候卖出，</span>
<span class="pre">最大利润</span> <span class="pre">=</span> <span class="pre">6-1</span> <span class="pre">=</span> <span class="pre">5</span> <span class="pre">。注意利润不能是</span> <span class="pre">7-1</span> <span class="pre">=</span> <span class="pre">6,</span> <span class="pre">因为卖出价格需要大于买入价格。</span>
<span class="pre">示例</span> <span class="pre">2:输入:</span> <span class="pre">[7,6,4,3,1]</span> <span class="pre">输出:</span> <span class="pre">0</span>
<span class="pre">解释:</span> <span class="pre">在这种情况下,</span> <span class="pre">没有交易完成,</span> <span class="pre">所以最大利润为</span> <span class="pre">0。</span>
<span class="pre">限制：</span> <span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">数组长度</span> <span class="pre">&lt;=</span> <span class="pre">10^5</span>
<span class="pre">注意：本题与主站</span> <span class="pre">121</span> <span class="pre">题相同：</span>
<span class="pre">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路                                                         | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ———————————————————— | ———- | ———- |</div>
<div class="line">01   | 暴力法                                                       | O(n^2)     | O(1)       |</div>
<div class="line">02   | 动态规划(从前到后)  最大利润=max{前一天最大利润, 今天的价格 - 之前最低价格}(书上方法) | O(n)       | O(1)       |</div>
<div class="line">03   | 动态规划(从后到前)                                           | O(n)       | O(1)       |</div>
</div>
<p><a href="#id1060"><span class="problematic" id="id1061">``</span></a><a href="#id1062"><span class="problematic" id="id1063">`</span></a>go
func maxProfit(prices []int) int {</p>
<blockquote>
<div><p>max := 0
length := len(prices)
for i := 0; i &lt; length-1; i++ {</p>
<blockquote>
<div><dl>
<dt>for j := i + 1; j &lt;= length-1; j++ {</dt><dd><dl class="simple">
<dt>if prices[j]-prices[i] &gt; max {</dt><dd><p>max = prices[j] - prices[i]</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return max</p>
</div></blockquote>
<p>}</p>
<p>#
func maxProfit(prices []int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if len(prices) &lt; 2 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
min := prices[0]
profit := 0
for i := 1; i &lt; len(prices); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if prices[i] &lt; min {</dt><dd><p>min = prices[i]</p>
</dd>
</dl>
<p>}
if profit &lt; prices[i]-min {</p>
<blockquote>
<div><p>profit = prices[i] - min</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return profit</p>
</div></blockquote>
<p>}</p>
<p>#
func maxProfit(prices []int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if len(prices) &lt; 2 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
max := 0
profit := 0
for i := len(prices) - 1; i &gt;= 0; i– {</p>
<blockquote>
<div><dl class="simple">
<dt>if max &lt; prices[i] {</dt><dd><p>max = prices[i]</p>
</dd>
</dl>
<p>}
if profit &lt; max-prices[i] {</p>
<blockquote>
<div><p>profit = max - prices[i]</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return profit</p>
</div></blockquote>
</div>
<div class="section" id="id1064">
<h1>}<a class="headerlink" href="#id1064" title="永久链接至标题">¶</a></h1>
<p>## 面试题64.求1+2+…+n(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">求</span> <span class="pre">1+2+...+n</span> <span class="pre">，要求不能使用乘除法、</span>
<span class="pre">for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</span>
<span class="pre">示例</span> <span class="pre">1：输入:</span> <span class="pre">n</span> <span class="pre">=</span> <span class="pre">3</span> <span class="pre">输出:</span> <span class="pre">6</span>
<span class="pre">示例</span> <span class="pre">2：输入:</span> <span class="pre">n</span> <span class="pre">=</span> <span class="pre">9</span> <span class="pre">输出:</span> <span class="pre">45</span>
<span class="pre">限制：1</span> <span class="pre">&lt;=</span> <span class="pre">n</span> <span class="pre">&lt;=</span> <span class="pre">10000</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路     | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ——– | ———- | ———- |</div>
<div class="line">01   | 递归     | O(n)       | O(n)       |</div>
<div class="line">02   | 内置函数 | O(1)       | O(1)       |</div>
</div>
<p><a href="#id1065"><span class="problematic" id="id1066">``</span></a><a href="#id1067"><span class="problematic" id="id1068">`</span></a>go
var res int</p>
<dl class="simple">
<dt>func sumNums(n int) int {</dt><dd><p>res = 0
dfs(n)
return res</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>func dfs(n int) bool {</dt><dd><p>res = res + n
return n &gt; 0 &amp;&amp; dfs(n-1)</p>
</dd>
</dl>
<p>}</p>
<p>#
func sumNums(n int) int {</p>
<blockquote>
<div><p>return (int(math.Pow(float64(n), float64(2))) + n) &gt;&gt; 1</p>
</div></blockquote>
</div>
<div class="section" id="id1069">
<h1>}<a class="headerlink" href="#id1069" title="永久链接至标题">¶</a></h1>
<p>## 面试题65.不用加减乘除做加法(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id1070"><span class="problematic" id="id1071">``</span></a>`
写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。
示例:输入: a = 1, b = 1 输出: 2
提示：</p>
<blockquote>
<div><p>a, b 均可能是负数或 0
结果不会溢出 32 位整数</p>
</div></blockquote>
<p><a href="#id1072"><span class="problematic" id="id1073">``</span></a><a href="#id1074"><span class="problematic" id="id1075">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路           | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ————– | ———- | ———- |</div>
<div class="line">01   | 迭代(书上方法) | O(1)       | O(1)       |</div>
<div class="line">02   | 递归           | O(1)       | O(1)       |</div>
</div>
<p><a href="#id1076"><span class="problematic" id="id1077">``</span></a><a href="#id1078"><span class="problematic" id="id1079">`</span></a>go
// 非进位和：异或运算
// 进位：与运算+左移一位
func add(a int, b int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>for b != 0 {</dt><dd><p>a, b = a^b, (a&amp;b)&lt;&lt;1</p>
</dd>
</dl>
<p>}
return a</p>
</div></blockquote>
<p>}</p>
<p>#
func add(a int, b int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if b == 0 {</dt><dd><p>return a</p>
</dd>
</dl>
<p>}
return add(a^b, (a&amp;b)&lt;&lt;1)</p>
</div></blockquote>
</div>
<div class="section" id="id1080">
<h1>}<a class="headerlink" href="#id1080" title="永久链接至标题">¶</a></h1>
<p>## 面试题66.构建乘积数组(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id1081"><span class="problematic" id="id1082">``</span></a>`
给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，
其中 B 中的元素 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。
示例:输入: [1,2,3,4,5] 输出: [120,60,40,30,24]
提示：所有元素乘积之和不会溢出 32 位整数</p>
<blockquote>
<div><p>a.length &lt;= 100000</p>
</div></blockquote>
<p><a href="#id1083"><span class="problematic" id="id1084">``</span></a><a href="#id1085"><span class="problematic" id="id1086">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路               | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —————— | ———- | ———- |</div>
<div class="line">01   | 二次遍历(书上方法) | O(n)       | O(1)       |</div>
<div class="line">02   | 数组辅助           | O(n)       | O(n)       |</div>
</div>
<p><a href="#id1087"><span class="problematic" id="id1088">``</span></a><a href="#id1089"><span class="problematic" id="id1090">`</span></a>go
func constructArr(a []int) []int {</p>
<blockquote>
<div><p>res := make([]int, len(a))
if len(a) == 0 {</p>
<blockquote>
<div><p>return res</p>
</div></blockquote>
<p>}
res[0] = 1
for i := 1; i &lt; len(res); i++ {</p>
<blockquote>
<div><p>res[i] = res[i-1] * a[i-1]</p>
</div></blockquote>
<p>}
temp := 1
for i := len(res) - 2; i &gt;= 0; i– {</p>
<blockquote>
<div><p>res[i] = res[i] * a[i+1] * temp
temp = temp * a[i+1]</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
func constructArr(a []int) []int {</p>
<blockquote>
<div><p>res := make([]int, len(a))
if len(a) == 0 {</p>
<blockquote>
<div><p>return res</p>
</div></blockquote>
<p>}
left := make([]int, len(a))
left[0] = 1
right := make([]int, len(a))
right[len(a)-1] = 1
for i := 1; i &lt; len(a); i++ {</p>
<blockquote>
<div><p>left[i] = left[i-1] * a[i-1]</p>
</div></blockquote>
<p>}
for i := len(a) - 2; i &gt;= 0; i– {</p>
<blockquote>
<div><p>right[i] = right[i+1] * a[i+1]</p>
</div></blockquote>
<p>}
for i := 0; i &lt; len(a); i++ {</p>
<blockquote>
<div><p>res[i] = left[i] * right[i]</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
</div>
<div class="section" id="id1091">
<h1>}<a class="headerlink" href="#id1091" title="永久链接至标题">¶</a></h1>
<p>## 面试题67.把字符串转换成整数(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id1092"><span class="problematic" id="id1093">``</span></a>`
写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。
首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。
当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，
作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。
该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。
注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、
字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。
在任何情况下，若函数不能进行有效的转换时，请返回 0。
说明：
假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p>
<p>示例 1:输入: “42”输出: 42
示例 2:输入: ”   -42”输出: -42
解释: 第一个非空白字符为 ‘-‘, 它是一个负号。
我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。
示例 3:输入: “4193 with words”输出: 4193
解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。
示例 4:输入: “words and 987” 输出: 0
解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。 因此无法执行有效的转换。
示例 5:输入: “-91283472332” 输出: -2147483648 因此返回 INT_MIN (−231) 。
注意：本题与主站 8 题相同：<a class="reference external" href="https://leetcode-cn.com/problems/string-to-integer-atoi/">https://leetcode-cn.com/problems/string-to-integer-atoi/</a>
<a href="#id1094"><span class="problematic" id="id1095">``</span></a><a href="#id1096"><span class="problematic" id="id1097">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路 | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —- | ———- | ———- |</div>
<div class="line">01   | 遍历 | O(n)       | O(n)       |</div>
<div class="line">02   | 正则 | O(n)       | O(n)       |</div>
</div>
<p><a href="#id1098"><span class="problematic" id="id1099">``</span></a><a href="#id1100"><span class="problematic" id="id1101">`</span></a>go
func strToInt(str string) int {</p>
<blockquote>
<div><p>i := 0
for i &lt; len(str) &amp;&amp; str[i] == ‘ ‘ {</p>
<blockquote>
<div><p>i++</p>
</div></blockquote>
<p>}
str = str[i:]
arr := make([]byte, 0)
isFlag := byte(‘ ‘)
for j := 0; j &lt; len(str); j++ {</p>
<blockquote>
<div><dl>
<dt>if str[j] &gt;= ‘0’ &amp;&amp; str[j] &lt;= ‘9’ {</dt><dd><p>arr = append(arr, str[j])</p>
</dd>
<dt>} else {</dt><dd><dl class="simple">
<dt>if len(arr) &gt; 0 {</dt><dd><p>break</p>
</dd>
</dl>
<p>}
if str[j] != ‘ ‘ &amp;&amp; str[j] != ‘+’ &amp;&amp; str[j] != ‘-‘ {</p>
<blockquote>
<div><p>return 0</p>
</div></blockquote>
<p>}
if isFlag != ‘ ‘ {</p>
<blockquote>
<div><p>return 0</p>
</div></blockquote>
<p>}
isFlag = str[j]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
res := 0
for i := 0; i &lt; len(arr); i++ {</p>
<blockquote>
<div><p>value := int(arr[i] - ‘0’)
res = res*10 + value
if isFlag == ‘-‘ {</p>
<blockquote>
<div><dl class="simple">
<dt>if -1*res &lt; math.MinInt32 {</dt><dd><p>return math.MinInt32</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl>
<dt>} else if isFlag == ‘ ‘ || isFlag == ‘+’ {</dt><dd><dl class="simple">
<dt>if res &gt; math.MaxInt32 {</dt><dd><p>return math.MaxInt32</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
if isFlag == ‘-‘ {</p>
<blockquote>
<div><p>return -1 * res</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
func strToInt(str string) int {</p>
<blockquote>
<div><p>re := regexp.MustCompile(<cite>^[+-]?d+</cite>)
arrS := re.FindAllString(strings.Trim(str, ” “), -1)
if len(arrS) == 0{</p>
<blockquote>
<div><p>return 0</p>
</div></blockquote>
<p>}
arr := arrS[0]
res := 0
isFlag := byte(‘ ‘)
if !(arr[0] &gt;= ‘0’ &amp;&amp; arr[0] &lt;= ‘9’) {</p>
<blockquote>
<div><p>isFlag = arr[0]
arr = arr[1:]</p>
</div></blockquote>
<p>}
for i := 0; i &lt; len(arr); i++ {</p>
<blockquote>
<div><p>value := int(arr[i] - ‘0’)
if isFlag == ‘-‘ {</p>
<blockquote>
<div><dl class="simple">
<dt>if res &gt; 214748364 || (res==214748364 &amp;&amp; value &gt;= 8) {</dt><dd><p>return math.MinInt32</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl>
<dt>} else if isFlag == ‘ ‘ || isFlag == ‘+’ {</dt><dd><dl class="simple">
<dt>if res &gt; 214748364 || (res==214748364 &amp;&amp; value &gt;= 7) {</dt><dd><p>return math.MaxInt32</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
res = res*10 + value</p>
</div></blockquote>
<p>}
if isFlag == ‘-‘ {</p>
<blockquote>
<div><p>return -1 * res</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
</div>
<div class="section" id="id1102">
<h1>}<a class="headerlink" href="#id1102" title="永久链接至标题">¶</a></h1>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="1001-1100.html" class="btn btn-neutral float-left" title="&lt;no title&gt;" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, willshang

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>