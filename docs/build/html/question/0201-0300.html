

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh-CN" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh-CN" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>} &mdash; go-leetcode v1.0.0 文档</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="}" href="0301-0400.html" />
    <link rel="prev" title="}" href="0101-0200.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> go-leetcode
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id20">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id31">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id42">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id53">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id86">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id111">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id114">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id119">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id122">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id127">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id138">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id149">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id160">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id171">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id182">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id193">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id204">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id215">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id226">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id249">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id260">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0001-0100.html#id279">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id24">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id25">]</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id48">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id65">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id80">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id95">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id112">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id115">]</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id120">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id131">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id142">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id153">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id164">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id175">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id192">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id219">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id250">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id261">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id272">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id283">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id294">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id305">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id316">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id327">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html#id350">}</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id18">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id23">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id34">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id51">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id62">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id73">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id138">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id157">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id168">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id217">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id234">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id253">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id266">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id277">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id296">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id301">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id312">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id323">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id334">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id345">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id356">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id367">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id378">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id20">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id25">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id36">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id47">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id58">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id69">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id74">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id79">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id90">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id101">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id106">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id111">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0301-0400.html#id124">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id26">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id37">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id42">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id45">]</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id50">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id55">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id66">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id71">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id100">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id105">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id116">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id127">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id138">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id143">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id154">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id159">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id170">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id181">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id192">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id203">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id214">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id225">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id236">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id247">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0401-0500.html#id258">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id24">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id35">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id40">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id51">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id62">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id73">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id98">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id109">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id138">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id149">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id170">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id181">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id192">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id207">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id218">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id235">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id246">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id273">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id284">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id295">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id306">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id323">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id328">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id339">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0501-0600.html#id350">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id28">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id51">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id62">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id67">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id84">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id95">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id106">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id133">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id144">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id155">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id166">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id185">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id204">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id209">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id220">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id231">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id242">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id267">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id280">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id287">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id298">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id309">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0601-0700.html#id328">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id46">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id85">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id96">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id111">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id122">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id133">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id146">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id157">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id170">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id181">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id192">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id203">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id214">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id225">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id252">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id263">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id274">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0701-0800.html#id285">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id22">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id33">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id44">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id55">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id66">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id77">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id82">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id93">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id104">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id115">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id126">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id137">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id148">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id159">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id170">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id181">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id186">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id221">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id232">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id255">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id266">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id277">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id288">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id299">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id310">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id321">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0801-0900.html#id356">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id22">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id33">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id44">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id55">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id66">}</a></li>
<li class="toctree-l1"><a class="reference internal" href="0901-1000.html#id77">}</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">go-leetcode</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>}</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/question/0201-0300.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <p># 0201-0300-Easy
* [0201-0300-Easy](#0201-0300-easy)</p>
<blockquote>
<div><ul class="simple">
<li><p>[202.快乐数(2)](#202快乐数2)</p></li>
<li><p>[203.移除链表元素(2)](#203移除链表元素2)</p></li>
<li><p>[204.计数质数(2)](#204计数质数2)</p></li>
<li><p>[205.同构字符串(3)](#205同构字符串3)</p></li>
<li><p>[206.反转链表(2)](#206反转链表2)</p></li>
<li><p>[217.存在重复元素(2)](#217存在重复元素2)</p></li>
<li><p>[219.存在重复元素 II(2)](#219存在重复元素-ii2)</p></li>
<li><p>[225.用队列实现栈(4)](#225用队列实现栈4)</p></li>
<li><p>[226.翻转二叉树(2)](#226翻转二叉树2)</p></li>
<li><p>[231.2的幂(3)](#2312的幂3)</p></li>
<li><p>[232.用栈实现队列(3)](#232用栈实现队列3)</p></li>
<li><p>[234.回文链表(4)](#234回文链表4)</p></li>
<li><p>[235.二叉搜索树的最近公共祖先(2)](#235二叉搜索树的最近公共祖先2)</p></li>
<li><p>[237.删除链表中的节点(1)](#237删除链表中的节点1)</p></li>
<li><p>[242.有效的字母异位词(2)](#242有效的字母异位词2)</p></li>
<li><p>[257.二叉树的所有路径(2)](#257二叉树的所有路径2)</p></li>
<li><p>[258.各位相加(4)](#258各位相加4)</p></li>
<li><p>[263.丑数(2)](#263丑数2)</p></li>
<li><p>[268.缺失数字(5)](#268缺失数字5)</p></li>
<li><p>[278.第一个错误的版本(2)](#278第一个错误的版本2)</p></li>
<li><p>[283.移动零(3)](#283移动零3)</p></li>
<li><p>[290.单词规律(2)](#290单词规律2)</p></li>
<li><p>[292.Nim 游戏(1)](#292nim-游戏1)</p></li>
<li><p>[299.猜数字游戏(2)](#299猜数字游戏2)</p></li>
</ul>
</div></blockquote>
<p>## 202.快乐数(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">编写一个算法来判断一个数</span> <span class="pre">n</span> <span class="pre">是不是快乐数。</span>
<span class="pre">「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，</span>
<span class="pre">然后重复这个过程直到这个数变为</span> <span class="pre">1，也可能是</span> <span class="pre">无限循环</span> <span class="pre">但始终变不到</span> <span class="pre">1。</span>
<span class="pre">如果</span> <span class="pre">可以变为</span>&#160; <span class="pre">1，那么这个数就是快乐数。</span>
<span class="pre">如果</span> <span class="pre">n</span> <span class="pre">是快乐数就返回</span> <span class="pre">True</span> <span class="pre">；不是，则返回</span> <span class="pre">False</span> <span class="pre">。</span>
<span class="pre">示例：</span> <span class="pre">输入：19</span> <span class="pre">输出：true</span>
<span class="pre">解释：</span>
<span class="pre">12</span> <span class="pre">+</span> <span class="pre">92</span> <span class="pre">=</span> <span class="pre">82</span>
<span class="pre">82</span> <span class="pre">+</span> <span class="pre">22</span> <span class="pre">=</span> <span class="pre">68</span>
<span class="pre">62</span> <span class="pre">+</span> <span class="pre">82</span> <span class="pre">=</span> <span class="pre">100</span>
<span class="pre">12</span> <span class="pre">+</span> <span class="pre">02</span> <span class="pre">+</span> <span class="pre">02</span> <span class="pre">=</span> <span class="pre">1</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路            | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ————— | ———- | ———- |</div>
<div class="line">01   | 哈希+遍历       | O(log(n))  | O(log(n))  |</div>
<div class="line">02   | 遍历+快慢判断环 | O(log(n))  | O(1)       |</div>
</div>
<p><a href="#id1"><span class="problematic" id="id2">``</span></a><a href="#id3"><span class="problematic" id="id4">`</span></a>go
func isHappy(n int) bool {</p>
<blockquote>
<div><p>now, next := n, nextValue(n)
m := make(map[int]int)
m[now] = 1
for {</p>
<blockquote>
<div><dl class="simple">
<dt>if next == 1 {</dt><dd><p>break</p>
</dd>
</dl>
<p>}
if _, ok := m[next]; ok {</p>
<blockquote>
<div><p>break</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>m[next] = 1</p>
</dd>
</dl>
<p>}
next = nextValue(next)</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>if next == 1 {</dt><dd><p>return true</p>
</dd>
</dl>
<p>}</p>
<p>return false</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func nextValue(n int) int {</dt><dd><p>ret := 0
for n != 0 {</p>
<blockquote>
<div><p>ret = ret + (n%10)*(n%10)
n = n / 10</p>
</div></blockquote>
<p>}
return ret</p>
</dd>
</dl>
<p>}</p>
<p>#
func isHappy(n int) bool {</p>
<blockquote>
<div><p>now, next := n, nextValue(n)
for now != next {</p>
<blockquote>
<div><p>now = nextValue(now)
next = nextValue(nextValue(next))</p>
</div></blockquote>
<p>}
if now == 1 {</p>
<blockquote>
<div><p>return true</p>
</div></blockquote>
<p>}
return false</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func nextValue(n int) int {</dt><dd><p>ret := 0
for n != 0 {</p>
<blockquote>
<div><p>ret = ret + (n%10)*(n%10)
n = n / 10</p>
</div></blockquote>
<p>}
return ret</p>
</dd>
</dl>
<div class="section" id="id5">
<h1>}<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h1>
<p>## 203.移除链表元素(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">删除链表中等于给定值</span> <span class="pre">val</span> <span class="pre">的所有节点。</span>
<span class="pre">示例:</span>
<span class="pre">输入:</span> <span class="pre">1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6,</span> <span class="pre">val</span> <span class="pre">=</span> <span class="pre">6</span>
<span class="pre">输出:</span> <span class="pre">1-&gt;2-&gt;3-&gt;4-&gt;5</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路              | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —————– | ———- | ———- |</div>
<div class="line">01   | 哨兵结点+链表遍历 | O(n)       | O(1)       |</div>
<div class="line">02   | 递归              | O(n)       | O(n)       |</div>
</div>
<p><a href="#id6"><span class="problematic" id="id7">``</span></a><a href="#id8"><span class="problematic" id="id9">`</span></a>go
func removeElements(head <a href="#id10"><span class="problematic" id="id11">*</span></a>ListNode, val int) <a href="#id12"><span class="problematic" id="id13">*</span></a>ListNode {</p>
<blockquote>
<div><p>headPre := &amp;ListNode{Next: head}
temp := headPre</p>
<dl>
<dt>for temp.Next != nil {</dt><dd><dl class="simple">
<dt>if temp.Next.Val == val {</dt><dd><p>//delete
temp.Next = temp.Next.Next</p>
</dd>
<dt>} else {</dt><dd><p>temp = temp.Next</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>return headPre.Next</p>
</div></blockquote>
<p>}</p>
<p># 递归
func removeElements(head <a href="#id14"><span class="problematic" id="id15">*</span></a>ListNode, val int) <a href="#id16"><span class="problematic" id="id17">*</span></a>ListNode {</p>
<blockquote>
<div><dl class="simple">
<dt>if head == nil {</dt><dd><p>return nil</p>
</dd>
</dl>
<p>}
head.Next = removeElements(head.Next, val)
if head.Val == val {</p>
<blockquote>
<div><p>return head.Next</p>
</div></blockquote>
<p>}
return head</p>
</div></blockquote>
</div>
<div class="section" id="id18">
<h1>}<a class="headerlink" href="#id18" title="永久链接至标题">¶</a></h1>
<p>## 204.计数质数(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">统计所有小于非负整数</span> <span class="pre">n</span> <span class="pre">的质数的数量。</span>
<span class="pre">示例:</span>
<span class="pre">输入:</span> <span class="pre">10</span>
<span class="pre">输出:</span> <span class="pre">4</span>
<span class="pre">解释:</span> <span class="pre">小于</span> <span class="pre">10</span> <span class="pre">的质数一共有</span> <span class="pre">4</span> <span class="pre">个,</span> <span class="pre">它们是</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">5,</span> <span class="pre">7</span> <span class="pre">。</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路                   | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ———————- | ———- | ———- |</div>
<div class="line">01   | 筛选质数(厄拉多塞筛法) | O(n^2)     | O(n)       |</div>
<div class="line">02   | 筛选质数优化           | O(n^(1/4)) | O(n)       |</div>
</div>
<p><a href="#id19"><span class="problematic" id="id20">``</span></a><a href="#id21"><span class="problematic" id="id22">`</span></a>go
func countPrimes(n int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if n &lt; 3 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
notPrimes := make([]bool, n)
count := 0
for i := 2; i &lt; n; i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if notPrimes[i] {</dt><dd><p>continue</p>
</dd>
</dl>
<p>}
for j := i*2 ; j &lt; n; j += i  {</p>
<blockquote>
<div><p>notPrimes[j] = true</p>
</div></blockquote>
<p>}
count++</p>
</div></blockquote>
<p>}
return count</p>
</div></blockquote>
<p>}</p>
<p>#
func countPrimes(n int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if n &lt; 3 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
isPrimes := make([]bool, n)
for i := range isPrimes {</p>
<blockquote>
<div><p>isPrimes[i] = true</p>
</div></blockquote>
<p>}
for i := 2; i*i &lt; n; i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if !isPrimes[i] {</dt><dd><p>continue</p>
</dd>
</dl>
<p>}
for j := i * i; j &lt; n; j += i {</p>
<blockquote>
<div><p>isPrimes[j] = false</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
count := 0
for i := 2; i &lt; n; i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if isPrimes[i] {</dt><dd><p>count++</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return count</p>
</div></blockquote>
</div>
<div class="section" id="id23">
<h1>}<a class="headerlink" href="#id23" title="永久链接至标题">¶</a></h1>
<p>## 205.同构字符串(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id24"><span class="problematic" id="id25">``</span></a>`
给定两个字符串 s 和 t，判断它们是否是同构的。
如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。
所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。
两个字符不能映射到同一个字符上，但字符可以映射自己本身。</p>
<p>示例 1: 输入: s = “egg”, t = “add” 输出: true
示例 2:输入: s = “foo”, t = “bar” 输出: false
示例 3: 输入: s = “paper”, t = “title” 输出: true</p>
<p>说明:你可以假设 s 和 t 具有相同的长度。
<a href="#id26"><span class="problematic" id="id27">``</span></a><a href="#id28"><span class="problematic" id="id29">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路           | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ————– | ———- | ———- |</div>
<div class="line">01   | 数组映射       | O(n)       | O(n)       |</div>
<div class="line">02   | 哈希映射       | O(n)       | O(n)       |</div>
<div class="line">03   | 字符串查找匹配 | O(n)       | O(1)       |</div>
</div>
<p><a href="#id30"><span class="problematic" id="id31">``</span></a><a href="#id32"><span class="problematic" id="id33">`</span></a>go
func isIsomorphic(s string, t string) bool {</p>
<blockquote>
<div><dl class="simple">
<dt>if len(s) != len(t) {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}</p>
<p>m1 := make([]int, 256)
m2 := make([]int, 256)</p>
<dl>
<dt>for i := 0; i &lt; len(s); i++ {</dt><dd><p>a := int(s[i])
b := int(t[i])
if m1[a] != m2[b] {</p>
<blockquote>
<div><p>return false</p>
</div></blockquote>
<p>}
m1[a] = i + 1
m2[b] = i + 1</p>
</dd>
</dl>
<p>}
return true</p>
</div></blockquote>
<p>}</p>
<p>#
func isIsomorphic(s string, t string) bool {</p>
<blockquote>
<div><dl class="simple">
<dt>if len(s) != len(t) {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}</p>
<p>m := make(map[int]int)
n := make(map[int]int)</p>
<dl>
<dt>for i := 0; i &lt; len(s); i++ {</dt><dd><p>a := int(s[i])
b := int(t[i])
if m[a] == 0 &amp;&amp; n[b] == 0 {</p>
<blockquote>
<div><p>m[a] = b
n[b] = a</p>
</div></blockquote>
<dl class="simple">
<dt>} else if m[a] != b || n[b] != a {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
return true</p>
</div></blockquote>
<p>}</p>
<p>#
func isIsomorphic(s string, t string) bool {</p>
<blockquote>
<div><dl>
<dt>for i := 0; i &lt; len(s); i++ {</dt><dd><dl class="simple">
<dt>if strings.IndexByte(s[i+1:], s[i]) != strings.IndexByte(t[i+1:], t[i]) {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
return true</p>
</div></blockquote>
</div>
<div class="section" id="id34">
<h1>}<a class="headerlink" href="#id34" title="永久链接至标题">¶</a></h1>
<p>## 206.反转链表(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">反转一个单链表。</span>
<span class="pre">示例:</span>
<span class="pre">输入:</span> <span class="pre">1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span>
<span class="pre">输出:</span> <span class="pre">5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span>
<span class="pre">进阶:</span>
<span class="pre">你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路 | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —- | ———- | ———- |</div>
<div class="line">01   | 递归 | O(n)       | O(n)       |</div>
<div class="line">02   | 迭代 | O(n)       | O(1)       |</div>
</div>
<p><a href="#id35"><span class="problematic" id="id36">``</span></a><a href="#id37"><span class="problematic" id="id38">`</span></a>go
func reverseList(head <a href="#id39"><span class="problematic" id="id40">*</span></a>ListNode) <a href="#id41"><span class="problematic" id="id42">*</span></a>ListNode {</p>
<blockquote>
<div><dl class="simple">
<dt>if head == nil || head.Next == nil {</dt><dd><p>return head</p>
</dd>
</dl>
<p>}</p>
<p>result := reverseList(head.Next)
head.Next.Next = head
head.Next = nil
return result</p>
</div></blockquote>
<p>}</p>
<p>//
func reverseList(head <a href="#id43"><span class="problematic" id="id44">*</span></a>ListNode) <a href="#id45"><span class="problematic" id="id46">*</span></a>ListNode {</p>
<blockquote>
<div><p>var result <a href="#id47"><span class="problematic" id="id48">*</span></a>ListNode
var temp <a href="#id49"><span class="problematic" id="id50">*</span></a>ListNode
for head != nil {</p>
<blockquote>
<div><p>temp = head.Next
head.Next = result
result = head
head = temp</p>
</div></blockquote>
<p>}
return result</p>
</div></blockquote>
</div>
<div class="section" id="id51">
<h1>}<a class="headerlink" href="#id51" title="永久链接至标题">¶</a></h1>
<p>## 217.存在重复元素(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id52"><span class="problematic" id="id53">``</span></a>`
给定一个整数数组，判断是否存在重复元素。
如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。</p>
<p>示例 1:输入: [1,2,3,1] 输出: true
示例 2:输入: [1,2,3,4] 输出: false
示例 3:输入: [1,1,1,3,3,4,3,2,4,2] 输出: true
<a href="#id54"><span class="problematic" id="id55">``</span></a><a href="#id56"><span class="problematic" id="id57">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路         | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ———— | ———- | ———- |</div>
<div class="line">01   | 哈希辅助遍历 | O(n)       | O(n)       |</div>
<div class="line">02   | 排序后遍历   | O(nlog(n)) | O(1)       |</div>
</div>
<p><a href="#id58"><span class="problematic" id="id59">``</span></a><a href="#id60"><span class="problematic" id="id61">`</span></a>go
func containsDuplicate(nums []int) bool {</p>
<blockquote>
<div><p>m := make(map[int]int)
for i := 0; i &lt; len(nums); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if _, ok := m[nums[i]]; ok {</dt><dd><p>return true</p>
</dd>
<dt>} else {</dt><dd><p>m[nums[i]] = 1</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return false</p>
</div></blockquote>
<p>}</p>
<p>#
func containsDuplicate(nums []int) bool {</p>
<blockquote>
<div><p>sort.Ints(nums)
for i := 0; i &lt; len(nums)-1; i++{</p>
<blockquote>
<div><dl class="simple">
<dt>if nums[i] == nums[i+1]{</dt><dd><p>return true</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return false</p>
</div></blockquote>
</div>
<div class="section" id="id62">
<h1>}<a class="headerlink" href="#id62" title="永久链接至标题">¶</a></h1>
<p>## 219.存在重复元素 II(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id63"><span class="problematic" id="id64">``</span></a>`
给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，
使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。</p>
<p>示例 1:输入: nums = [1,2,3,1], k = 3输出: true
示例 2:输入: nums = [1,0,1,1], k = 1 输出: true
示例 3:输入: nums = [1,2,3,1,2,3], k = 2 输出: false
<a href="#id65"><span class="problematic" id="id66">``</span></a><a href="#id67"><span class="problematic" id="id68">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路            | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ————— | ———- | ———- |</div>
<div class="line">01   | 哈希辅助遍历    | O(n)       | O(n)       |</div>
<div class="line">02   | 哈希表+滑动窗口 | O(n)       | O(n)       |</div>
</div>
<p><a href="#id69"><span class="problematic" id="id70">``</span></a><a href="#id71"><span class="problematic" id="id72">`</span></a>go
#
func containsNearbyDuplicate(nums []int, k int) bool {</p>
<blockquote>
<div><p>m := make(map[int]int)</p>
<dl>
<dt>for i, n := range nums {</dt><dd><dl class="simple">
<dt>if m[n] != 0 &amp;&amp; (i+1)-m[n] &lt;= k {</dt><dd><p>return true</p>
</dd>
</dl>
<p>}
m[n] = i + 1</p>
</dd>
</dl>
<p>}
return false</p>
</div></blockquote>
<p>}</p>
<p>#
func containsNearbyDuplicate(nums []int, k int) bool {</p>
<blockquote>
<div><p>m := make(map[int]int)</p>
<dl>
<dt>for i, n := range nums {</dt><dd><dl class="simple">
<dt>if m[n] != 0 {</dt><dd><p>return true</p>
</dd>
</dl>
<p>}
m[n] = i + 1
if len(m) &gt; k {</p>
<blockquote>
<div><p>delete(m, nums[i-k])</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}
return false</p>
</div></blockquote>
</div>
<div class="section" id="id73">
<h1>}<a class="headerlink" href="#id73" title="永久链接至标题">¶</a></h1>
<p>## 225.用队列实现栈(4)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id74"><span class="problematic" id="id75">``</span></a>`
使用队列实现栈的下列操作：</p>
<blockquote>
<div><p>push(x) – 元素 x 入栈
pop() – 移除栈顶元素
top() – 获取栈顶元素
empty() – 返回栈是否为空</p>
</div></blockquote>
<dl class="simple">
<dt>注意:</dt><dd><p>你只能使用队列的基本操作– 也就是 push to back, peek/pop from front, size,
和 is empty 这些操作是合法的。
你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 ,
只要是标准的队列操作即可。
你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</p>
</dd>
</dl>
<p><a href="#id76"><span class="problematic" id="id77">``</span></a><a href="#id78"><span class="problematic" id="id79">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路                     | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ———————— | ———- | ———- |</div>
<div class="line">01   | 使用切片实现             | O(1)       | O(n)       |</div>
<div class="line">02   | 使用1个list实现          | O(1)       | O(n)       |</div>
<div class="line">03   | 使用2个list实现          | O(n)       | O(n)       |</div>
<div class="line">04   | 使用2个双端队列deque实现 | O(n)       | O(n)       |</div>
</div>
<p><a href="#id80"><span class="problematic" id="id81">``</span></a><a href="#id82"><span class="problematic" id="id83">`</span></a>go
type MyStack struct {</p>
<blockquote>
<div><p>arr []int</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>func Constructor() MyStack {</dt><dd><p>return MyStack{}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>func (m <a href="#id84"><span class="problematic" id="id85">*</span></a>MyStack) Push(x int) {</dt><dd><p>m.arr = append(m.arr, x)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func (m <a href="#id86"><span class="problematic" id="id87">*</span></a>MyStack) Pop() int {</dt><dd><dl class="simple">
<dt>if len(m.arr) == 0 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
last := m.arr[len(m.arr)-1]
m.arr = m.arr[0 : len(m.arr)-1]
return last</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func (m <a href="#id88"><span class="problematic" id="id89">*</span></a>MyStack) Top() int {</dt><dd><dl class="simple">
<dt>if len(m.arr) == 0 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
return m.arr[len(m.arr)-1]</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func (m <a href="#id90"><span class="problematic" id="id91">*</span></a>MyStack) Empty() bool {</dt><dd><dl class="simple">
<dt>if len(m.arr) == 0 {</dt><dd><p>return true</p>
</dd>
</dl>
<p>}
return false</p>
</dd>
</dl>
<p>}</p>
<p># 使用1个list实现
type MyStack struct {</p>
<blockquote>
<div><p><a href="#id92"><span class="problematic" id="id93">*</span></a>list.List</p>
</div></blockquote>
<p>}
func Constructor() MyStack {</p>
<blockquote>
<div><dl class="simple">
<dt>return MyStack{</dt><dd><p>list.New(),</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>func (m <a href="#id94"><span class="problematic" id="id95">*</span></a>MyStack) Push(x int) {</dt><dd><p>m.PushBack(x)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func (m <a href="#id96"><span class="problematic" id="id97">*</span></a>MyStack) Pop() int {</dt><dd><dl class="simple">
<dt>if m.Len() == 0 {</dt><dd><p>return -1</p>
</dd>
</dl>
<p>}
return m.Remove(m.Back()).(int)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func (m <a href="#id98"><span class="problematic" id="id99">*</span></a>MyStack) Top() int {</dt><dd><dl class="simple">
<dt>if m.Len() == 0 {</dt><dd><p>return -1</p>
</dd>
</dl>
<p>}
return m.Back().Value.(int)</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>func (m <a href="#id100"><span class="problematic" id="id101">*</span></a>MyStack) Empty() bool {</dt><dd><p>return m.Len() == 0</p>
</dd>
</dl>
<p>}</p>
<p>#  使用2个list实现
/*
入栈过程：
1、q1 为空，放入 q2，否则放入 q1
出栈过程：
1、q1为空：依次取出q2中的元素（除了最后一个），并且放入q1中 取出q2中的最后一个元素，返回结果
否则 依次取出q1中的元素（除了最后一个），并且放入q2中 取出q1中的最后一个元素，返回结果
<a href="#id102"><span class="problematic" id="id103">*</span></a>/
type MyStack struct {</p>
<blockquote>
<div><p>l1 <a href="#id104"><span class="problematic" id="id105">*</span></a>list.List
l2 <a href="#id106"><span class="problematic" id="id107">*</span></a>list.List</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func Constructor() MyStack {</dt><dd><dl class="simple">
<dt>return MyStack{</dt><dd><p>l1: list.New(),
l2: list.New(),</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func (m <a href="#id108"><span class="problematic" id="id109">*</span></a>MyStack) Push(x int) {</dt><dd><dl class="simple">
<dt>if m.l1.Len() == 0 {</dt><dd><p>m.l2.PushBack(x)</p>
</dd>
<dt>} else {</dt><dd><p>m.l1.PushBack(x)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func (m <a href="#id110"><span class="problematic" id="id111">*</span></a>MyStack) Pop() int {</dt><dd><p>var top int
if m.l1.Len() &gt; 0 {</p>
<blockquote>
<div><dl class="simple">
<dt>for m.l1.Len() &gt; 1 {</dt><dd><p>m.l2.PushBack(m.l1.Remove(m.l1.Front()))</p>
</dd>
</dl>
<p>}
top = m.l1.Remove(m.l1.Front()).(int)</p>
</div></blockquote>
<dl>
<dt>} else {</dt><dd><dl class="simple">
<dt>for m.l2.Len() &gt; 1 {</dt><dd><p>m.l1.PushBack(m.l2.Remove(m.l2.Front()))</p>
</dd>
</dl>
<p>}
top = m.l2.Remove(m.l2.Front()).(int)</p>
</dd>
</dl>
<p>}
return top</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func (m <a href="#id112"><span class="problematic" id="id113">*</span></a>MyStack) Top() int {</dt><dd><p>var top int
if m.l1.Len() &gt; 0 {</p>
<blockquote>
<div><dl class="simple">
<dt>for m.l1.Len() &gt; 1 {</dt><dd><p>m.l2.PushBack(m.l1.Remove(m.l1.Front()))</p>
</dd>
</dl>
<p>}
top = m.l1.Back().Value.(int)
m.l2.PushBack(m.l1.Remove(m.l1.Front()))</p>
</div></blockquote>
<dl>
<dt>} else {</dt><dd><dl class="simple">
<dt>for m.l2.Len() &gt; 1 {</dt><dd><p>m.l1.PushBack(m.l2.Remove(m.l2.Front()))</p>
</dd>
</dl>
<p>}
top = m.l2.Back().Value.(int)
m.l1.PushBack(m.l2.Remove(m.l2.Front()))</p>
</dd>
</dl>
<p>}
return top</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>func (m <a href="#id114"><span class="problematic" id="id115">*</span></a>MyStack) Empty() bool {</dt><dd><p>return m.l1.Len() == 0 &amp;&amp; m.l2.Len() == 0</p>
</dd>
</dl>
<p>}</p>
<p># 使用2个双端队列deque实现
type MyStack struct {</p>
<blockquote>
<div><p>l1 <a href="#id116"><span class="problematic" id="id117">*</span></a>Queue
l2 <a href="#id118"><span class="problematic" id="id119">*</span></a>Queue</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func Constructor() MyStack {</dt><dd><dl class="simple">
<dt>return MyStack{</dt><dd><p>l1: NewQueue(),
l2: NewQueue(),</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>func (m <a href="#id120"><span class="problematic" id="id121">*</span></a>MyStack) Push(x int) {</dt><dd><p>m.l1.Push(x)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func (m <a href="#id122"><span class="problematic" id="id123">*</span></a>MyStack) Pop() int {</dt><dd><dl class="simple">
<dt>if m.l2.Len() == 0 {</dt><dd><p>m.l1, m.l2 = m.l2, m.l1</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>for m.l2.Len() &gt; 1 {</dt><dd><p>m.l1.Push(m.l2.Pop())</p>
</dd>
</dl>
<p>}
return m.l2.Pop()</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>func (m <a href="#id124"><span class="problematic" id="id125">*</span></a>MyStack) Top() int {</dt><dd><p>res := m.Pop()
m.l1.Push(res)
return res</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>func (m <a href="#id126"><span class="problematic" id="id127">*</span></a>MyStack) Empty() bool {</dt><dd><p>return (m.l1.Len() + m.l2.Len()) == 0</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>type Queue struct {</dt><dd><p>nums []int</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func NewQueue() <a href="#id128"><span class="problematic" id="id129">*</span></a>Queue {</dt><dd><dl class="simple">
<dt>return &amp;Queue{</dt><dd><p>nums: []int{},</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>func (q <a href="#id130"><span class="problematic" id="id131">*</span></a>Queue) Push(n int) {</dt><dd><p>q.nums = append(q.nums, n)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func (q <a href="#id132"><span class="problematic" id="id133">*</span></a>Queue) Pop() int {</dt><dd><dl class="simple">
<dt>if len(q.nums) == 0 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
res := q.nums[0]
q.nums = q.nums[1:]
return res</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>func (q <a href="#id134"><span class="problematic" id="id135">*</span></a>Queue) Len() int {</dt><dd><p>return len(q.nums)</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>func (q <a href="#id136"><span class="problematic" id="id137">*</span></a>Queue) IsEmpty() bool {</dt><dd><p>return q.Len() == 0</p>
</dd>
</dl>
</div>
<div class="section" id="id138">
<h1>}<a class="headerlink" href="#id138" title="永久链接至标题">¶</a></h1>
<p>## 226.翻转二叉树(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id139"><span class="problematic" id="id140">``</span></a>`
翻转一棵二叉树。</p>
<p>示例：</p>
<p>输入：</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><p>4</p>
</div></blockquote>
<p>/   </p>
</div></blockquote>
<p>2     7</p>
</div></blockquote>
<p>/   / </p>
</div></blockquote>
<p>1   3 6   9</p>
<p>输出：</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><p>4</p>
</div></blockquote>
<p>/   </p>
</div></blockquote>
<p>7     2</p>
</div></blockquote>
<p>/   / </p>
</div></blockquote>
<p>9   6 3   1</p>
<p>备注:
这个问题是受到 Max Howell 的 原问题 启发的 ：</p>
<blockquote>
<div><p>谷歌：我们90％的工程师使用您编写的软件(Homebrew)，
但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。</p>
</div></blockquote>
<p><a href="#id141"><span class="problematic" id="id142">``</span></a><a href="#id143"><span class="problematic" id="id144">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路 | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —- | ———- | ———- |</div>
<div class="line">01   | 递归 | O(n)       | O(n)       |</div>
<div class="line">02   | 迭代 | O(n)       | O(n)       |</div>
</div>
<p><a href="#id145"><span class="problematic" id="id146">``</span></a><a href="#id147"><span class="problematic" id="id148">`</span></a>go
func invertTree(root <a href="#id149"><span class="problematic" id="id150">*</span></a>TreeNode) <a href="#id151"><span class="problematic" id="id152">*</span></a>TreeNode {</p>
<blockquote>
<div><dl class="simple">
<dt>if root == nil || (root.Left == nil &amp;&amp; root.Right == nil) {</dt><dd><p>return root</p>
</dd>
</dl>
<p>}
root.Left, root.Right = invertTree(root.Right), invertTree(root.Left)
return root</p>
</div></blockquote>
<p>}</p>
<p>#
func invertTree(root <a href="#id153"><span class="problematic" id="id154">*</span></a>TreeNode) <a href="#id155"><span class="problematic" id="id156">*</span></a>TreeNode {</p>
<blockquote>
<div><dl class="simple">
<dt>if root == nil {</dt><dd><p>return root</p>
</dd>
</dl>
<p>}</p>
<p>var queue []*TreeNode
queue = append(queue, root)
for len(queue) &gt; 0 {</p>
<blockquote>
<div><p>node := queue[0]
queue = queue[1:]
node.Left, node.Right = node.Right, node.Left
if node.Left != nil {</p>
<blockquote>
<div><p>queue = append(queue, node.Left)</p>
</div></blockquote>
<p>}
if node.Right != nil {</p>
<blockquote>
<div><p>queue = append(queue, node.Right)</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return root</p>
</div></blockquote>
</div>
<div class="section" id="id157">
<h1>}<a class="headerlink" href="#id157" title="永久链接至标题">¶</a></h1>
<p>## 231.2的幂(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id158"><span class="problematic" id="id159">``</span></a>`
给定一个整数，编写一个函数来判断它是否是 2 的幂次方。</p>
<p>示例 1:输入: 1 输出: true 解释: 2^0 = 1
示例 2:输入: 16 输出: true 解释: 2^4 = 16
示例 3:输入: 218 输出: false
<a href="#id160"><span class="problematic" id="id161">``</span></a><a href="#id162"><span class="problematic" id="id163">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路   | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —— | ———- | ———- |</div>
<div class="line">01   | 迭代   | O(log(n))  | O(1)       |</div>
<div class="line">02   | 位运算 | O(1)       | O(1)       |</div>
<div class="line">03   | 递归   | O(log(n))  | O(log(n))  |</div>
</div>
<p><a href="#id164"><span class="problematic" id="id165">``</span></a><a href="#id166"><span class="problematic" id="id167">`</span></a>go
func isPowerOfTwo(n int) bool {</p>
<blockquote>
<div><dl class="simple">
<dt>if n &lt; 1 {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}
for n &gt; 1 {</p>
<blockquote>
<div><dl class="simple">
<dt>if n%2 == 1 {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}
n = n / 2</p>
</div></blockquote>
<p>}
return true</p>
</div></blockquote>
<p>}</p>
<p>#
func isPowerOfTwo(n int) bool {</p>
<blockquote>
<div><dl class="simple">
<dt>if n &lt; 1 {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}
return n &amp; (n-1) == 0</p>
</div></blockquote>
<p>}</p>
<p>#
func isPowerOfTwo(n int) bool {</p>
<blockquote>
<div><dl class="simple">
<dt>if n &lt; 1 {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}
if n == 1{</p>
<blockquote>
<div><p>return true</p>
</div></blockquote>
<p>}
if n % 2 != 0{</p>
<blockquote>
<div><p>return false</p>
</div></blockquote>
<p>}
return isPowerOfTwo(n/2)</p>
</div></blockquote>
</div>
<div class="section" id="id168">
<h1>}<a class="headerlink" href="#id168" title="永久链接至标题">¶</a></h1>
<p>## 232.用栈实现队列(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id169"><span class="problematic" id="id170">``</span></a>`
使用栈实现队列的下列操作：</p>
<blockquote>
<div><p>push(x) – 将一个元素放入队列的尾部。
pop() – 从队列首部移除元素。
peek() – 返回队列首部的元素。
empty() – 返回队列是否为空。</p>
</div></blockquote>
<p>示例:
MyQueue queue = new MyQueue();
queue.push(1);
queue.push(2);
queue.peek();  // 返回 1
queue.pop();   // 返回 1
queue.empty(); // 返回 false</p>
<p>说明:
你只能使用标准的栈操作 – 也就是只有 push to top, peek/pop from top, size,
和 is empty 操作是合法的。
你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。
假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。
<a href="#id171"><span class="problematic" id="id172">``</span></a><a href="#id173"><span class="problematic" id="id174">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路            | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ————— | ———- | ———- |</div>
<div class="line">01   | 使用切片实现    | O(1)       | O(n)       |</div>
<div class="line">02   | 使用2个栈实现   | O(n)       | O(n)       |</div>
<div class="line">03   | 使用2个切片实现 | O(n)       | O(n)       |</div>
</div>
<p><a href="#id175"><span class="problematic" id="id176">``</span></a><a href="#id177"><span class="problematic" id="id178">`</span></a>go
type MyQueue struct {</p>
<blockquote>
<div><p>a []int</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>func Constructor() MyQueue {</dt><dd><p>return MyQueue{}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>func (m <a href="#id179"><span class="problematic" id="id180">*</span></a>MyQueue) Push(x int) {</dt><dd><p>m.a = append(m.a, x)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func (m <a href="#id181"><span class="problematic" id="id182">*</span></a>MyQueue) Pop() int {</dt><dd><dl class="simple">
<dt>if len(m.a) == 0 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
first := m.a[0]
m.a = m.a[1:]
return first</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func (m <a href="#id183"><span class="problematic" id="id184">*</span></a>MyQueue) Peek() int {</dt><dd><dl class="simple">
<dt>if len(m.a) == 0 {</dt><dd><p>return 0</p>
</dd>
</dl>
<p>}
return m.a[0]</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func (m <a href="#id185"><span class="problematic" id="id186">*</span></a>MyQueue) Empty() bool {</dt><dd><dl class="simple">
<dt>if len(m.a) == 0 {</dt><dd><p>return true</p>
</dd>
</dl>
<p>}
return false</p>
</dd>
</dl>
<p>}</p>
<p># 使用2个栈实现
/*
入队: 直接入栈a
出队: 栈b为空，则把栈a中全部数据出栈进入栈b，然后出栈b,不为空直接出栈b
<a href="#id187"><span class="problematic" id="id188">*</span></a>/
type MyQueue struct {</p>
<blockquote>
<div><p>a, b <a href="#id189"><span class="problematic" id="id190">*</span></a>Stack</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func Constructor() MyQueue {</dt><dd><dl class="simple">
<dt>return MyQueue{</dt><dd><p>a: NewStack(),
b: NewStack(),</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>func (m <a href="#id191"><span class="problematic" id="id192">*</span></a>MyQueue) Push(x int) {</dt><dd><p>m.a.Push(x)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func (m <a href="#id193"><span class="problematic" id="id194">*</span></a>MyQueue) Pop() int {</dt><dd><dl>
<dt>if m.b.Len() == 0 {</dt><dd><dl class="simple">
<dt>for m.a.Len() &gt; 0 {</dt><dd><p>m.b.Push(m.a.Pop())</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
return m.b.Pop()</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>func (m <a href="#id195"><span class="problematic" id="id196">*</span></a>MyQueue) Peek() int {</dt><dd><p>res := m.Pop()
m.b.Push(res)
return res</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>func (m <a href="#id197"><span class="problematic" id="id198">*</span></a>MyQueue) Empty() bool {</dt><dd><p>return m.a.Len() == 0 &amp;&amp; m.b.Len() == 0</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>type Stack struct {</dt><dd><p>nums []int</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func NewStack() <a href="#id199"><span class="problematic" id="id200">*</span></a>Stack {</dt><dd><dl class="simple">
<dt>return &amp;Stack{</dt><dd><p>nums: []int{},</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>func (s <a href="#id201"><span class="problematic" id="id202">*</span></a>Stack) Push(n int) {</dt><dd><p>s.nums = append(s.nums, n)</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>func (s <a href="#id203"><span class="problematic" id="id204">*</span></a>Stack) Pop() int {</dt><dd><p>res := s.nums[len(s.nums)-1]
s.nums = s.nums[:len(s.nums)-1]
return res</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>func (s <a href="#id205"><span class="problematic" id="id206">*</span></a>Stack) Len() int {</dt><dd><p>return len(s.nums)</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>func (s <a href="#id207"><span class="problematic" id="id208">*</span></a>Stack) IsEmpty() bool {</dt><dd><p>return s.Len() == 0</p>
</dd>
</dl>
<p>}</p>
<p># 使用2个切片实现
type MyQueue struct {</p>
<blockquote>
<div><p>a []int
b []int</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>func Constructor() MyQueue {</dt><dd><p>return MyQueue{}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>func (m <a href="#id209"><span class="problematic" id="id210">*</span></a>MyQueue) Push(x int) {</dt><dd><p>m.a = append(m.a, x)</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>func (m <a href="#id211"><span class="problematic" id="id212">*</span></a>MyQueue) Pop() int {</dt><dd><p>m.Peek()
temp := m.b[len(m.b)-1]
m.b = m.b[:len(m.b)-1]
return temp</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>func (m <a href="#id213"><span class="problematic" id="id214">*</span></a>MyQueue) Peek() int {</dt><dd><dl>
<dt>if len(m.b) == 0 {</dt><dd><dl class="simple">
<dt>for len(m.a) &gt; 0 {</dt><dd><p>m.b = append(m.b, m.a[len(m.a)-1])
m.a = m.a[:len(m.a)-1]</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
if len(m.b) == 0 {</p>
<blockquote>
<div><p>return -1</p>
</div></blockquote>
<p>}
return m.b[len(m.b)-1]</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>func (m <a href="#id215"><span class="problematic" id="id216">*</span></a>MyQueue) Empty() bool {</dt><dd><p>return len(m.a) == 0 &amp;&amp; len(m.b) == 0</p>
</dd>
</dl>
</div>
<div class="section" id="id217">
<h1>}<a class="headerlink" href="#id217" title="永久链接至标题">¶</a></h1>
<p>## 234.回文链表(4)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">请判断一个链表是否为回文链表。</span>
<span class="pre">示例</span> <span class="pre">1:输入:</span> <span class="pre">1-&gt;2</span> <span class="pre">输出:</span> <span class="pre">false</span>
<span class="pre">示例</span> <span class="pre">2:输入:</span> <span class="pre">1-&gt;2-&gt;2-&gt;1</span> <span class="pre">输出:</span> <span class="pre">true</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路             | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —————- | ———- | ———- |</div>
<div class="line">01   | 哈希辅助遍历     | O(n)       | O(n)       |</div>
<div class="line">02   | 快慢指针反转链表 | O(n)       | O(1)       |</div>
<div class="line">03   | 栈辅助           | O(n)       | O(n)       |</div>
<div class="line">04   | 递归             | O(n)       | O(n)       |</div>
</div>
<p><a href="#id218"><span class="problematic" id="id219">``</span></a><a href="#id220"><span class="problematic" id="id221">`</span></a>go
func isPalindrome(head <a href="#id222"><span class="problematic" id="id223">*</span></a>ListNode) bool {</p>
<blockquote>
<div><p>m := make([]int, 0)
for head != nil {</p>
<blockquote>
<div><p>m = append(m, head.Val)
head = head.Next</p>
</div></blockquote>
<p>}
i, j := 0, len(m)-1
for i &lt; j {</p>
<blockquote>
<div><dl class="simple">
<dt>if m[i] != m[j] {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}
i++
j–</p>
</div></blockquote>
<p>}
return true</p>
</div></blockquote>
<p>}</p>
<p>#
func isPalindrome(head <a href="#id224"><span class="problematic" id="id225">*</span></a>ListNode) bool {</p>
<blockquote>
<div><p>fast, slow := head, head
for fast != nil &amp;&amp; fast.Next != nil {</p>
<blockquote>
<div><p>fast = fast.Next.Next
slow = slow.Next</p>
</div></blockquote>
<p>}
var pre <a href="#id226"><span class="problematic" id="id227">*</span></a>ListNode
cur := slow
for cur != nil{</p>
<blockquote>
<div><p>next := cur.Next
cur.Next = pre
pre = cur
cur = next</p>
</div></blockquote>
<p>}
for pre != nil{</p>
<blockquote>
<div><dl class="simple">
<dt>if head.Val != pre.Val{</dt><dd><p>return false</p>
</dd>
</dl>
<p>}
pre = pre.Next
head = head.Next</p>
</div></blockquote>
<p>}
return true</p>
</div></blockquote>
<p>}</p>
<p>#
func isPalindrome(head <a href="#id228"><span class="problematic" id="id229">*</span></a>ListNode) bool {</p>
<blockquote>
<div><p>m := make([]int, 0)
temp := head
for temp != nil {</p>
<blockquote>
<div><p>m = append(m, temp.Val)
temp = temp.Next</p>
</div></blockquote>
<p>}
for head != nil {</p>
<blockquote>
<div><p>val := m[len(m)-1]
m = m[:len(m)-1]
if head.Val != val {</p>
<blockquote>
<div><p>return false</p>
</div></blockquote>
<p>}
head = head.Next</p>
</div></blockquote>
<p>}
return true</p>
</div></blockquote>
<p>}</p>
<p>#
var p <a href="#id230"><span class="problematic" id="id231">*</span></a>ListNode
func isPalindrome(head <a href="#id232"><span class="problematic" id="id233">*</span></a>ListNode) bool {</p>
<blockquote>
<div><dl class="simple">
<dt>if head == nil{</dt><dd><p>return true</p>
</dd>
</dl>
<p>}
if p == nil{</p>
<blockquote>
<div><p>p = head</p>
</div></blockquote>
<p>}
if isPalindrome(head.Next) &amp;&amp; (p.Val == head.Val){</p>
<blockquote>
<div><p>p = p.Next
return true</p>
</div></blockquote>
<p>}
p = nil
return false</p>
</div></blockquote>
</div>
<div class="section" id="id234">
<h1>}<a class="headerlink" href="#id234" title="永久链接至标题">¶</a></h1>
<p>## 235.二叉搜索树的最近公共祖先(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id235"><span class="problematic" id="id236">``</span></a>`
给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，
满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p>
<p>示例 1:输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 输出: 6
解释: 节点 2 和节点 8 的最近公共祖先是 6。</p>
<p>示例 2:输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 输出: 2
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</p>
<dl class="simple">
<dt>说明:</dt><dd><p>所有节点的值都是唯一的。
p、q 为不同节点且均存在于给定的二叉搜索树中。</p>
</dd>
</dl>
<p><a href="#id237"><span class="problematic" id="id238">``</span></a><a href="#id239"><span class="problematic" id="id240">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路 | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —- | ———- | ———- |</div>
<div class="line">01   | 递归 | O(log(n))  | O(log(n))  |</div>
<div class="line">02   | 迭代 | O(log(n))  | O(1)       |</div>
</div>
<p><a href="#id241"><span class="problematic" id="id242">``</span></a><a href="#id243"><span class="problematic" id="id244">`</span></a>go
func lowestCommonAncestor(root, p, q <a href="#id245"><span class="problematic" id="id246">*</span></a>TreeNode) <a href="#id247"><span class="problematic" id="id248">*</span></a>TreeNode {</p>
<blockquote>
<div><dl class="simple">
<dt>if p.Val &gt; root.Val &amp;&amp; q.Val &gt; root.Val{</dt><dd><p>return lowestCommonAncestor(root.Right, p, q)</p>
</dd>
<dt>}else if p.Val &lt; root.Val &amp;&amp; q.Val &lt; root.Val{</dt><dd><p>return lowestCommonAncestor(root.Left, p, q)</p>
</dd>
<dt>}else {</dt><dd><p>return root</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>#
func lowestCommonAncestor(root, p, q <a href="#id249"><span class="problematic" id="id250">*</span></a>TreeNode) <a href="#id251"><span class="problematic" id="id252">*</span></a>TreeNode {</p>
<blockquote>
<div><dl>
<dt>for root != nil{</dt><dd><dl class="simple">
<dt>if p.Val &gt; root.Val &amp;&amp; q.Val &gt; root.Val{</dt><dd><p>root = root.Right</p>
</dd>
<dt>}else if p.Val &lt; root.Val &amp;&amp; q.Val &lt; root.Val{</dt><dd><p>root = root.Left</p>
</dd>
<dt>}else {</dt><dd><p>return root</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
return nil</p>
</div></blockquote>
</div>
<div class="section" id="id253">
<h1>}<a class="headerlink" href="#id253" title="永久链接至标题">¶</a></h1>
<p>## 237.删除链表中的节点(1)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id254"><span class="problematic" id="id255">``</span></a>`
请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。
现有一个链表 – head = [4,5,1,9]，它可以表示为:</p>
<p>示例 1: 输入: head = [4,5,1,9], node = 5  输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</p>
<p>示例 2:输入: head = [4,5,1,9], node = 1 输出: [4,5,9]
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</p>
<dl class="simple">
<dt>说明:</dt><dd><p>链表至少包含两个节点。
链表中所有节点的值都是唯一的。
给定的节点为非末尾节点并且一定是链表中的一个有效节点。
不要从你的函数中返回任何结果。</p>
</dd>
</dl>
<p><a href="#id256"><span class="problematic" id="id257">``</span></a><a href="#id258"><span class="problematic" id="id259">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路                       | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ————————– | ———- | ———- |</div>
<div class="line">01   | 把当前节点替换成下一个节点 | O(1)       | O(1)       |</div>
</div>
<p><a href="#id260"><span class="problematic" id="id261">``</span></a><a href="#id262"><span class="problematic" id="id263">`</span></a>go
func deleteNode(node <a href="#id264"><span class="problematic" id="id265">*</span></a>ListNode) {</p>
<blockquote>
<div><p>node.Val = node.Next.Val
node.Next = node.Next.Next</p>
</div></blockquote>
</div>
<div class="section" id="id266">
<h1>}<a class="headerlink" href="#id266" title="永久链接至标题">¶</a></h1>
<p>## 242.有效的字母异位词(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id267"><span class="problematic" id="id268">``</span></a>`
给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。
示例 1:输入: s = “anagram”, t = “nagaram”输出: true
示例 2:输入: s = “rat”, t = “car”输出: false</p>
<p>说明:你可以假设字符串只包含小写字母。
进阶:如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？
<a href="#id269"><span class="problematic" id="id270">``</span></a><a href="#id271"><span class="problematic" id="id272">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路     | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ——– | ———- | ———- |</div>
<div class="line">01   | 哈希辅助 | O(n)       | O(1)       |</div>
<div class="line">02   | 排序比较 | O(nlog(n)) | O(n)       |</div>
</div>
<p><a href="#id273"><span class="problematic" id="id274">``</span></a><a href="#id275"><span class="problematic" id="id276">`</span></a>go
func isAnagram(s string, t string) bool {</p>
<blockquote>
<div><dl class="simple">
<dt>if len(s) != len(t) {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}</p>
<p>sr := []rune(s)
tr := []rune(t)</p>
<p>rec := make(map[rune]int, len(sr))
for i := range sr {</p>
<blockquote>
<div><p>rec[sr[i]]++
rec[tr[i]]–</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>for _, n := range rec {</dt><dd><dl class="simple">
<dt>if n != 0 {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
return true</p>
</div></blockquote>
<p>}</p>
<p>#
func isAnagram(s string, t string) bool {</p>
<blockquote>
<div><dl class="simple">
<dt>if len(s) != len(t) {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}
sArr := make([]int, len(s))
tArr := make([]int, len(t))
for i := 0; i &lt; len(s); i++ {</p>
<blockquote>
<div><p>sArr[i] = int(s[i] - ‘a’)
tArr[i] = int(t[i] - ‘a’)</p>
</div></blockquote>
<p>}
sort.Ints(sArr)
sort.Ints(tArr)
for i := 0; i &lt; len(s); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if sArr[i] != tArr[i] {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return true</p>
</div></blockquote>
</div>
<div class="section" id="id277">
<h1>}<a class="headerlink" href="#id277" title="永久链接至标题">¶</a></h1>
<p>## 257.二叉树的所有路径(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id278"><span class="problematic" id="id279">``</span></a>`
给定一个二叉树，返回所有从根节点到叶子节点的路径。
说明: 叶子节点是指没有子节点的节点。
示例:
输入:</p>
<blockquote>
<div><blockquote>
<div><p>1</p>
</div></blockquote>
<p>/   </p>
</div></blockquote>
<dl class="simple">
<dt>2     3</dt><dd><dl class="simple">
<dt></dt><dd><p>5</p>
</dd>
</dl>
</dd>
</dl>
<p>输出: [“1-&gt;2-&gt;5”, “1-&gt;3”]
解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3
<a href="#id280"><span class="problematic" id="id281">``</span></a><a href="#id282"><span class="problematic" id="id283">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路 | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —- | ———- | ———- |</div>
<div class="line">01   | 递归 | O(n)       | O(log(n))  |</div>
<div class="line">02   | 迭代 | O(n)       | O(n)       |</div>
</div>
<p><a href="#id284"><span class="problematic" id="id285">``</span></a><a href="#id286"><span class="problematic" id="id287">`</span></a>go
#
func binaryTreePaths(root <a href="#id288"><span class="problematic" id="id289">*</span></a>TreeNode) []string {</p>
<blockquote>
<div><dl class="simple">
<dt>if root == nil {</dt><dd><p>return nil</p>
</dd>
</dl>
<p>}</p>
<p>res := make([]string, 0)
var dfs func(string, <a href="#id290"><span class="problematic" id="id291">*</span></a>TreeNode)
dfs = func(pre string, root <a href="#id292"><span class="problematic" id="id293">*</span></a>TreeNode) {</p>
<blockquote>
<div><dl class="simple">
<dt>if pre == “” {</dt><dd><p>pre = strconv.Itoa(root.Val)</p>
</dd>
<dt>} else {</dt><dd><p>pre += “-&gt;” + strconv.Itoa(root.Val)</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>if root.Left != nil {</dt><dd><p>dfs(pre, root.Left)</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>if root.Right != nil {</dt><dd><p>dfs(pre, root.Right)</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>if root.Left == nil &amp;&amp; root.Right == nil {</dt><dd><p>res = append(res, pre)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>dfs(“”, root)
return res</p>
</div></blockquote>
<p>}</p>
<p>#
func binaryTreePaths(root <a href="#id294"><span class="problematic" id="id295">*</span></a>TreeNode) []string {</p>
<blockquote>
<div><p>res := make([]string, 0)
if root == nil {</p>
<blockquote>
<div><p>return res</p>
</div></blockquote>
<p>}
var queue []*TreeNode
var stringQueue []string
queue = append(queue, root)
stringQueue = append(stringQueue, strconv.Itoa(root.Val))
for len(queue) &gt; 0 {</p>
<blockquote>
<div><p>node := queue[0]
path := stringQueue[0]
queue = queue[1:]
stringQueue = stringQueue[1:]
if node.Left == nil &amp;&amp; node.Right == nil {</p>
<blockquote>
<div><p>res = append(res, path)</p>
</div></blockquote>
<p>}
if node.Left != nil {</p>
<blockquote>
<div><p>queue = append(queue, node.Left)
stringQueue = append(stringQueue, path+”-&gt;”+strconv.Itoa(node.Left.Val))</p>
</div></blockquote>
<p>}
if node.Right != nil {</p>
<blockquote>
<div><p>queue = append(queue, node.Right)
stringQueue = append(stringQueue, path+”-&gt;”+strconv.Itoa(node.Right.Val))</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
</div>
<div class="section" id="id296">
<h1>}<a class="headerlink" href="#id296" title="永久链接至标题">¶</a></h1>
<p>## 258.各位相加(4)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">给定一个非负整数</span> <span class="pre">num，反复将各个位上的数字相加，直到结果为一位数。</span>
<span class="pre">示例:</span> <span class="pre">输入:</span> <span class="pre">38</span> <span class="pre">输出:</span> <span class="pre">2</span>
<span class="pre">解释:</span> <span class="pre">各位相加的过程为：3</span> <span class="pre">+</span> <span class="pre">8</span> <span class="pre">=</span> <span class="pre">11,</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">=</span> <span class="pre">2。</span> <span class="pre">由于</span> <span class="pre">2</span> <span class="pre">是一位数，所以返回</span> <span class="pre">2。</span>
<span class="pre">进阶:</span>
<span class="pre">你可以不使用循环或者递归，且在</span> <span class="pre">O(1)</span> <span class="pre">时间复杂度内解决这个问题吗？</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路            | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ————— | ———- | ———- |</div>
<div class="line">01   | 找规律1         | O(1)       | O(1)       |</div>
<div class="line">02   | 找规律2         | O(1)       | O(1)       |</div>
<div class="line">03   | 模拟计算-字符串 | O(log(n))  | O(1)       |</div>
<div class="line">04   | 模拟计算-递归   | O(log(n))  | O(log(n))  |</div>
</div>
<p><a href="#id297"><span class="problematic" id="id298">``</span></a><a href="#id299"><span class="problematic" id="id300">`</span></a>go
# 找规律1
func addDigits(num int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>if num &lt; 10 {</dt><dd><p>return num</p>
</dd>
</dl>
<p>}
if num%9 == 0 {</p>
<blockquote>
<div><p>return 9</p>
</div></blockquote>
<p>}
return num % 9</p>
</div></blockquote>
<p>}</p>
<p># 找规律2
func addDigits(num int) int {</p>
<blockquote>
<div><p>return (num-1)%9 + 1</p>
</div></blockquote>
<p>}</p>
<p># 模拟计算-字符串
func addDigits(num int) int {</p>
<blockquote>
<div><dl class="simple">
<dt>for num &gt;= 10 {</dt><dd><p>num = sumDigits(num)</p>
</dd>
</dl>
<p>}
return num</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func sumDigits(num int) int {</dt><dd><p>sumVal := 0
str := strconv.Itoa(num)
for i := range str {</p>
<blockquote>
<div><p>sumVal = sumVal + int(str[i]-‘0’)</p>
</div></blockquote>
<p>}
return sumVal</p>
</dd>
</dl>
<p>}</p>
<p># 模拟计算-递归
func addDigits(num int) int {</p>
<blockquote>
<div><p>sum := 0
for num != 0 {</p>
<blockquote>
<div><p>sum = sum + num%10
num = num / 10</p>
</div></blockquote>
<p>}
if sum/10 == 0 {</p>
<blockquote>
<div><p>return sum</p>
</div></blockquote>
<p>}
return addDigits(sum)</p>
</div></blockquote>
</div>
<div class="section" id="id301">
<h1>}<a class="headerlink" href="#id301" title="永久链接至标题">¶</a></h1>
<p>## 263.丑数(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id302"><span class="problematic" id="id303">``</span></a>`
丑数就是只包含质因数 2, 3, 5 的正整数。</p>
<p>示例 1:输入: 6 输出: true 解释: 6 = 2 × 3
示例 2:输入: 8 输出: true 解释: 8 = 2 × 2 × 2
示例 3: 输入: 14 输出: false  解释: 14 不是丑数，因为它包含了另外一个质因数 7。</p>
<p>说明：
1 是丑数。
输入不会超过 32 位有符号整数的范围: [−231,  231 − 1]。
<a href="#id304"><span class="problematic" id="id305">``</span></a><a href="#id306"><span class="problematic" id="id307">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路 | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —- | ———- | ———- |</div>
<div class="line">01   | 递归 | O(log(n))  | O(log(n))  |</div>
<div class="line">02   | 迭代 | O(log(n))  | O(1)       |</div>
</div>
<p><a href="#id308"><span class="problematic" id="id309">``</span></a><a href="#id310"><span class="problematic" id="id311">`</span></a>go
func isUgly(num int) bool {</p>
<blockquote>
<div><dl class="simple">
<dt>if num &lt;= 0 {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}
if num &lt;= 6 {</p>
<blockquote>
<div><p>return true</p>
</div></blockquote>
<p>}
if num%2 == 0 {</p>
<blockquote>
<div><p>return isUgly(num / 2)</p>
</div></blockquote>
<p>}
if num%3 == 0 {</p>
<blockquote>
<div><p>return isUgly(num / 3)</p>
</div></blockquote>
<p>}
if num%5 == 0 {</p>
<blockquote>
<div><p>return isUgly(num / 5)</p>
</div></blockquote>
<p>}
return false</p>
</div></blockquote>
<p>}</p>
<p># 迭代
func isUgly(num int) bool {</p>
<blockquote>
<div><dl class="simple">
<dt>if num &lt;= 0 {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}
for num != 1 {</p>
<blockquote>
<div><dl class="simple">
<dt>if num%2 == 0 {</dt><dd><p>num = num / 2</p>
</dd>
<dt>} else if num%3 == 0 {</dt><dd><p>num = num / 3</p>
</dd>
<dt>} else if num%5 == 0 {</dt><dd><p>num = num / 5</p>
</dd>
<dt>} else {</dt><dd><p>return false</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return true</p>
</div></blockquote>
</div>
<div class="section" id="id312">
<h1>}<a class="headerlink" href="#id312" title="永久链接至标题">¶</a></h1>
<p>## 268.缺失数字(5)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id313"><span class="problematic" id="id314">``</span></a>`
给定一个包含 0, 1, 2, …, n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。</p>
<p>示例 1:输入: [3,0,1]输出: 2
示例 2:输入: [9,6,4,2,3,5,7,0,1] 输出: 8</p>
<p>说明:你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现?
<a href="#id315"><span class="problematic" id="id316">``</span></a><a href="#id317"><span class="problematic" id="id318">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路               | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —————— | ———- | ———- |</div>
<div class="line">01   | 数学计算           | O(n)       | O(1)       |</div>
<div class="line">02   | 排序遍历           | )          | O(1)       |</div>
<div class="line">03   | 异或-位运算        | O(n)       | O(1)       |</div>
<div class="line">04   | 交换排序(就地排序) | O(n)       | O(1)       |</div>
<div class="line">05   | 哈希辅助           | O(n)       | O(n)       |</div>
</div>
<p><a href="#id319"><span class="problematic" id="id320">``</span></a><a href="#id321"><span class="problematic" id="id322">`</span></a>go
func missingNumber(nums []int) int {</p>
<blockquote>
<div><p>n := len(nums)
sum := n * (n + 1) / 2
for i := 0; i &lt; n; i++ {</p>
<blockquote>
<div><p>sum = sum - nums[i]</p>
</div></blockquote>
<p>}
return sum</p>
</div></blockquote>
<p>}</p>
<p>#
func missingNumber(nums []int) int {</p>
<blockquote>
<div><p>sort.Ints(nums)
for i := 0; i &lt; len(nums); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if nums[i] != i {</dt><dd><p>return i</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return len(nums)</p>
</div></blockquote>
<p>}</p>
<p>#
func missingNumber(nums []int) int {</p>
<blockquote>
<div><p>res := 0
for i := 0; i &lt; len(nums); i++ {</p>
<blockquote>
<div><p>res = res ^ (i+1) ^ nums[i]</p>
</div></blockquote>
<p>}
return res</p>
</div></blockquote>
<p>}</p>
<p>#
func missingNumber(nums []int) int {</p>
<blockquote>
<div><p>n := len(nums)
index := n
for i := 0; i &lt; n; {</p>
<blockquote>
<div><dl class="simple">
<dt>if nums[i] == n{</dt><dd><p>index = i
i++
continue</p>
</dd>
</dl>
<p>}
if i == nums[i]{</p>
<blockquote>
<div><p>i++
continue</p>
</div></blockquote>
<p>}
nums[i], nums[nums[i]] = nums[nums[i]], nums[i]</p>
</div></blockquote>
<p>}
return index</p>
</div></blockquote>
<p>}</p>
<p>#
func missingNumber(nums []int) int {</p>
<blockquote>
<div><p>n := len(nums)
// 假设index=n
index := n
for i := 0; i &lt; n; {</p>
<blockquote>
<div><p>// nums[i]到指定位置i后往后走
if i == nums[i] {</p>
<blockquote>
<div><p>i++
continue</p>
</div></blockquote>
<p>}
if nums[i] == n {</p>
<blockquote>
<div><p>index = i
i++
continue</p>
</div></blockquote>
<p>}
nums[i], nums[nums[i]] = nums[nums[i]], nums[i]</p>
</div></blockquote>
<p>}
return index</p>
</div></blockquote>
<p>}</p>
<p>#
func missingNumber(nums []int) int {</p>
<blockquote>
<div><p>m := make(map[int]bool)
for i := range nums{</p>
<blockquote>
<div><p>m[nums[i]] = true</p>
</div></blockquote>
<p>}
for i := 0; i &lt;= len(nums); i++{</p>
<blockquote>
<div><dl class="simple">
<dt>if m[i] == false{</dt><dd><p>return i</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return 0</p>
</div></blockquote>
</div>
<div class="section" id="id323">
<h1>}<a class="headerlink" href="#id323" title="永久链接至标题">¶</a></h1>
<p>## 278.第一个错误的版本(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id324"><span class="problematic" id="id325">``</span></a>`
你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。
由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。
假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。
你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。
实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p>
<p>示例:
给定 n = 5，并且 version = 4 是第一个错误的版本。</p>
<p>调用 isBadVersion(3) -&gt; false
调用 isBadVersion(5) -&gt; true
调用 isBadVersion(4) -&gt; true
所以，4 是第一个错误的版本。
<a href="#id326"><span class="problematic" id="id327">``</span></a><a href="#id328"><span class="problematic" id="id329">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路     | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ——– | ———- | ———- |</div>
<div class="line">01   | 二分查找 | O(log(n))  | O(1)       |</div>
<div class="line">02   | 二分查找 | O(log(n))  | O(1)       |</div>
</div>
<p><a href="#id330"><span class="problematic" id="id331">``</span></a><a href="#id332"><span class="problematic" id="id333">`</span></a>go
func firstBadVersion(n int) int {</p>
<blockquote>
<div><p>low := 1
high := n
for low &lt;= high {</p>
<blockquote>
<div><p>mid := low + (high-low)/2
if isBadVersion(mid) == false {</p>
<blockquote>
<div><p>low = mid + 1</p>
</div></blockquote>
<dl class="simple">
<dt>} else if isBadVersion(mid) == true &amp;&amp; isBadVersion(mid-1) == true {</dt><dd><p>high = mid - 1</p>
</dd>
<dt>} else if isBadVersion(mid) == true &amp;&amp; isBadVersion(mid-1) == false {</dt><dd><p>return mid</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return -1</p>
</div></blockquote>
<p>}</p>
<p>#
func firstBadVersion(n int) int {</p>
<blockquote>
<div><p>low := 1
high := n
for low &lt; high {</p>
<blockquote>
<div><p>mid := low + (high-low)/2
if isBadVersion(mid) {</p>
<blockquote>
<div><p>high = mid</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>low = mid + 1</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return low</p>
</div></blockquote>
</div>
<div class="section" id="id334">
<h1>}<a class="headerlink" href="#id334" title="永久链接至标题">¶</a></h1>
<p>## 283.移动零(3)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id335"><span class="problematic" id="id336">``</span></a>`
给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
示例:
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
说明:</p>
<blockquote>
<div><p>必须在原数组上操作，不能拷贝额外的数组。
尽量减少操作次数。</p>
</div></blockquote>
<p><a href="#id337"><span class="problematic" id="id338">``</span></a><a href="#id339"><span class="problematic" id="id340">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路     | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ——– | ———- | ———- |</div>
<div class="line">01   | 前移补零 | O(n)       | O(1)       |</div>
<div class="line">02   | 遇零交换 | O(n)       | O(1)       |</div>
<div class="line">03   | 数组辅助 | O(n)       | O(n)       |</div>
</div>
<p><a href="#id341"><span class="problematic" id="id342">``</span></a><a href="#id343"><span class="problematic" id="id344">`</span></a>go
func moveZeroes(nums []int) {</p>
<blockquote>
<div><p>length := 0
for i := 0; i &lt; len(nums); i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if nums[i] != 0 {</dt><dd><p>nums[length] = nums[i]
length++</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>for i := length; i &lt; len(nums); i++ {</dt><dd><p>nums[i] = 0</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>#
func moveZeroes(nums []int) {</p>
<blockquote>
<div><p>length := 0
for i:= 0; i &lt; len(nums); i++ {</p>
<blockquote>
<div><p>nums[i], nums[length] = nums[length], nums[i]
if nums[length] != 0 {</p>
<blockquote>
<div><p>length++</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>#
func moveZeroes(nums []int) {</p>
<blockquote>
<div><p>arr := make([]int,len(nums))
count := 0
for i := range nums{</p>
<blockquote>
<div><dl class="simple">
<dt>if nums[i] != 0{</dt><dd><p>arr[count] = nums[i]
count++</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>copy(nums, arr)</p>
</div></blockquote>
</div>
<div class="section" id="id345">
<h1>}<a class="headerlink" href="#id345" title="永久链接至标题">¶</a></h1>
<p>## 290.单词规律(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id346"><span class="problematic" id="id347">``</span></a>`
给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。</p>
<p>这里的 遵循 指完全匹配，
例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。</p>
<p>示例1:输入: pattern = “abba”, str = “dog cat cat dog”输出: true
示例 2:输入:pattern = “abba”, str = “dog cat cat fish”输出: false
示例 3:输入: pattern = “aaaa”, str = “dog cat cat dog”输出: false
示例 4:输入: pattern = “abba”, str = “dog dog dog dog” 输出: false</p>
<p>说明:
你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母。
<a href="#id348"><span class="problematic" id="id349">``</span></a><a href="#id350"><span class="problematic" id="id351">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路           | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ————– | ———- | ———- |</div>
<div class="line">01   | 双哈希相互映射 | O(n)       | O(n)       |</div>
<div class="line">02   | 单哈希相互映射 | O(n)       | O(n)       |</div>
</div>
<p><a href="#id352"><span class="problematic" id="id353">``</span></a><a href="#id354"><span class="problematic" id="id355">`</span></a>go
func wordPattern(pattern string, str string) bool {</p>
<blockquote>
<div><p>pa := strings.Split(pattern, “”)
sa := strings.Split(str, ” “)
if len(pa) != len(sa) {</p>
<blockquote>
<div><p>return false</p>
</div></blockquote>
<p>}
length := len(pa)
pMap := make(map[string]string, length)
sMap := make(map[string]string, length)</p>
<dl>
<dt>for i := 0; i &lt; length; i++ {</dt><dd><p>pStr, ok := pMap[pa[i]]
sStr, ok1 := sMap[sa[i]]</p>
<dl class="simple">
<dt>if (ok &amp;&amp; pStr != sa[i]) || (ok1 &amp;&amp; sStr != pa[i]) {</dt><dd><p>return false</p>
</dd>
<dt>} else {</dt><dd><p>pMap[pa[i]] = sa[i]
sMap[sa[i]] = pa[i]</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
return true</p>
</div></blockquote>
<p>}</p>
<p>#
func wordPattern(pattern string, str string) bool {</p>
<blockquote>
<div><p>pa := strings.Split(pattern, “”)
sa := strings.Split(str, ” “)
if len(pa) != len(sa) {</p>
<blockquote>
<div><p>return false</p>
</div></blockquote>
<p>}
return isMatch(pa, sa) &amp;&amp; isMatch(sa, pa)</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>func isMatch(pa, sa []string) bool {</dt><dd><p>length := len(pa)
m := make(map[string]string, length)
for i := 0; i &lt; length; i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if w, ok := m[pa[i]]; ok &amp;&amp; w != sa[i] {</dt><dd><p>return false</p>
</dd>
<dt>} else {</dt><dd><p>m[pa[i]] = sa[i]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return true</p>
</dd>
</dl>
</div>
<div class="section" id="id356">
<h1>}<a class="headerlink" href="#id356" title="永久链接至标题">¶</a></h1>
<p>## 292.Nim 游戏(1)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id357"><span class="problematic" id="id358">``</span></a>`
你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。
拿掉最后一块石头的人就是获胜者。你作为先手。
你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。</p>
<p>示例:
输入: 4
输出: false
解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛；</p>
<blockquote>
<div><p>因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。</p>
</div></blockquote>
<p><a href="#id359"><span class="problematic" id="id360">``</span></a><a href="#id361"><span class="problematic" id="id362">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路 | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | —- | ———- | ———- |</div>
<div class="line">01   | 推理 | O(1)       | O(1)       |</div>
</div>
<p><a href="#id363"><span class="problematic" id="id364">``</span></a><a href="#id365"><span class="problematic" id="id366">`</span></a>go
func canWinNim(n int) bool {</p>
<blockquote>
<div><p>// return n&amp;3 != 0
return n%4 != 0</p>
</div></blockquote>
</div>
<div class="section" id="id367">
<h1>}<a class="headerlink" href="#id367" title="永久链接至标题">¶</a></h1>
<p>## 299.猜数字游戏(2)</p>
<ul class="simple">
<li><p>题目</p></li>
</ul>
<p><a href="#id368"><span class="problematic" id="id369">``</span></a>`
你正在和你的朋友玩 猜数字（Bulls and Cows）游戏：你写下一个数字让你的朋友猜。
每次他猜测后，你给他一个提示，告诉他有多少位数字和确切位置都猜对了（称为“Bulls”, 公牛），
有多少位数字猜对了但是位置不对（称为“Cows”, 奶牛）。
你的朋友将会根据提示继续猜，直到猜出秘密数字。</p>
<p>请写出一个根据秘密数字和朋友的猜测数返回提示的函数，用 A 表示公牛，用 B 表示奶牛。
请注意秘密数字和朋友的猜测数都可能含有重复数字。</p>
<p>示例 1:输入: secret = “1807”, guess = “7810”输出: “1A3B”
解释: 1 公牛和 3 奶牛。公牛是 8，奶牛是 0, 1 和 7。</p>
<p>示例 2:输入: secret = “1123”, guess = “0111”输出: “1A1B”
解释: 朋友猜测数中的第一个 1 是公牛，第二个或第三个 1 可被视为奶牛。</p>
<p>说明: 你可以假设秘密数字和朋友的猜测数都只包含数字，并且它们的长度永远相等。
<a href="#id370"><span class="problematic" id="id371">``</span></a><a href="#id372"><span class="problematic" id="id373">`</span></a></p>
<ul class="simple">
<li><p>解题思路</p></li>
</ul>
<div class="line-block">
<div class="line">No.  | 思路       | 时间复杂度 | 空间复杂度 |</div>
<div class="line">—- | ———- | ———- | ———- |</div>
<div class="line">01   | 双哈希辅助 | O(n)       | O(1)       |</div>
<div class="line">02   | 单哈希辅助 | O(n)       | O(1)       |</div>
</div>
<p><a href="#id374"><span class="problematic" id="id375">``</span></a><a href="#id376"><span class="problematic" id="id377">`</span></a>go
func getHint(secret string, guess string) string {</p>
<blockquote>
<div><p>length := len(secret)
right := 0
wrongLoc := 0
m := make(map[byte]int)
n := make(map[byte]int)
for i := 0; i &lt; length; i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if secret[i] == guess[i] {</dt><dd><p>right++</p>
</dd>
<dt>} else {</dt><dd><p>m[secret[i]]++
n[guess[i]]++</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
for i := range m {</p>
<blockquote>
<div><dl class="simple">
<dt>if m[i] &lt; n[i] {</dt><dd><p>wrongLoc = wrongLoc + m[i]</p>
</dd>
<dt>} else {</dt><dd><p>wrongLoc = wrongLoc + n[i]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>return fmt.Sprintf(“%dA%dB”, right, wrongLoc)</p>
</div></blockquote>
<p>}</p>
<p>#
func getHint(secret string, guess string) string {</p>
<blockquote>
<div><p>length := len(secret)
right := 0
wrongNum := 0
m := make(map[int]int)
for i := 0; i &lt; length; i++ {</p>
<blockquote>
<div><dl class="simple">
<dt>if secret[i] == guess[i] {</dt><dd><p>right++</p>
</dd>
</dl>
<p>}
m[int(secret[i]-‘0’)]++
m[int(guess[i]-‘0’)]–</p>
</div></blockquote>
<p>}
for i := range m {</p>
<blockquote>
<div><dl class="simple">
<dt>if m[i] &gt; 0{</dt><dd><p>wrongNum = wrongNum + m[i]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
// wrongLoc = 总数 - 猜对的数 - 猜错的数
wrongLoc := length - right - wrongNum
return fmt.Sprintf(“%dA%dB”, right, wrongLoc)</p>
</div></blockquote>
</div>
<div class="section" id="id378">
<h1>}<a class="headerlink" href="#id378" title="永久链接至标题">¶</a></h1>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="0301-0400.html" class="btn btn-neutral float-right" title="}" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="0101-0200.html" class="btn btn-neutral float-left" title="}" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, willshang

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>