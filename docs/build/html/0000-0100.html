

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh-CN" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh-CN" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>0001-0100 &mdash; go-leetcode v1.0.0 文档</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script type="text/javascript" src="_static/translations.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" />
    <link rel="next" title="0101-0200" href="0101-0200.html" />
    <link rel="prev" title="Welcome to go-leetcode’s documentation!" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> go-leetcode
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">0001-0100</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id2">1. 两数之和</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id3">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">解答思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id5">7. 整数反转</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id6">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id7">解答思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id8">9.回文数</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id9">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id10">解答思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id11">13.罗马数字转整数</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id12">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id13">解答思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id14">14.最长公共前缀</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id15">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id16">解答思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id17">20.有效的括号</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id18">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id19">解题思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id20">21.合并两个有序链表</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id21">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id22">解题思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id23">26.删除排序数组中的重复项</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id24">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id25">解题思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id26">27.移除元素</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id27">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id28">解题思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#strstr">28.实现strStr()</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id29">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id30">解题思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id31">35.搜索插入位置</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id32">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id33">解题思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id34">38.报数</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id35">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id36">解题思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id37">53.最大子序和</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id38">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id39">解题思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id40">58.最后一个单词的长度</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id41">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id42">解题思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id43">66.加一</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id44">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id45">解题思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id46">67.二进制求和</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id47">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id48">解题思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#x">69.x的平方跟</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id49">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id50">解题思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id51">70.爬楼梯</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id52">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id53">解题思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id54">83.删除排序链表中的重复元素</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id55">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id56">解题思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id57">88.合并两个有序数组</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id58">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id59">解题思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id60">100.相同的树</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id61">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id62">解题思路</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="0101-0200.html">0101-0200</a></li>
<li class="toctree-l1"><a class="reference internal" href="0201-0300.html">0201-0300</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">go-leetcode</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>0001-0100</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/0000-0100.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>0001-0100<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<p>[TOC]</p>
<div class="section" id="id2">
<h2>1. 两数之和<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<div class="section" id="id3">
<h3>题目<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个整数数组 nums 和一个目标值 target，
请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

示例:
给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h3>解答思路<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<p>| No.      | 思路                | 时间复杂度 | 空间复杂度 |
| ——– | ——————- | ———- | ———- |
| 01       | 暴力法: 2层循环遍历 | O(n^2)     | O(1)       |
| 02       | 两遍哈希遍历        | O(n)       | O(n)       |
| 03(最优) | 一遍哈希遍历        | O(n)       | O(n)       |</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span># 暴力法: 2层循环遍历
func twoSum(nums []int, target int) []int {
	for i := 0; i &lt; len(nums); i++ {
		for j := i + 1; j &lt; len(nums); j++ {
			if nums[i]+nums[j] == target {
				return []int{i, j}
			}
		}
	}
	return []int{}
}

# 两遍哈希遍历
func twoSum(nums []int, target int) []int {
	m := make(map[int]int,len(nums))
	for k, v := range nums{
		m[v] = k
	}

	for i := 0; i &lt; len(nums); i++{
		b := target - nums[i]
		if num, ok := m[b]; ok &amp;&amp; num != i{
			return []int{i,m[b]}
		}
	}
	return []int{}
}

# 一遍哈希遍历
func twoSum(nums []int, target int) []int {
	m := make(map[int]int, len(nums))
	for i, b := range nums {
		if j, ok := m[target-b]; ok {
			return []int{j, i}
		}
		m[b] = i
	}
	return nil
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="id5">
<h2>7. 整数反转<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<div class="section" id="id6">
<h3>题目<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。

示例 1:
输入: 123
输出: 321

示例 2:
输入: -123
输出: -321

示例 3:
输入: 120
输出: 21

注意:假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31,  2^31 − 1]。
请根据这个假设，如果反转后整数溢出那么就返回 0。
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h3>解答思路<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h3>
<p>| No.      | 思路                                                  | 时间复杂度 | 空间复杂度 |
| ——– | —————————————————– | ———- | ———- |
| 01       | 使用符号标记，转成正数，循环得到%10的余数，再加上符号 | O(log(x))  | O(1)       |
| 02(最优) | 对x进行逐个%10取个位，一旦溢出，直接跳出循环          | O(log(x))  | O(1)       |</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 使用符号标记，转成正数，循环得到%10的余数，再加上符号</span>
<span class="kd">func</span> <span class="nx">reverse</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">flag</span> <span class="o">:=</span> <span class="mi">1</span>
	<span class="k">if</span> <span class="nx">x</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">flag</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
		<span class="nx">x</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">x</span>
	<span class="p">}</span>

	<span class="nx">result</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">x</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">temp</span> <span class="o">:=</span> <span class="nx">x</span> <span class="o">%</span> <span class="mi">10</span>
		<span class="nx">x</span> <span class="p">=</span> <span class="nx">x</span> <span class="o">/</span> <span class="mi">10</span>

		<span class="nx">result</span> <span class="p">=</span> <span class="nx">result</span><span class="o">*</span><span class="mi">10</span> <span class="o">+</span> <span class="nx">temp</span>
	<span class="p">}</span>

	<span class="nx">result</span> <span class="p">=</span> <span class="nx">flag</span> <span class="o">*</span> <span class="nx">result</span>
	<span class="k">if</span> <span class="nx">result</span> <span class="p">&gt;</span> <span class="nx">math</span><span class="p">.</span><span class="nx">MaxInt32</span> <span class="o">||</span> <span class="nx">result</span> <span class="p">&lt;</span> <span class="nx">math</span><span class="p">.</span><span class="nx">MinInt32</span> <span class="p">{</span>
		<span class="nx">result</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>

<span class="c1">// 对x进行逐个%10取个位，一旦溢出，直接跳出循环</span>
<span class="kd">func</span> <span class="nx">reverse</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">x</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">temp</span> <span class="o">:=</span> <span class="nx">x</span> <span class="o">%</span> <span class="mi">10</span>
		<span class="nx">result</span> <span class="p">=</span> <span class="nx">result</span><span class="o">*</span><span class="mi">10</span> <span class="o">+</span> <span class="nx">temp</span>
		<span class="k">if</span> <span class="nx">result</span> <span class="p">&gt;</span> <span class="nx">math</span><span class="p">.</span><span class="nx">MaxInt32</span> <span class="o">||</span> <span class="nx">result</span> <span class="p">&lt;</span> <span class="nx">math</span><span class="p">.</span><span class="nx">MinInt32</span> <span class="p">{</span>
			<span class="k">return</span> <span class="mi">0</span>
		<span class="p">}</span>
		<span class="nx">x</span> <span class="p">=</span> <span class="nx">x</span> <span class="o">/</span> <span class="mi">10</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id8">
<h2>9.回文数<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h2>
<div class="section" id="id9">
<h3>题目<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

示例 1:	输入: 121	输出: true

示例 2:输入: -121	输出: false
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。

示例 3:输入: 10  	输出: false
解释: 从右向左读, 为 01 。因此它不是一个回文数。

进阶:
你能不将整数转为字符串来解决这个问题吗？
</pre></div>
</div>
</div>
<div class="section" id="id10">
<h3>解答思路<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h3>
<p>| No.      | 思路                                               | 时间复杂度 | 空间复杂度 |
| ——– | ————————————————– | ———- | ———- |
| 01(最优) | 数学解法，取出后半段数字进行翻转，然后判断是否相等 | O(log(x))  | O(1)       |
| 02       | 转成字符串，依次判断                               | O(log(x))  | O(log(x))  |
| 03       | 转成byte数组，依次判断，同2                        | O(log(x))  | O(log(x))  |</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 数学解法，取出后半段数字进行翻转，然后判断是否相等</span>
<span class="kd">func</span> <span class="nx">isPalindrome</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">x</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">(</span><span class="nx">x</span><span class="o">%</span><span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="nx">revertedNumber</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">x</span> <span class="p">&gt;</span> <span class="nx">revertedNumber</span> <span class="p">{</span>
		<span class="nx">temp</span> <span class="o">:=</span> <span class="nx">x</span> <span class="o">%</span> <span class="mi">10</span>
		<span class="nx">revertedNumber</span> <span class="p">=</span> <span class="nx">revertedNumber</span><span class="o">*</span><span class="mi">10</span> <span class="o">+</span> <span class="nx">temp</span>
		<span class="nx">x</span> <span class="p">=</span> <span class="nx">x</span> <span class="o">/</span> <span class="mi">10</span>
	<span class="p">}</span>
	<span class="c1">// for example:</span>
	<span class="c1">// x = 1221  =&gt; x = 12 revertedNumber = 12</span>
	<span class="c1">// x = 12321 =&gt; x = 12 revertedNumber = 123</span>
	<span class="k">return</span> <span class="nx">x</span> <span class="o">==</span> <span class="nx">revertedNumber</span> <span class="o">||</span> <span class="nx">x</span> <span class="o">==</span> <span class="nx">revertedNumber</span><span class="o">/</span><span class="mi">10</span>
<span class="p">}</span>

<span class="c1">// 转成字符串，依次判断</span>
<span class="kd">func</span> <span class="nx">isPalindrome</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">x</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="nx">s</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">Itoa</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">j</span><span class="p">;</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="p">=</span> <span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">j</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="c1">// 转成byte数组，依次判断，同2</span>
<span class="kd">func</span> <span class="nx">isPalindrome</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">x</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="nx">arrs</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">strconv</span><span class="p">.</span><span class="nx">Itoa</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span>
	<span class="nx">Len</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">arrs</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">Len</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">arrs</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">arrs</span><span class="p">[</span><span class="nx">Len</span><span class="o">-</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id11">
<h2>13.罗马数字转整数<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h2>
<div class="section" id="id12">
<h3>题目<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。

字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。
通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：
    I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
    X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
    C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。

给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。

示例 1:输入: &quot;III&quot; 输出: 3

示例 2:	输入: &quot;IV&quot; 输出: 4

示例 3:	输入: &quot;IX&quot;	输出: 9

示例 4:	输入: &quot;LVIII&quot;	输出: 58
解释: L = 50, V= 5, III = 3.

示例 5:
输入: &quot;MCMXCIV&quot;	输出: 1994
解释: M = 1000, CM = 900, XC = 90, IV = 4.
</pre></div>
</div>
</div>
<div class="section" id="id13">
<h3>解答思路<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h3>
<p>| No.      | 思路                                                         | 时间复杂度 | 空间复杂度 |
| ——– | ———————————————————— | ———- | ———- |
| 01       | 本质上其实就是全部累加，然后遇到特殊的就做判断。使用一个字段记录递增 | O(n)       | O(1)       |
| 02(最优) | 从右到左遍历字符串，如果当前字符代表的值不小于其右边，就加上该值；否则就减去该值。 | O(n)       | O(1)       |</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 带标记位</span>
<span class="kd">func</span> <span class="nx">romanToInt</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">byte</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span>
		<span class="sc">&#39;I&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
		<span class="sc">&#39;V&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
		<span class="sc">&#39;X&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
		<span class="sc">&#39;L&#39;</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span>
		<span class="sc">&#39;C&#39;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
		<span class="sc">&#39;D&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
		<span class="sc">&#39;M&#39;</span><span class="p">:</span> <span class="mi">1000</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">last</span> <span class="o">:=</span> <span class="mi">0</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="nx">current</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">[</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span>
		<span class="nx">flag</span> <span class="o">:=</span> <span class="mi">1</span>
		<span class="k">if</span> <span class="nx">current</span> <span class="p">&lt;</span> <span class="nx">last</span> <span class="p">{</span>
			<span class="nx">flag</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
		<span class="p">}</span>
		<span class="nx">result</span> <span class="p">=</span> <span class="nx">result</span> <span class="o">+</span> <span class="nx">flag</span><span class="o">*</span><span class="nx">current</span>
		<span class="nx">last</span> <span class="p">=</span> <span class="nx">current</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>

<span class="c1">// 不带标记位，小于则减去2倍数</span>
<span class="kd">func</span> <span class="nx">romanToInt</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">byte</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span>
		<span class="sc">&#39;I&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
		<span class="sc">&#39;V&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
		<span class="sc">&#39;X&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
		<span class="sc">&#39;L&#39;</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span>
		<span class="sc">&#39;C&#39;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
		<span class="sc">&#39;D&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
		<span class="sc">&#39;M&#39;</span><span class="p">:</span> <span class="mi">1000</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">last</span> <span class="o">:=</span> <span class="mi">0</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="nx">current</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">[</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span>
		<span class="k">if</span> <span class="nx">current</span> <span class="p">&lt;</span> <span class="nx">last</span> <span class="p">{</span>
			<span class="nx">result</span> <span class="p">=</span> <span class="nx">result</span> <span class="o">-</span> <span class="nx">current</span>
		<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
			<span class="nx">result</span> <span class="p">=</span> <span class="nx">result</span> <span class="o">+</span> <span class="nx">current</span>
		<span class="p">}</span>
		<span class="nx">last</span> <span class="p">=</span> <span class="nx">current</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id14">
<h2>14.最长公共前缀<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h2>
<div class="section" id="id15">
<h3>题目<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>编写一个函数来查找字符串数组中的最长公共前缀。
如果不存在公共前缀，返回空字符串 &quot;&quot;。

示例 1:
输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]
输出: &quot;fl&quot;

示例 2:
输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]
输出: &quot;&quot;
解释: 输入不存在公共前缀。

说明:
所有输入只包含小写字母 a-z 。
</pre></div>
</div>
</div>
<div class="section" id="id16">
<h3>解答思路<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h3>
<p>| No.      | 思路                                                         | 时间复杂度    | 空间复杂度 |
| ——– | ———————————————————— | ————- | ———- |
| 01       | 先找最短的一个字符串，依次比较最短字符串子串是否是其他字符串子串 | O(n^2)/O(n<em>m) | O(1)       |
| 02       | 纵向扫描(暴力法):直接取第一个字符串作为最长公共前缀，将其每个字符遍历过一次 | O(n^2)/O(n</em>m) | O(1)       |
| 03(最优) | 排序后，然后计算第一个，和最后一个字符串的最长前缀           | O(nlog(n))    | O(1)       |
| 04       | trie树                                                       | O(n^2)        | O(n^2)     |
| 05       | 水平扫描法:比较前2个字符串得到最长前缀，然后跟第3个比较得到一个新的最长前缀，继续比较，直到最后 | O(n^2)/O(n*m) | O(1)       |
| 06       | 分治法                                                       | O(n^2)        | O(1)       |</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 先找最短的一个字符串，依次比较最短字符串子串是否是其他字符串子串</span>
<span class="kd">func</span> <span class="nx">longestCommonPrefix</span><span class="p">(</span><span class="nx">strs</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">{</span>
		<span class="k">return</span> <span class="s">&quot;&quot;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">{</span>
		<span class="k">return</span> <span class="nx">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="p">}</span>

	<span class="nx">short</span> <span class="o">:=</span> <span class="nx">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">s</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">strs</span><span class="p">{</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">short</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">){</span>
			<span class="nx">short</span> <span class="p">=</span> <span class="nx">s</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">short</span><span class="p">{</span>
		<span class="nx">shortest</span> <span class="o">:=</span> <span class="nx">short</span><span class="p">[:</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span><span class="nx">str</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">strs</span><span class="p">{</span>
			<span class="k">if</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Index</span><span class="p">(</span><span class="nx">str</span><span class="p">,</span><span class="nx">shortest</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">{</span>
				<span class="k">return</span> <span class="nx">short</span><span class="p">[:</span><span class="nx">i</span><span class="p">]</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">short</span>
<span class="p">}</span>

<span class="c1">// 暴力法:直接依次遍历</span>
<span class="kd">func</span> <span class="nx">longestCommonPrefix</span><span class="p">(</span><span class="nx">strs</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="s">&quot;&quot;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="p">}</span>

	<span class="nx">length</span> <span class="o">:=</span> <span class="mi">0</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">char</span> <span class="o">:=</span> <span class="nx">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">i</span><span class="p">]</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">);</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">[</span><span class="nx">j</span><span class="p">])</span> <span class="o">||</span> <span class="nx">char</span> <span class="o">!=</span> <span class="nx">strs</span><span class="p">[</span><span class="nx">j</span><span class="p">][</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nx">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="nx">length</span><span class="p">]</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="nx">length</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="nx">length</span><span class="p">]</span>
<span class="p">}</span>

<span class="c1">// 排序后，遍历比较第一个，和最后一个字符串</span>
<span class="kd">func</span> <span class="nx">longestCommonPrefix</span><span class="p">(</span><span class="nx">strs</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">{</span>
		<span class="k">return</span> <span class="s">&quot;&quot;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">{</span>
		<span class="k">return</span> <span class="nx">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="p">}</span>

	<span class="nx">sort</span><span class="p">.</span><span class="nx">Strings</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span>
	<span class="nx">first</span> <span class="o">:=</span> <span class="nx">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="nx">last</span> <span class="o">:=</span> <span class="nx">strs</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">length</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">first</span><span class="p">)</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">last</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nx">length</span><span class="p">{</span>
		<span class="nx">length</span> <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">last</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">length</span><span class="p">{</span>
		<span class="k">if</span> <span class="nx">first</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">last</span><span class="p">[</span><span class="nx">i</span><span class="p">]{</span>
			<span class="k">return</span> <span class="nx">first</span><span class="p">[:</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span>
		<span class="nx">i</span><span class="o">++</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">first</span><span class="p">[:</span><span class="nx">i</span><span class="p">]</span>
<span class="p">}</span>


<span class="c1">// trie树</span>
<span class="kd">var</span> <span class="nx">trie</span> <span class="p">[][]</span><span class="kt">int</span>
<span class="kd">var</span> <span class="nx">index</span> <span class="kt">int</span>

<span class="kd">func</span> <span class="nx">longestCommonPrefix</span><span class="p">(</span><span class="nx">strs</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="s">&quot;&quot;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="p">}</span>

	<span class="nx">trie</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">2000</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">k</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">trie</span> <span class="p">{</span>
		<span class="nx">value</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">26</span><span class="p">)</span>
		<span class="nx">trie</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="p">=</span> <span class="nx">value</span>
	<span class="p">}</span>
	<span class="nx">insert</span><span class="p">(</span><span class="nx">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

	<span class="nx">minValue</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">MaxInt32</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">retValue</span> <span class="o">:=</span> <span class="nx">insert</span><span class="p">(</span><span class="nx">strs</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="k">if</span> <span class="nx">minValue</span> <span class="p">&gt;</span> <span class="nx">retValue</span> <span class="p">{</span>
			<span class="nx">minValue</span> <span class="p">=</span> <span class="nx">retValue</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="nx">minValue</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">insert</span><span class="p">(</span><span class="nx">str</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">p</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">count</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">str</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">ch</span> <span class="o">:=</span> <span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span>
		<span class="c1">// fmt.Println(string(str[i]),p,ch,trie[p][ch])</span>
		<span class="k">if</span> <span class="nx">value</span> <span class="o">:=</span> <span class="nx">trie</span><span class="p">[</span><span class="nx">p</span><span class="p">][</span><span class="nx">ch</span><span class="p">];</span> <span class="nx">value</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">index</span><span class="o">++</span>
			<span class="nx">trie</span><span class="p">[</span><span class="nx">p</span><span class="p">][</span><span class="nx">ch</span><span class="p">]</span> <span class="p">=</span> <span class="nx">index</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">count</span><span class="o">++</span>
		<span class="p">}</span>
		<span class="nx">p</span> <span class="p">=</span> <span class="nx">trie</span><span class="p">[</span><span class="nx">p</span><span class="p">][</span><span class="nx">ch</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">count</span>
<span class="p">}</span>

<span class="c1">// 水平扫描法:比较前2个字符串得到最长前缀，然后跟第3个比较得到一个新的最长前缀，继续比较，直到最后</span>
<span class="kd">func</span> <span class="nx">longestCommonPrefix</span><span class="p">(</span><span class="nx">strs</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="s">&quot;&quot;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="p">}</span>

	<span class="nx">commonStr</span> <span class="o">:=</span> <span class="nx">common</span><span class="p">(</span><span class="nx">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">strs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
	<span class="k">if</span> <span class="nx">commonStr</span> <span class="o">==</span> <span class="s">&quot;&quot;</span> <span class="p">{</span>
		<span class="k">return</span> <span class="s">&quot;&quot;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">commonStr</span> <span class="o">==</span> <span class="s">&quot;&quot;</span> <span class="p">{</span>
			<span class="k">return</span> <span class="s">&quot;&quot;</span>
		<span class="p">}</span>
		<span class="nx">commonStr</span> <span class="p">=</span> <span class="nx">common</span><span class="p">(</span><span class="nx">commonStr</span><span class="p">,</span> <span class="nx">strs</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">commonStr</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">common</span><span class="p">(</span><span class="nx">str1</span><span class="p">,</span> <span class="nx">str2</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">length</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">str1</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">char</span> <span class="o">:=</span> <span class="nx">str1</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="k">if</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">str2</span><span class="p">)</span> <span class="o">||</span> <span class="nx">char</span> <span class="o">!=</span> <span class="nx">str2</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">str1</span><span class="p">[:</span><span class="nx">length</span><span class="p">]</span>
		<span class="p">}</span>
		<span class="nx">length</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">str1</span><span class="p">[:</span><span class="nx">length</span><span class="p">]</span>
<span class="p">}</span>

<span class="c1">// 分治法</span>
<span class="kd">func</span> <span class="nx">longestCommonPrefix</span><span class="p">(</span><span class="nx">strs</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="s">&quot;&quot;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">commonPrefix</span><span class="p">(</span><span class="nx">strs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">commonPrefix</span><span class="p">(</span><span class="nx">strs</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">left</span><span class="p">,</span> <span class="nx">right</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">left</span> <span class="o">==</span> <span class="nx">right</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">strs</span><span class="p">[</span><span class="nx">left</span><span class="p">]</span>
	<span class="p">}</span>

	<span class="nx">middle</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">left</span> <span class="o">+</span> <span class="nx">right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
	<span class="nx">leftStr</span> <span class="o">:=</span> <span class="nx">commonPrefix</span><span class="p">(</span><span class="nx">strs</span><span class="p">,</span> <span class="nx">left</span><span class="p">,</span> <span class="nx">middle</span><span class="p">)</span>
	<span class="nx">rightStr</span> <span class="o">:=</span> <span class="nx">commonPrefix</span><span class="p">(</span><span class="nx">strs</span><span class="p">,</span> <span class="nx">middle</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">right</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">commonPrefixWord</span><span class="p">(</span><span class="nx">leftStr</span><span class="p">,</span> <span class="nx">rightStr</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">commonPrefixWord</span><span class="p">(</span><span class="nx">leftStr</span><span class="p">,</span> <span class="nx">rightStr</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">leftStr</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">rightStr</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">leftStr</span> <span class="p">=</span> <span class="nx">leftStr</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">rightStr</span><span class="p">)]</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">leftStr</span><span class="p">)</span> <span class="p">&lt;</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">leftStr</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">leftStr</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">leftStr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">rightStr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">leftStr</span><span class="p">[:</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">leftStr</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id17">
<h2>20.有效的括号<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h2>
<div class="section" id="id18">
<h3>题目<a class="headerlink" href="#id18" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串，判断字符串是否有效。
有效字符串需满足：
    左括号必须用相同类型的右括号闭合。
    左括号必须以正确的顺序闭合。
注意空字符串可被认为是有效字符串。

示例 1:
输入: &quot;()&quot;
输出: true

示例 2:
输入: &quot;()[]{}&quot;
输出: true

示例 3:
输入: &quot;(]&quot;
输出: false

示例 4:
输入: &quot;([)]&quot;
输出: false

示例 5:
输入: &quot;{[]}&quot;
输出: true
</pre></div>
</div>
</div>
<div class="section" id="id19">
<h3>解题思路<a class="headerlink" href="#id19" title="永久链接至标题">¶</a></h3>
<p>| No.  | 思路                               | 时间复杂度 | 空间复杂度 |
| —- | ———————————- | ———- | ———- |
| 01   | 使用栈结构实现栈                   | O(n)       | O(n)       |
| 02   | 借助数组实现栈                     | O(n)       | O(n)       |
| 03   | 借助数组实现栈，使用数字表示来匹配 | O(n)       | O(n)       |</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 使用栈结构实现</span>
<span class="kd">func</span> <span class="nx">isValid</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">st</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">char</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="nx">char</span> <span class="p">{</span>
		<span class="k">case</span> <span class="sc">&#39;(&#39;</span><span class="p">,</span> <span class="sc">&#39;[&#39;</span><span class="p">,</span> <span class="sc">&#39;{&#39;</span><span class="p">:</span>
			<span class="nx">st</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">char</span><span class="p">)</span>
		<span class="k">case</span> <span class="sc">&#39;)&#39;</span><span class="p">,</span> <span class="sc">&#39;]&#39;</span><span class="p">,</span> <span class="sc">&#39;}&#39;</span><span class="p">:</span>
			<span class="nx">ret</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">pop</span><span class="p">()</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="o">||</span> <span class="nx">ret</span> <span class="o">!=</span> <span class="nx">match</span><span class="p">[</span><span class="nx">char</span><span class="p">]</span> <span class="p">{</span>
				<span class="k">return</span> <span class="kc">false</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="o">*</span><span class="nx">st</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">match</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">rune</span><span class="p">]</span><span class="kt">rune</span><span class="p">{</span>
	<span class="sc">&#39;)&#39;</span><span class="p">:</span> <span class="sc">&#39;(&#39;</span><span class="p">,</span>
	<span class="sc">&#39;]&#39;</span><span class="p">:</span> <span class="sc">&#39;[&#39;</span><span class="p">,</span>
	<span class="sc">&#39;}&#39;</span><span class="p">:</span> <span class="sc">&#39;{&#39;</span><span class="p">,</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">stack</span> <span class="p">[]</span><span class="kt">rune</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">stack</span><span class="p">)</span> <span class="nx">push</span><span class="p">(</span><span class="nx">b</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span>
	<span class="o">*</span><span class="nx">s</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="o">*</span><span class="nx">s</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">stack</span><span class="p">)</span> <span class="nx">pop</span><span class="p">()</span> <span class="p">(</span><span class="kt">rune</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="o">*</span><span class="nx">s</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">res</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">s</span><span class="p">)[</span><span class="nb">len</span><span class="p">(</span><span class="o">*</span><span class="nx">s</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="o">*</span><span class="nx">s</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">s</span><span class="p">)[:</span><span class="nb">len</span><span class="p">(</span><span class="o">*</span><span class="nx">s</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="k">return</span> <span class="nx">res</span><span class="p">,</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="c1">// 借助数组实现栈</span>
<span class="kd">func</span> <span class="nx">isValid</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="s">&quot;&quot;</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>

	<span class="nx">stack</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">rune</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
	<span class="nx">length</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="kd">var</span> <span class="nx">match</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">rune</span><span class="p">]</span><span class="kt">rune</span><span class="p">{</span>
		<span class="sc">&#39;)&#39;</span><span class="p">:</span> <span class="sc">&#39;(&#39;</span><span class="p">,</span>
		<span class="sc">&#39;]&#39;</span><span class="p">:</span> <span class="sc">&#39;[&#39;</span><span class="p">,</span>
		<span class="sc">&#39;}&#39;</span><span class="p">:</span> <span class="sc">&#39;{&#39;</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">char</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="nx">char</span> <span class="p">{</span>
		<span class="k">case</span> <span class="sc">&#39;(&#39;</span><span class="p">,</span> <span class="sc">&#39;[&#39;</span><span class="p">,</span> <span class="sc">&#39;{&#39;</span><span class="p">:</span>
			<span class="nx">stack</span><span class="p">[</span><span class="nx">length</span><span class="p">]</span> <span class="p">=</span> <span class="nx">char</span>
			<span class="nx">length</span><span class="o">++</span>
		<span class="k">case</span> <span class="sc">&#39;)&#39;</span><span class="p">,</span> <span class="sc">&#39;]&#39;</span><span class="p">,</span> <span class="sc">&#39;}&#39;</span><span class="p">:</span>
			<span class="k">if</span> <span class="nx">length</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="k">return</span> <span class="kc">false</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">stack</span><span class="p">[</span><span class="nx">length</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">match</span><span class="p">[</span><span class="nx">char</span><span class="p">]{</span>
				<span class="k">return</span> <span class="kc">false</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">length</span><span class="o">--</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">length</span> <span class="o">==</span> <span class="mi">0</span>
<span class="p">}</span>

<span class="c1">// 借助数组实现栈，使用数字表示来匹配</span>
<span class="kd">func</span> <span class="nx">isValid</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="s">&quot;&quot;</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>

	<span class="nx">stack</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
	<span class="nx">length</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="kd">var</span> <span class="nx">match</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">rune</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span>
		<span class="sc">&#39;)&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
		<span class="sc">&#39;(&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
		<span class="sc">&#39;]&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
		<span class="sc">&#39;[&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>
		<span class="sc">&#39;}&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
		<span class="sc">&#39;{&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">char</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="nx">char</span> <span class="p">{</span>
		<span class="k">case</span> <span class="sc">&#39;(&#39;</span><span class="p">,</span> <span class="sc">&#39;[&#39;</span><span class="p">,</span> <span class="sc">&#39;{&#39;</span><span class="p">:</span>
			<span class="nx">stack</span><span class="p">[</span><span class="nx">length</span><span class="p">]</span> <span class="p">=</span> <span class="nx">match</span><span class="p">[</span><span class="nx">char</span><span class="p">]</span>
			<span class="nx">length</span><span class="o">++</span>
		<span class="k">case</span> <span class="sc">&#39;)&#39;</span><span class="p">,</span> <span class="sc">&#39;]&#39;</span><span class="p">,</span> <span class="sc">&#39;}&#39;</span><span class="p">:</span>
			<span class="k">if</span> <span class="nx">length</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="k">return</span> <span class="kc">false</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">stack</span><span class="p">[</span><span class="nx">length</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="nx">match</span><span class="p">[</span><span class="nx">char</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="k">return</span> <span class="kc">false</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">length</span><span class="o">--</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">length</span> <span class="o">==</span> <span class="mi">0</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id20">
<h2>21.合并两个有序链表<a class="headerlink" href="#id20" title="永久链接至标题">¶</a></h2>
<div class="section" id="id21">
<h3>题目<a class="headerlink" href="#id21" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

示例：
输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4
输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4
</pre></div>
</div>
</div>
<div class="section" id="id22">
<h3>解题思路<a class="headerlink" href="#id22" title="永久链接至标题">¶</a></h3>
<p>| No.      | 思路     | 时间复杂度 | 空间复杂度 |
| ——– | ——– | ———- | ———- |
| 01(最优) | 迭代遍历 | O(n)       | O(1)       |
| 02       | 递归实现 | O(n)       | O(n)       |</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 迭代遍历</span>
<span class="kd">func</span> <span class="nx">mergeTwoLists</span><span class="p">(</span><span class="nx">l1</span> <span class="o">*</span><span class="nx">ListNode</span><span class="p">,</span> <span class="nx">l2</span> <span class="o">*</span><span class="nx">ListNode</span><span class="p">)</span> <span class="o">*</span><span class="nx">ListNode</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">l1</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">l2</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">l2</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">l1</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">head</span><span class="p">,</span> <span class="nx">node</span> <span class="o">*</span><span class="nx">ListNode</span>
	<span class="k">if</span> <span class="nx">l1</span><span class="p">.</span><span class="nx">Val</span> <span class="p">&lt;</span> <span class="nx">l2</span><span class="p">.</span><span class="nx">Val</span> <span class="p">{</span>
		<span class="nx">head</span> <span class="p">=</span> <span class="nx">l1</span>
		<span class="nx">node</span> <span class="p">=</span> <span class="nx">l1</span>
		<span class="nx">l1</span> <span class="p">=</span> <span class="nx">l1</span><span class="p">.</span><span class="nx">Next</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">head</span> <span class="p">=</span> <span class="nx">l2</span>
		<span class="nx">node</span> <span class="p">=</span> <span class="nx">l2</span>
		<span class="nx">l2</span> <span class="p">=</span> <span class="nx">l2</span><span class="p">.</span><span class="nx">Next</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">l1</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">l2</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">l1</span><span class="p">.</span><span class="nx">Val</span> <span class="p">&lt;</span> <span class="nx">l2</span><span class="p">.</span><span class="nx">Val</span> <span class="p">{</span>
			<span class="nx">node</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">l1</span>
			<span class="nx">l1</span> <span class="p">=</span> <span class="nx">l1</span><span class="p">.</span><span class="nx">Next</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">node</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">l2</span>
			<span class="nx">l2</span> <span class="p">=</span> <span class="nx">l2</span><span class="p">.</span><span class="nx">Next</span>
		<span class="p">}</span>
		<span class="nx">node</span> <span class="p">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Next</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">l1</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">node</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">l1</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">l2</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">node</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">l2</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">head</span>
<span class="p">}</span>


<span class="c1">// 递归遍历</span>
<span class="kd">func</span> <span class="nx">mergeTwoLists</span><span class="p">(</span><span class="nx">l1</span> <span class="o">*</span><span class="nx">ListNode</span><span class="p">,</span> <span class="nx">l2</span> <span class="o">*</span><span class="nx">ListNode</span><span class="p">)</span> <span class="o">*</span><span class="nx">ListNode</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">l1</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">l2</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">l2</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">l1</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">l1</span><span class="p">.</span><span class="nx">Val</span> <span class="p">&lt;</span> <span class="nx">l2</span><span class="p">.</span><span class="nx">Val</span><span class="p">{</span>
		<span class="nx">l1</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">mergeTwoLists</span><span class="p">(</span><span class="nx">l1</span><span class="p">.</span><span class="nx">Next</span><span class="p">,</span><span class="nx">l2</span><span class="p">)</span>
		<span class="k">return</span> <span class="nx">l1</span>
	<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
		<span class="nx">l2</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">mergeTwoLists</span><span class="p">(</span><span class="nx">l1</span><span class="p">,</span><span class="nx">l2</span><span class="p">.</span><span class="nx">Next</span><span class="p">)</span>
		<span class="k">return</span> <span class="nx">l2</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id23">
<h2>26.删除排序数组中的重复项<a class="headerlink" href="#id23" title="永久链接至标题">¶</a></h2>
<div class="section" id="id24">
<h3>题目<a class="headerlink" href="#id24" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

示例 1:
给定数组 nums = [1,1,2], 
函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 
你不需要考虑数组中超出新长度后面的元素。

示例 2:
给定 nums = [0,0,1,1,1,2,2,3,3,4],
函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。
你不需要考虑数组中超出新长度后面的元素。

说明:
为什么返回数值是整数，但输出的答案是数组呢?
请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
你可以想象内部操作如下:
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i &lt; len; i++) {
    print(nums[i]);
}
</pre></div>
</div>
</div>
<div class="section" id="id25">
<h3>解题思路<a class="headerlink" href="#id25" title="永久链接至标题">¶</a></h3>
<p>| No.      | 思路     | 时间复杂度 | 空间复杂度 |
| ——– | ——– | ———- | ———- |
| 01       | 双指针法 | O(n)       | O(1)       |
| 02(最优) | 计数法   | O(n)       | O(1)       |</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 双指针法</span>
<span class="kd">func</span> <span class="nx">removeDuplicates</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">i</span> <span class="p">,</span> <span class="nx">j</span> <span class="p">,</span> <span class="nx">length</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nx">length</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">{</span>
		<span class="k">if</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]{</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">i</span><span class="o">++</span>
		<span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">i</span><span class="o">+</span><span class="mi">1</span>
<span class="p">}</span>

<span class="c1">// 计数法</span>
<span class="kd">func</span> <span class="nx">removeDuplicates</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">count</span> <span class="o">:=</span> <span class="mi">1</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span>
			<span class="nx">nums</span><span class="p">[</span><span class="nx">count</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
			<span class="nx">count</span><span class="o">++</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">count</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id26">
<h2>27.移除元素<a class="headerlink" href="#id26" title="永久链接至标题">¶</a></h2>
<div class="section" id="id27">
<h3>题目<a class="headerlink" href="#id27" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

示例 1:
给定 nums = [3,2,2,3], val = 3,
函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。
你不需要考虑数组中超出新长度后面的元素。

示例 2:
给定 nums = [0,1,2,2,3,0,4,2], val = 2,
函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。
注意这五个元素可为任意顺序。
你不需要考虑数组中超出新长度后面的元素。
说明:
为什么返回数值是整数，但输出的答案是数组呢?
请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
你可以想象内部操作如下:
// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
int len = removeElement(nums, val);
// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i &lt; len; i++) {
    print(nums[i]);
}
</pre></div>
</div>
</div>
<div class="section" id="id28">
<h3>解题思路<a class="headerlink" href="#id28" title="永久链接至标题">¶</a></h3>
<p>| No.      | 思路                         | 时间复杂度 | 空间复杂度 |
| ——– | —————————- | ———- | ———- |
| 01(最优) | 双指针，数字前移             | O(n)       | O(1)       |
| 02       | 双指针，出现重复最后数字前移 | O(n)       | O(1)       |
| 03       | 首位指针法                   | O(n)       | O(1)       |</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 双指针，数字前移</span>
<span class="kd">func</span> <span class="nx">removeElement</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">j</span><span class="o">++</span><span class="p">{</span>
		<span class="k">if</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">val</span><span class="p">{</span>
			<span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
			<span class="nx">i</span><span class="o">++</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">i</span>
<span class="p">}</span>

<span class="c1">// 双指针，出现重复最后数字前移</span>
<span class="kd">func</span> <span class="nx">removeElement</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">{</span>
		<span class="k">if</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">val</span><span class="p">{</span>
			<span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="nx">n</span><span class="o">--</span>
		<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
			<span class="nx">i</span><span class="o">++</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">n</span>
<span class="p">}</span>

<span class="c1">// 首位指针法</span>
<span class="kd">func</span> <span class="nx">removeElement</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="c1">// 从左向右找到等于 val 的位置</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">val</span> <span class="p">{</span>
			<span class="nx">i</span><span class="o">++</span>
		<span class="p">}</span>
		<span class="c1">// 从右向左找到不等于 val 的位置</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">==</span> <span class="nx">val</span> <span class="p">{</span>
			<span class="nx">j</span><span class="o">--</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="nx">j</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="c1">// fmt.Println(i,j)</span>
		<span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">i</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="strstr">
<h2>28.实现strStr()<a class="headerlink" href="#strstr" title="永久链接至标题">¶</a></h2>
<div class="section" id="id29">
<h3>题目<a class="headerlink" href="#id29" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>实现 strStr() 函数。
给定一个 haystack 字符串和一个 needle 字符串，
在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。
如果不存在，则返回-1。

示例 1:
输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;
输出: 2

示例 2:
输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;
输出: -1

说明:
当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。
对于本题而言，当 needle 是空字符串时我们应当返回 0 。
这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。
</pre></div>
</div>
</div>
<div class="section" id="id30">
<h3>解题思路<a class="headerlink" href="#id30" title="永久链接至标题">¶</a></h3>
<p>| No.      | 思路       | 时间复杂度 | 空间复杂度 |
| ——– | ———- | ———- | ———- |
| 01(最优) | Sunday算法 | O(n)       | O(1)       |
| 02       | 直接匹配   | O(n)       | O(1)       |
| 03       | 系统函数   | O(n)       | O(1)       |
| 04       | kmp算法    | O(n)       | O(n)       |</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Sunday算法</span>
<span class="kd">func</span> <span class="nx">strStr</span><span class="p">(</span><span class="nx">haystack</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">needle</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">needle</span> <span class="o">==</span> <span class="s">&quot;&quot;</span><span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">needle</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">haystack</span><span class="p">){</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
	<span class="p">}</span>
	<span class="c1">// 计算模式串needle的偏移量</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int32</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">k</span><span class="p">,</span><span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">needle</span><span class="p">{</span>
		<span class="nx">m</span><span class="p">[</span><span class="nx">v</span><span class="p">]</span> <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">needle</span><span class="p">)</span><span class="o">-</span><span class="nx">k</span>
	<span class="p">}</span>

	<span class="nx">index</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">index</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="nx">needle</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">haystack</span><span class="p">){</span>
		<span class="c1">// 匹配字符串</span>
		<span class="nx">str</span> <span class="o">:=</span> <span class="nx">haystack</span><span class="p">[</span><span class="nx">index</span><span class="p">:</span><span class="nx">index</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="nx">needle</span><span class="p">)]</span>
		<span class="k">if</span> <span class="nx">str</span> <span class="o">==</span> <span class="nx">needle</span><span class="p">{</span>
			<span class="k">return</span> <span class="nx">index</span>
		<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">index</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="nx">needle</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">haystack</span><span class="p">){</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
			<span class="p">}</span>
			<span class="c1">// 后一位字符串</span>
			<span class="nx">next</span> <span class="o">:=</span> <span class="nx">haystack</span><span class="p">[</span><span class="nx">index</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="nx">needle</span><span class="p">)]</span>
			<span class="k">if</span> <span class="nx">nextStep</span><span class="p">,</span><span class="nx">ok</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">[</span><span class="nb">int32</span><span class="p">(</span><span class="nx">next</span><span class="p">)];</span><span class="nx">ok</span><span class="p">{</span>
				<span class="nx">index</span> <span class="p">=</span> <span class="nx">index</span><span class="o">+</span><span class="nx">nextStep</span>
			<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
				<span class="nx">index</span> <span class="p">=</span> <span class="nx">index</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="nx">needle</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">index</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="nx">needle</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">haystack</span><span class="p">){</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
	<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">index</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// </span>
<span class="kd">func</span> <span class="nx">strStr</span><span class="p">(</span><span class="nx">haystack</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">needle</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">hlen</span><span class="p">,</span> <span class="nx">nlen</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">haystack</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="nx">needle</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">hlen</span><span class="o">-</span><span class="nx">nlen</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">haystack</span><span class="p">[</span><span class="nx">i</span><span class="p">:</span><span class="nx">i</span><span class="o">+</span><span class="nx">nlen</span><span class="p">]</span> <span class="o">==</span> <span class="nx">needle</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">i</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">}</span>

<span class="c1">//</span>
<span class="kd">func</span> <span class="nx">strStr</span><span class="p">(</span><span class="nx">haystack</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">needle</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Index</span><span class="p">(</span><span class="nx">haystack</span><span class="p">,</span> <span class="nx">needle</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">//</span>
<span class="kd">func</span> <span class="nx">strStr</span><span class="p">(</span><span class="nx">haystack</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">needle</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">needle</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span>
	<span class="p">}</span>

	<span class="nx">next</span> <span class="o">:=</span> <span class="nx">getNext</span><span class="p">(</span><span class="nx">needle</span><span class="p">)</span>

	<span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">haystack</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">needle</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">j</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="nx">haystack</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">needle</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">{</span>
			<span class="nx">i</span><span class="o">++</span>
			<span class="nx">j</span><span class="o">++</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">j</span> <span class="p">=</span> <span class="nx">next</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">j</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nx">needle</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">i</span> <span class="o">-</span> <span class="nx">j</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">}</span>

<span class="c1">// 求next数组</span>
<span class="kd">func</span> <span class="nx">getNext</span><span class="p">(</span><span class="nx">str</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">next</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">str</span><span class="p">))</span>
	<span class="nx">next</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>

	<span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">j</span> <span class="o">:=</span> <span class="o">-</span><span class="mi">1</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">j</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">str</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">{</span>
			<span class="nx">i</span><span class="o">++</span>
			<span class="nx">j</span><span class="o">++</span>
			<span class="nx">next</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">j</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">j</span> <span class="p">=</span> <span class="nx">next</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">next</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id31">
<h2>35.搜索插入位置<a class="headerlink" href="#id31" title="永久链接至标题">¶</a></h2>
<div class="section" id="id32">
<h3>题目<a class="headerlink" href="#id32" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

你可以假设数组中无重复元素。

示例 1:
输入: [1,3,5,6], 5
输出: 2

示例 2:
输入: [1,3,5,6], 2
输出: 1

示例 3:
输入: [1,3,5,6], 7
输出: 4

示例 4:
输入: [1,3,5,6], 0
输出: 0
</pre></div>
</div>
</div>
<div class="section" id="id33">
<h3>解题思路<a class="headerlink" href="#id33" title="永久链接至标题">¶</a></h3>
<p>| No.      | 思路     | 时间复杂度 | 空间复杂度 |
| ——– | ——– | ———- | ———- |
| 01(最优) | 二分查找 | O(log(n))  | O(1)       |
| 02       | 顺序查找 | O(n)       | O(1)       |
| 03       | 顺序查找 | O(n)       | O(1)       |</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 二分查找</span>
<span class="kd">func</span> <span class="nx">searchInsert</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">target</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">low</span><span class="p">,</span> <span class="nx">high</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
	<span class="k">for</span> <span class="nx">low</span> <span class="o">&lt;=</span> <span class="nx">high</span> <span class="p">{</span>
		<span class="nx">mid</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">low</span> <span class="o">+</span> <span class="nx">high</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
		<span class="k">switch</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">mid</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">target</span><span class="p">:</span>
			<span class="nx">low</span> <span class="p">=</span> <span class="nx">mid</span> <span class="o">+</span> <span class="mi">1</span>
		<span class="k">case</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">mid</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">target</span><span class="p">:</span>
			<span class="nx">high</span> <span class="p">=</span> <span class="nx">mid</span> <span class="o">-</span> <span class="mi">1</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="k">return</span> <span class="nx">mid</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">low</span>
<span class="p">}</span>

<span class="c1">// 顺序查找</span>
<span class="kd">func</span> <span class="nx">searchInsert</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">target</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">target</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">target</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">i</span>
		<span class="p">}</span>
		<span class="nx">i</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">i</span>
<span class="p">}</span>

<span class="c1">// 顺序查找</span>
<span class="kd">func</span> <span class="nx">searchInsert</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">target</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="nx">target</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">i</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id34">
<h2>38.报数<a class="headerlink" href="#id34" title="永久链接至标题">¶</a></h2>
<div class="section" id="id35">
<h3>题目<a class="headerlink" href="#id35" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：
1.     1
2.     11
3.     21
4.     1211
5.     111221

1 被读作  &quot;one 1&quot;  (&quot;一个一&quot;) , 即 11。
11 被读作 &quot;two 1s&quot; (&quot;两个一&quot;）, 即 21。
21 被读作 &quot;one 2&quot;,  &quot;one 1&quot; （&quot;一个二&quot; ,  &quot;一个一&quot;) , 即 1211。

给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。
注意：整数顺序将表示为一个字符串。

 

示例 1:
输入: 1
输出: &quot;1&quot;

示例 2:
输入: 4
输出: &quot;1211&quot;
</pre></div>
</div>
</div>
<div class="section" id="id36">
<h3>解题思路<a class="headerlink" href="#id36" title="永久链接至标题">¶</a></h3>
<p>| No.       | 思路            | 时间复杂度 | 空间复杂度 |
| ——— | ————— | ———- | ———- |
| 01 (最优) | 递推+双指针计数 | O(n^2)     | O(1)       |
| 02        | 递归+双指针计数 | O(n^2)     | O(n)       |</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 递推+双指针计数</span>
<span class="kd">func</span> <span class="nx">countAndSay</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">strs</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{</span><span class="sc">&#39;1&#39;</span><span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">strs</span> <span class="p">=</span> <span class="nx">say</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">string</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">say</span><span class="p">(</span><span class="nx">strs</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>

	<span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">strs</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">strs</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">{</span>
			<span class="nx">j</span><span class="o">++</span>
		<span class="p">}</span>
		<span class="c1">// 几个几</span>
		<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nb">byte</span><span class="p">(</span><span class="nx">j</span><span class="o">-</span><span class="nx">i</span><span class="o">+</span><span class="sc">&#39;0&#39;</span><span class="p">))</span>
		<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">strs</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="nx">i</span> <span class="p">=</span> <span class="nx">j</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>

<span class="c1">// 递归+双指针计数</span>
<span class="kd">func</span> <span class="nx">countAndSay</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="k">return</span> <span class="s">&quot;1&quot;</span>
	<span class="p">}</span>
	<span class="nx">strs</span> <span class="o">:=</span> <span class="nx">countAndSay</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

	<span class="nx">result</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>

	<span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">strs</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">strs</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">{</span>
			<span class="nx">j</span><span class="o">++</span>
		<span class="p">}</span>
		<span class="c1">// 几个几</span>
		<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nb">byte</span><span class="p">(</span><span class="nx">j</span><span class="o">-</span><span class="nx">i</span><span class="o">+</span><span class="sc">&#39;0&#39;</span><span class="p">))</span>
		<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">strs</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="nx">i</span> <span class="p">=</span> <span class="nx">j</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">string</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id37">
<h2>53.最大子序和<a class="headerlink" href="#id37" title="永久链接至标题">¶</a></h2>
<div class="section" id="id38">
<h3>题目<a class="headerlink" href="#id38" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例:
输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。

进阶:
如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。
</pre></div>
</div>
</div>
<div class="section" id="id39">
<h3>解题思路<a class="headerlink" href="#id39" title="永久链接至标题">¶</a></h3>
<p>| No.      | 思路     | 时间复杂度 | 空间复杂度 |
| ——– | ——– | ———- | ———- |
| 01(最优) | 贪心法   | O(n)       | O(1)       |
| 02       | 暴力法   | O(n^2)     | O(1)       |
| 03       | 动态规划 | O(n)       | O(n)       |
| 04       | 动态规划 | O(n)       | O(1)       |
| 05       | 分治     | O(nlog(n)) | O(log(n))  |</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 贪心法</span>
<span class="kd">func</span> <span class="nx">maxSubArray</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="nx">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">sum</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">sum</span> <span class="o">+=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">sum</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">sum</span> <span class="p">&gt;</span> <span class="nx">result</span> <span class="p">{</span>
			<span class="nx">result</span> <span class="p">=</span> <span class="nx">sum</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>

<span class="c1">// 暴力法</span>
<span class="kd">func</span> <span class="nx">maxSubArray</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">MinInt32</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">sum</span> <span class="o">+=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
			<span class="k">if</span> <span class="nx">sum</span> <span class="p">&gt;</span> <span class="nx">result</span> <span class="p">{</span>
				<span class="nx">result</span> <span class="p">=</span> <span class="nx">sum</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>

<span class="c1">// </span>
<span class="kd">func</span> <span class="nx">maxSubArray</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">dp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">))</span>
	<span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="nx">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
			<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">result</span> <span class="p">{</span>
			<span class="nx">result</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>

<span class="c1">// 动态规划</span>
<span class="kd">func</span> <span class="nx">maxSubArray</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">dp</span> <span class="o">:=</span> <span class="nx">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="nx">dp</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">dp</span><span class="o">+</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
			<span class="nx">dp</span> <span class="p">=</span> <span class="nx">dp</span> <span class="o">+</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">dp</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="nx">dp</span> <span class="p">&gt;</span> <span class="nx">result</span> <span class="p">{</span>
			<span class="nx">result</span> <span class="p">=</span> <span class="nx">dp</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>

<span class="c1">// 分治法</span>
<span class="kd">func</span> <span class="nx">maxSubArray</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="nx">maxSubArr</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">maxSubArr</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">left</span><span class="p">,</span> <span class="nx">right</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">left</span> <span class="o">==</span> <span class="nx">right</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">left</span><span class="p">]</span>
	<span class="p">}</span>

	<span class="nx">mid</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">left</span> <span class="o">+</span> <span class="nx">right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
	<span class="nx">leftSum</span> <span class="o">:=</span> <span class="nx">maxSubArr</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">left</span><span class="p">,</span> <span class="nx">mid</span><span class="p">)</span>        <span class="c1">// 最大子序在左边</span>
	<span class="nx">rightSum</span> <span class="o">:=</span> <span class="nx">maxSubArr</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">right</span><span class="p">)</span>    <span class="c1">// 最大子序在右边</span>
	<span class="nx">midSum</span> <span class="o">:=</span> <span class="nx">findMaxArr</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">left</span><span class="p">,</span> <span class="nx">mid</span><span class="p">,</span> <span class="nx">right</span><span class="p">)</span> <span class="c1">// 跨中心</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="nx">max</span><span class="p">(</span><span class="nx">leftSum</span><span class="p">,</span> <span class="nx">rightSum</span><span class="p">)</span>
	<span class="nx">result</span> <span class="p">=</span> <span class="nx">max</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">midSum</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">findMaxArr</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">left</span><span class="p">,</span> <span class="nx">mid</span><span class="p">,</span> <span class="nx">right</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">leftSum</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">MinInt32</span>
	<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="c1">// 从右到左</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">mid</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="nx">left</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="nx">sum</span> <span class="o">+=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="nx">leftSum</span> <span class="p">=</span> <span class="nx">max</span><span class="p">(</span><span class="nx">leftSum</span><span class="p">,</span> <span class="nx">sum</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">rightSum</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">MinInt32</span>
	<span class="nx">sum</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="c1">// 从左到右</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">right</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">sum</span> <span class="o">+=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="nx">rightSum</span> <span class="p">=</span> <span class="nx">max</span><span class="p">(</span><span class="nx">rightSum</span><span class="p">,</span> <span class="nx">sum</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">leftSum</span> <span class="o">+</span> <span class="nx">rightSum</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">a</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id40">
<h2>58.最后一个单词的长度<a class="headerlink" href="#id40" title="永久链接至标题">¶</a></h2>
<div class="section" id="id41">
<h3>题目<a class="headerlink" href="#id41" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个仅包含大小写字母和空格 &#39; &#39; 的字符串，返回其最后一个单词的长度。
如果不存在最后一个单词，请返回 0 。
说明：一个单词是指由字母组成，但不包含任何空格的字符串。

示例:
输入: &quot;Hello World&quot;
输出: 5
</pre></div>
</div>
</div>
<div class="section" id="id42">
<h3>解题思路<a class="headerlink" href="#id42" title="永久链接至标题">¶</a></h3>
<p>| No.      | 思路                                 | 时间复杂度 | 空间复杂度 |
| ——– | ———————————— | ———- | ———- |
| 01(最优) | 调用系统函数，切割为数组取最后一个值 | O(n)       | O(1)       |
| 02       | 遍历统计                             | O(n)       | O(1)       |</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 调用系统函数，切割为数组取最后一个值</span>
<span class="kd">func</span> <span class="nx">lengthOfLastWord</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">arr</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Split</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nx">Trim</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&quot; &quot;</span><span class="p">),</span> <span class="s">&quot; &quot;</span><span class="p">)</span>
	<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="p">}</span>

<span class="c1">// 遍历统计</span>
<span class="kd">func</span> <span class="nx">lengthOfLastWord</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">length</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">length</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span>
	<span class="p">}</span>

	<span class="nx">result</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39; &#39;</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">result</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nx">result</span>
			<span class="p">}</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">result</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id43">
<h2>66.加一<a class="headerlink" href="#id43" title="永久链接至标题">¶</a></h2>
<div class="section" id="id44">
<h3>题目<a class="headerlink" href="#id44" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。
最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。
你可以假设除了整数 0 之外，这个整数不会以零开头。

示例 1:
输入: [1,2,3]
输出: [1,2,4]
解释: 输入数组表示数字 123。

示例 2:
输入: [4,3,2,1]
输出: [4,3,2,2]
解释: 输入数组表示数字 4321。
</pre></div>
</div>
</div>
<div class="section" id="id45">
<h3>解题思路<a class="headerlink" href="#id45" title="永久链接至标题">¶</a></h3>
<p>| No.      | 思路     | 时间复杂度 | 空间复杂度 |
| ——– | ——– | ———- | ———- |
| 01       | 直接模拟 | O(n)       | O(1)       |
| 02(最优) | 直接模拟 | O(n)       | O(1)       |</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 模拟进位</span>
<span class="kd">func</span> <span class="nx">plusOne</span><span class="p">(</span><span class="nx">digits</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">length</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">digits</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">length</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">digits</span><span class="p">[</span><span class="nx">length</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">++</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">digits</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&lt;</span> <span class="mi">10</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="nx">digits</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">digits</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">10</span>
		<span class="nx">digits</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">++</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">digits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">&gt;</span> <span class="mi">9</span> <span class="p">{</span>
		<span class="nx">digits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="nx">digits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">10</span>
		<span class="nx">digits</span> <span class="p">=</span> <span class="nb">append</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">},</span> <span class="nx">digits</span><span class="o">...</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">digits</span>
<span class="p">}</span>

<span class="c1">// 模拟进位</span>
<span class="kd">func</span> <span class="nx">plusOne</span><span class="p">(</span><span class="nx">digits</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">digits</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">digits</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&lt;</span> <span class="mi">9</span> <span class="p">{</span>
			<span class="nx">digits</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">++</span>
			<span class="k">return</span> <span class="nx">digits</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">digits</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">append</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">},</span> <span class="nx">digits</span><span class="o">...</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id46">
<h2>67.二进制求和<a class="headerlink" href="#id46" title="永久链接至标题">¶</a></h2>
<div class="section" id="id47">
<h3>题目<a class="headerlink" href="#id47" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定两个二进制字符串，返回他们的和（用二进制表示）。

输入为非空字符串且只包含数字 1 和 0。

示例 1:

输入: a = &quot;11&quot;, b = &quot;1&quot;
输出: &quot;100&quot;

示例 2:

输入: a = &quot;1010&quot;, b = &quot;1011&quot;
输出: &quot;10101&quot;
</pre></div>
</div>
</div>
<div class="section" id="id48">
<h3>解题思路<a class="headerlink" href="#id48" title="永久链接至标题">¶</a></h3>
<p>| No.      | 思路           | 时间复杂度 | 空间复杂度 |
| ——– | ————– | ———- | ———- |
| 01       | 转换成数组模拟 | O(n)       | O(n)       |
| 02(最优) | 直接模拟       | O(n)       | O(1)       |</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 转换成数组模拟</span>
<span class="kd">func</span> <span class="nx">addBinary</span><span class="p">(</span><span class="nx">a</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="p">=</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">a</span>
	<span class="p">}</span>
	<span class="nx">length</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>

	<span class="nx">A</span> <span class="o">:=</span> <span class="nx">transToInt</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">length</span><span class="p">)</span>
	<span class="nx">B</span> <span class="o">:=</span> <span class="nx">transToInt</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">length</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">makeString</span><span class="p">(</span><span class="nx">add</span><span class="p">(</span><span class="nx">A</span><span class="p">,</span> <span class="nx">B</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">transToInt</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">length</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">length</span><span class="p">)</span>
	<span class="nx">ls</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">b</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="nx">result</span><span class="p">[</span><span class="nx">length</span><span class="o">-</span><span class="nx">ls</span><span class="o">+</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">b</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">add</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">length</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">length</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="nx">temp</span> <span class="o">:=</span> <span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">+</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nx">b</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">temp</span> <span class="o">%</span> <span class="mi">2</span>
		<span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">temp</span> <span class="o">/</span> <span class="mi">2</span>
	<span class="p">}</span>
	<span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">length</span><span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">i</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="p">:]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">makeString</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">bytes</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">bytes</span> <span class="p">{</span>
		<span class="nx">bytes</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">byte</span><span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="o">+</span> <span class="sc">&#39;0&#39;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">string</span><span class="p">(</span><span class="nx">bytes</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 直接模拟</span>
<span class="kd">func</span> <span class="nx">addBinary</span><span class="p">(</span><span class="nx">a</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">i</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
	<span class="nx">j</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="s">&quot;&quot;</span>
	<span class="nx">flag</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">current</span> <span class="o">:=</span> <span class="mi">0</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">intA</span><span class="p">,</span> <span class="nx">intB</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
		<span class="k">if</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">intA</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">intB</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">b</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">current</span> <span class="p">=</span> <span class="nx">intA</span> <span class="o">+</span> <span class="nx">intB</span> <span class="o">+</span> <span class="nx">flag</span>
		<span class="nx">flag</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="k">if</span> <span class="nx">current</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="p">{</span>
			<span class="nx">flag</span> <span class="p">=</span> <span class="mi">1</span>
			<span class="nx">current</span> <span class="p">=</span> <span class="nx">current</span> <span class="o">-</span> <span class="mi">2</span>
		<span class="p">}</span>
		<span class="nx">cur</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">Itoa</span><span class="p">(</span><span class="nx">current</span><span class="p">)</span>
		<span class="nx">result</span> <span class="p">=</span> <span class="nx">cur</span> <span class="o">+</span> <span class="nx">result</span>
		<span class="nx">i</span><span class="o">--</span>
		<span class="nx">j</span><span class="o">--</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">flag</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="nx">result</span> <span class="p">=</span> <span class="s">&quot;1&quot;</span> <span class="o">+</span> <span class="nx">result</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="x">
<h2>69.x的平方跟<a class="headerlink" href="#x" title="永久链接至标题">¶</a></h2>
<div class="section" id="id49">
<h3>题目<a class="headerlink" href="#id49" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>实现 int sqrt(int x) 函数。
计算并返回 x 的平方根，其中 x 是非负整数。
由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

示例 1:
输入: 4
输出: 2

示例 2:
输入: 8
输出: 2
说明: 8 的平方根是 2.82842..., 
     由于返回类型是整数，小数部分将被舍去。
</pre></div>
</div>
</div>
<div class="section" id="id50">
<h3>解题思路<a class="headerlink" href="#id50" title="永久链接至标题">¶</a></h3>
<p>| No.      | 思路        | 时间复杂度 | 空间复杂度 |
| ——– | ———– | ———- | ———- |
| 01       | 系统函数    | O(log(n))  | O(1)       |
| 02       | 系统函数    | O(log(n))  | O(1)       |
| 03(最优) | 牛顿迭代法  | O(log(n))  | O(1)       |
| 04       | 二分查找法  | O(log(n))  | O(1)       |
| 05       | 暴力法:遍历 | O(n)       | O(1)       |</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 系统函数</span>
<span class="kd">func</span> <span class="nx">mySqrt</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nx">Sqrt</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">x</span><span class="p">)))</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>

<span class="c1">// 系统函数</span>
<span class="kd">func</span> <span class="nx">mySqrt</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Floor</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nx">Sqrt</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">x</span><span class="p">)))</span>
	<span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 牛顿迭代法</span>
<span class="kd">func</span> <span class="nx">mySqrt</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="nx">x</span>
	<span class="k">for</span> <span class="nx">result</span><span class="o">*</span><span class="nx">result</span> <span class="p">&gt;</span> <span class="nx">x</span> <span class="p">{</span>
		<span class="nx">result</span> <span class="p">=</span> <span class="p">(</span><span class="nx">result</span> <span class="o">+</span> <span class="nx">x</span><span class="o">/</span><span class="nx">result</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>

<span class="c1">// 二分查找法</span>
<span class="kd">func</span> <span class="nx">mySqrt</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">left</span> <span class="o">:=</span> <span class="mi">1</span>
	<span class="nx">right</span> <span class="o">:=</span> <span class="nx">x</span>
	<span class="k">for</span> <span class="nx">left</span> <span class="o">&lt;=</span> <span class="nx">right</span> <span class="p">{</span>
		<span class="nx">mid</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">left</span> <span class="o">+</span> <span class="nx">right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
		<span class="k">if</span> <span class="nx">mid</span> <span class="o">==</span> <span class="nx">x</span><span class="o">/</span><span class="nx">mid</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">mid</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">mid</span> <span class="p">&lt;</span> <span class="nx">x</span><span class="o">/</span><span class="nx">mid</span> <span class="p">{</span>
			<span class="nx">left</span> <span class="p">=</span> <span class="nx">mid</span> <span class="o">+</span> <span class="mi">1</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">right</span> <span class="p">=</span> <span class="nx">mid</span> <span class="o">-</span> <span class="mi">1</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">left</span> <span class="o">*</span> <span class="nx">left</span> <span class="o">&lt;=</span> <span class="nx">x</span><span class="p">{</span>
		<span class="k">return</span> <span class="nx">left</span>
	<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">left</span><span class="o">-</span><span class="mi">1</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 暴力法:遍历</span>
<span class="kd">func</span> <span class="nx">mySqrt</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">x</span><span class="o">/</span><span class="nx">i</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">i</span><span class="o">*</span><span class="nx">i</span> <span class="o">==</span> <span class="nx">x</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">i</span>
		<span class="p">}</span>
		<span class="nx">result</span> <span class="p">=</span> <span class="nx">i</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id51">
<h2>70.爬楼梯<a class="headerlink" href="#id51" title="永久链接至标题">¶</a></h2>
<div class="section" id="id52">
<h3>题目<a class="headerlink" href="#id52" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
注意：给定 n 是一个正整数。

示例 1：
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶

示例 2：
输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
</pre></div>
</div>
</div>
<div class="section" id="id53">
<h3>解题思路<a class="headerlink" href="#id53" title="永久链接至标题">¶</a></h3>
<p>| No.      | 思路     | 时间复杂度 | 空间复杂度 |
| ——– | ——– | ———- | ———- |
| 01       | 递归     | O(n)       | O(n)       |
| 02       | 动态规划 | O(n)       | O(n)       |
| 03(最优) | 斐波那契 | O(n)       | O(1)       |</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 递归</span>
<span class="kd">func</span> <span class="nx">climbStart</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="nx">n</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="nx">n</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">1</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>

	<span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">climbStart</span><span class="p">(</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span> <span class="o">+</span> <span class="nx">climbStart</span><span class="p">(</span><span class="nx">i</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
<span class="p">}</span>

<span class="c1">// 动态规划</span>
<span class="kd">func</span> <span class="nx">climbStairs</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">1</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">2</span>
	<span class="p">}</span>
	<span class="nx">dp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="nx">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
	<span class="nx">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="mi">2</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span>
<span class="p">}</span>

<span class="c1">// 斐波那契</span>
<span class="kd">func</span> <span class="nx">climbStairs</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">1</span>
	<span class="p">}</span>
	<span class="nx">first</span> <span class="o">:=</span> <span class="mi">1</span>
	<span class="nx">second</span> <span class="o">:=</span> <span class="mi">2</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">third</span> <span class="o">:=</span> <span class="nx">first</span> <span class="o">+</span> <span class="nx">second</span>
		<span class="nx">first</span> <span class="p">=</span> <span class="nx">second</span>
		<span class="nx">second</span> <span class="p">=</span> <span class="nx">third</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">second</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id54">
<h2>83.删除排序链表中的重复元素<a class="headerlink" href="#id54" title="永久链接至标题">¶</a></h2>
<div class="section" id="id55">
<h3>题目<a class="headerlink" href="#id55" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。

示例 1:
输入: 1-&gt;1-&gt;2
输出: 1-&gt;2

示例 2:
输入: 1-&gt;1-&gt;2-&gt;3-&gt;3
输出: 1-&gt;2-&gt;3
</pre></div>
</div>
</div>
<div class="section" id="id56">
<h3>解题思路<a class="headerlink" href="#id56" title="永久链接至标题">¶</a></h3>
<p>| No.       | 思路     | 时间复杂度 | 空间复杂度 |
| ——— | ——– | ———- | ———- |
| 01( 最优) | 直接法   | O(n)       | O(1)       |
| 02        | 递归法   | O(n)       | O(1)       |
| 03        | 双指针法 | O(n)       | O(1)       |</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 直接法</span>
<span class="kd">func</span> <span class="nx">deleteDuplicates</span><span class="p">(</span><span class="nx">head</span> <span class="o">*</span><span class="nx">ListNode</span><span class="p">)</span> <span class="o">*</span><span class="nx">ListNode</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">head</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="nx">temp</span> <span class="o">:=</span> <span class="nx">head</span>
	<span class="k">for</span> <span class="nx">temp</span><span class="p">.</span><span class="nx">Next</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">temp</span><span class="p">.</span><span class="nx">Val</span> <span class="o">==</span> <span class="nx">temp</span><span class="p">.</span><span class="nx">Next</span><span class="p">.</span><span class="nx">Val</span> <span class="p">{</span>
			<span class="nx">temp</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">temp</span><span class="p">.</span><span class="nx">Next</span><span class="p">.</span><span class="nx">Next</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">temp</span> <span class="p">=</span> <span class="nx">temp</span><span class="p">.</span><span class="nx">Next</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">head</span>
<span class="p">}</span>

<span class="c1">// 递归法</span>
<span class="kd">func</span> <span class="nx">deleteDuplicates</span><span class="p">(</span><span class="nx">head</span> <span class="o">*</span><span class="nx">ListNode</span><span class="p">)</span> <span class="o">*</span><span class="nx">ListNode</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">head</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">head</span><span class="p">.</span><span class="nx">Next</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">{</span>
		<span class="k">return</span> <span class="nx">head</span>
	<span class="p">}</span>
	<span class="nx">head</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">deleteDuplicates</span><span class="p">(</span><span class="nx">head</span><span class="p">.</span><span class="nx">Next</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">head</span><span class="p">.</span><span class="nx">Val</span> <span class="o">==</span> <span class="nx">head</span><span class="p">.</span><span class="nx">Next</span><span class="p">.</span><span class="nx">Val</span><span class="p">{</span>
		<span class="nx">head</span> <span class="p">=</span> <span class="nx">head</span><span class="p">.</span><span class="nx">Next</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">head</span>
<span class="p">}</span>

<span class="c1">// 双指针法</span>
<span class="kd">func</span> <span class="nx">deleteDuplicates</span><span class="p">(</span><span class="nx">head</span> <span class="o">*</span><span class="nx">ListNode</span><span class="p">)</span> <span class="o">*</span><span class="nx">ListNode</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">head</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">head</span><span class="p">.</span><span class="nx">Next</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">{</span>
		<span class="k">return</span> <span class="nx">head</span>
	<span class="p">}</span>
	<span class="nx">p</span> <span class="o">:=</span> <span class="nx">head</span>
	<span class="nx">q</span> <span class="o">:=</span> <span class="nx">head</span><span class="p">.</span><span class="nx">Next</span>
	<span class="k">for</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Next</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
		<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Val</span> <span class="o">==</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Val</span><span class="p">{</span>
			<span class="k">if</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Next</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">{</span>
				<span class="nx">p</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="kc">nil</span>
			<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
				<span class="nx">p</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Next</span>
				<span class="nx">q</span> <span class="p">=</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Next</span>
			<span class="p">}</span>
		<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
			<span class="nx">p</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Next</span>
			<span class="nx">q</span> <span class="p">=</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Next</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">head</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id57">
<h2>88.合并两个有序数组<a class="headerlink" href="#id57" title="永久链接至标题">¶</a></h2>
<div class="section" id="id58">
<h3>题目<a class="headerlink" href="#id58" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。
说明:
    初始化 nums1 和 nums2 的元素数量分别为 m 和 n。
    你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。

示例:
输入:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3
输出: [1,2,2,3,5,6]
</pre></div>
</div>
</div>
<div class="section" id="id59">
<h3>解题思路<a class="headerlink" href="#id59" title="永久链接至标题">¶</a></h3>
<p>| No.      | 思路       | 时间复杂度 | 空间复杂度 |
| ——– | ———- | ———- | ———- |
| 01       | 合并后排序 | O(nlog(n)) | O(1)       |
| 02(最优) | 双指针法   | O(n)       | O(1)       |
| 03       | 拷贝后插入 | O(n)       | O(n)       |</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 合并后排序</span>
<span class="kd">func</span> <span class="nx">merge</span><span class="p">(</span><span class="nx">n</span> <span class="nx">ums1</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">m</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">nums2</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">nums1</span> <span class="p">=</span> <span class="nx">nums1</span><span class="p">[:</span><span class="nx">m</span><span class="p">]</span>
	<span class="nx">nums1</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">nums1</span><span class="p">,</span> <span class="nx">nums2</span><span class="p">[:</span><span class="nx">n</span><span class="p">]</span><span class="o">...</span><span class="p">)</span>
	<span class="nx">sort</span><span class="p">.</span><span class="nx">Ints</span><span class="p">(</span><span class="nx">nums1</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 双指针法</span>
<span class="kd">func</span> <span class="nx">merge</span><span class="p">(</span><span class="nx">nums1</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">m</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">nums2</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">m</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">nums1</span><span class="p">[</span><span class="nx">m</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">nums2</span><span class="p">[</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span>
			<span class="nx">nums1</span><span class="p">[</span><span class="nx">m</span><span class="o">+</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums2</span><span class="p">[</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="nx">n</span><span class="o">--</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">nums1</span><span class="p">[</span><span class="nx">m</span><span class="o">+</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums1</span><span class="p">[</span><span class="nx">m</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="nx">m</span><span class="o">--</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">m</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">nums1</span><span class="p">[</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums2</span><span class="p">[</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="nx">n</span><span class="o">--</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 拷贝后插入</span>
<span class="kd">func</span> <span class="nx">merge</span><span class="p">(</span><span class="nx">nums1</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">m</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">nums2</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">temp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">m</span><span class="p">)</span>
	<span class="nb">copy</span><span class="p">(</span><span class="nx">temp</span><span class="p">,</span> <span class="nx">nums1</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">first</span><span class="p">,</span> <span class="nx">second</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums1</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">second</span> <span class="o">&gt;=</span> <span class="nx">n</span> <span class="p">{</span>
			<span class="nx">nums1</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">temp</span><span class="p">[</span><span class="nx">first</span><span class="p">]</span>
			<span class="nx">first</span><span class="o">++</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">first</span> <span class="o">&gt;=</span> <span class="nx">m</span> <span class="p">{</span>
			<span class="nx">nums1</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums2</span><span class="p">[</span><span class="nx">second</span><span class="p">]</span>
			<span class="nx">second</span><span class="o">++</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">temp</span><span class="p">[</span><span class="nx">first</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">nums2</span><span class="p">[</span><span class="nx">second</span><span class="p">]</span> <span class="p">{</span>
			<span class="nx">nums1</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">temp</span><span class="p">[</span><span class="nx">first</span><span class="p">]</span>
			<span class="nx">first</span><span class="o">++</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">nums1</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums2</span><span class="p">[</span><span class="nx">second</span><span class="p">]</span>
			<span class="nx">second</span><span class="o">++</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id60">
<h2>100.相同的树<a class="headerlink" href="#id60" title="永久链接至标题">¶</a></h2>
<div class="section" id="id61">
<h3>题目<a class="headerlink" href="#id61" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定两个二叉树，编写一个函数来检验它们是否相同。
如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

示例 1:
输入:       1         1
          / \       / \
         2   3     2   3
        [1,2,3],   [1,2,3]
输出: true

示例 2:
输入:      1          1
          /           \
         2             2
        [1,2],     [1,null,2]
输出: false

示例 3:
输入:       1         1
          / \       / \
         2   1     1   2
        [1,2,1],   [1,1,2]
输出: false
</pre></div>
</div>
</div>
<div class="section" id="id62">
<h3>解题思路<a class="headerlink" href="#id62" title="永久链接至标题">¶</a></h3>
<p>| No.  | 思路               | 时间复杂度 | 空间复杂度 |
| —- | —————— | ———- | ———- |
| 01   | 递归(深度优先)     | O(n)       | O(log(n))  |
| 02   | 层序遍历(宽度优先) | O(n)       | O(log(n))  |</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 递归(深度优先)</span>
<span class="kd">func</span> <span class="nx">isSameTree</span><span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span> <span class="nx">q</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">p</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">q</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">p</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">q</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Val</span> <span class="o">==</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Val</span> <span class="o">&amp;&amp;</span> <span class="nx">isSameTree</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="nx">isSameTree</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">Right</span><span class="p">,</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 层序遍历(宽度优先)</span>
<span class="kd">func</span> <span class="nx">isSameTree</span><span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span> <span class="nx">q</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">p</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">q</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">p</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">q</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">queueP</span><span class="p">,</span> <span class="nx">queueQ</span> <span class="p">[]</span><span class="o">*</span><span class="nx">TreeNode</span>
	<span class="k">if</span> <span class="nx">p</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">queueP</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">queueP</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span>
		<span class="nx">queueQ</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">queueQ</span><span class="p">,</span> <span class="nx">q</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">queueP</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">queueQ</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">tempP</span> <span class="o">:=</span> <span class="nx">queueP</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="nx">queueP</span> <span class="p">=</span> <span class="nx">queueP</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

		<span class="nx">tempQ</span> <span class="o">:=</span> <span class="nx">queueQ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="nx">queueQ</span> <span class="p">=</span> <span class="nx">queueQ</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

		<span class="k">if</span> <span class="nx">tempP</span><span class="p">.</span><span class="nx">Val</span> <span class="o">!=</span> <span class="nx">tempQ</span><span class="p">.</span><span class="nx">Val</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="nx">tempP</span><span class="p">.</span><span class="nx">Left</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">tempQ</span><span class="p">.</span><span class="nx">Left</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">(</span><span class="nx">tempP</span><span class="p">.</span><span class="nx">Left</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">tempQ</span><span class="p">.</span><span class="nx">Left</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">tempP</span><span class="p">.</span><span class="nx">Left</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">queueP</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">queueP</span><span class="p">,</span> <span class="nx">tempP</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
			<span class="nx">queueQ</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">queueQ</span><span class="p">,</span> <span class="nx">tempQ</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="nx">tempP</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">tempQ</span><span class="p">.</span><span class="nx">Right</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">(</span><span class="nx">tempP</span><span class="p">.</span><span class="nx">Right</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">tempQ</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">tempP</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">queueP</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">queueP</span><span class="p">,</span> <span class="nx">tempP</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
			<span class="nx">queueQ</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">queueQ</span><span class="p">,</span> <span class="nx">tempQ</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="0101-0200.html" class="btn btn-neutral float-right" title="0101-0200" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral float-left" title="Welcome to go-leetcode’s documentation!" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, willshang

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>