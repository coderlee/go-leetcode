{"./":{"url":"./","title":"Introduction","keywords":"","body":"go-Leetcode readthedoc gitbook gitbook0.参考 https://leetcode-cn.com/ 2.6k https://github.com/kylesliu/awesome-golang-leetcode 2.5k https://github.com/aQuaYi/LeetCode-in-Go 5.2k https://github.com/greyireland/algorithm-pattern1.完成的题目 Easy系列 No. Title Tag 难度 完成情况 第1期 0001 1.两数之和 数组、哈希表 Easy 完成 0002 7.整数反转 数学 Easy 完成 0003 9.回文数 数学 Easy 完成 0004 13.罗马数字转整数 数学、字符串 Easy 完成 0005 14.最长公共前缀 字符串 Easy 完成 0006 20.有效的括号 栈、字符串 Easy 完成 0007 21.合并两个有序链表 链表 Easy 完成 0008 26.删除排序数组中的重复项 数组、双指针 Easy 完成 0009 27.移除元素 数组、双指针 Easy 完成 0010 28.实现strStr() 双指针、字符串 Easy 完成 第2期 0011 35.搜索插入位置 数组、二分查找 Easy 完成 0012 38.报数 字符串 Easy 完成 0013 53.最大子序和 数组、分治算法、动态规划 Easy 完成 0014 58.最后一个单词的长度 字符串 Easy 完成 0015 66.加一 数组 Easy 完成 0016 67.二进制求和 数字、字符串 Easy 完成 0017 69.x的平方根 数学，二分查找 Easy 完成 0018 70.爬楼梯 动态规划 Easy 完成 0019 83.删除排序链表中的重复元素 链表 Easy 完成 0020 88.合并两个有序数组 数组、双指针 Easy 完成 第3期 0021 100.相同的树 树、深度优先搜索 Easy 完成 0022 101.对称二叉树 树、深度优先搜索、广度优先搜索 Easy 完成 0023 104.二叉树的最大深度 树、深度优先搜索 Easy 完成 0024 107.二叉树的层次遍历II 树、广度优先搜索 Easy 完成 0025 108.将有序数组转换为二叉搜索树 树、深度优先搜索 Easy 完成 0026 110.平衡二叉树 树、深度优先搜索 Easy 完成 0027 111.二叉树的最小深度 树、深度优先搜索、广度优先搜索 Easy 完成 0028 112.路径总和 树、深度优先搜索 Easy 完成 0029 118.杨辉三角 数组 Easy 完成 0030 119.杨辉三角II 数组 Easy 完成 第4期 0031 121.买卖股票的最佳时机 数组、动态规划 Easy 完成 0032 122.买卖股票的最佳时机II 贪心算法、数组 Easy 完成 0033 125.验证回文串 双指针、字符串 Easy 完成 0034 136.只出现一次的数字 位运算、哈希表 Easy 完成 0035 141.环形链表 链表、双指针 Easy 完成 0036 155.最小栈 栈、设计 Easy 完成 0037 160.相交链表 链表 Easy 完成 0038 167.两数之和II-输入有序数组 数组、双指针、二分查找 Easy 完成 0039 168.Excel表列名称 数学 Easy 完成 0040 169.多数元素 位运算、数组、分治算法 Easy 完成 第5期 0041 171.Excel表列序号 数学 Easy 完成 0042 172.阶乘后的零 数学 Easy 完成 0043 175.组合两个表 Mysql Easy 完成 0044 176.第二高的薪水 Mysql Easy 完成 0045 181.超过经理收入的员工 Mysql Easy 完成 0046 182.查找重复的电子邮箱 Mysql Easy 完成 0047 183.从不订购的客户 Mysql Easy 完成 0048 189.旋转数组 数组 Easy 完成 0049 190.颠倒二进制位 位运算 Easy 完成 0050 191.位1的个数 位运算 Easy 完成 第6期 0051 193.有效电话号码 Bash Easy 完成 0052 195.第十行 Bash Easy 完成 0053 196.删除重复的电子邮箱 Mysql Easy 完成 0054 197.上升的温度 Mysql Easy 完成 0055 198.打家劫舍 动态规划 Easy 完成 0056 202.快乐数 哈希表、数学 Easy 完成 0057 203.移除链表元素 链表 Easy 完成 0058 204.计数质数 哈希表、数学 Easy 完成 0059 205.同构字符串 哈希表 Easy 完成 0060 206.反转链表 链表 Easy 完成 第7期 0061 217.存在重复元素 数组、哈希表 Easy 完成 0062 219.存在重复元素II 数组、哈希表 Easy 完成 0063 225.用队列实现栈 栈、设计 Easy 完成 0064 226.翻转二叉树 树 Easy 完成 0065 231.2的幂 位运算、数学 Easy 完成 0066 232.用栈实现队列 栈、设计 Easy 完成 0067 234.回文链表 链表、双指针 Easy 完成 0068 235.二叉搜索树的最近公共祖先 树 Easy 完成 0069 237.删除链表中的节点 链表 Easy 完成 0070 242.有效的字母异位词 排序、哈希 Easy 完成 第8期 0071 257.二叉树的所有路径 树、深度优先搜索 Easy 完成 0072 258.各位相加 数学 Easy 完成 0073 263.丑数 数学 Easy 完成 0074 268.缺失数字 位运算、数组、数学 Easy 完成 0075 278.第一个错误的版本 二分查找 Easy 完成 0076 283.移动零 数组、双指针 Easy 完成 0077 290.单词规律 哈希表 Easy 完成 0078 292.Nim游戏 脑筋急转弯、极小化极大 Easy 完成 0079 299.猜数字游戏 哈希表 Easy 完成 0080 303.区域和检索-数组不可变 动态规划 Easy 完成 第9期 0081 326.3的幂 数学 Easy 完成 0082 342.4的幂 位运算 Easy 完成 0083 344.反转字符串 双指针、字符串 Easy 完成 0084 345.反转字符串中的元音字母 双指针、字符串 Easy 完成 0085 349.两个数组的交集 排序、哈希表、双指针、二分查找 Easy 完成 0086 350.两个数组的交集II 排序、哈希表、双指针、二分查找 Easy 完成 0087 367.有效的完全平方数 数学、二分查找 Easy 完成 0088 371.两整数之和 位运算 Easy 完成 0089 374.猜数字大小 二分查找 Easy 完成 0090 383.赎金信 字符串 Easy 完成 第10期 0091 387.字符串中的第一个唯一字符 哈希表、字符串 Easy 完成 0092 389.找不同 位运算、哈希表 Easy 完成 0093 392.判断子序列 贪心算法、二分查找、动态规划 Easy 完成 0094 401.二进制手表 位运算、回溯算法 Easy 完成 0095 404.左叶子之和 树 Easy 完成 0096 405.数字转换为十六进制数 位运算 Easy 完成 0097 409.最长回文串 哈希表 Easy 完成 0098 412.Fizz Buzz Easy 完成 0099 414.第三大的数 数组 Easy 完成 0100 415.字符串相加 字符串 Easy 完成 第11期 0101 434.字符串中的单词数 字符串 Easy 完成 0102 437.路径总和III 树 Easy 完成 0103 441.排列硬币 数学、二分查找 Easy 完成 0104 443.压缩字符串 字符串 Easy 完成 0105 447.回旋镖的数量 哈希表 Easy 完成 0106 448.找到所有数组中消失的数字 数组 Easy 完成 0107 453.最小移动次数使数组元素相等 数学 Easy 完成 0108 455.分发饼干 贪心算法 Easy 完成 0109 459.重复的子字符串 字符串 Easy 完成 0110 461.汉明距离 位运算 Easy 完成 第12期 0111 463.岛屿的周长 哈希表 Easy 完成 0112 475.供暖器 二分查找 Easy 完成 0113 476.数字的补数 位运算 Easy 完成 0114 482.密钥格式化 Easy 完成 0115 485.最大连续1的个数 数组 Easy 完成 0116 492.构造矩形 Easy 完成 0117 496.下一个更大元素I 栈 Easy 完成 0118 500.键盘行 哈希表 Easy 完成 0119 501.二叉搜索树中的众数 树 Easy 完成 0120 504.七进制数 Easy 完成 第13期 0121 506.相对名次 Easy 完成 0122 507.完美数 数学 Easy 完成 0123 509.斐波那契数 数组 Easy 完成 0124 520.检测大写字母 字符串 Easy 完成 0125 521.最长特殊序列Ⅰ 字符串 Easy 完成 0126 530.二叉搜索树的最小绝对差 树 Easy 完成 0127 532.数组中的K-diff数对 数组、双指针 Easy 完成 0128 538.把二叉搜索树转换为累加树 树 Easy 完成 0129 541.反转字符串II 字符串 Easy 完成 0130 543.二叉树的直径 树 Easy 完成 第14期 0131 551.学生出勤记录I 字符串 Easy 完成 0132 557.反转字符串中的单词III 字符串 Easy 完成 0133 559.N叉树的最大深度 树、深度优先搜索、广度优先搜索 Easy 完成 0134 561.数组拆分I 数组 Easy 完成 0135 563.二叉树的坡度 树 Easy 完成 0136 566.重塑矩阵 数组 Easy 完成 0137 572.另一个树的子树 树 Easy 完成 0138 575.分糖果 哈希表 Easy 完成 0139 581.最短无序连续子数组 数组 Easy 完成 0140 589.N叉树的前序遍历 树 Easy 完成 第15期 0141 590.N叉树的后序遍历 树 Easy 完成 0142 594.最长和谐子序列 哈希表 Easy 完成 0143 595.大的国家 Mysql Easy 完成 0144 596.超过5名学生的课 Mysql Easy 完成 0145 598.范围求和II 数学 Easy 完成 0146 599.两个列表的最小索引总和 哈希表 Easy 完成 0147 605.种花问题 数组 Easy 完成 0148 606.根据二叉树创建字符串 树、字符串 Easy 完成 0149 617.合并二叉树 树 Easy 完成 0150 620.有趣的电影 Mysql Easy 完成 第16期 0151 627.交换工资 Mysql Easy 完成 0152 628.三个数的最大乘积 数组、数学 Easy 完成 0153 633.平方数之和 数学 Easy 完成 0154 637.二叉树的层平均值 树 Easy 完成 0155 643.子数组最大平均数I 数组 Easy 完成 0156 645.错误的集合 哈希表、数学 Easy 完成 0157 653.两数之和IV-输入BST 树 Easy 完成 0158 657.机器人能否返回原点 字符串 Easy 完成 0159 661.图片平滑器 数组 Easy 完成 0160 665.非递减数列 数组 Easy 完成 第17期 0161 669.修剪二叉搜索树 树 Easy 完成 0162 671.二叉树中第二小的节点 树 Easy 完成 0163 674.最长连续递增序列 数组 Easy 完成 0164 680.验证回文字符串Ⅱ 字符串 Easy 完成 0165 682.棒球比赛 栈 Easy 完成 0166 686.重复叠加字符串匹配 字符串 Easy 完成 0167 687.最长同值路径 树 Easy 完成 0168 690.员工的重要性 深度优先搜索、广度优先搜索、哈希表 Easy 完成 0169 693.交替位二进制数 位运算 Easy 完成 0170 696.计数二进制子串 字符串 Easy 完成 第18期 0171 697.数组的度 数组 Easy 完成 0172 700.二叉搜索树中的搜索 树 Easy 完成 0173 703.数据流中的第K大元素 堆 Easy 完成 0174 704.二分查找 二分查找 Easy 完成 0175 705.设计哈希集合 设计、哈希表 Easy 完成 0176 706.设计哈希映射 设计、哈希表 Easy 完成 0177 709.转换成小写字母 字符串 Easy 完成 0178 717.1比特与2比特字符 数组 Easy 完成 0179 720.词典中最长的单词 字典树、哈希表 Easy 完成 0180 724.寻找数组的中心索引 数组 Easy 完成 第19期 0181 728.自除数 数学 Easy 完成 0182 733.图像渲染 深度优先搜索 Easy 完成 0183 744.寻找比目标字母大的最小字母 二分查找 Easy 完成 0184 746.使用最小花费爬楼梯 数组、动态规划 Easy 完成 0185 747.至少是其他数字两倍的最大数 数组 Easy 完成 0186 748.最短完整词 哈希表 Easy 完成 0187 762.二进制表示中质数个计算置位 位运算 Easy 完成 0188 766.托普利茨矩阵 数组 Easy 完成 0189 771.宝石与石头 哈希表 Easy 完成 0190 783.二叉搜索树节点最小距离 树、递归 Easy 完成 第20期 0191 784.字母大小写全排列 位运算、回溯算法 Easy 完成 0192 788.旋转数字 字符串 Easy 完成 0193 796.旋转字符串 Easy 完成 0194 804.唯一摩尔斯密码词 字符串 Easy 完成 0195 806.写字符串需要的行数 Easy 完成 0196 811.子域名访问计数 哈希表 Easy 完成 0197 812.最大三角形面积 数学 Easy 完成 0198 819.最常见的单词 字符串 Easy 完成 0199 821.字符的最短距离 Easy 完成 0200 824.山羊拉丁文 字符串 Easy 完成 第21期 0201 830.较大分组的位置 数组 Easy 完成 0202 832.翻转图像 数组 Easy 完成 0203 836.矩形重叠 数学 Easy 完成 0204 840.矩阵中的幻方 数组 Easy 完成 0205 844.比较含退格的字符串 栈、双指针 Easy 完成 0206 849.到最近的人的最大距离 数组 Easy 完成 0207 852.山脉数组的峰顶索引 二分查找 Easy 完成 0208 859.亲密字符串 字符串 Easy 完成 0209 860.柠檬水找零 贪心算法 Easy 完成 0210 867.转置矩阵 数组 Easy 完成 第22期 0211 868.二进制间距 数学 Easy 完成 0212 872.叶子相似的树 树、深度优先搜索 Easy 完成 0213 874.模拟行走机器人 贪心算法 Easy 完成 0214 876.链表的中间结点 链表 Easy 完成 0215 883.三维形体投影面积 数学 Easy 完成 0216 884.两句话中的不常见单词 哈希表 Easy 完成 0217 888.公平的糖果交换 数组 Easy 完成 0218 892.三维形体的表面积 几何、数学 Easy 完成 0219 893.特殊等价字符串组 字符串 Easy 完成 0220 896.单调数列 数组 Easy 完成 第23期 0221 897.递增顺序查找树 树、深度优先搜索 Easy 完成 0222 905.按奇偶排序数组 数组 Easy 完成 0223 908.最小差值I 数学 Easy 完成 0224 914.卡牌分组 数组、数学 Easy 完成 0225 917.仅仅反转字母 字符串 Easy 完成 0226 922.按奇偶排序数组II 排序、数组 Easy 完成 0227 925.长按键入 双指针、字符串 Easy 完成 0228 929.独特的电子邮件地址 字符串 Easy 完成 0229 933.最近的请求次数 队列 Easy 完成 0230 937.重新排列日志文件 字符串 Easy 完成 第24期 0231 938.二叉搜索树的范围和 树、递归 Easy 完成 0232 941.有效的山脉数组 数组 Easy 完成 0233 942.增减字符串匹配 数学 Easy 完成 0234 944.删列造序 贪心算法 Easy 完成 0235 949.给定数字能组成的最大时间 数学 Easy 完成 0236 953.验证外星语词典 哈希表 Easy 完成 0237 961.重复N次的元素 哈希表 Easy 完成 0238 965.单值二叉树 树 Easy 完成 0239 970.强整数 哈希表、数学 Easy 完成 0240 976.三角形的最大周长 排序、数学 Easy 完成 第25期 0241 977.有序数组的平方 数组、双指针 Easy 完成 0242 985.查询后的偶数和 数组 Easy 完成 0243 989.数组形式的整数加法 数组 Easy 完成 0244 993.二叉树的堂兄弟节点 树、广度优先搜索 Easy 完成 0245 997.找到小镇的法官 图 Easy 完成 0246 999.可以被一步捕获的棋子数 数组 Easy 完成 0247 1002.查找常用字符 数组、哈希表 Easy 完成 0248 1005.K次取反后最大化的数组和 贪心算法 Easy 完成 0249 1009.十进制整数的反码 数学 Easy 完成 0250 1010.总持续时间可被60整除的歌曲 数组 Easy 完成 第26期 0251 1013.将数组分成和相等的三个部分 数组 Easy 完成 0252 1018.可被5整除的二进制前缀 数组 Easy 完成 0253 1021.删除最外层的括号 栈 Easy 完成 0254 1022.从根到叶的二进制数之和 树 Easy 完成 0255 1025.除数博弈 数学、动态规划 Easy 完成 0256 1029.两地调度 贪心算法 Easy 完成 0257 1030.距离顺序排列矩阵单元格 排序 Easy 完成 0258 1033.移动石子直到连续 脑筋急转弯 Easy 完成 0259 1037.有效的回旋镖 数学 Easy 完成 0260 1042.不邻接植花 图 Easy 完成 第27期 0261 1046.最后一块石头的重量 堆、贪心算法 Easy 完成 0262 1047.删除字符串中的所有相邻重复项 栈 Easy 完成 0263 1051.高度检查器 数组 Easy 完成 0264 1071.字符串的最大公因子 字符串 Easy 完成 0265 1078.Bigram分词 哈希表 Easy 完成 0266 1089.复写零 数组 Easy 完成 0267 1103.分糖果II 数学 Easy 完成 0268 1108.IP地址无效化 字符串 Easy 完成 0269 1114.按序打印 Easy [提交没有Go语言] 0270 1122.数组的相对排序 排序、数组 Easy 完成 第28期 0271 1128.等价多米诺骨牌对的数量 数组 Easy 完成 0272 1137.第N个泰波那契数 递归 Easy 完成 0273 1154.一年中的第几天 数学 Easy 完成 0274 1160.拼写单词 数组、哈希表 Easy 完成 0275 1170.比较字符串最小字母出现频次 数组、字符串 Easy 完成 0276 1175.质数排列 数学 Easy 完成 0277 1179.重新格式化部门表 Mysql Easy 完成 0278 1184.公交站间的距离 数组 Easy 完成 0279 1185.一周中的第几天 数组 Easy 完成 0280 1189.“气球”的最大数量 哈希表、字符串 Easy 完成 第29期 0281 1200.最小绝对差 数组 Easy 完成 0282 1207.独一无二的出现次数 哈希表 Easy 完成 0283 1217.玩筹码 贪心算法、数组、数学 Easy 完成 0284 1221.分割平衡字符串 贪心算法、字符串 Easy 完成 0285 1232.缀点成线 几何、数组、数学 Easy 完成 0286 1237.找出给定方程的正整数解 数学、二分查找 Easy 完成 0287 1252.奇数值单元格的数目 数组 Easy 完成 0288 1260.二维网格迁移 数组 Easy 完成 0289 1266.访问所有点的最小时间 几何、数组 Easy 完成 0290 1275.找出井字棋的获胜者 数组 Easy 完成 第30期 0291 1281.整数的各位积和之差 数学 Easy 完成 0292 1287.有序数组中出现次数超过25%的元素 数字 Easy 完成 0293 1290.二进制链表转整数 位运算、链表 Easy 完成 0294 1295.统计位数为偶数的数字 数组 Easy 完成 0295 1299.将每个元素替换为右侧最大元素 数组 Easy 完成 0296 1304.和为零的N个唯一整数 数组 Easy 完成 0297 1309.解码字母到整数映射 字符串 Easy 完成 0298 1313.解压缩编码列表 数组 Easy 完成 0299 1317.将整数转换为两个无零整数的和 数学 Easy 完成 0300 1323.6和9组成的最大数字 数学 Easy 完成 第31期 0301 1331.数组序号转换 数组 Easy 完成 0302 1332.删除回文子序列 字符串 Easy 完成 0303 1337.方阵中战斗力最弱的K行 数组、二分查找 Easy 完成 0304 1342.将数字变成0的操作次数 位运算 Easy 完成 0305 1346.检查整数及其两倍数是否存在 数组 Easy 完成 0306 1351.统计有序矩阵中的负数 数组、二分查找 Easy 完成 0307 1356.根据数字二进制下1的数目排序 排序、位运算 Easy 完成 0308 1360.日期之间隔几天 Easy 完成 0309 1365.有多少小于当前数字的数字 数组、哈希表 Easy 完成 0310 1370.上升下降字符串 排序、字符串 Easy 完成 第32期 0311 1374.生成每种字符都是奇数个的字符串 字符串 Easy 完成 0312 1380.矩阵中的幸运数 数组 Easy 完成 0313 1385.两个数组间的距离值 数组 Easy 完成 0314 1389.按既定顺序创建目标数组 数组 Easy 完成 0315 1394.找出数组中的幸运数 数组 Easy 完成 0316 1399.统计最大组的数目 数组 Easy 完成 0317 1403.非递增顺序的最小子序列 贪心算法、排序 Easy 完成 0318 1408.数组中的字符串匹配 字符串 Easy 完成 0319 1413.逐步求和得到正数的最小值 数组 Easy 完成 0320 1417.重新格式化字符串 字符串 Easy 完成 第33期 0321 1422.分割字符串的最大得分 字符串 Easy 完成 0322 1431.拥有最多糖果的孩子 数组 Easy 完成 0323 1436.旅行终点站 字符串 Easy 完成 0324 1441.用栈操作构建数组 栈 Easy 完成 0325 1446.连续字符 字符串 Easy 完成 0326 1450.在既定时间做作业的学生人数 数组 Easy 完成 0327 1455.检查单词是否为句中其他单词的前缀 字符串 Easy 完成 0328 1460.通过翻转子数组使两个数组相等 数组 Easy 完成 0329 1464.数组中两元素的最大乘积 数组 Easy 完成 0330 1470.重新排列数组 数组 Easy 完成 第34期 0331 1475.商品折扣后的最终价格 数组 Easy 完成 0332 1480.一维数组的动态和 数组 Easy 完成 0333 1486.数组异或操作 位运算、数组 Easy 完成 0334 1491.去掉最低工资和最高工资后的工资平均值 排序、数组 Easy 完成 0335 1496.判断路径是否相交 字符串 Easy 完成 0336 1502.判断能否形成等差数列 排序、数组 Easy 完成 0337 1507.转变日期格式 字符串 Easy 完成 0338 1512.好数对的数目 数组、哈希表、数学 Easy 完成 0339 1518.换酒问题 贪心算法 Easy 完成 Medium No. Title Tag 难度 完成情况 第1期 0001 2.两数相加 链表、数学 Medium 完成 0002 3.无重复字符的最长子串 哈希表、双指针、字符串Sliding Window Medium 完成 0003 5.最长回文子串 字符串、动态规划 Medium 完成 0004 6.Z字形变换 字符串 Medium 完成 0005 8.字符串转换整数(atoi) 数字、字符串 Medium 完成 0006 11.盛最多水的容器 数组、双指针 Medium 完成 0007 12.整数转罗马数字 数学、字符串 Medium 完成 0008 15.三数之和 数组、双指针 Medium 完成 0009 16.最接近的三数之和 数组、双指针 Medium 完成 0010 17.电话号码的字母组合 字符串、回溯算法 Medium 完成 第2期 0011 18.四数之和 数组、哈希表、双指针 Medium 完成 0012 19.删除链表的倒数第N个节点 链表、双指针 Medium 完成 0013 22.括号生成 字符串、回溯算法 Medium 完成 0014 24.两两交换链表中的节点 链表 Medium 完成 0015 29.两数相除 数学、二分查找 Medium 完成 0016 31.下一个排列 数组 Medium 完成 0017 33.搜索旋转排序数组 数组、二分查找 Medium 完成 0018 34.在排序数组中查找元素的第一个和最后一个位置 数组、二分查找 Medium 完成 0019 36.有效的数独 哈希表 Medium 完成 0020 39.组合总和 数组、回溯算法 Medium 完成 第3期 0021 40.组合总和II 数组、回溯算法 Medium 完成 0022 43.字符串相乘 数学、字符串 Medium 0023 46.全排列 回溯算法 Medium 完成 0024 47.全排列II 回溯算法 Medium 完成 0025 48.旋转图像 数组 Medium 完成 0026 49.字母异位词分组 哈希表、字符串 Medium 完成 0027 50.Pow(x,n) 数学、二分查找 Medium 完成 0028 54.螺旋矩阵 数组 Medium 完成 0029 55.跳跃游戏 贪心算法、数组 Medium 完成 0030 56.合并区间 排序、数组 Medium 完成 第4期 0031 59.螺旋矩阵II 数组 Medium 完成 0032 60.第k个排列 数学、回溯算法 Medium 完成 0033 61.旋转链表 链表、双指针 Medium 完成 0034 62.不同路径 数组、动态规划 Medium 完成 0035 63.不同路径II 数组、动态规划 Medium 完成 0036 64.最小路径和 数组、动态规划 Medium 完成 0037 71.简化路径 栈、字符串 Medium 完成 0038 73.矩阵置零 数组 Medium 完成 0039 74.搜索二维矩阵 数组、二分查找 Medium 完成 0040 75.颜色分类 排序、数组、双指针 Medium 完成 第5期 0041 77.组合 回溯算法 Medium 完成 0042 78.子集 位运算、数组、回溯算法 Medium 完成 0043 79.单词搜索 数组、回溯算法 Medium 完成 0044 80.删除排序数组中的重复项II 数组、双指针 Medium 完成 0045 81.搜索旋转排序数组II 数组、二分查找 Medium 完成 0046 82.删除排序链表中的重复元素II 链表 Medium 完成 0047 86.分隔链表 链表、双指针 Medium 完成 0048 89.格雷编码 回溯算法 Medium 完成 0049 90.子集II 数组、回溯算法 Medium 0050 91.解码方法 字符串、动态规划 Medium 完成 第6期 0051 92.反转链表II 链表 Medium 完成 0052 93.复原IP地址 字符串、回溯算法 Medium 完成 0053 94.二叉树的中序遍历 栈、树、哈希表 Medium 完成 0054 95.不同的二叉搜索树II 树、动态规划 Medium 0055 96.不同的二叉搜索树 树、动态规划 Medium 完成 0056 98.验证二叉搜索树 树、深度优先搜索 Medium 完成 0057 102.二叉树的层序遍历 树、广度优先搜索 Medium 完成 0058 103.二叉树的锯齿形层次遍历 栈、树、广度优先搜索 Medium 完成 0059 105.从前序与中序遍历序列构造二叉树 树、深度优先搜索、数组 Medium 完成 0060 106.从中序与后序遍历序列构造二叉树 树、深度优先搜索、数组 Medium 完成 第7期 0061 109.有序链表转换二叉搜索树 深度优先搜索、链表 Medium 完成 0062 113.路径总和II 树、深度优先搜索 Medium 完成 0063 114.二叉树展开为链表 树、深度优先搜索 Medium 完成 0064 116.填充每个节点的下一个右侧节点指针 树、深度优先搜索 Medium 0065 117.填充每个节点的下一个右侧节点指针II 树、深度优先搜索 Medium 0066 120.三角形最小路径和 数组、动态规划 Medium 完成 0067 127.单词接龙 广度优先搜索 Medium 0068 129.求根到叶子节点数字之和 树、深度优先搜索 Medium 完成 0069 130.被围绕的区域 深度优先搜索、广度优先搜索、并查集 Medium 完成 0070 131.分割回文串 回溯算法 Medium 完成 第8期 0071 133.克隆图 深度优先搜索、广度优先搜索、图 Medium 0072 134.加油站 贪心算法 Medium 完成 0073 137.只出现一次的数字II 位运算 Medium 完成 0074 138.复制带随机指针的链表 哈希表、链表 Medium 0075 139.单词拆分 动态规划 Medium 完成 0076 142.环形链表II 链表、双指针 Medium 0077 143.重排链表 链表 Medium 0078 144.二叉树的前序遍历 栈、树 Medium 完成 0079 146.LRU缓存机制 设计 Medium 0080 147.对链表进行插入排序 排序、链表 Medium 第9期 0081 148.排序链表 排序、链表 Medium 0082 150.逆波兰表达式求值 栈 Medium 完成 0083 151.翻转字符串里的单词 字符串 Medium 完成 0084 152.乘积最大子数组 数组、动态规划 Medium 完成 0085 153.寻找旋转排序数组中的最小值 数组、二分查找 Medium 完成 0086 162.寻找峰值 数组、二分查找 Medium 完成 0087 165.比较版本号 字符串 Medium 完成 0088 166.分数到小数 哈希表、数学 Medium 0089 173.二叉搜索树迭代器 栈、树、设计 Medium 0090 177.第N高的薪水 Mysql Medium 第10期 0091 178.分数排名 Mysql Medium 0092 179.最大数 排序 Medium 完成 0093 180.连续出现的数字 Mysql Medium 0094 184.部门工资最高的员工 Mysql Medium 0095 187.重复的DNA序列 位运算、哈希表 Medium 0096 192.统计词频 Bash Medium 0097 194.转置文件 Bash Medium 0098 199.二叉树的右视图 树、深度优先搜索、广度优先搜索 Medium 完成 0099 200.岛屿数量 深度优先搜索、广度优先搜索、并查集 Medium 完成 0100 201.数字范围按位与 位运算 Medium 第11期 0101 207.课程表 深度优先搜索、广度优先搜索、图、拓扑排序 Medium 0102 208.实现 Trie (前缀树) 设计、字典树 Medium 0103 209.长度最小的子数组 数组、双指针、二分查找 Medium 216.组合总和III 数组、回溯算法 Medium 完成 第x期 384.打乱数组 Medium 完成 498.对角线遍历 Medium 1418.点菜展示表 哈希表 Medium 完成 1442.形成两个异或相等数组的三元组数目 位运算、数组、数学 Medium 完成 1487.保证文件名唯一 哈希表、字符串 Medium 完成 1492.n的第k个因子 数学 Medium 完成 1493.删掉一个元素以后全为1的最长子数组 数组 Medium 完成 1508.子数组和排序后的区间和 排序、数组 Medium 完成 1509.三次操作后最大值与最小值的最小差 排序、数组 Medium 完成 1513.仅含1的子串数 数学、字符串 Medium 完成 1514.概率最大的路径 图 Medium Hard No. Title Tag 难度 完成情况 第1期 0001 4.寻找两个正序数组的中位数 数组、二分查找、分治算法 Hard Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-07-27 09:34:47 "},"docs/source/question/readme.html":{"url":"docs/source/question/readme.html","title":"题目","keywords":"","body":"Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-07-27 11:01:52 "},"docs/source/question/0001-0100.html":{"url":"docs/source/question/0001-0100.html","title":"0001-0100","keywords":"","body":"0001-0100-Easy 0001-0100-Easy 1.两数之和(3) 7.整数反转(2) 9.回文数(3) 13.罗马数字转整数(2) 14.最长公共前缀(6) 20.有效的括号(3) 21.合并两个有序链表(3) 26.删除排序数组中的重复项(2) 27.移除元素(3) 28.实现strStr()(4) 35.搜索插入位置(3) 38.报数(2) 53.最大子序和(5) 58.最后一个单词的长度(2) 66.加一(2) 67.二进制求和(2) 69.x的平方根 (5) 70.爬楼梯(3) 83.删除排序链表中的重复元素(3) 88.合并两个有序数组(3) 100.相同的树(2) 1.两数之和(3) 题目 给定一个整数数组 nums 和一个目标值 target， 请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例:给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 解答思路 No. 思路 时间复杂度 空间复杂度 01 暴力法: 2层循环遍历 O(n^2) O(1) 02 两遍哈希遍历 O(n) O(n) 03(最优) 一遍哈希遍历 O(n) O(n) # 暴力法: 2层循环遍历 func twoSum(nums []int, target int) []int { for i := 0; i 7.整数反转(2) 题目 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1:输入: 123 输出: 321 示例 2:输入: -123 输出: -321 示例 3:输入: 120 输出: 21 注意:假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31, 2^31 − 1]。 请根据这个假设，如果反转后整数溢出那么就返回 0。 解答思路 No. 思路 时间复杂度 空间复杂度 01 使用符号标记，转成正数，循环得到%10的余数，再加上符号 O(log(x)) O(1) 02(最优) 对x进行逐个%10取个位，一旦溢出，直接跳出循环 O(log(x)) O(1) // 使用符号标记，转成正数，循环得到%10的余数，再加上符号 func reverse(x int) int { flag := 1 if x 0 { temp := x % 10 x = x / 10 result = result*10 + temp } result = flag * result if result > math.MaxInt32 || result math.MaxInt32 || result 9.回文数(3) 题目 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1: 输入: 121 输出: true 示例 2:输入: -121 输出: false 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3:输入: 10 输出: false 解释: 从右向左读, 为 01 。因此它不是一个回文数。 进阶: 你能不将整数转为字符串来解决这个问题吗？ 解答思路 No. 思路 时间复杂度 空间复杂度 01(最优) 数学解法，取出后半段数字进行翻转，然后判断是否相等 O(log(x)) O(1) 02 转成字符串，依次判断 O(log(x)) O(log(x)) 03 转成byte数组，依次判断，同2 O(log(x)) O(log(x)) // 数学解法，取出后半段数字进行翻转，然后判断是否相等 func isPalindrome(x int) bool { if x revertedNumber { temp := x % 10 revertedNumber = revertedNumber*10 + temp x = x / 10 } // for example: // x = 1221 => x = 12 revertedNumber = 12 // x = 12321 => x = 12 revertedNumber = 123 return x == revertedNumber || x == revertedNumber/10 } // 转成字符串，依次判断 func isPalindrome(x int) bool { if x 13.罗马数字转整数(2) 题目 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。 但也存在特例，例如 4 不写做 IIII，而是 IV。 数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。 同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1:输入: \"III\" 输出: 3 示例 2: 输入: \"IV\" 输出: 4 示例 3: 输入: \"IX\" 输出: 9 示例 4: 输入: \"LVIII\" 输出: 58 解释: L = 50, V= 5, III = 3. 示例 5: 输入: \"MCMXCIV\" 输出: 1994 解释: M = 1000, CM = 900, XC = 90, IV = 4. 解答思路 No. 思路 时间复杂度 空间复杂度 01 本质上其实就是全部累加，然后遇到特殊的就做判断。使用一个字段记录递增 O(n) O(1) 02(最优) 从右到左遍历字符串，如果当前字符代表的值不小于其右边，就加上该值；否则就减去该值。 O(n) O(1) // 带标记位 func romanToInt(s string) int { m := map[byte]int{ 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000, } result := 0 last := 0 for i := len(s) - 1; i >= 0; i-- { current := m[s[i]] flag := 1 if current = 0; i-- { current := m[s[i]] if current 14.最长公共前缀(6) 题目 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 \"\"。 示例 1:输入: [\"flower\",\"flow\",\"flight\"] 输出: \"fl\" 示例 2:输入: [\"dog\",\"racecar\",\"car\"] 输出: \"\" 解释: 输入不存在公共前缀。 说明: 所有输入只包含小写字母 a-z 。 解答思路 No. 思路 时间复杂度 空间复杂度 01 先找最短的一个字符串，依次比较最短字符串子串是否是其他字符串子串 O(n^2)/O(n*m) O(1) 02 纵向扫描(暴力法):直接取第一个字符串作为最长公共前缀，将其每个字符遍历过一次 O(n^2)/O(n*m) O(1) 03(最优) 排序后，然后计算第一个，和最后一个字符串的最长前缀 O(nlog(n)) O(1) 04 trie树 O(n^2) O(n^2) 05 水平扫描法:比较前2个字符串得到最长前缀，然后跟第3个比较得到一个新的最长前缀，继续比较，直到最后 O(n^2)/O(n*m) O(1) 06 分治法 O(n^2) O(1) // 先找最短的一个字符串，依次比较最短字符串子串是否是其他字符串子串 func longestCommonPrefix(strs []string) string { if len(strs) == 0{ return \"\" } if len(strs) == 1{ return strs[0] } short := strs[0] for _, s := range strs{ if len(short) > len(s){ short = s } } for i := range short{ shortest := short[:i+1] for _,str := range strs{ if strings.Index(str,shortest) != 0{ return short[:i] } } } return short } // 暴力法:直接依次遍历 func longestCommonPrefix(strs []string) string { if len(strs) == 0 { return \"\" } if len(strs) == 1 { return strs[0] } length := 0 for i := 0; i = len(strs[j]) || char != strs[j][i] { return strs[0][:length] } } length++ } return strs[0][:length] } // 排序后，遍历比较第一个，和最后一个字符串 func longestCommonPrefix(strs []string) string { if len(strs) == 0{ return \"\" } if len(strs) == 1{ return strs[0] } sort.Strings(strs) first := strs[0] last := strs[len(strs)-1] i := 0 length := len(first) if len(last) retValue { minValue = retValue } } return strs[0][:minValue] } func insert(str string) int { p := 0 count := 0 for i := 0; i = len(str2) || char != str2[i] { return str1[:length] } length++ } return str1[:length] } // 分治法 func longestCommonPrefix(strs []string) string { if len(strs) == 0 { return \"\" } if len(strs) == 1 { return strs[0] } return commonPrefix(strs, 0, len(strs)-1) } func commonPrefix(strs []string, left, right int) string { if left == right { return strs[left] } middle := (left + right) / 2 leftStr := commonPrefix(strs, left, middle) rightStr := commonPrefix(strs, middle+1, right) return commonPrefixWord(leftStr, rightStr) } func commonPrefixWord(leftStr, rightStr string) string { if len(leftStr) > len(rightStr) { leftStr = leftStr[:len(rightStr)] } if len(leftStr) 20.有效的括号(3) 题目 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例 1: 输入: \"()\" 输出: true 示例 2: 输入: \"()[]{}\" 输出: true 示例 3: 输入: \"(]\" 输出: false 示例 4: 输入: \"([)]\" 输出: false 示例 5: 输入: \"{[]}\" 输出: true 解题思路 No. 思路 时间复杂度 空间复杂度 01 使用栈结构实现栈 O(n) O(n) 02 借助数组实现栈 O(n) O(n) 03 借助数组实现栈，使用数字表示来匹配 O(n) O(n) // 使用栈结构实现 func isValid(s string) bool { st := new(stack) for _, char := range s { switch char { case '(', '[', '{': st.push(char) case ')', ']', '}': ret, ok := st.pop() if !ok || ret != match[char] { return false } } } if len(*st) > 0 { return false } return true } var match = map[rune]rune{ ')': '(', ']': '[', '}': '{', } type stack []rune func (s *stack) push(b rune) { *s = append(*s, b) } func (s *stack) pop() (rune, bool) { if len(*s) > 0 { res := (*s)[len(*s)-1] *s = (*s)[:len(*s)-1] return res, true } return 0, false } // 借助数组实现栈 func isValid(s string) bool { if s == \"\" { return true } stack := make([]rune, len(s)) length := 0 var match = map[rune]rune{ ')': '(', ']': '[', '}': '{', } for _, char := range s { switch char { case '(', '[', '{': stack[length] = char length++ case ')', ']', '}': if length == 0 { return false } if stack[length-1] != match[char]{ return false } else { length-- } } } return length == 0 } // 借助数组实现栈，使用数字表示来匹配 func isValid(s string) bool { if s == \"\" { return true } stack := make([]int, len(s)) length := 0 var match = map[rune]int{ ')': 1, '(': -1, ']': 2, '[': -2, '}': 3, '{': -3, } for _, char := range s { switch char { case '(', '[', '{': stack[length] = match[char] length++ case ')', ']', '}': if length == 0 { return false } if stack[length-1]+match[char] != 0 { return false } else { length-- } } } return length == 0 } 21.合并两个有序链表(3) 题目 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例：输入：1->2->4, 1->3->4 输出：1->1->2->3->4->4 解题思路 No. 思路 时间复杂度 空间复杂度 01(最优) 迭代遍历 O(n) O(1) 02 递归实现 O(n) O(n) 03 迭代 O(n) O(1) // 迭代遍历 func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode { if l1 == nil { return l2 } if l2 == nil { return l1 } var head, node *ListNode if l1.Val 26.删除排序数组中的重复项(2) 题目 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。 你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。 for (int i = 0; i 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针法 O(n) O(1) 02(最优) 计数法 O(n) O(1) // 双指针法 func removeDuplicates(nums []int) int { i , j , length := 0, 1, len(nums) for ; j 27.移除元素(3) 题目 给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。 注意这五个元素可为任意顺序。 你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝 int len = removeElement(nums, val); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。 for (int i = 0; i 解题思路 No. 思路 时间复杂度 空间复杂度 01(最优) 双指针，数字前移 O(n) O(1) 02 双指针，出现重复最后数字前移 O(n) O(1) 03 首位指针法 O(n) O(1) // 双指针，数字前移 func removeElement(nums []int, val int) int { i := 0 for j := 0; j = 0 && nums[j] == val { j-- } if i >= j { break } // fmt.Println(i,j) nums[i], nums[j] = nums[j], nums[i] } return i } 28.实现strStr()(4) 题目 实现 strStr() 函数。 给定一个 haystack 字符串和一个 needle 字符串， 在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。 如果不存在，则返回-1。 示例 1:输入: haystack = \"hello\", needle = \"ll\" 输出: 2 示例 2: 输入: haystack = \"aaaaa\", needle = \"bba\" 输出: -1 说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。 这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。 解题思路 No. 思路 时间复杂度 空间复杂度 01(最优) Sunday算法 O(n) O(1) 02 直接匹配 O(n) O(1) 03 系统函数 O(n) O(1) 04 kmp算法 O(n) O(n) // Sunday算法 func strStr(haystack string, needle string) int { if needle == \"\"{ return 0 } if len(needle) > len(haystack){ return -1 } // 计算模式串needle的偏移量 m := make(map[int32]int) for k,v := range needle{ m[v] = len(needle)-k } index := 0 for index+len(needle) = len(haystack){ return -1 } // 后一位字符串 next := haystack[index+len(needle)] if nextStep,ok := m[int32(next)];ok{ index = index+nextStep }else { index = index+len(needle)+1 } } } if index + len(needle) >= len(haystack){ return -1 }else { return index } } // func strStr(haystack string, needle string) int { hlen, nlen := len(haystack), len(needle) for i := 0; i 35.搜索插入位置(3) 题目 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。 如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例 1: 输入: [1,3,5,6], 5 输出: 2 示例 2: 输入: [1,3,5,6], 2 输出: 1 示例 3: 输入: [1,3,5,6], 7 输出: 4 示例 4: 输入: [1,3,5,6], 0 输出: 0 解题思路 No. 思路 时间复杂度 空间复杂度 01(最优) 二分查找 O(log(n)) O(1) 02 顺序查找 O(n) O(1) 03 顺序查找 O(n) O(1) // 二分查找 func searchInsert(nums []int, target int) int { low, high := 0, len(nums)-1 for low target: high = mid - 1 default: return mid } } return low } // 顺序查找 func searchInsert(nums []int, target int) int { i := 0 for i = target { return i } } return len(nums) } 38.报数(2) 题目 报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下： 1. 1 2. 11 3. 21 4. 1211 5. 111221 1 被读作 \"one 1\" (\"一个一\") , 即 11。 11 被读作 \"two 1s\" (\"两个一\"）, 即 21。 21 被读作 \"one 2\", \"one 1\" （\"一个二\" , \"一个一\") , 即 1211。 给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。 注意：整数顺序将表示为一个字符串。 示例 1:输入: 1 输出: \"1\" 示例 2: 输入: 4 输出: \"1211\" 解题思路 No. 思路 时间复杂度 空间复杂度 01 (最优) 递推+双指针计数 O(n^2) O(1) 02 递归+双指针计数 O(n^2) O(n) // 递推+双指针计数 func countAndSay(n int) string { strs := []byte{'1'} for i := 1; i 53.最大子序和(5) 题目 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 解题思路 No. 思路 时间复杂度 空间复杂度 01(最优) 贪心法 O(n) O(1) 02 暴力法 O(n^2) O(1) 03 动态规划 O(n) O(n) 04 动态规划 O(n) O(1) 05 分治 O(nlog(n)) O(log(n)) // 贪心法 func maxSubArray(nums []int) int { result := nums[0] sum := 0 for i := 0; i 0 { sum += nums[i] } else { sum = nums[i] } if sum > result { result = sum } } return result } // 暴力法 func maxSubArray(nums []int) int { result := math.MinInt32 for i := 0; i result { result = sum } } } return result } // func maxSubArray(nums []int) int { dp := make([]int, len(nums)) dp[0] = nums[0] result := nums[0] for i := 1; i nums[i] { dp[i] = dp[i-1] + nums[i] } else { dp[i] = nums[i] } if dp[i] > result { result = dp[i] } } return result } // 动态规划 func maxSubArray(nums []int) int { dp := nums[0] result := dp for i := 1; i nums[i] { dp = dp + nums[i] } else { dp = nums[i] } if dp > result { result = dp } } return result } // 分治法 func maxSubArray(nums []int) int { result := maxSubArr(nums, 0, len(nums)-1) return result } func maxSubArr(nums []int, left, right int) int { if left == right { return nums[left] } mid := (left + right) / 2 leftSum := maxSubArr(nums, left, mid) // 最大子序在左边 rightSum := maxSubArr(nums, mid+1, right) // 最大子序在右边 midSum := findMaxArr(nums, left, mid, right) // 跨中心 result := max(leftSum, rightSum) result = max(result, midSum) return result } func findMaxArr(nums []int, left, mid, right int) int { leftSum := math.MinInt32 sum := 0 // 从右到左 for i := mid; i >= left; i-- { sum += nums[i] leftSum = max(leftSum, sum) } rightSum := math.MinInt32 sum = 0 // 从左到右 for i := mid + 1; i b { return a } return b } 58.最后一个单词的长度(2) 题目 给定一个仅包含大小写字母和空格 ' ' 的字符串，返回其最后一个单词的长度。 如果不存在最后一个单词，请返回 0 。 说明：一个单词是指由字母组成，但不包含任何空格的字符串。 示例: 输入: \"Hello World\" 输出: 5 解题思路 No. 思路 时间复杂度 空间复杂度 01(最优) 调用系统函数，切割为数组取最后一个值 O(n) O(1) 02 遍历统计 O(n) O(1) // 调用系统函数，切割为数组取最后一个值 func lengthOfLastWord(s string) int { arr := strings.Split(strings.Trim(s, \" \"), \" \") return len(arr[len(arr)-1]) } // 遍历统计 func lengthOfLastWord(s string) int { length := len(s) if length == 0 { return 0 } result := 0 for i := length - 1; i >= 0; i-- { if s[i] == ' ' { if result > 0 { return result } continue } result++ } return result } 66.加一(2) 题目 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1: 输入: [1,2,3] 输出: [1,2,4] 解释: 输入数组表示数字 123。 示例 2: 输入: [4,3,2,1] 输出: [4,3,2,2] 解释: 输入数组表示数字 4321。 解题思路 No. 思路 时间复杂度 空间复杂度 01 直接模拟 O(n) O(1) 02(最优) 直接模拟 O(n) O(1) // 模拟进位 func plusOne(digits []int) []int { length := len(digits) if length == 0 { return []int{1} } digits[length-1]++ for i := length - 1; i > 0; i-- { if digits[i] 9 { digits[0] = digits[0] - 10 digits = append([]int{1}, digits...) } return digits } // 模拟进位 func plusOne(digits []int) []int { for i := len(digits) - 1; i >= 0; i-- { if digits[i] 67.二进制求和(2) 题目 给定两个二进制字符串，返回他们的和（用二进制表示）。 输入为非空字符串且只包含数字 1 和 0。 示例 1: 输入: a = \"11\", b = \"1\" 输出: \"100\" 示例 2:输入: a = \"1010\", b = \"1011\" 输出: \"10101\" 解题思路 No. 思路 时间复杂度 空间复杂度 01 转换成数组模拟 O(n) O(n) 02(最优) 直接模拟 O(n) O(1) // 转换成数组模拟 func addBinary(a string, b string) string { if len(a) = 1; i-- { temp := result[i] + a[i-1] + b[i-1] result[i] = temp % 2 result[i-1] = temp / 2 } i := 0 for i = 0 || j >= 0 { intA, intB := 0, 0 if i >= 0 { intA = int(a[i] - '0') } if j >= 0 { intB = int(b[j] - '0') } current = intA + intB + flag flag = 0 if current >= 2 { flag = 1 current = current - 2 } cur := strconv.Itoa(current) result = cur + result i-- j-- } if flag == 1 { result = \"1\" + result } return result } 69.x的平方根 (5) 题目 实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 示例 1:输入: 4 输出: 2 示例 2:输入: 8 输出: 2 说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 解题思路 No. 思路 时间复杂度 空间复杂度 01 系统函数 O(log(n)) O(1) 02 系统函数 O(log(n)) O(1) 03(最优) 牛顿迭代法 O(log(n)) O(1) 04 二分查找法 O(log(n)) O(1) 05 暴力法:遍历 O(n) O(1) // 系统函数 func mySqrt(x int) int { result := int(math.Sqrt(float64(x))) return result } // 系统函数 func mySqrt(x int) int { result := math.Floor(math.Sqrt(float64(x))) return int(result) } // 牛顿迭代法 func mySqrt(x int) int { result := x for result*result > x { result = (result + x/result) / 2 } return result } // 二分查找法 func mySqrt(x int) int { left := 1 right := x for left 70.爬楼梯(3) 题目 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。 1. 1 阶 + 1 阶 2. 2 阶 示例 2： 输入： 3 输出： 3 解释： 有三种方法可以爬到楼顶。 1. 1 阶 + 1 阶 + 1 阶 2. 1 阶 + 2 阶 3. 2 阶 + 1 阶 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(n) 02 动态规划 O(n) O(n) 03(最优) 斐波那契 O(n) O(1) // 递归 var arr []int func climbStairs(n int) int { arr = make([]int, n+1) return climbStart(0, n) } func climbStart(i, n int) int { if i > n { return 0 } if i == n { return 1 } if arr[i] > 0 { return arr[i] } arr[i] = climbStart(i+1, n) + climbStart(i+2, n) return arr[i] } // 动态规划 func climbStairs(n int) int { if n == 1 { return 1 } if n == 2 { return 2 } dp := make([]int, n+1) dp[1] = 1 dp[2] = 2 for i := 3; i 83.删除排序链表中的重复元素(3) 题目 给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 示例 1:输入: 1->1->2 输出: 1->2 示例 2:输入: 1->1->2->3->3 输出: 1->2->3 解题思路 No. 思路 时间复杂度 空间复杂度 01( 最优) 直接法 O(n) O(1) 02 递归法 O(n) O(1) 03 双指针法 O(n) O(1) // 直接法 func deleteDuplicates(head *ListNode) *ListNode { if head == nil { return nil } temp := head for temp.Next != nil { if temp.Val == temp.Next.Val { temp.Next = temp.Next.Next } else { temp = temp.Next } } return head } // 递归法 func deleteDuplicates(head *ListNode) *ListNode { if head == nil || head.Next == nil{ return head } head.Next = deleteDuplicates(head.Next) if head.Val == head.Next.Val{ head = head.Next } return head } // 双指针法 func deleteDuplicates(head *ListNode) *ListNode { if head == nil || head.Next == nil{ return head } p := head q := head.Next for p.Next != nil{ if p.Val == q.Val{ if q.Next == nil{ p.Next = nil }else { p.Next = q.Next q = q.Next } }else { p = p.Next q = q.Next } } return head } 88.合并两个有序数组(3) 题目 给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 示例:输入: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3 输出: [1,2,2,3,5,6] 解题思路 No. 思路 时间复杂度 空间复杂度 01 合并后排序 O(nlog(n)) O(1) 02(最优) 双指针法 O(n) O(1) 03 拷贝后插入 O(n) O(n) // 合并后排序 func merge(n ums1 []int, m int, nums2 []int, n int) { nums1 = nums1[:m] nums1 = append(nums1, nums2[:n]...) sort.Ints(nums1) } // 双指针法 func merge(nums1 []int, m int, nums2 []int, n int) { for m > 0 && n > 0 { if nums1[m-1] 0 { for n > 0 { nums1[n-1] = nums2[n-1] n-- } } } // 拷贝后插入 func merge(nums1 []int, m int, nums2 []int, n int) { temp := make([]int, m) copy(temp, nums1) if n == 0 { return } first, second := 0, 0 for i := 0; i = n { nums1[i] = temp[first] first++ continue } if first >= m { nums1[i] = nums2[second] second++ continue } if temp[first] 100.相同的树(2) 题目 给定两个二叉树，编写一个函数来检验它们是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 示例 1: 输入: 1 1 / \\ / \\ 2 3 2 3 [1,2,3], [1,2,3] 输出: true 示例 2: 输入: 1 1 / \\ 2 2 [1,2], [1,null,2] 输出: false 示例 3: 输入: 1 1 / \\ / \\ 2 1 1 2 [1,2,1], [1,1,2] 输出: false 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归(深度优先) O(n) O(log(n)) 02 层序遍历(宽度优先) O(n) O(log(n)) // 递归(深度优先) func isSameTree(p *TreeNode, q *TreeNode) bool { if p == nil && q == nil { return true } if p == nil || q == nil { return false } return p.Val == q.Val && isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right) } // 层序遍历(宽度优先) func isSameTree(p *TreeNode, q *TreeNode) bool { if p == nil && q == nil { return true } if p == nil || q == nil { return false } var queueP, queueQ []*TreeNode if p != nil { queueP = append(queueP, p) queueQ = append(queueQ, q) } for len(queueP) > 0 && len(queueQ) > 0 { tempP := queueP[0] queueP = queueP[1:] tempQ := queueQ[0] queueQ = queueQ[1:] if tempP.Val != tempQ.Val { return false } if (tempP.Left != nil && tempQ.Left == nil) || (tempP.Left == nil && tempQ.Left != nil) { return false } if tempP.Left != nil { queueP = append(queueP, tempP.Left) queueQ = append(queueQ, tempQ.Left) } if (tempP.Right != nil && tempQ.Right == nil) || (tempP.Right == nil && tempQ.Right != nil) { return false } if tempP.Right != nil { queueP = append(queueP, tempP.Right) queueQ = append(queueQ, tempQ.Right) } } return true } 0001-0100-Medium 2.两数相加(2) 题目 给出两个 非空 的链表用来表示两个非负的整数。 其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例：输入：(2 -> 4 -> 3) + (5 -> 6 -> 4) 输出：7 -> 0 -> 8 原因：342 + 465 = 807 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(n) 02 递归 O(n) O(n) func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { res := &ListNode{} cur := res carry := 0 for l1 != nil || l2 != nil || carry > 0 { sum := carry if l1 != nil { sum += l1.Val l1 = l1.Next } if l2 != nil { sum += l2.Val l2 = l2.Next } carry = sum / 10 // 进位 cur.Next = &ListNode{Val: sum % 10} cur = cur.Next } return res.Next } # func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { if l1 == nil && l2 == nil { return nil } if l1 == nil { return l2 } if l2 == nil { return l1 } sum := l1.Val + l2.Val res := &ListNode{Val: sum % 10} if sum >= 10 { l1.Next = addTwoNumbers(l1.Next, &ListNode{Val: 1}) } res.Next = addTwoNumbers(l1.Next, l2.Next) return res } 3.无重复字符的最长子串(3) 题目 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1:输入: \"abcabcbb\"输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。 示例 2:输入: \"bbbbb\" 输出: 1 解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。 示例 3:输入: \"pwwkew\" 输出: 3 解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。 同剑指offer面试题48.最长不含重复字符的子字符串 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组辅助-双指针 O(n) O(1) 02 双指针-内置函数 O(n^2) O(1) 03 哈希辅助-双指针 O(n) O(1) 04 动态规划 O(n) O(n) func lengthOfLongestSubstring(s string) int { arr := [256]int{} for i := range arr { arr[i] = -1 } max, j := 0, 0 for i := 0; i = j { j = arr[s[i]] + 1 } else if i+1-j > max { max = i + 1 - j } arr[s[i]] = i } return max } # func lengthOfLongestSubstring(s string) int { max, j := 0, 0 for i := 0; i max { max = i - j } j = j + index + 1 } if len(s)-j > max { max = len(s) - j } return max } # func lengthOfLongestSubstring(s string) int { m := make(map[uint8]int) max, j := 0, 0 for i := 0; i = j { j = v + 1 } else if i+1-j > max { max = i + 1 - j } m[s[i]] = i } return max } # func lengthOfLongestSubstring(s string) int { if len(s) dp[i-1] { dp[i] = dp[i-1] + 1 } else { dp[i] = i - index } m[s[i]] = i if dp[i] > res { res = dp[i] } } return res } 5.最长回文子串(5) 题目 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1：输入: \"babad\"输出: \"bab\" 注意: \"aba\" 也是一个有效答案。 示例 2：输入: \"cbbd\" 输出: \"bb\" 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n^2) O(n^2) 02 中心扩展 O(n^2) O(1) 03 暴力法 O(n^3) O(1) 04 Manacher算法 O(n^2) O(n) 05 Manacher算法 O(n) O(n) // dp(l,r)=dp(l+1,r−1)&&(s[l]==s[r]) // dp[l,r]：字符串s从索引l到r的子串是否是回文串 func longestPalindrome(s string) string { if len(s) max { max = r - l + 1 start = l } } } } return s[start : start+max] } # 2 func longestPalindrome(s string) string { if len(s) end-start { start, end = left1, right1 } if right2-left2 > end-start { start, end = left2, right2 } } return s[start : end+1] } func find(s string, left, right int) (int, int) { for ; 0 max { max = curLength begin = (i - max) / 2 } } return s[begin : begin+max] } func search(s string, center int) int { i := center - 1 j := center + 1 step := 0 for ; i >= 0 && j = 0 && right maxRight { maxRight = i + temp[i] center = i } if temp[i] > max { max = temp[i] begin = (i - max) / 2 } } return s[begin : begin+max] } func add(s string) string { var res []rune for _, v := range s { res = append(res, '#') res = append(res, v) } res = append(res, '#') return string(res) } func min(a, b int) int { if a > b { return b } return a } 6.Z字形变换(2) 题目 将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 \"LEETCODEISHIRING\" 行数为 3 时，排列如下： L C I R E T O E S I I G E D H N 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：\"LCIRETOESIIGEDHN\"。 请你实现这个将字符串进行指定行数变换的函数： string convert(string s, int numRows); 示例 1:输入: s = \"LEETCODEISHIRING\", numRows = 3 输出: \"LCIRETOESIIGEDHN\" 示例 2:输入: s = \"LEETCODEISHIRING\", numRows = 4 输出: \"LDREOEIIECIHNTSG\" 解释: L D R E O E I I E C I H N T S G 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(n) 02 遍历 O(n) O(n) func convert(s string, numRows int) string { if numRows == 1 { return s } arr := []rune(s) total := numRows*2 - 2 res := make([]string, numRows) for i := 0; i 8.字符串转换整数 (atoi)(3) 题目 请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下： 如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。 假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。 该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时， 则你的函数不需要进行转换，即无法进行有效转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0 。 提示： 本题中的空白字符只包括空格字符 ' ' 。 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。 如果数值超过这个范围，请返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 示例 1:输入: \"42\" 输出: 42 示例 2:输入: \" -42\" 输出: -42 解释: 第一个非空白字符为 '-', 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 示例 3:输入: \"4193 with words\" 输出: 4193 解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。 示例 4:输入: \"words and 987\" 输出: 0 解释: 第一个非空字符是 'w', 但它不是数字或正、负号。 因此无法执行有效的转换。 示例 5:输入: \"-91283472332\" 输出: -2147483648 解释: 数字 \"-91283472332\" 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(n) 02 正则 O(n) O(n) 03 遍历 O(n) O(n) func myAtoi(str string) int { i := 0 for i = '0' && str[j] 0 { break } if str[j] != ' ' && str[j] != '+' && str[j] != '-' { return 0 } if isFlag != ' ' { return 0 } isFlag = str[j] } } res := 0 for i := 0; i math.MaxInt32 { return math.MaxInt32 } } } if isFlag == '-' { return -1 * res } return res } # func myAtoi(str string) int { re := regexp.MustCompile(`^[+-]?\\d+`) arrS := re.FindAllString(strings.Trim(str, \" \"), -1) if len(arrS) == 0{ return 0 } arr := arrS[0] res := 0 isFlag := byte(' ') if !(arr[0] >= '0' && arr[0] 214748364 || (res==214748364 && value >= 8) { return math.MinInt32 } } else if isFlag == ' ' || isFlag == '+' { if res > 214748364 || (res==214748364 && value >= 7) { return math.MaxInt32 } } res = res*10 + value } if isFlag == '-' { return -1 * res } return res } # func myAtoi(str string) int { str = strings.TrimSpace(str) result := 0 flag := 1 for i, v := range str { if v >= '0' && v math.MaxInt32 { if flag == -1 { return math.MinInt32 } return math.MaxInt32 } } return flag * result } 11.盛最多水的容器(2) 题目 给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。 在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例：输入：[1,8,6,2,5,4,8,3,7] 输出：49 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历-双指针 O(n) O(1) 02 遍历-暴力法 O(n^2) O(1) func maxArea(height []int) int { i := 0 j := len(height) - 1 res := 0 for i res { res = area } // 移动较小的指针，尝试获取更大的面积 if height[i] > height[j] { j-- } else { i++ } } return res } func min(a, b int) int { if a > b { return b } return a } # func maxArea(height []int) int { res := 0 for i := 0; i res { res = area } } } return res } func min(a, b int) int { if a > b { return b } return a } 12.整数转罗马数字(2) 题目 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。 数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。 同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。 示例 1:输入: 3输出: \"III\" 示例 2:输入: 4 输出: \"IV\" 示例 3:输入: 9 输出: \"IX\" 示例 4:输入: 58 输出: \"LVIII\" 解释: L = 50, V = 5, III = 3. 示例 5:输入: 1994 输出: \"MCMXCIV\" 解释: M = 1000, CM = 900, XC = 90, IV = 4. 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(log(n)) O(1) 02 枚举 O(1) O(1) func intToRoman(num int) string { m := map[int]string{ 1: \"I\", 4: \"IV\", 5: \"V\", 9: \"IX\", 10: \"X\", 40: \"XL\", 50: \"L\", 90: \"XC\", 100: \"C\", 400: \"CD\", 500: \"D\", 900: \"CM\", 1000: \"M\", } arr := []int{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1} result := \"\" for i := 0; i 15.三数之和(2) 题目 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？ 请你找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例： 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ] 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n^2) O(n^2) 02 哈希辅助 O(n^2) O(n^2) func threeSum(nums []int) [][]int { res := make([][]int, 0) sort.Ints(nums) for i := 0; i 0 || nums[i]+nums[left] > 0 { break } if i > 0 && nums[i] == nums[i-1] { continue } for left i+1 && nums[left] == nums[left-1] { left++ continue } if right target { right-- } else if nums[left]+nums[right] 0 { break } if value, ok := p[-sum]; ok && value > j { if _, ok2 := m[[2]int{nums[i], nums[j]}]; !ok2 { res = append(res, []int{nums[i], nums[j], 0 - nums[i] - nums[j]}) m[[2]int{nums[i], nums[j]}] = 1 } } } } return res } 16.最接近的三数之和(2) 题目 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。 找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 示例：输入：nums = [-1,2,1,-4], target = 1 输出：2 解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。 提示： 3 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n^2) O(1) 02 暴力法 O(n^3) O(1) func threeSumClosest(nums []int, target int) int { sort.Ints(nums) res := nums[0] + nums[1] + nums[2] for i := 0; i target { right-- } else if sum b { return a - b } return b - a } # func threeSumClosest(nums []int, target int) int { res := nums[0] + nums[1] + nums[2] for i := 0; i b { return a - b } return b - a } 17.电话号码的字母组合(2) 题目 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例:输入：\"23\"输出：[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]. 说明:尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(4^n) O(4^n) 02 递归-回溯 O(4^n) O(4^n) func letterCombinations(digits string) []string { if len(digits) == 0 { return nil } arr := []string{\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"} res := []string{\"\"} for i := 0; i 18.四数之和(3) 题目 给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ， 使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 注意：答案中不可以包含重复的四元组。 示例：给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ] 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n^3) O(n^3) 02 哈希辅助 O(n^3) O(n^3) 03 全排列+递归 O(n^3) O(n^3) func fourSum(nums []int, target int) [][]int { sort.Ints(nums) res := make([][]int, 0) for i := 0; i 0 && nums[i] == nums[i-1] { continue } for j := i + 1; j i+1 && nums[j] == nums[j-1] { continue } temp := target - nums[i] - nums[j] left := j + 1 right := len(nums) - 1 for left j+1 && nums[left] == nums[left-1] { left++ continue } if right temp { right-- } else if nums[left]+nums[right] k { if _, ok2 := m[[3]int{nums[i], nums[j], nums[k]}]; !ok2 { res = append(res, []int{nums[i], nums[j], nums[k], target - nums[i] - nums[j] - nums[k]}) m[[3]int{nums[i], nums[j], nums[k]}] = 1 } } } } } return res } # var res [][]int func fourSum(nums []int, target int) [][]int { sort.Ints(nums) res = make([][]int, 0) dfs(nums, target, []int{}, 0) return res } func dfs(nums []int, target int, arr []int, level int) { if len(arr) == 4 { sum := 0 for i := 0; i 19.删除链表的倒数第N个节点(3) 题目 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例：给定一个链表: 1->2->3->4->5, 和 n = 2. 当删除了倒数第二个节点后，链表变为 1->2->3->5. 说明：给定的 n 保证是有效的。 进阶：你能尝试使用一趟扫描实现吗？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 快慢指针 O(n) O(1) 03 递归 O(n) O(n) func removeNthFromEnd(head *ListNode, n int) *ListNode { temp := &ListNode{Next: head} cur := temp total := 0 for cur.Next != nil { cur = cur.Next total++ } cur = temp count := 0 for cur.Next != nil { if total-n == count { cur.Next = cur.Next.Next break } cur = cur.Next count++ } return temp.Next } # func removeNthFromEnd(head *ListNode, n int) *ListNode { temp := &ListNode{Next: head} fast, slow := temp, temp for i := 0; i 22.括号生成(3) 题目 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 示例：输入：n = 3 输出：[ \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\" ] 解题思路 No. 思路 时间复杂度 空间复杂度 01 全排列-递归 O(4^n/n^(1/2)) O(4^n/n^(1/2)) 02 动态规划 O(4^n/n^(1/2)) O(4^n/n^(1/2)) 03 广度优先搜索 O(4^n/n^(1/2)) O(4^n/n^(1/2)) var res []string func generateParenthesis(n int) []string { res = make([]string, 0) dfs(0, 0, n, \"\") return res } func dfs(left, right, max int, str string) { if left == right && left == max { res = append(res, str) return } if left 0 { node := queue[0] queue = queue[1:] if node.left == 0 && node.right == 0 { res = append(res, node.str) } if node.left > 0 { queue = append(queue, &Node{ str: node.str + \"(\", left: node.left - 1, right: node.right, }) } if node.right > 0 && node.left 24.两两交换链表中的节点(2) 题目 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例:给定 1->2->3->4, 你应该返回 2->1->4->3. 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 递归 O(n) O(n) func swapPairs(head *ListNode) *ListNode { temp := &ListNode{Next: head} prev := temp for head != nil && head.Next != nil { first, second := head, head.Next prev.Next = second first.Next, second.Next = second.Next, first prev, head = first, first.Next } return temp.Next } # func swapPairs(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } first, second := head, head.Next first.Next, second.Next = swapPairs(second.Next), first return second } 29.两数相除(2) 题目 给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。 返回被除数 dividend 除以除数 divisor 得到的商。 整数除法的结果应当截去（truncate）其小数部分， 例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2 示例 1:输入: dividend = 10, divisor = 3输出: 3 解释: 10/3 = truncate(3.33333..) = truncate(3) = 3 示例 2:输入: dividend = 7, divisor = -3 输出: -2 解释: 7/-3 = truncate(-2.33333..) = -2 提示： 被除数和除数均为 32 位有符号整数。 除数不为 0。 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31, 2^31 − 1]。 本题中，如果除法结果溢出，则返回 2^31 − 1。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(log(n)) O(1) 02 计算 O(1) O(1) func divide(dividend int, divisor int) int { if divisor == 0 || dividend == 0 { return 0 } if divisor == 1 { return dividend } flag, count := 1, 1 if dividend = 0 { for a-b >= 0 { a = a - b c = c + count b = b + b count = count + count } b = temp count = 1 } if c > math.MaxInt32 { return math.MaxInt32 } if flag math.MaxInt32 { return math.MaxInt32 } return res } 31.下一个排列(1) 题目 实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。 必须原地修改，只允许使用额外常数空间。 以下是一些例子，输入位于左侧列，其相应输出位于右侧列。 1,2,3 → 1,3,2 3,2,1 → 1,2,3 1,1,5 → 1,5,1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) func nextPermutation(nums []int) { left := len(nums) - 2 for left >= 0 && nums[left] >= nums[left+1] { left-- } if left == -1 { sort.Ints(nums) return } right := len(nums) - 1 for right >= 0 && nums[right] 33.搜索旋转排序数组(2) 题目 假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 你可以假设数组中不存在重复的元素。 你的算法时间复杂度必须是 O(log n) 级别。 示例 1:输入: nums = [4,5,6,7,0,1,2], target = 0 输出: 4 示例 2:输入: nums = [4,5,6,7,0,1,2], target = 3 输出: -1 解题思路 No. 思路 时间复杂度 空间复杂度 01 二分查找 O(log(n)) O(1) 02 遍历 O(n) O(1) func search(nums []int, target int) int { left, right := 0, len(nums)-1 for left 34.在排序数组中查找元素的第一个和最后一个位置(4) 题目 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 你的算法时间复杂度必须是 O(log n) 级别。 如果数组中不存在目标值，返回 [-1, -1]。 示例 1:输入: nums = [5,7,7,8,8,10], target = 8 输出: [3,4] 示例 2:输入: nums = [5,7,7,8,8,10], target = 6 输出: [-1,-1] 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n) O(1) 02 遍历 O(n) O(1) 03 二分查找 O(log(n)) O(1) 04 二分查找 O(log(n)) O(1) func searchRange(nums []int, target int) []int { left := 0 right := len(nums) - 1 for left nums[left] { left++ } } if nums[right] != target { if target = 0 && nums[left] == nums[right] && nums[left] == target { break } } if right target { break } } for i := len(nums) - 1; i >= 0; i-- { if nums[i] == target { left = i } else if nums[i] target || nums[len(nums)-1] nums[mid] { left = mid + 1 } else { right = mid - 1 } } if left = 0 && nums[right] == target { return right } return -1 } # func searchRange(nums []int, target int) []int { left := -1 right := -1 for i, j := 0, len(nums)-1; i target { j = mid - 1 } else { for temp := mid; temp >= 0; temp-- { if target == nums[temp] { left = temp } else { break } } for temp := mid; temp 36.有效的数独(1) 题目 判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 上图是一个部分填充的有效的数独。 数独部分空格内已填入了数字，空白格用 '.' 表示。 示例 1:输入: [ [\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"], [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"], [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"], [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"], [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"], [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"], [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"], [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"], [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"] ] 输出: true 示例 2:输入: [ [\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"], [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"], [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"], [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"], [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"], [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"], [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"], [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"], [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"] ] 输出: false 解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。 说明: 一个有效的数独（部分已被填充）不一定是可解的。 只需要根据以上规则，验证已经填入的数字是否有效即可。 给定数独序列只包含数字 1-9 和字符 '.' 。 给定数独永远是 9x9 形式的。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(1) O(1) func isValidSudoku(board [][]byte) bool { var row, col, arr [9][9]int for i := 0; i 39.组合总和(2) 题目 给定一个无重复元素的数组 candidates 和一个目标数 target ， 找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。 解集不能包含重复的组合。 示例 1:输入: candidates = [2,3,6,7], target = 7, 所求解集为: [ [7], [2,2,3] ] 示例 2:输入: candidates = [2,3,5], target = 8, 所求解集为: [ [2,2,2,2], [2,3,3], [3,5] ] 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(2^n) O(2^n) 02 递归 O(2^n) O(2^n) var res [][]int func combinationSum(candidates []int, target int) [][]int { res = make([][]int, 0) sort.Ints(candidates) dfs(candidates, target, []int{}, 0) return res } func dfs(candidates []int, target int, arr []int, index int) { if target == 0 { temp := make([]int, len(arr)) copy(temp, arr) res = append(res, temp) return } if target 40.组合总和II(2) 题目 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。 说明： 所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。 示例 1:输入: candidates = [10,1,2,7,6,1,5], target = 8, 所求解集为: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ] 示例 2:输入: candidates = [2,5,2,1,2], target = 5, 所求解集为: [ [1,2,2], [5] ] 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n!) O(n!) 02 递归 O(n!) O(n!) var res [][]int func combinationSum2(candidates []int, target int) [][]int { res = make([][]int, 0) sort.Ints(candidates) dfs(candidates, target, []int{}, 0) return res } func dfs(candidates []int, target int, arr []int, index int) { if target == 0 { temp := make([]int, len(arr)) copy(temp, arr) res = append(res, temp) return } if target 43.字符串相乘 题目 给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积， 它们的乘积也表示为字符串形式。 示例 1:输入: num1 = \"2\", num2 = \"3\"输出: \"6\" 示例 2:输入: num1 = \"123\", num2 = \"456\"输出: \"56088\" 说明： num1 和 num2 的长度小于110。 num1 和 num2 只包含数字 0-9。 num1 和 num2 均不以零开头，除非是数字 0 本身。 不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(1) O(1) 46.全排列(3) 题目 给定一个 没有重复 数字的序列，返回其所有可能的全排列。 示例:输入: [1,2,3]输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] 解题思路 No. 思路 时间复杂度 空间复杂度 01 回溯 O(n^n) O(n*n!) 02 递归 O(n!) O(n*n!) 03 回溯 O(n!) O(n*n!) var res [][]int func permute(nums []int) [][]int { res = make([][]int, 0) arr := make([]int, 0) visited := make(map[int]bool) dfs(nums, 0, arr, visited) return res } func dfs(nums []int, index int, arr []int, visited map[int]bool) { if index == len(nums) { temp := make([]int, len(arr)) copy(temp, arr) res = append(res, temp) return } for i := 0; i 47.全排列II(3) 题目 给定一个可包含重复数字的序列，返回所有不重复的全排列。 示例:输入: [1,1,2] 输出: [ [1,1,2], [1,2,1], [2,1,1] ] 解题思路 No. 思路 时间复杂度 空间复杂度 01 回溯 O(n!) O(n!) 02 回溯 O(n!) O(n!) 03 回溯 O(n!) O(n!) var res [][]int func permuteUnique(nums []int) [][]int { res = make([][]int, 0) sort.Ints(nums) dfs(nums, 0, make([]int, len(nums)), make([]int, 0)) return res } func dfs(nums []int, index int, visited []int, arr []int) { if len(nums) == index { temp := make([]int, len(arr)) copy(temp, arr) res = append(res, temp) return } for i := 0; i 0 && nums[i] == nums[i-1] && visited[i-1] == 0{ continue } arr = append(arr, nums[i]) visited[i] = 1 dfs(nums, index+1, visited, arr) visited[i] = 0 arr = arr[:len(arr)-1] } } # 2 var res [][]int func permuteUnique(nums []int) [][]int { res = make([][]int, 0) sort.Ints(nums) dfs(nums, 0) return res } func dfs(nums []int, index int) { if index == len(nums) { temp := make([]int, len(nums)) copy(temp, nums) res = append(res, temp) return } m := make(map[int]int) for i := index; i 48.旋转图像(2) 题目 给定一个 n × n 的二维矩阵表示一个图像。 将图像顺时针旋转 90 度。 说明：你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。 示例 1:给定 matrix = [ [1,2,3], [4,5,6], [7,8,9] ], 原地旋转输入矩阵，使其变为: [ [7,4,1], [8,5,2], [9,6,3] ] 示例 2:给定 matrix = [ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16] ], 原地旋转输入矩阵，使其变为: [ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11] ] 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n^2) O(1) 02 遍历 O(n^2) O(1) func rotate(matrix [][]int) { n := len(matrix) // 同行逆置 // [[1 2 3] [4 5 6] [7 8 9]] // [[3 2 1] [6 5 4] [9 8 7]] for i := 0; i 49.字母异位词分组(2) 题目 给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。 示例:输入: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"] 输出: [ [\"ate\",\"eat\",\"tea\"], [\"nat\",\"tan\"], [\"bat\"] ] 说明： 所有输入均为小写字母。 不考虑答案输出的顺序。 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n^2nlog(n)) O(n^2) 02 哈希辅助 O(n^2) O(n^2) func groupAnagrams(strs []string) [][]string { m := make(map[string]int) res := make([][]string, 0) for i := 0; i 50.Pow(x,n)(4) 题目 实现 pow(x, n) ，即计算 x 的 n 次幂函数。 示例 1:输入: 2.00000, 10 输出: 1024.00000 示例 2:输入: 2.10000, 3 输出: 9.26100 示例 3:输入: 2.00000, -2 输出: 0.25000 解释: 2-2 = 1/22 = 1/4 = 0.25 说明: -100.0 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(log(n)) O(1) 02 迭代 O(log(n)) O(1) 03 计算 O(log(n)) O(1) 04 递归 O(log(n)) O(log(n)) func myPow(x float64, n int) float64 { if n == 0 { return 1 } if n 0 { if n%2 == 1 { res = res * x } x = x * x n = n / 2 } return res } # func myPow(x float64, n int) float64 { return math.Pow(x, float64(n)) } # func myPow(x float64, n int) float64 { if n == 0 { return 1 } if n == 1 { return x } res := 1.0 if n > 0 { res = myPow(x, n/2) return res * res * myPow(x, n%2) } else { res = myPow(x, -n/2) res = res * res * myPow(x, -n%2) return 1 / res } } 54.螺旋矩阵(2) 题目 给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。 示例 1:输入: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] 输出: [1,2,3,6,9,8,7,4,5] 示例 2:输入: [ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12] ] 输出: [1,2,3,4,8,12,11,10,9,5,6,7] 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n^2) O(n^2) 02 遍历 O(n^2) O(n^2) var res []int func spiralOrder(matrix [][]int) []int { res = make([]int, 0) rows := len(matrix) if rows == 0 { return res } cols := len(matrix[0]) if cols == 0 { return res } start := 0 for cols > start*2 && rows > start*2 { printCircle(matrix, cols, rows, start) start++ } return res } func printCircle(matrix [][]int, cols, rows, start int) { x := cols - 1 - start y := rows - 1 - start // 左到右 for i := start; i = start; i-- { res = append(res, matrix[y][i]) } } // 下到上 if start = start+1; i-- { res = append(res, matrix[i][start]) } } } # func spiralOrder(matrix [][]int) []int { res := make([]int, 0) rows := len(matrix) if rows == 0 { return res } cols := len(matrix[0]) if cols == 0 { return res } x1, x2, y1, y2 := 0, rows-1, 0, cols-1 direct := 0 for x1 = y1; i-- { res = append(res, matrix[x2][i]) } x2-- } else if direct == 3 { for i := x2; i >= x1; i-- { res = append(res, matrix[i][y1]) } y1++ } direct++ } return res } 55.跳跃游戏(4) 题目 给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个位置。 示例 1:输入: [2,3,1,1,4] 输出: true 解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。 示例 2:输入: [3,2,1,0,4] 输出: false 解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历-贪心 O(n) O(1) 02 动态规划 O(n^2) O(n) 03 遍历-贪心 O(n) O(1) 04 遍历 O(n) O(1) func canJump(nums []int) bool { j := len(nums) - 1 for i := len(nums) - 2; i >= 0; i-- { if nums[i]+i >= j { j = i } } return j = i { flag = true break } } dp[i] = flag } return dp[len(nums)-1] } # func canJump(nums []int) bool { max := 0 for i := 0; i max { max = i + nums[i] } if max >= len(nums)-1 { return true } } } return false } # func canJump(nums []int) bool { zero := -1 for i := len(nums) - 2; i >= 0; i-- { if zero > 0 { if i+nums[i] > zero { zero = -1 } continue } if nums[i] == 0 { zero = i continue } } return zero 56.合并区间(2) 题目 给出一个区间的集合，请合并所有重叠的区间。 示例 1:输入: [[1,3],[2,6],[8,10],[15,18]] 输出: [[1,6],[8,10],[15,18]] 解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2:输入: [[1,4],[4,5]] 输出: [[1,5]] 解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序遍历 O(nlog(n)) O(n) 02 排序-双指针 O(nlog(n)) O(n) func merge(intervals [][]int) [][]int { res := make([][]int, 0) if len(intervals) == 0 { return nil } sort.Slice(intervals, func(i, j int) bool { return intervals[i][0] arr[1] { res = append(res, intervals[i]) } else if intervals[i][1] > arr[1] { res[len(res)-1][1] = intervals[i][1] } } return res } # func merge(intervals [][]int) [][]int { res := make([][]int, 0) if len(intervals) == 0 { return nil } sort.Slice(intervals, func(i, j int) bool { return intervals[i][0] end { end = intervals[j][1] } j++ } res = append(res, []int{intervals[i][0], end}) i = j } return res } 59.螺旋矩阵II(2) 题目 给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。 示例:输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ] 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n^2) O(n^2) 02 遍历模拟 O(n^2) O(n^2) func generateMatrix(n int) [][]int { res := make([][]int, n) for i := 0; i = left && left = top+1 && top = left; i-- { res[bottom][i] = count count++ } bottom-- for i := bottom; i >= top; i-- { res[i][left] = count count++ } left++ } return res } 60.第k个排列(1) 题目 给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。 按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下： \"123\" \"132\" \"213\" \"231\" \"312\" \"321\" 给定 n 和 k，返回第 k 个排列。 说明： 给定 n 的范围是 [1, 9]。 给定 k 的范围是[1, n!]。 示例 1:输入: n = 3, k = 3 输出: \"213\" 示例 2:输入: n = 4, k = 9 输出: \"2314\" 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历计算 O(n) O(n) func getPermutation(n int, k int) string { res := \"\" arr := []string{\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"} times := make([]int, 0) times = append(times, 1) value := 1 for i := 1; i 0 { i := k / times[n-1] k = k % times[n-1] n-- res = res + arr[i] arr = append(arr[:i], arr[i+1:]...) } return res } 61.旋转链表(2) 题目 给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。 示例 1: 输入: 1->2->3->4->5->NULL, k = 2 输出: 4->5->1->2->3->NULL 解释: 向右旋转 1 步: 5->1->2->3->4->NULL 向右旋转 2 步: 4->5->1->2->3->NULL 示例 2: 输入: 0->1->2->NULL, k = 4 输出: 2->0->1->NULL 解释: 向右旋转 1 步: 2->0->1->NULL 向右旋转 2 步: 1->2->0->NULL 向右旋转 3 步: 0->1->2->NULL 向右旋转 4 步: 2->0->1->NULL 解题思路 No. 思路 时间复杂度 空间复杂度 01 统计遍历 O(n) O(1) 02 数组辅助 O(n) O(n) func rotateRight(head *ListNode, k int) *ListNode { if head == nil || k == 0 { return head } temp := head count := 1 for temp.Next != nil { temp = temp.Next count++ } temp.Next = head k = k % count for i := 0; i 62.不同路径(4) 题目 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ 例如，上图是一个7 x 3 的网格。有多少可能的路径？ 示例 1:输入: m = 3, n = 2 输出: 3 解释: 从左上角开始，总共有 3 条路径可以到达右下角。 1. 向右 -> 向右 -> 向下 2. 向右 -> 向下 -> 向右 3. 向下 -> 向右 -> 向右 示例 2:输入: m = 7, n = 3 输出: 28 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n^2) O(n^2) 02 动态规划 O(n^2) O(n) 03 数学 O(n) O(1) 04 递归 O(n^2) O(n^2) // dp[i][j] = dp[i-1][j] + dp[i][j-1] func uniquePaths(m int, n int) int { if m n { m, n = n, m } a := 1 for i := 1; i 0 { return arr[n][m] } arr[n][m] = dfs(m, n-1) + dfs(m-1, n) return arr[n][m] } 63.不同路径II(3) 题目 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 网格中的障碍物和空位置分别用 1 和 0 来表示。 说明：m 和 n 的值均不超过 100。 示例 1: 输入: [ [0,0,0], [0,1,0], [0,0,0] ] 输出: 2 解释: 3x3 网格的正中间有一个障碍物。 从左上角到右下角一共有 2 条不同的路径： 1. 向右 -> 向右 -> 向下 -> 向下 2. 向下 -> 向下 -> 向右 -> 向右 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n^2) O(n^2) 02 动态规划 O(n^2) O(n) 03 动态规划 O(n^2) O(1) func uniquePathsWithObstacles(obstacleGrid [][]int) int { n := len(obstacleGrid) if n = 1 && obstacleGrid[i][j-1] == 0 { dp[j] = dp[j] + dp[j-1] } } } return dp[m-1] } # 3 func uniquePathsWithObstacles(obstacleGrid [][]int) int { n := len(obstacleGrid) if n 64.最小路径和(4) 题目 给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例: 输入: [ [1,3,1], [1,5,1], [4,2,1] ] 输出: 7解释: 因为路径 1→3→1→1→1 的总和最小。 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n^2) O(n^2) 02 动态规划 O(n^2) O(1) 03 动态规划 O(n^2) O(n) 04 递归 O(n^2) O(n^2) func minPathSum(grid [][]int) int { n := len(grid) if n == 0 { return 0 } m := len(grid[0]) dp := make([][]int, n) for i := 0; i b { return b } return a } # func minPathSum(grid [][]int) int { n := len(grid) if n == 0 { return 0 } m := len(grid[0]) for i := 0; i b { return b } return a } # 3 func minPathSum(grid [][]int) int { n := len(grid) if n == 0 { return 0 } m := len(grid[0]) dp := make([]int, m) dp[0] = grid[0][0] for i := 1; i b { return b } return a } # 4 var arr [][]int func minPathSum(grid [][]int) int { n := len(grid) if n == 0 { return 0 } m := len(grid[0]) arr = make([][]int, n) for i := 0; i 0 { return arr[n][m] } arr[n][m] = min(dfs(grid, n-1, m), dfs(grid, n, m-1)) + grid[n][m] return arr[n][m] } func min(a, b int) int { if a > b { return b } return a } 71.简化路径(2) 题目 以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。 在 Unix 风格的文件系统中，一个点（.）表示当前目录本身； 此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。 更多信息请参阅：Linux / Unix中的绝对路径 vs 相对路径 请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。 最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。 示例 1：输入：\"/home/\" 输出：\"/home\" 解释：注意，最后一个目录名后面没有斜杠。 示例 2：输入：\"/../\" 输出：\"/\" 解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。 示例 3：输入：\"/home//foo/\" 输出：\"/home/foo\" 解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。 示例 4：输入：\"/a/./b/../../c/\" 输出：\"/c\" 示例 5：输入：\"/a/../../b/../c//.//\" 输出：\"/c\" 示例 6：输入：\"/a//b////c/d//././/..\" 输出：\"/a/b/c\" 解题思路 No. 思路 时间复杂度 空间复杂度 01 栈辅助 O(n) O(n) 02 内置函数 O(n) O(n) func simplifyPath(path string) string { stack := make([]string, 0) arr := strings.Split(path, \"/\") for i := 0; i 0 { stack = stack[:len(stack)-1] } } else { stack = append(stack, arr[i]) } } return \"/\" + strings.Join(stack, \"/\") } # func simplifyPath(path string) string { return filepath.Clean(path) } 73.矩阵置零(4) 题目 给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。 示例 1: 输入: [ [1,1,1], [1,0,1], [1,1,1] ] 输出: [ [1,0,1], [0,0,0], [1,0,1] ] 示例 2: 输入: [ [0,1,2,0], [3,4,5,2], [1,3,1,5] ] 输出: [ [0,0,0,0], [0,4,5,0], [0,3,1,0] ] 进阶: 一个直接的解决方案是使用 O(mn) 的额外空间，但这并不是一个好的解决方案。 一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。 你能想出一个常数空间的解决方案吗？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n^2) O(n) 02 暴力法 O(n^4) O(1) 03 遍历 O(n^2) O(1) 04 遍历 O(n^2) O(1) func setZeroes(matrix [][]int) { x := make(map[int]int) y := make(map[int]int) for i := 0; i = 0; i-- { for j := len(matrix[i]) - 1; j >= 1; j-- { if matrix[i][0] == 0 || matrix[0][j] == 0 { matrix[i][j] = 0 } } } // 第一列处理 if flag == true { for i := 0; i 74.搜索二维矩阵(6) 题目 编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性： 每行中的整数从左到右按升序排列。 每行的第一个整数大于前一行的最后一个整数。 示例 1:输入: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 3 输出: true 示例 2:输入: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 13 输出: false 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法 O(n^2) O(1) 02 暴力法-优化 O(n^2) O(1) 03 二分查找 O(nlog(n)) O(1) 04 左下角查找 O(n) O(1) 05 右上角查找 O(n) O(1) 06 内置函数 O(n^2) O(1) func searchMatrix(matrix [][]int, target int) bool { if len(matrix) == 0 { return false } if len(matrix[0]) == 0 { return false } for i := 0; i = target { for j := 0; j = target { res := binarySearch(matrix[i], target) if res == true { return true } } } return false } func binarySearch(arr []int, target int) bool { left := 0 right := len(arr) - 1 for left target { right = mid - 1 } else { left = mid + 1 } } return false } # 4 func searchMatrix(matrix [][]int, target int) bool { if len(matrix) == 0 { return false } if len(matrix[0]) == 0 { return false } i := len(matrix) - 1 j := 0 for i >= 0 && j target { i-- } else { j++ } } return false } # 5 func searchMatrix(matrix [][]int, target int) bool { if len(matrix) == 0 { return false } if len(matrix[0]) == 0 { return false } i := 0 j := len(matrix[0]) - 1 for j >= 0 && i target { j-- } else { i++ } } return false } # 6 func searchMatrix(matrix [][]int, target int) bool { if len(matrix) == 0 { return false } if len(matrix[0]) == 0 { return false } for i := 0; i 75.颜色分类(3) 题目 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序， 使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 注意: 不能使用代码库中的排序函数来解决这道题。 示例:输入: [2,0,2,1,1,0] 输出: [0,0,1,1,2,2] 进阶： 一个直观的解决方案是使用计数排序的两趟扫描算法。 首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。 你能想出一个仅使用常数空间的一趟扫描算法吗？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序 O(nlog(n)) O(1) 02 双指针 O(n) O(1) 03 数组辅助 O(n) O(1) func sortColors(nums []int) { sort.Ints(nums) } # 2 func sortColors(nums []int) { left := 0 right := len(nums) - 1 for i := 0; i 77.组合(4) 题目 给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。 示例:输入: n = 4, k = 2 输出: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ] 解题思路 No. 思路 时间复杂度 空间复杂度 01 回溯-递归 O(kC(n,k)) O(C(n,k)) 02 回溯 O(kC(n,k)) O(C(n,k)) 03 回溯 O(kC(n,k)) O(C(n,k)) 04 迭代 O(kC(n,k)) O(C(n,k)) var res [][]int func combine(n int, k int) [][]int { res = make([][]int, 0) nums := make([]int, 0) for i := 1; i nums[index-1] { nums[i], nums[index] = nums[index], nums[i] dfs(nums, index+1, k) nums[i], nums[index] = nums[index], nums[i] } } } # 2 var res [][]int func combine(n int, k int) [][]int { res = make([][]int, 0) dfs(n, k, 1, make([]int, 0)) return res } func dfs(n, k, index int, arr []int) { if len(arr) == k { temp := make([]int, k) copy(temp, arr) res = append(res, temp) return } for i := index; i = 0 { arr[i]++ if arr[i] > n { i-- } else if i == k-1 { temp := make([]int, k) copy(temp, arr) res = append(res, temp) } else { i++ arr[i] = arr[i-1] } } return res } 78.子集(3) 题目 给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例:输入: nums = [1,2,3] 输出: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ] 解题思路 No. 思路 时间复杂度 空间复杂度 01 回溯 O(n*2^n) O(n*2^n) 02 迭代 O(n*2^n) O(n*2^n) 03 位运算 O(n*2^n) O(n*2^n) var res [][]int func subsets(nums []int) [][]int { res = make([][]int, 0) dfs(nums, make([]int, 0), 0) return res } func dfs(nums []int, arr []int, level int) { temp := make([]int, len(arr)) copy(temp, arr) res = append(res, temp) for i := level; i 79.单词搜索(2) 题目 给定一个二维网格和一个单词，找出该单词是否存在于网格中。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。 同一个单元格内的字母不允许被重复使用。 示例:board = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] 给定 word = \"ABCCED\", 返回 true 给定 word = \"SEE\", 返回 true 给定 word = \"ABCB\", 返回 false 提示： board 和 word 中只包含大写和小写英文字母。 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 深度优先搜索+回溯 O(n^2) O(n) 02 深度优先搜索+回溯+数组辅助 O(n^2) O(n^2) func exist(board [][]byte, word string) bool { for i := 0; i = len(board) || j = len(board[0]) || board[i][j] != word[level] { return false } if level == len(word)-1 { return true } temp := board[i][j] board[i][j] = ' ' res := dfs(board, i+1, j, word, level+1) || dfs(board, i-1, j, word, level+1) || dfs(board, i, j+1, word, level+1) || dfs(board, i, j-1, word, level+1) board[i][j] = temp return res } # func exist(board [][]byte, word string) bool { visited := make([][]bool, len(board)) for i := 0; i = 0 && i = 0 && j 80.删除排序数组中的重复项II(2) 题目 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1:给定 nums = [1,1,1,2,2,3], 函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 你不需要考虑数组中超出新长度后面的元素。 示例 2:给定 nums = [0,0,1,1,1,1,2,3,3], 函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。 你不需要考虑数组中超出新长度后面的元素。 说明:为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。 for (int i = 0; i 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n) O(1) 02 双指针 O(n) O(1) func removeDuplicates(nums []int) int { if len(nums) == 0 { return 0 } if len(nums) == 1 { return 1 } n := 2 i := n for j := n; j 81.搜索旋转排序数组II(2) 题目 假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。 编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。 示例 1:输入: nums = [2,5,6,0,0,1,2], target = 0 输出: true 示例 2:输入: nums = [2,5,6,0,0,1,2], target = 3 输出: false 进阶: 这是 搜索旋转排序数组 的延伸题目，本题中的 nums 可能包含重复元素。 这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 二分查找 O(log(n)) O(1) func search(nums []int, target int) bool { for i := 0; i 82.删除排序链表中的重复元素II(3) 题目 给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。 示例 1:输入: 1->2->3->3->4->4->5 输出: 1->2->5 示例 2:输入: 1->1->1->2->3 输出: 2->3 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 递归 O(n) O(n) 03 双指针 O(n) O(1) func deleteDuplicates(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } temp := &ListNode{Next: head} cur := temp value := 0 for cur.Next != nil && cur.Next.Next != nil { if cur.Next.Val == cur.Next.Next.Val { value = cur.Next.Val for cur.Next != nil && cur.Next.Val == value { cur.Next = cur.Next.Next } } else { cur = cur.Next } } return temp.Next } # func deleteDuplicates(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } flag := false for head.Next != nil && head.Val == head.Next.Val{ head = head.Next flag = true } head.Next = deleteDuplicates(head.Next) if flag{ return head.Next } return head } # func deleteDuplicates(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } flag := false for head.Next != nil && head.Val == head.Next.Val{ head = head.Next flag = true } head.Next = deleteDuplicates(head.Next) if flag{ return head.Next } return head } 86.分隔链表(2) 题目 给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。 你应当保留两个分区中每个节点的初始相对位置。 示例: 输入: head = 1->4->3->2->5->2, x = 3 输出: 1->2->2->4->3->5 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n) O(1) 02 数组辅助 O(n) O(n) func partition(head *ListNode, x int) *ListNode { first := &ListNode{} second := &ListNode{} a := first b := second for head != nil { if head.Val 89.格雷编码(2) 题目 格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。 给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。即使有多个不同答案，你也只需要返回其中一种。 格雷编码序列必须以 0 开头。 示例 1:输入: 2 输出: [0,1,3,2] 解释: 00 - 0 01 - 1 11 - 3 10 - 2 对于给定的 n，其格雷编码序列并不唯一。例如，[0,2,3,1] 也是一个有效的格雷编码序列。 00 - 0 10 - 2 11 - 3 01 - 1 示例 2:输入: 0 输出: [0] 解释: 我们定义格雷编码序列必须以 0 开头。 给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n = 0 时，长度为 20 = 1。 因此，当 n = 0 时，其格雷编码序列为 [0]。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历-推导 O(2^n) O(2^n) 02 公式 O(2^n) O(2^n) func grayCode(n int) []int { if n == 0 { return []int{0} } res := []int{0, 1} for i := 1; i = 0; j-- { // 10 1 11 // 10 0 10 // 100 10 110 // 100 11 111 // 100 1 101 // 100 0 100 // fmt.Printf(\"%b %b %b\\n\", value, res[j], res[j]^value) // temp = append(temp, res[j]|value) // temp = append(temp, res[j]^value) temp = append(temp, res[j]+value) } res = append(res, temp...) } return res } # 2 func grayCode(n int) []int { total := 1 >1)) } return res } 90.子集II 题目 给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例:输入: [1,2,2] 输出: [ [2], [1], [1,2,2], [2,2], [1,2], [] ] 解题思路 No. 思路 时间复杂度 空间复杂度 01 回溯 O(n*2^n) O(n*2^n) 02 回溯 O(n*2^n) O(n*2^n) 03 迭代 var res [][]int func subsetsWithDup(nums []int) [][]int { sort.Ints(nums) res = make([][]int, 0) dfs(nums, make([]int, 0), 0) return res } func dfs(nums []int, arr []int, level int) { temp := make([]int, len(arr)) copy(temp, arr) res = append(res, temp) for i := level; i level && nums[i] == nums[i-1] { continue } arr = append(arr, nums[i]) dfs(nums, arr, i+1) arr = arr[:len(arr)-1] } } # var res [][]int func subsetsWithDup(nums []int) [][]int { sort.Ints(nums) res = make([][]int, 0) dfs(nums, make([]int, 0)) return res } func dfs(nums []int, arr []int) { temp := make([]int, len(arr)) copy(temp, arr) res = append(res, temp) for i := 0; i 0 && nums[i] == nums[i-1] { continue } arr = append(arr, nums[i]) dfs(nums[i+1:], arr) arr = arr[:len(arr)-1] } } 91.解码方法(3) 题目 一条包含字母 A-Z 的消息通过以下方式进行了编码： 'A' -> 1 'B' -> 2 ... 'Z' -> 26 给定一个只包含数字的非空字符串，请计算解码方法的总数。 示例 1:输入: \"12\" 输出: 2 解释: 它可以解码为 \"AB\"（1 2）或者 \"L\"（12）。 示例 2:输入: \"226\" 输出: 3 解释: 它可以解码为 \"BZ\" (2 26), \"VF\" (22 6), 或者 \"BBF\" (2 2 6) 。 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n) O(1) 02 动态规划 O(n) O(n) 03 递归 O(n) O(n) func numDecodings(s string) int { if s[0] == '0' { return 0 } pre := 1 cur := 1 for i := 1; i = '1' && s[i] 0 && (s[i-1] == '2' && s[i] >= '1' && s[i] 0 { return m[s] } if len(s) == 0 { return 1 } if s[0] == '0' { return 0 } if len(s) == 1 { return 1 } if (s[0]-'0')*10+s[1]-'0' > 26 { return dfs(s[1:]) } m[s] = dfs(s[1:]) + dfs(s[2:]) return m[s] } 92.反转链表II(2) 题目 反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。 说明: 1 ≤ m ≤ n ≤ 链表长度。 示例:输入: 1->2->3->4->5->NULL, m = 2, n = 4 输出: 1->4->3->2->5->NULL 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 递归 O(n) O(n) func reverseBetween(head *ListNode, m int, n int) *ListNode { if m == n || head == nil { return head } temp := &ListNode{Next: head} prev := temp for i := 1; i 93.复原IP地址(2) 题目 给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。 有效的 IP 地址正好由四个整数（每个整数位于 0 到 255 之间组成），整数之间用 '.' 分隔。 示例:输入: \"25525511135\" 输出: [\"255.255.11.135\", \"255.255.111.35\"] 解题思路 No. 思路 时间复杂度 空间复杂度 01 回溯 O(1) O(1) 02 暴力法 O(1) O(1) func dfs(s string, arr []string, level int) { if level == 4 { if len(s) == 0 { str := strings.Join(arr, \".\") res = append(res, str) } return } for i := 1; i 12 { return nil } for i := 1; i 1 && s[0] == '0' { return false } value, _ := strconv.Atoi(s) if value > 255 { return false } return true } 94.二叉树的中序遍历(3) 题目 给定一个二叉树，返回它的中序 遍历。 示例:输入: [1,null,2,3] 1 \\ 2 / 3 输出: [1,3,2] 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(n) 02 迭代 O(n) O(n) 03 递归 O(n) O(n) func inorderTraversal(root *TreeNode) []int { if root == nil { return nil } left := inorderTraversal(root.Left) right := inorderTraversal(root.Right) res := left res = append(res, root.Val) res = append(res, right...) return res } # 2 func inorderTraversal(root *TreeNode) []int { if root == nil { return nil } stack := make([]*TreeNode, 0) res := make([]int, 0) for len(stack) > 0 || root != nil { for root != nil { stack = append(stack, root) root = root.Left } last := len(stack) - 1 res = append(res, stack[last].Val) root = stack[last].Right stack = stack[:last] } return res } # 3 var res []int func inorderTraversal(root *TreeNode) []int { res = make([]int, 0) dfs(root) return res } func dfs(root *TreeNode) { if root != nil { dfs(root.Left) res = append(res, root.Val) dfs(root.Right) } } 95.不同的二叉搜索树II 题目 给定一个整数 n，生成所有由 1 ... n 为节点所组成的 二叉搜索树 。 示例：输入：3 输出： [ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3] ] 解释：以上的输出对应以下 5 种不同结构的二叉搜索树： 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 提示： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序 O(nlog(n)) O(n) 96.不同的二叉搜索树(3) 题目 给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？ 示例:输入: 3 输出: 5 解释: 给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n^2) O(n) 02 公式 ) O(1) 03 公式 O(n) O(1) func numTrees(n int) int { dp := make([]int, n+1) dp[0] =1 dp[1] =1 for i := 2; i 98.验证二叉搜索树(5) 题目 给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1:输入: 2 / \\ 1 3 输出: true 示例 2:输入: 5 / \\ 1 4 / \\ 3 6 输出: false 解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 递归 O(n) O(n) 03 迭代 O(n) O(n) 04 迭代 O(n) O(n) 05 递归 O(n) O(log(n)) func isValidBST(root *TreeNode) bool { return dfs(root, math.MinInt64, math.MaxInt64) } func dfs(root *TreeNode, left, right int) bool { if root == nil { return true } if left >= root.Val || right = res[i+1] { return false } } return true } func dfs(root *TreeNode) { if root != nil { dfs(root.Left) res = append(res, root.Val) dfs(root.Right) } } # 3 func isValidBST(root *TreeNode) bool { if root == nil { return true } stack := make([]*TreeNode, 0) res := make([]int, 0) for len(stack) > 0 || root != nil { for root != nil { stack = append(stack, root) root = root.Left } last := len(stack) - 1 res = append(res, stack[last].Val) root = stack[last].Right stack = stack[:last] } for i := 0; i = res[i+1] { return false } } return true } # 4 func isValidBST(root *TreeNode) bool { if root == nil { return true } stack := make([]*TreeNode, 0) pre := math.MinInt64 for len(stack) > 0 || root != nil { for root != nil { stack = append(stack, root) root = root.Left } last := len(stack) - 1 if stack[last].Val 0001-1000-Hard 4.寻找两个正序数组的中位数 题目 给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。 请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 示例 1:nums1 = [1, 3] nums2 = [2] 则中位数是 2.0 示例 2:nums1 = [1, 2] nums2 = [3, 4] 则中位数是 (2 + 3)/2 = 2.5 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序 O(nlog(n)) O(n) func findMedianSortedArrays(nums1 []int, nums2 []int) float64 { nums1 = append(nums1, nums2...) sort.Ints(nums1) if len(nums1)%2 == 1 { return float64(nums1[len(nums1)/2]) } return float64(nums1[len(nums1)/2]+nums1[len(nums1)/2-1]) / 2 } # Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-07-24 10:16:35 "},"docs/source/question/0101-0200.html":{"url":"docs/source/question/0101-0200.html","title":"0100-0200","keywords":"","body":"0101-0200-Easy 0101-0200-Easy 101. 对称二叉树(2) 104.二叉树的最大深度(2) 107.二叉树的层次遍历II(2) 108.将有序数组转换为二叉搜索树(2) 110.平衡二叉树(2) 111.二叉树的最小深度(2) 112.路径总和(2) 118.杨辉三角(2) 119.杨辉三角II(3) 121.买卖股票的最佳时机(3) 122.买卖股票的最佳时机II(2) 125.验证回文串(2) 136.只出现一次的数字(4) 141.环形链表(2) 155.最小栈(2) 160.相交链表(4) 167.两数之和 II - 输入有序数组(4) 168.Excel表列名称(2) 169.多数元素(5) 171.Excel表列序号(1) 172.阶乘后的零(1) 189.旋转数组(4) 190.颠倒二进制位(3) 191.位1的个数(4) 198.打家劫舍(4) 101. 对称二叉树(2) 题目 给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 / \\ 2 2 / \\ / \\ 3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 1 / \\ 2 2 \\ \\ 3 3 说明: 如果你可以运用递归和迭代两种方法解决这个问题，会很加分。 解答思路 No. 思路 时间复杂度 空间复杂度 01(最优) 递归 O(n) O(n) 02 迭代 O(n) O(n) // 递归 func isSymmetric(root *TreeNode) bool { if root == nil { return true } return recur(root.Left, root.Right) } func recur(left, right *TreeNode) bool { if left == nil && right == nil { return true } if left == nil || right == nil { return false } return left.Val == right.Val && recur(left.Left, right.Right) && recur(left.Right, right.Left) } // 迭代 func isSymmetric(root *TreeNode) bool { leftQ := make([]*TreeNode, 0) rightQ := make([]*TreeNode, 0) leftQ = append(leftQ, root) rightQ = append(rightQ, root) for len(leftQ) != 0 && len(rightQ) != 0 { leftCur, rightCur := leftQ[0], rightQ[0] leftQ, rightQ = leftQ[1:], rightQ[1:] if leftCur == nil && rightCur == nil { continue } else if leftCur != nil && rightCur != nil && leftCur.Val == rightCur.Val { leftQ = append(leftQ, leftCur.Left, leftCur.Right) rightQ = append(rightQ, rightCur.Right, rightCur.Left) } else { return false } } if len(leftQ) == 0 && len(rightQ) == 0 { return true } else { return false } } 104.二叉树的最大深度(2) 题目 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例：给定二叉树 [3,9,20,null,null,15,7]， 3 / \\ 9 20 / \\ 15 7 返回它的最大深度 3 。 解答思路 No. 思路 时间复杂度 空间复杂度 01(最优) 递归 O(n) O(log(n)) 02 迭代 O(n) O(n) // 递归 func maxDepth(root *TreeNode) int { if root == nil { return 0 } left := maxDepth(root.Left) right := maxDepth(root.Right) return max(left, right) + 1 } func max(a, b int) int { if a > b { return a } return b } // 迭代 func maxDepth(root *TreeNode) int { if root == nil { return 0 } queue := make([]*TreeNode,0) queue = append(queue,root) depth := 0 for len(queue) > 0{ length := len(queue) for i := 0; i 107.二叉树的层次遍历II(2) 题目 给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） 例如： 给定二叉树 [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 返回其自底向上的层次遍历为： [ [15,7], [9,20], [3] ] 解题思路 No. 思路 时间复杂度 空间复杂度 01(最优) 递归 O(n) O(n) 02 迭代 O(n) O(n) // 迭代 func levelOrderBottom(root *TreeNode) [][]int { if root == nil { return nil } queue := make([]*TreeNode,0) out := make([][]int,0) queue = append(queue, root) for len(queue) != 0 { l := len(queue) arr := make([]int,0) for i := 0; i level { fmt.Println(level, result, root.Val) (*result)[level] = append((*result)[level], root.Val) } else { *result = append(*result, []int{root.Val}) } orderBottom(root.Left, result, level+1) orderBottom(root.Right, result, level+1) } 108.将有序数组转换为二叉搜索树(2) 题目 将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 示例: 给定有序数组: [-10,-3,0,5,9], 一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树： 0 / \\ -3 9 / / -10 5 解题思路 No. 思路 时间复杂度 空间复杂度 01(最优) 递归 O(n) O(log(n)) 02 迭代 O(n) O(n) // 递归 func sortedArrayToBST(nums []int) *TreeNode { if len(nums) == 0 { return nil } mid := len(nums) / 2 return &TreeNode{ Val: nums[mid], Left: sortedArrayToBST(nums[:mid]), Right: sortedArrayToBST(nums[mid+1:]), } } // 迭代 type MyTreeNode struct { root *TreeNode start int end int } func sortedArrayToBST(nums []int) *TreeNode { if len(nums) == 0 { return nil } queue := make([]MyTreeNode, 0) root := &TreeNode{Val: 0} queue = append(queue, MyTreeNode{root, 0, len(nums)}) for len(queue) > 0 { myRoot := queue[0] queue = queue[1:] start := myRoot.start end := myRoot.end mid := (start + end) / 2 curRoot := myRoot.root curRoot.Val = nums[mid] if start 110.平衡二叉树(2) 题目 给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。 示例 1: 给定二叉树 [3,9,20,null,null,15,7] 3 / \\ 9 20 / \\ 15 7 返回 true 。 示例 2: 给定二叉树 [1,2,2,3,3,null,null,4,4] 1 / \\ 2 2 / \\ 3 3 / \\ 4 4 返回 false 。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 递归 O(n) O(log(n)) func isBalanced(root *TreeNode) bool { _, isBalanced := recur(root) return isBalanced } func recur(root *TreeNode) (int, bool) { if root == nil { return 0, true } leftDepth, leftIsBalanced := recur(root.Left) if leftIsBalanced == false{ return 0,false } rightDepth, rightIsBalanced := recur(root.Right) if rightIsBalanced == false{ return 0,false } if -1 b { return a } return b } # func isBalanced(root *TreeNode) bool { return dfs(root) != -1 } func dfs(root *TreeNode) int { if root == nil { return 0 } left := dfs(root.Left) right := dfs(root.Right) if left != -1 && right != -1 && abs(left, right) b { return a } return b } func abs(a, b int) int { if a > b { return a - b } return b - a } 111.二叉树的最小深度(2) 题目 给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明: 叶子节点是指没有子节点的节点。 示例: 给定二叉树 [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 返回它的最小深度 2. 解题思路 No. 思路 时间复杂度 空间复杂度 01(最优) 递归 O(n) O(log(n)) 02 广度优先 O(n) O(n) // 递归 func minDepth(root *TreeNode) int { if root == nil { return 0 } else if root.Left == nil { return 1 + minDepth(root.Right) } else if root.Right == nil { return 1 + minDepth(root.Left) } else { return 1 + min(minDepth(root.Left), minDepth(root.Right)) } } func min(a, b int) int { if a 0{ length := len(list) for i := 0; i 112.路径总和(2) 题目 给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的节点。 示例: 给定如下二叉树，以及目标和 sum = 22， 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\ 7 2 1 返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。 解题思路 No. 思路 时间复杂度 空间复杂度 01(最优) 递归 O(n) O(log(n)) 02 迭代 O(n) O(n) // 递归 func hasPathSum(root *TreeNode, sum int) bool { if root == nil { return false } sum = sum - root.Val if root.Left == nil && root.Right == nil { return sum == 0 } return hasPathSum(root.Left, sum) || hasPathSum(root.Right, sum) } // 迭代 func hasPathSum(root *TreeNode, sum int) bool { if root == nil { return false } list1 := list.New() list2 := list.New() list1.PushFront(root) list2.PushFront(sum - root.Val) for list1.Len() > 0 { length := list1.Len() for i := 0; i 118.杨辉三角(2) 题目 给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例: 输入: 5 输出: [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1] ] 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n^2) O(n^2) 02(最优) 递推 O(n^2) O(n^2) // 动态规划 func generate(numRows int) [][]int { var result [][]int for i := 0; i 119.杨辉三角II(3) 题目 给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例: 输入: 3 输出: [1,3,3,1] 进阶： 你可以优化你的算法到 O(k) 空间复杂度吗？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n^2) O(n^2) 02 递推 O(n^2) O(n) 03(最优) 二项式定理 O(n) O(n) // 动态规划 func getRow(rowIndex int) []int { var result [][]int for i := 0; i 0; j--{ res[j] = res[j] + res[j-1] } } return res } // 二项式定理 func getRow(rowIndex int) []int { res := make([]int,rowIndex+1) res[0] = 1 if rowIndex == 0{ return res } // 公式 // C(n,k）= n! /(k! * (n-k)!) // C(n,k) = (n-k+1)/k * C(n,k-1) for i := 1; i 121.买卖股票的最佳时机(3) 题目 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 1: 输入: [7,1,5,3,6,4] 输出: 5 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2: 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法 O(n^2) O(1) 02(最优) 动态规划(从前到后) 最大利润=max{前一天最大利润, 今天的价格 - 之前最低价格} O(n) O(1) 03 动态规划(从后到前) O(n) O(1) // 暴力法 func maxProfit(prices []int) int { max := 0 length := len(prices) for i := 0; i max{ max = prices[j] - prices[i] } } } return max } // 动态规划(从前到后) func maxProfit(prices []int) int { if len(prices) = 0; i-- { if max 122.买卖股票的最佳时机II(2) 题目 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 输入: [7,1,5,3,6,4] 输出: 7 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 输入: [1,2,3,4,5] 输出: 4 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 解题思路 No. 思路 时间复杂度 空间复杂度 01(最优) 贪心法 O(n) O(1) 02 峰谷峰顶法 O(n) O(1) func maxProfit(prices []int) int { max := 0 for i := 1; i prices[i-1] { max = max + prices[i] - prices[i-1] } } return max } func maxProfit(prices []int) int { if len(prices) == 0 { return 0 } i := 0 valley := prices[0] peak := prices[0] profit := 0 for i = prices[i+1] { i++ } valley = prices[i] for i 125.验证回文串(2) 题目 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。 示例 1: 输入: \"A man, a plan, a canal: Panama\" 输出: true 示例 2: 输入: \"race a car\" 输出: false 解题思路 No. 思路 时间复杂度 空间复杂度 01( 最优) 双指针法 O(n) O(1) 02 双指针法 O(n) O(n) func isPalindrome(s string) bool { s = strings.ToLower(s) i, j := 0, len(s)-1 for i = '0' && value = 'a' && value 136.只出现一次的数字(4) 题目 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 输入: [2,2,1] 输出: 1 示例 2: 输入: [4,1,2,1,2] 输出: 4 解题思路 No. 思路 时间复杂度 空间复杂度 01(最优) 异或 O(n) O(1) 02 哈希 O(n) O(n) 03 暴力法 O(n^2) O(1) 04 排序遍历 O(nlog(n)) O(1) // 异或 func singleNumber(nums []int) int { res := 0 for _, n := range nums { res = res ^ n } return res } // 哈希 func singleNumber(nums []int) int { m := make(map[int]int) for _,v := range nums{ m[v]++ } for k,v := range m{ if v == 1{ return k } } return -1 } // 暴力法 func singleNumber(nums []int) int { for i := 0; i 141.环形链表(2) 题目 给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 示例 1： 输入：head = [3,2,0,-4], pos = 1 输出：true 解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 输入：head = [1,2], pos = 0 输出：true 解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 输入：head = [1], pos = -1 输出：false 解释：链表中没有环。 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希法 O(n) O(n) 02(最优) 双指针(快慢指针) O(n) O(1) func hasCycle(head *ListNode) bool { m := make(map[*ListNode]bool) for head != nil { if m[head] { return true } m[head] = true head = head.Next } return false } // 双指针(快慢指针) func hasCycle(head *ListNode) bool { if head == nil { return false } fast := head.Next for fast != nil && head != nil && fast.Next != nil { if fast == head { return true } fast = fast.Next.Next head = head.Next } return false } 155.最小栈(2) 题目 设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) -- 将元素 x 推入栈中。 pop() -- 删除栈顶的元素。 top() -- 获取栈顶元素。 getMin() -- 检索栈中的最小元素。 示例: MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); --> 返回 -3. minStack.pop(); minStack.top(); --> 返回 0. minStack.getMin(); --> 返回 -2. 解题思路 No. 思路 时间复杂度 空间复杂度 01(最优) 使用数组模拟栈，保存数据的时候同时保存当前的最小值 O(n) O(n) 02 使用双栈 O(n) O(n) type item struct { min, x int } type MinStack struct { stack []item } func Constructor() MinStack { return MinStack{} } func (this *MinStack) Push(x int) { min := x if len(this.stack) > 0 && this.GetMin() 160.相交链表(4) 题目 编写一个程序，找到两个单链表相交的起始节点。 如下面的两个链表： 在节点 c1 开始相交。 示例 1： 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出：Reference of the node with value = 8 输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。 从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。 在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2： 输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 输出：Reference of the node with value = 2 输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。 从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。 在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3： 输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2 输出：null 输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。 由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。 解释：这两个链表不相交，因此返回 null。 注意： 如果两个链表没有交点，返回 null. 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。 解题思路 No. 思路 时间复杂度 空间复杂度 01 计算长度后，对齐长度再比较 O(n) O(1) 02(最优) 交换后相连，再比较 O(n) O(1) 03 暴力法 O(n^2) O(1) 04 哈希法 O(n) O(n) func getIntersectionNode(headA, headB *ListNode) *ListNode { ALength := 0 A := headA for A != nil { ALength++ A = A.Next } BLength := 0 B := headB for B != nil { BLength++ B = B.Next } pA := headA pB := headB if ALength > BLength { n := ALength - BLength for n > 0 { pA = pA.Next n-- } } else { n := BLength - ALength for n > 0 { pB = pB.Next n-- } } for pA != pB { pA = pA.Next pB = pB.Next } return pA } // func getIntersectionNode(headA, headB *ListNode) *ListNode { A, B := headA, headB for A != B { if A != nil { A = A.Next } else { A = headB } if B != nil { B = B.Next } else { B = headA } } return A } // 暴力法 func getIntersectionNode(headA, headB *ListNode) *ListNode { A, B := headA, headB for A != nil { for B != nil { if A == B { return A } B = B.Next } A = A.Next B = headB } return nil } // 哈希表法 func getIntersectionNode(headA, headB *ListNode) *ListNode { m := make(map[*ListNode]bool) for headA != nil { m[headA] = true headA = headA.Next } for headB != nil { if _, ok := m[headB]; ok { return headB } headB = headB.Next } return nil } 167.两数之和 II - 输入有序数组(4) 题目 给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明: 返回的下标值（index1 和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例: 输入: numbers = [2, 7, 11, 15], target = 9 输出: [1,2] 解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法: 2层循环遍历 O(n^2) O(1) 02 两遍哈希遍历 O(n) O(n) 03 一遍哈希遍历 O(n) O(n) 04(最优) 一遍哈希遍历 O(n) O(1) // 暴力法: 2层循环遍历 func twoSum(nums []int, target int) []int { for i := 0; i target { last-- } else { first++ } } } 168.Excel表列名称(2) 题目 给定一个正整数，返回它在 Excel 表中相对应的列名称。 例如， 1 -> A 2 -> B 3 -> C ... 26 -> Z 27 -> AA 28 -> AB ... 示例 1: 输入: 1 输出: \"A\" 示例 2: 输入: 28 输出: \"AB\" 示例 3: 输入: 701 输出: \"ZY\" 解题思路 No. 思路 时间复杂度 空间复杂度 01(最优) 求余模拟进制 O(log(n)) O(1) 02 递归计算 O(log(n)) O(log(n)) // 求余模拟进制 func convertToTitle(n int) string { str := \"\" for n > 0 { n-- str = string(byte(n%26)+'A') + str n /= 26 } return str } // 递归计算 func convertToTitle(n int) string { if n AZ return convertToTitle((n-y-1)/26)+convertToTitle(26) } return convertToTitle((n-y)/26)+convertToTitle(y) } 169.多数元素(5) 题目 给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 示例 1: 输入: [3,2,3] 输出: 3 示例 2: 输入: [2,2,1,1,1,2,2] 输出: 2 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序取半 O(nlog(n)) O(1) 02 哈希法 O(n) O(n) 03(最优) Boyer-Moore投票算法 O(n) O(1) 04 位运算 O(n) O(1) 05 分治法 O(nlog(n)) O(log(n)) // 排序取半 func majorityElement(nums []int) int { sort.Ints(nums) return nums[len(nums)/2] } // 哈希法 func majorityElement(nums []int) int { m := make(map[int]int) result := 0 for _, v := range nums{ if _,ok := m[v];ok{ m[v]++ }else { m[v]=1 } if m[v] > (len(nums)/2){ result = v } } return result } // Boyer-Moore投票算法 func majorityElement(nums []int) int { result, count := 0, 0 for i := 0; i len(nums)/2 { result = result | mask } mask = mask rightCount { return left } return right } 171.Excel表列序号(1) 题目 给定一个Excel表格中的列名称，返回其相应的列序号。 例如， A -> 1 B -> 2 C -> 3 ... Z -> 26 AA -> 27 AB -> 28 ... 示例 1: 输入: \"A\" 输出: 1 示例 2: 输入: \"AB\" 输出: 28 示例 3: 输入: \"ZY\" 输出: 701 解题思路 No. 思路 时间复杂度 空间复杂度 01 26进制计算 O(log(n)) O(1) func titleToNumber(s string) int { result := 0 for i := 0; i 172.阶乘后的零(1) 题目 给定一个整数 n，返回 n! 结果尾数中零的数量。 示例 1: 输入: 3 输出: 0 解释: 3! = 6, 尾数中没有零。 示例 2: 输入: 5 输出: 1 解释: 5! = 120, 尾数中有 1 个零. 说明: 你算法的时间复杂度应为 O(log n) 。 解题思路 No. 思路 时间复杂度 空间复杂度 01 数学，找规律 O(log(n)) O(1) func trailingZeroes(n int) int { result := 0 for n >= 5 { n = n / 5 result = result + n } return result } 189.旋转数组(4) 题目 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 示例 1: 输入: [1,2,3,4,5,6,7] 和 k = 3 输出: [5,6,7,1,2,3,4] 解释: 向右旋转 1 步: [7,1,2,3,4,5,6] 向右旋转 2 步: [6,7,1,2,3,4,5] 向右旋转 3 步: [5,6,7,1,2,3,4] 示例 2: 输入: [-1,-100,3,99] 和 k = 2 输出: [3,99,-1,-100] 解释: 向右旋转 1 步: [99,-1,-100,3] 向右旋转 2 步: [3,99,-1,-100] 说明: 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。 要求使用空间复杂度为 O(1) 的 原地 算法。 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法 O(n^2) O(1) 02 三次反转法 O(n) O(1) 03 使用额外的数组 O(n) O(n) 04(最优) 环形替换 O(n) O(1) // 暴力法 func rotate(nums []int, k int) { n := len(nums) if k > n { k = k % n } if k == 0 || k == n { return } for i := 0; i n { k = k % n } if k == 0 || k == n { return } reverse(nums, 0, n-1) reverse(nums, 0, k-1) reverse(nums, k, n-1) } func reverse(nums []int, i, j int) { for i n { k = k % n } if k == 0 || k == n { return } arr := make([]int, len(nums)) for i := 0; i n { k = k % n } if k == 0 || k == n { return } count := 0 for i := 0; count 190.颠倒二进制位(3) 题目 颠倒给定的 32 位无符号整数的二进制位。 示例 1： 输入: 00000010100101000001111010011100 输出: 00111001011110000010100101000000 解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596， 因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。 示例 2： 输入：11111111111111111111111111111101 输出：10111111111111111111111111111111 解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293， 因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。 提示： 请注意，在某些语言（如 Java）中，没有无符号整数类型。 在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现， 因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在 Java 中，编译器使用二进制补码记法来表示有符号整数。 因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。 进阶: 如果多次调用这个函数，你将如何优化你的算法？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 位操作 O(1) O(1) 02 转字符串 O(n) O(1) 03 二进制交换 O(1) O(1) func reverseBits(num uint32) uint32 { result := uint32(0) for i := 0; i > 1 } return result } // func reverseBits(num uint32) uint32 { str := strconv.FormatUint(uint64(num), 2) rev := \"\" for i := len(str) - 1; i >= 0; i-- { rev = rev + str[i:i+1] } if len(rev) > 16) | ((num & 0x0000ffff) > 8) | ((num & 0x00ff00ff) > 4) | ((num & 0x0f0f0f0f) > 2) | ((num & 0x33333333) > 1) | ((num & 0x55555555) 191.位1的个数(4) 题目 编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数 （也被称为汉明重量）。 示例 1： 输入：00000000000000000000000000001011 输出：3 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。 示例 2： 输入：00000000000000000000000010000000 输出：1 解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。 示例 3： 输入：11111111111111111111111111111101 输出：31 解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。 提示： 请注意，在某些语言（如 Java）中，没有无符号整数类型。 在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现， 因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在 Java 中，编译器使用二进制补码记法来表示有符号整数。 因此，在上面的 示例 3 中，输入表示有符号整数 -3。 进阶: 如果多次调用这个函数，你将如何优化你的算法？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 循环位计算 O(1) O(1) 02(最优) 位计算n&(n-1)，会把该整数的最右边的1变成0 O(1) O(1) 03 内置函数 O(1) O(1) 04 遍历 O(1) O(1) // 循环位计算 func hammingWeight(num uint32) int { count := 0 for num != 0 { if num&1 == 1 { count++ } num = num >> 1 } return count } // func hammingWeight(num uint32) int { count := 0 for num != 0 { num = num & (num - 1) count++ } return count } # func hammingWeight(num uint32) int { return strings.Count(strconv.FormatInt(int64(num),2),\"1\") // return strings.Count(fmt.Sprintf(\"%b\",num),\"1\") } # func hammingWeight(num uint32) int { count := 0 flag := uint32(1) for flag != 0 { if num&flag == flag { count++ } flag = flag 198.打家劫舍(4) 题目 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金， 影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统， 如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1:输入: [1,2,3,1] 输出: 4 解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2: 输入: [2,7,9,3,1] 输出: 12 解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 解题思路 No. 思路 时间复杂度 空间复杂度 01(最优) 动态规划 O(n) O(1) 02 动态规划+一维数组 O(n) O(n) 03 动态规划+二维数组 O(n) O(n) 04 奇偶法 O(n) O(1) func rob(nums []int) int { if len(nums) == 0 { return 0 } if len(nums) == 1 { return nums[0] } a := nums[0] b := max(a, nums[1]) for i := 2; i b { return a } return b } # func rob(nums []int) int { n := len(nums) if n == 0 { return 0 } if n == 1 { return nums[0] } dp := make([]int, n) dp[0] = nums[0] if nums[0] > nums[1] { dp[1] = nums[0] } else { dp[1] = nums[1] } for i := 2; i b { return a } return b } # func rob(nums []int) int { if len(nums) == 0 { return 0 } if len(nums) == 1 { return nums[0] } n := len(nums) dp := make([][]int, n) for n := range dp { dp[n] = make([]int, 2) } dp[0][0], dp[0][1] = 0, nums[0] for i := 1; i b { return a } return b } # func rob(nums []int) int { var a, b int for i, v := range nums { if i%2 == 0 { a = max(a+v, b) } else { b = max(a, b+v) } } return max(a, b) } func max(a, b int) int { if a > b { return a } return b } 0101-0200-Medium 102.二叉树的层序遍历(2) 题目 给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。 示例：二叉树：[3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 返回其层次遍历结果： [ [3], [9,20], [15,7] ] 解题思路 No. 思路 时间复杂度 空间复杂度 01 层序遍历 O(n) O(n) 02 递归 O(n) O(n) func levelOrder(root *TreeNode) [][]int { res := make([][]int, 0) if root == nil { return res } list := make([]*TreeNode, 0) list = append(list, root) for len(list) > 0 { length := len(list) temp := make([]int, 0) for i := 0; i 103.二叉树的锯齿形层次遍历(2) 题目 给定一个二叉树，返回其节点值的锯齿形层次遍历。 （即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 例如：给定二叉树 [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 返回锯齿形层次遍历如下： [ [3], [20,9], [15,7] ] 解题思路 No. 思路 时间复杂度 空间复杂度 01 层序遍历 O(n) O(n) 02 递归 O(n) O(n) func zigzagLevelOrder(root *TreeNode) [][]int { res := make([][]int, 0) if root == nil { return res } list := make([]*TreeNode, 0) list = append(list, root) for len(list) > 0 { length := len(list) temp := make([]int, 0) for i := 0; i 105.从前序与中序遍历序列构造二叉树(3) 题目 根据一棵树的前序遍历与中序遍历构造二叉树。 注意:你可以假设树中没有重复的元素。 例如，给出 前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树： 3 / \\ 9 20 / \\ 15 7 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(n) 02 迭代 O(n) O(n) 03 递归 O(n) O(n) func buildTree(preorder []int, inorder []int) *TreeNode { for k := range inorder { if inorder[k] == preorder[0] { return &TreeNode{ Val: preorder[0], Left: buildTree(preorder[1:k+1], inorder[0:k]), Right: buildTree(preorder[k+1:], inorder[k+1:]), } } } return nil } # 2 func buildTree(preorder []int, inorder []int) *TreeNode { if preorder == nil || len(preorder) == 0 { return nil } root := &TreeNode{ Val: preorder[0], } length := len(preorder) stack := make([]*TreeNode, 0) stack = append(stack, root) index := 0 for i := 1; i 0 && stack[len(stack)-1].Val == inorder[index] { node = stack[len(stack)-1] stack = stack[:len(stack)-1] index++ } node.Right = &TreeNode{Val: value} stack = append(stack, node.Right) } } return root } # func buildTree(preorder []int, inorder []int) *TreeNode { if len(preorder) == 0 { return nil } return helper(preorder, inorder) } func helper(preorder []int, inorder []int) *TreeNode { var root *TreeNode for k := range inorder { if inorder[k] == preorder[0] { root = &TreeNode{Val: preorder[0]} root.Left = helper(preorder[1:k+1], inorder[0:k]) root.Right = helper(preorder[k+1:], inorder[k+1:]) } } return root } 106.从中序与后序遍历序列构造二叉树(3) 题目 根据一棵树的中序遍历与后序遍历构造二叉树。 注意:你可以假设树中没有重复的元素。 例如，给出 中序遍历 inorder = [9,3,15,20,7] 后序遍历 postorder = [9,15,7,20,3] 返回如下的二叉树： 3 / \\ 9 20 / \\ 15 7 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(n) 02 递归 O(n) O(n) 03 迭代 O(n) O(n) func buildTree(inorder []int, postorder []int) *TreeNode { last := len(postorder) - 1 for k := range inorder { if inorder[k] == postorder[last] { return &TreeNode{ Val: postorder[last], Left: buildTree(inorder[0:k], postorder[0:k]), Right: buildTree(inorder[k+1:], postorder[k:last]), } } } return nil } # func buildTree(inorder []int, postorder []int) *TreeNode { if len(postorder) == 0 { return nil } return helper(inorder, postorder) } func helper(inorder []int, postorder []int) *TreeNode { var root *TreeNode last := len(postorder) - 1 for k := range inorder { if inorder[k] == postorder[last] { root = &TreeNode{Val: postorder[last]} root.Left = helper(inorder[0:k], postorder[0:k]) root.Right = helper(inorder[k+1:], postorder[k:last]) } } return root } # func buildTree(inorder []int, postorder []int) *TreeNode { if postorder == nil || len(postorder) == 0 { return nil } last := len(postorder) - 1 root := &TreeNode{ Val: postorder[last], } length := len(postorder) stack := make([]*TreeNode, 0) stack = append(stack, root) index := last for i := length - 2; i >= 0; i-- { value := postorder[i] node := stack[len(stack)-1] if node.Val != inorder[index] { node.Right = &TreeNode{Val: value} stack = append(stack, node.Right) } else { for len(stack) > 0 && stack[len(stack)-1].Val == inorder[index] { node = stack[len(stack)-1] stack = stack[:len(stack)-1] index-- } node.Left = &TreeNode{Val: value} stack = append(stack, node.Left) } } return root } 109.有序链表转换二叉搜索树(2) 题目 给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 示例:给定的有序链表： [-10, -3, 0, 5, 9], 一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树： 0 / \\ -3 9 / / -10 5 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(nlog(n)) O(log(n)) 02 数组辅助 O(n) O(n) func sortedListToBST(head *ListNode) *TreeNode { if head == nil { return nil } mid := find(head) if mid == head { return &TreeNode{Val: mid.Val} } return &TreeNode{ Val: mid.Val, Left: sortedListToBST(head), Right: sortedListToBST(mid.Next), } } func find(head *ListNode) *ListNode { if head == nil { return nil } slow, fast := head, head var prev *ListNode for fast != nil && fast.Next != nil { prev = slow slow = slow.Next fast = fast.Next.Next } if prev != nil { prev.Next = nil } return slow } # func sortedListToBST(head *ListNode) *TreeNode { if head == nil { return nil } arr := make([]int, 0) for head != nil { arr = append(arr, head.Val) head = head.Next } return sortArr(arr) } func sortArr(arr []int) *TreeNode { if len(arr) == 0 { return nil } return &TreeNode{ Val: arr[len(arr)/2], Left: sortArr(arr[:len(arr)/2]), Right: sortArr(arr[len(arr)/2+1:]), } } 113.路径总和II(2) 题目 给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。 说明: 叶子节点是指没有子节点的节点。 示例:给定如下二叉树，以及目标和 sum = 22， 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\ 7 2 5 1 返回: [ [5,4,11,2], [5,8,4,5] ] 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 迭代 O(n) O(n) var res [][]int func pathSum(root *TreeNode, sum int) [][]int { if root == nil { return nil } res = make([][]int, 0) var arr []int dfs(root, sum, arr) return res } func dfs(root *TreeNode, sum int, arr []int) { if root == nil { return } arr = append(arr, root.Val) if root.Val == sum && root.Left == nil && root.Right == nil { temp := make([]int, len(arr)) copy(temp, arr) res = append(res, temp) } dfs(root.Left, sum-root.Val, arr) dfs(root.Right, sum-root.Val, arr) arr = arr[:len(arr)-1] } # func pathSum(root *TreeNode, sum int) [][]int { res := make([][]int, 0) if root == nil { return res } temp := make([]int, 0) stack := make([]*TreeNode, 0) visited := make(map[*TreeNode]bool) curSum := 0 for root != nil || len(stack) > 0 { for root != nil { temp = append(temp, root.Val) curSum = curSum + root.Val visited[root] = true stack = append(stack, root) root = root.Left } node := stack[len(stack)-1] if node.Right == nil || visited[node.Right] { if node.Left == nil && node.Right == nil && curSum == sum { tmp := make([]int, len(temp)) copy(tmp, temp) res = append(res, tmp) } stack = stack[:len(stack)-1] temp = temp[:len(temp)-1] curSum = curSum - node.Val root = nil } else { root = node.Right } } return res } 114.二叉树展开为链表(3) 题目 给定一个二叉树，原地将它展开为一个单链表。 例如，给定二叉树 1 / \\ 2 5 / \\ \\ 3 4 6 将其展开为： 1 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 递归 O(n) O(log(n)) 03 迭代 O(n) O(n) // 将原左子树变为节点的右子树 // 再将原右子树变为当前右子树最右节点的右子树。 func flatten(root *TreeNode) { if root == nil { return } flatten(root.Left) flatten(root.Right) right := root.Right root.Right, root.Left = root.Left, nil for root.Right != nil { root = root.Right } root.Right = right } # func flatten(root *TreeNode) { dfs(root, nil) } func dfs(root *TreeNode, pre *TreeNode) *TreeNode { if root == nil { return pre } pre = dfs(root.Right, pre) pre = dfs(root.Left, pre) root.Right, root.Left = pre, nil pre = root return pre } # func flatten(root *TreeNode) { if root == nil { return } res := make([]*TreeNode, 0) stack := make([]*TreeNode, 0) stack = append(stack, root) for len(stack) > 0 { node := stack[len(stack)-1] res = append(res, node) stack = stack[:len(stack)-1] if node.Right != nil { stack = append(stack, node.Right) } if node.Left != nil { stack = append(stack, node.Left) } } for i := 1; i 116.填充每个节点的下一个右侧节点指针 题目 解题思路 117.填充每个节点的下一个右侧节点指针II 题目 解题思路 120.三角形最小路径和(5) 题目 给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。 相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。 例如，给定三角形： [ [2], [3,4], [6,5,7], [4,1,8,3] ] 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 说明：如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n^2) O(n^2) 02 动态规划 O(n^2) O(n) 03 动态规划 O(n^2) O(n) 04 遍历 O(n^2) O(1) 05 递归 O(n^2) O(n^2) func minimumTotal(triangle [][]int) int { n := len(triangle) dp := make([][]int, n) for i := 0; i b { return b } return a } # 2 func minimumTotal(triangle [][]int) int { n := len(triangle) dp := [2][]int{} for i := 0; i b { return b } return a } # 3 func minimumTotal(triangle [][]int) int { n := len(triangle) dp := make([]int, n) dp[0] = triangle[0][0] for i := 1; i 0; j-- { dp[j] = min(dp[j-1], dp[j]) + triangle[i][j] } dp[0] = dp[0] + triangle[i][0] } res := dp[0] for i := 1; i b { return b } return a } # 4 func minimumTotal(triangle [][]int) int { n := len(triangle) for i := n - 2; i >= 0; i-- { for j := 0; j b { return b } return a } # 5 var dp [][]int func minimumTotal(triangle [][]int) int { dp = make([][]int, len(triangle)) for i := 0; i b { return b } return a } 127.单词接龙 题目 给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。 转换需遵循如下规则： 每次转换只能改变一个字母。 转换过程中的中间单词必须是字典中的单词。 说明: 如果不存在这样的转换序列，返回 0。 所有单词具有相同的长度。 所有单词只由小写字母组成。 字典中不存在重复的单词。 你可以假设 beginWord 和 endWord 是非空的，且二者不相同。 示例 1:输入: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"] 输出: 5 解释: 一个最短转换序列是 \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\", 返回它的长度 5。 示例 2:输入: beginWord = \"hit\" endWord = \"cog\" wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"] 输出: 0 解释: endWord \"cog\" 不在字典中，所以无法进行转换。 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n^2) O(n^2) 129.求根到叶子节点数字之和(2) 题目 给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。 例如，从根到叶子节点路径 1->2->3 代表数字 123。 计算从根到叶子节点生成的所有数字之和。 说明: 叶子节点是指没有子节点的节点。 示例 1:输入: [1,2,3] 1 / \\ 2 3 输出: 25 解释: 从根到叶子节点路径 1->2 代表数字 12. 从根到叶子节点路径 1->3 代表数字 13. 因此，数字总和 = 12 + 13 = 25. 示例 2:输入: [4,9,0,5,1] 4 / \\ 9 0 / \\ 5 1 输出: 1026 解释: 从根到叶子节点路径 4->9->5 代表数字 495. 从根到叶子节点路径 4->9->1 代表数字 491. 从根到叶子节点路径 4->0 代表数字 40. 因此，数字总和 = 495 + 491 + 40 = 1026。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 迭代 O(n) O(n) var res int func sumNumbers(root *TreeNode) int { res = 0 dfs(root, 0) return res } func dfs(root *TreeNode, sum int) { if root == nil { return } sum = sum*10 + root.Val if root.Left == nil && root.Right == nil { res = res + sum } dfs(root.Left, sum) dfs(root.Right, sum) } # func sumNumbers(root *TreeNode) int { res := 0 if root == nil { return res } list := make([]*TreeNode, 0) list = append(list, root) for len(list) > 0 { length := len(list) for i := 0; i 130.被围绕的区域(1) 题目 给定一个二维的矩阵，包含 'X' 和 'O'（字母 O）。 找到所有被 'X' 围绕的区域，并将这些区域里所有的 'O' 用 'X' 填充。 示例: X X X X X O O X X X O X X O X X 运行你的函数后，矩阵变为： X X X X X X X X X X X X X O X X 解释: 被围绕的区间不会存在于边界上，换句话说，任何边界上的 'O' 都不会被填充为 'X'。 任何不在边界上，或不与边界上的 'O' 相连的 'O' 最终都会被填充为 'X'。 如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。 解题思路 No. 思路 时间复杂度 空间复杂度 01 深度优先搜索 O(n^2) O(1) func solve(board [][]byte) { if board == nil || len(board) == 0 { return } for i := 0; i = len(board) || j >= len(board[0]) || board[i][j] == '#' || board[i][j] == 'X' { return } board[i][j] = '#' dfs(board, i+1, j) dfs(board, i-1, j) dfs(board, i, j+1) dfs(board, i, j-1) } 131.分割回文串(2) 题目 给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。 返回 s 所有可能的分割方案。 示例:输入: \"aab\" 输出: [ [\"aa\",\"b\"], [\"a\",\"a\",\"b\"] ] 解题思路 No. 思路 时间复杂度 空间复杂度 01 回溯 O(n*2^n) O(n*2^n) 02 动态规划+回溯 O(n*2^n) O(n*2^n) var res [][]string func partition(s string) [][]string { res = make([][]string, 0) arr := make([]string, 0) dfs(s, 0, arr) return res } func dfs(s string, level int, arr []string) { if level == len(s) { temp := make([]string, len(arr)) copy(temp, arr) res = append(res, temp) return } for i := level; i 133.克隆图 题目 解题思路 134.加油站(2) 题目 在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。 你从其中的一个加油站出发，开始时油箱为空。 如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。 说明: 如果题目有解，该答案即为唯一答案。 输入数组均为非空数组，且长度相同。 输入数组中的元素均为非负数。 示例 1:输入: gas = [1,2,3,4,5] cost = [3,4,5,1,2] 输出: 3 解释:从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。 因此，3 可为起始索引。 示例 2:输入: gas = [2,3,4] cost = [3,4,3]输出: -1 解释:你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。 我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油 开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油 开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油 你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。 因此，无论怎样，你都不可能绕环路行驶一周。。 解题思路 No. 思路 时间复杂度 空间复杂度 01 贪心 O(n) O(1) 02 暴力法 O(n^2) O(1) func canCompleteCircuit(gas []int, cost []int) int { total, sum, start := 0, 0, 0 for i := 0; i 1, 2, 3, 4, -11, 12 // 1->-11 -11 -11 -11 =0)， // 那么i和j之间的所有点都到不了b(= cost[j] { return i } total = total - cost[j] } } gas = append(gas[1:], gas[0]) cost = append(cost[1:], cost[0]) } return -1 } 137.只出现一次的数字II(5) 题目 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1:输入: [2,2,3,2] 输出: 3 示例 2:输入: [0,1,0,1,0,1,99] 输出: 99 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(n) 02 排序遍历 O(nlog(n)) O(1) 03 位运算 O(n) O(1) 04 位运算 O(n) O(1) 05 数学计算 O(n) O(n) func singleNumber(nums []int) int { m := make(map[int]int) for _, v := range nums { m[v]++ } for k, v := range m { if v == 1 { return k } } return 0 } # 2 func singleNumber(nums []int) int { sort.Ints(nums) for i := 0; i >i) & 1 ==1{ count++ } } res |= count%3 138.复制带随机指针的链表 题目 给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。 要求返回这个链表的 深拷贝。 我们用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示： val：一个表示 Node.val 的整数。 random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为 null 。 示例 1：输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]] 输出：[[7,null],[13,0],[11,4],[10,2],[1,0]] 示例 2：输入：head = [[1,1],[2,1]] 输出：[[1,1],[2,1]] 示例 3：输入：head = [[3,null],[3,0],[3,null]] 输出：[[3,null],[3,0],[3,null]] 示例 4：输入：head = [] 输出：[] 解释：给定的链表为空（空指针），因此返回 null。 提示： -10000 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(n) 139.单词拆分(1) 题目 给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict， 判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 说明： 拆分时可以重复使用字典中的单词。 你可以假设字典中没有重复的单词。 示例 1：输入: s = \"leetcode\", wordDict = [\"leet\", \"code\"] 输出: true 解释: 返回 true 因为 \"leetcode\" 可以被拆分成 \"leet code\"。 示例 2：输入: s = \"applepenapple\", wordDict = [\"apple\", \"pen\"] 输出: true 解释: 返回 true 因为 \"applepenapple\" 可以被拆分成 \"apple pen apple\"。 注意你可以重复使用字典中的单词。 示例 3：输入: s = \"catsandog\", wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"] 输出: false 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n^2) O(n) func wordBreak(s string, wordDict []string) bool { m := make(map[string]bool) for i := 0; i 142.环形链表II 题目 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 说明：不允许修改给定的链表。 示例 1：输入：head = [3,2,0,-4], pos = 1 输出：tail connects to node index 1 解释：链表中有一个环，其尾部连接到第二个节点。 示例 2：输入：head = [1,2], pos = 0 输出：tail connects to node index 0 解释：链表中有一个环，其尾部连接到第一个节点。 示例 3：输入：head = [1], pos = -1 输出：no cycle 解释：链表中没有环。 进阶：你是否可以不用额外空间解决此题？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n^2) O(n) 143.重排链表 题目 给定一个单链表 L：L0→L1→…→Ln-1→Ln ， 将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→… 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例 1:给定链表 1->2->3->4, 重新排列为 1->4->2->3. 示例 2:给定链表 1->2->3->4->5, 重新排列为 1->5->2->4->3. 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n^2) O(n) 144.二叉树的前序遍历(3) 题目 给定一个二叉树，返回它的 前序 遍历。 示例:输入: [1,null,2,3] 1 \\ 2 / 3 输出: [1,2,3] 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(n) 02 迭代 O(n) O(n) 03 迭代 O(n) O(n) var res []int func preorderTraversal(root *TreeNode) []int { res = make([]int, 0) dfs(root) return res } func dfs(root *TreeNode) { if root != nil { res = append(res, root.Val) dfs(root.Left) dfs(root.Right) } } # 2 func preorderTraversal(root *TreeNode) []int { res := make([]int, 0) stack := make([]*TreeNode, 0) for len(stack) > 0 || root != nil { for root != nil { res = append(res, root.Val) stack = append(stack, root.Right) root = root.Left } last := len(stack) - 1 root = stack[last] stack = stack[:last] } return res } # 3 func preorderTraversal(root *TreeNode) []int { res := make([]int, 0) if root == nil { return res } stack := make([]*TreeNode, 0) stack = append(stack, root) for len(stack) > 0 { node := stack[len(stack)-1] stack = stack[:len(stack)-1] res = append(res, node.Val) if node.Right != nil { stack = append(stack, node.Right) } if node.Left != nil { stack = append(stack, node.Left) } } return res } 146.LRU缓存机制 题目 解题思路 147.对链表进行插入排序 题目 解题思路 148.排序链表 题目 解题思路 150.逆波兰表达式求值(1) 题目 根据 逆波兰表示法，求表达式的值。 有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 说明： 整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。 示例 1：输入: [\"2\", \"1\", \"+\", \"3\", \"*\"] 输出: 9 解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9 示例 2：输入: [\"4\", \"13\", \"5\", \"/\", \"+\"] 输出: 6 解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6 示例 3： 输入: [\"10\", \"6\", \"9\", \"3\", \"+\", \"-11\", \"*\", \"/\", \"*\", \"17\", \"+\", \"5\", \"+\"] 输出: 22 解释: 该算式转化为常见的中缀算术表达式为： ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22 逆波兰表达式： 逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。 平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。 该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。 逆波兰表达式主要有以下两个优点： 去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。 解题思路 No. 思路 时间复杂度 空间复杂度 01 栈辅助 O(n) O(n) func evalRPN(tokens []string) int { stack := make([]int, 0) for _, v := range tokens { length := len(stack) if v == \"+\" || v == \"-\" || v == \"*\" || v == \"/\" { a := stack[length-2] b := stack[length-1] stack = stack[:length-2] var value int if v == \"+\" { value = a + b } else if v == \"-\" { value = a - b } else if v == \"*\" { value = a * b } else { value = a / b } stack = append(stack, value) } else { value, _ := strconv.Atoi(v) stack = append(stack, value) } } return stack[0] } 151.翻转字符串里的单词(2) 题目 给定一个字符串，逐个翻转字符串中的每个单词。 示例 1：输入: \"the sky is blue\" 输出: \"blue is sky the\" 示例 2：输入: \" hello world! \" 输出: \"world! hello\" 解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 示例 3：输入: \"a good example\" 输出: \"example good a\" 解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 说明： 无空格字符构成一个单词。 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 进阶：请选用 C 语言的用户尝试使用 O(1) 额外空间复杂度的原地解法。 解题思路 No. 思路 时间复杂度 空间复杂度 01 内置函数 O(n) O(n) 02 遍历 O(n) O(n) func reverseWords(s string) string { arr := strings.Fields(s) for i := 0; i 152.乘积最大子数组(2) 题目 给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字）， 并返回该子数组所对应的乘积。 示例 1:输入: [2,3,-2,4] 输出: 6 解释: 子数组 [2,3] 有最大乘积 6。 示例 2:输入: [-2,0,-1] 输出: 0 解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。 -解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n) O(1) 02 暴力法 O(n^2) O(1) func maxProduct(nums []int) int { minValue, maxValue, res := nums[0], nums[0], nums[0] for i := 1; i b { return a } return b } func min(a, b int) int { if a > b { return b } return a } # func maxProduct(nums []int) int { res := math.MinInt64 for i := 0; i res { res = temp } } } return res } 153.寻找旋转排序数组中的最小值(2) 题目 假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 请找出其中最小的元素。 你可以假设数组中不存在重复元素。 示例 1:输入: [3,4,5,1,2]输出: 1 示例 2:输入: [4,5,6,7,0,1,2]输出: 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 二分查找 O(log(n)) O(1) func findMin(nums []int) int { res := nums[0] for i := 1; i nums[right] { left = mid + 1 } else { right = mid } } return nums[left] } 162.寻找峰值(3) 题目 峰值元素是指其值大于左右相邻值的元素。 给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。 数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。 你可以假设 nums[-1] = nums[n] = -∞。 示例 1:输入: nums = [1,2,3,1] 输出: 2 解释: 3 是峰值元素，你的函数应该返回其索引 2。 示例 2:输入: nums = [1,2,1,3,5,6,4] 输出: 1 或 5 解释: 你的函数可以返回索引 1，其峰值元素为 2； 或者返回索引 5， 其峰值元素为 6。 说明:你的解法应该是 O(logN) 时间复杂度的。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 二分查找 O(log(n)) O(1) 03 遍历 O(n) O(1) func findPeakElement(nums []int) int { n := len(nums) if n == 1 { return 0 } for i := 0; i nums[i+1] { return i } if i == n-1 && i-1 >= 0 && nums[i] > nums[i-1] { return i } if i-1 >= 0 && i+1 nums[i+1] && nums[i] > nums[i-1] { return i } } return -1 } # 2 func findPeakElement(nums []int) int { n := len(nums) if n == 1 { return 0 } left := 0 right := n - 1 for left nums[mid+1] { right = mid } else { left = mid + 1 } } return left } # 3 func findPeakElement(nums []int) int { n := len(nums) if n == 1 { return 0 } for i := 0; i nums[i+1] { return i } } return n - 1 } 165.比较版本号(2) 题目 比较两个版本号 version1 和 version2。 如果 version1 > version2 返回 1，如果 version1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(n) 02 遍历 O(n) O(n) func compareVersion(version1 string, version2 string) int { arr1 := strings.Split(version1, \".\") arr2 := strings.Split(version2, \".\") for len(arr1) b { return 1 } else if a 01 b[j] { return 1 } } } return 0 } 166.分数到小数 题目 给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以字符串形式返回小数。 如果小数部分为循环小数，则将循环的部分括在括号内。 示例 1:输入: numerator = 1, denominator = 2 输出: \"0.5\" 示例 2:输入: numerator = 2, denominator = 1 输出: \"2\" 示例 3:输入: numerator = 2, denominator = 3 输出: \"0.(6)\" 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(n) 173.二叉搜索树迭代器 题目 解题思路 179.最大数(2) 题目 给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。 示例 1:输入: [10,2] 输出: 210 示例 2:输入: [3,30,34,5,9] 输出: 9534330 说明: 输出结果可能非常大，所以你需要返回一个字符串而不是整数。 解题思路 No. 思路 时间复杂度 空间复杂度 01 自定义排序 O(nlog(n)) O(n) 02 自定义排序 O(nlog(n)) O(n) func largestNumber(nums []int) string { arr := make([]string, 0) for i := 0; i = arr[j]+arr[i] }) res := strings.Join(arr, \"\") if res[0] == '0' { return \"0\" } return res } # func largestNumber(nums []int) string { sort.Slice(nums, func(i, j int) bool { return fmt.Sprintf(\"%d%d\", nums[i], nums[j]) >= fmt.Sprintf(\"%d%d\", nums[j], nums[i]) }) res := \"\" for i := 0; i 187.重复的DNA序列 题目 所有 DNA 都由一系列缩写为 A，C，G 和 T 的核苷酸组成，例如：“ACGAATTCCG”。 在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。 编写一个函数来查找目标子串，目标子串的长度为 10，且在 DNA 字符串 s 中出现次数超过一次。 示例：输入：s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\" 输出：[\"AAAAACCCCC\", \"CCCCCAAAAA\"] 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(n) func findRepeatedDnaSequences(s string) []string { res := make([]string, 0) m := make(map[string]int) for i := 0; i 1 { res = append(res, k) } } return res } 199.二叉树的右视图(2) 题目 给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 示例:输入: [1,2,3,null,5,null,4] 输出: [1, 3, 4] 解释: 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 迭代 O(n) O(n) 02 递归 O(n) O(log(n)) func rightSideView(root *TreeNode) []int { res := make([]int, 0) if root == nil{ return res } list := make([]*TreeNode, 0) list = append(list, root) for len(list) > 0 { length := len(list) res = append(res, list[0].Val) for i := 0; i len(res) { res = append(res, root.Val) } dfs(root.Right, level+1) dfs(root.Left, level+1) } 200.岛屿数量(1) 题目 给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 示例 1:输入: [ ['1','1','1','1','0'], ['1','1','0','1','0'], ['1','1','0','0','0'], ['0','0','0','0','0'] ] 输出: 1 示例 2:输入: [ ['1','1','0','0','0'], ['1','1','0','0','0'], ['0','0','1','0','0'], ['0','0','0','1','1'] ] 输出: 3 解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。 解题思路 No. 思路 时间复杂度 空间复杂度 01 深度优先遍历 O(n^2) O(1) func numIslands(grid [][]byte) int { res := 0 for i := 0; i = len(grid) || j >= len(grid[0]) || grid[i][j] == '0' { return } grid[i][j] = '0' dfs(grid, i+1, j) dfs(grid, i-1, j) dfs(grid, i, j+1) dfs(grid, i, j-1) } Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-07-26 22:19:47 "},"docs/source/question/0201-0300.html":{"url":"docs/source/question/0201-0300.html","title":"0201-0300","keywords":"","body":"0201-0300-Easy 0201-0300-Easy 202.快乐数(2) 203.移除链表元素(2) 204.计数质数(2) 205.同构字符串(3) 206.反转链表(4) 217.存在重复元素(2) 219.存在重复元素 II(2) 225.用队列实现栈(4) 226.翻转二叉树(2) 231.2的幂(3) 232.用栈实现队列(3) 234.回文链表(4) 235.二叉搜索树的最近公共祖先(2) 237.删除链表中的节点(1) 242.有效的字母异位词(2) 257.二叉树的所有路径(2) 258.各位相加(4) 263.丑数(2) 268.缺失数字(5) 278.第一个错误的版本(2) 283.移动零(3) 290.单词规律(2) 292.Nim 游戏(1) 299.猜数字游戏(2) 202.快乐数(2) 题目 编写一个算法来判断一个数 n 是不是快乐数。 「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和， 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。 如果 可以变为 1，那么这个数就是快乐数。 如果 n 是快乐数就返回 True ；不是，则返回 False 。 示例： 输入：19 输出：true 解释： 12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希+遍历 O(log(n)) O(log(n)) 02 遍历+快慢判断环 O(log(n)) O(1) func isHappy(n int) bool { now, next := n, nextValue(n) m := make(map[int]int) m[now] = 1 for { if next == 1 { break } if _, ok := m[next]; ok { break } else { m[next] = 1 } next = nextValue(next) } if next == 1 { return true } return false } func nextValue(n int) int { ret := 0 for n != 0 { ret = ret + (n%10)*(n%10) n = n / 10 } return ret } # func isHappy(n int) bool { now, next := n, nextValue(n) for now != next { now = nextValue(now) next = nextValue(nextValue(next)) } if now == 1 { return true } return false } func nextValue(n int) int { ret := 0 for n != 0 { ret = ret + (n%10)*(n%10) n = n / 10 } return ret } 203.移除链表元素(2) 题目 删除链表中等于给定值 val 的所有节点。 示例: 输入: 1->2->6->3->4->5->6, val = 6 输出: 1->2->3->4->5 解题思路 No. 思路 时间复杂度 空间复杂度 01 哨兵结点+链表遍历 O(n) O(1) 02 递归 O(n) O(n) func removeElements(head *ListNode, val int) *ListNode { headPre := &ListNode{Next: head} temp := headPre for temp.Next != nil { if temp.Next.Val == val { //delete temp.Next = temp.Next.Next } else { temp = temp.Next } } return headPre.Next } # 递归 func removeElements(head *ListNode, val int) *ListNode { if head == nil { return nil } head.Next = removeElements(head.Next, val) if head.Val == val { return head.Next } return head } 204.计数质数(2) 题目 统计所有小于非负整数 n 的质数的数量。 示例: 输入: 10 输出: 4 解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。 解题思路 No. 思路 时间复杂度 空间复杂度 01 筛选质数(厄拉多塞筛法) O(n^2) O(n) 02 筛选质数优化 O(n) O(n) func countPrimes(n int) int { if n 205.同构字符串(3) 题目 给定两个字符串 s 和 t，判断它们是否是同构的。 如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。 所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。 两个字符不能映射到同一个字符上，但字符可以映射自己本身。 示例 1: 输入: s = \"egg\", t = \"add\" 输出: true 示例 2:输入: s = \"foo\", t = \"bar\" 输出: false 示例 3: 输入: s = \"paper\", t = \"title\" 输出: true 说明:你可以假设 s 和 t 具有相同的长度。 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组映射 O(n) O(n) 02 哈希映射 O(n) O(n) 03 字符串查找匹配 O(n) O(1) func isIsomorphic(s string, t string) bool { if len(s) != len(t) { return false } m1 := make([]int, 256) m2 := make([]int, 256) for i := 0; i 206.反转链表(4) 题目 反转一个单链表。 示例: 输入: 1->2->3->4->5->NULL 输出: 5->4->3->2->1->NULL 进阶: 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(n) 02 迭代 O(n) O(1) 03 数组辅助 O(n) O(n) 04 迭代-新建节点 O(n) O(1) func reverseList(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } result := reverseList(head.Next) head.Next.Next = head head.Next = nil return result } // func reverseList(head *ListNode) *ListNode { var result *ListNode var temp *ListNode for head != nil { temp = head.Next head.Next = result result = head head = temp } return result } # func reverseList(head *ListNode) *ListNode { result := &ListNode{} arr := make([]*ListNode, 0) for head != nil { arr = append(arr, head) head = head.Next } temp := result for i := len(arr) - 1; i >= 0; i-- { arr[i].Next = nil temp.Next = arr[i] temp = temp.Next } return result.Next } # func reverseList(head *ListNode) *ListNode { var res *ListNode for { if head == nil { break } res = &ListNode{head.Val, res} head = head.Next } return res } 217.存在重复元素(2) 题目 给定一个整数数组，判断是否存在重复元素。 如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。 示例 1:输入: [1,2,3,1] 输出: true 示例 2:输入: [1,2,3,4] 输出: false 示例 3:输入: [1,1,1,3,3,4,3,2,4,2] 输出: true 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助遍历 O(n) O(n) 02 排序后遍历 O(nlog(n)) O(1) func containsDuplicate(nums []int) bool { m := make(map[int]int) for i := 0; i 219.存在重复元素 II(2) 题目 给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j， 使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。 示例 1:输入: nums = [1,2,3,1], k = 3输出: true 示例 2:输入: nums = [1,0,1,1], k = 1 输出: true 示例 3:输入: nums = [1,2,3,1,2,3], k = 2 输出: false 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助遍历 O(n) O(n) 02 哈希表+滑动窗口 O(n) O(n) # func containsNearbyDuplicate(nums []int, k int) bool { m := make(map[int]int) for i, n := range nums { if m[n] != 0 && (i+1)-m[n] k { delete(m, nums[i-k]) } } return false } 225.用队列实现栈(4) 题目 使用队列实现栈的下列操作： push(x) -- 元素 x 入栈 pop() -- 移除栈顶元素 top() -- 获取栈顶元素 empty() -- 返回栈是否为空 注意: 你只能使用队列的基本操作-- 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。 你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。 你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。 解题思路 No. 思路 时间复杂度 空间复杂度 01 使用切片实现 O(1) O(n) 02 使用1个list实现 O(1) O(n) 03 使用2个list实现 O(n) O(n) 04 使用2个双端队列deque实现 O(n) O(n) type MyStack struct { arr []int } func Constructor() MyStack { return MyStack{} } func (m *MyStack) Push(x int) { m.arr = append(m.arr, x) } func (m *MyStack) Pop() int { if len(m.arr) == 0 { return 0 } last := m.arr[len(m.arr)-1] m.arr = m.arr[0 : len(m.arr)-1] return last } func (m *MyStack) Top() int { if len(m.arr) == 0 { return 0 } return m.arr[len(m.arr)-1] } func (m *MyStack) Empty() bool { if len(m.arr) == 0 { return true } return false } # 使用1个list实现 type MyStack struct { *list.List } func Constructor() MyStack { return MyStack{ list.New(), } } func (m *MyStack) Push(x int) { m.PushBack(x) } func (m *MyStack) Pop() int { if m.Len() == 0 { return -1 } return m.Remove(m.Back()).(int) } func (m *MyStack) Top() int { if m.Len() == 0 { return -1 } return m.Back().Value.(int) } func (m *MyStack) Empty() bool { return m.Len() == 0 } # 使用2个list实现 /* 入栈过程： 1、q1 为空，放入 q2，否则放入 q1 出栈过程： 1、q1为空：依次取出q2中的元素（除了最后一个），并且放入q1中 取出q2中的最后一个元素，返回结果 否则 依次取出q1中的元素（除了最后一个），并且放入q2中 取出q1中的最后一个元素，返回结果 */ type MyStack struct { l1 *list.List l2 *list.List } func Constructor() MyStack { return MyStack{ l1: list.New(), l2: list.New(), } } func (m *MyStack) Push(x int) { if m.l1.Len() == 0 { m.l2.PushBack(x) } else { m.l1.PushBack(x) } } func (m *MyStack) Pop() int { var top int if m.l1.Len() > 0 { for m.l1.Len() > 1 { m.l2.PushBack(m.l1.Remove(m.l1.Front())) } top = m.l1.Remove(m.l1.Front()).(int) } else { for m.l2.Len() > 1 { m.l1.PushBack(m.l2.Remove(m.l2.Front())) } top = m.l2.Remove(m.l2.Front()).(int) } return top } func (m *MyStack) Top() int { var top int if m.l1.Len() > 0 { for m.l1.Len() > 1 { m.l2.PushBack(m.l1.Remove(m.l1.Front())) } top = m.l1.Back().Value.(int) m.l2.PushBack(m.l1.Remove(m.l1.Front())) } else { for m.l2.Len() > 1 { m.l1.PushBack(m.l2.Remove(m.l2.Front())) } top = m.l2.Back().Value.(int) m.l1.PushBack(m.l2.Remove(m.l2.Front())) } return top } func (m *MyStack) Empty() bool { return m.l1.Len() == 0 && m.l2.Len() == 0 } # 使用2个双端队列deque实现 type MyStack struct { l1 *Queue l2 *Queue } func Constructor() MyStack { return MyStack{ l1: NewQueue(), l2: NewQueue(), } } func (m *MyStack) Push(x int) { m.l1.Push(x) } func (m *MyStack) Pop() int { if m.l2.Len() == 0 { m.l1, m.l2 = m.l2, m.l1 } for m.l2.Len() > 1 { m.l1.Push(m.l2.Pop()) } return m.l2.Pop() } func (m *MyStack) Top() int { res := m.Pop() m.l1.Push(res) return res } func (m *MyStack) Empty() bool { return (m.l1.Len() + m.l2.Len()) == 0 } type Queue struct { nums []int } func NewQueue() *Queue { return &Queue{ nums: []int{}, } } func (q *Queue) Push(n int) { q.nums = append(q.nums, n) } func (q *Queue) Pop() int { if len(q.nums) == 0 { return 0 } res := q.nums[0] q.nums = q.nums[1:] return res } func (q *Queue) Len() int { return len(q.nums) } func (q *Queue) IsEmpty() bool { return q.Len() == 0 } 226.翻转二叉树(2) 题目 翻转一棵二叉树。 示例： 输入： 4 / \\ 2 7 / \\ / \\ 1 3 6 9 输出： 4 / \\ 7 2 / \\ / \\ 9 6 3 1 备注: 这个问题是受到 Max Howell 的 原问题 启发的 ： 谷歌：我们90％的工程师使用您编写的软件(Homebrew)， 但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(n) 02 迭代 O(n) O(n) func invertTree(root *TreeNode) *TreeNode { if root == nil || (root.Left == nil && root.Right == nil) { return root } root.Left, root.Right = invertTree(root.Right), invertTree(root.Left) return root } # func invertTree(root *TreeNode) *TreeNode { if root == nil { return root } var queue []*TreeNode queue = append(queue, root) for len(queue) > 0 { node := queue[0] queue = queue[1:] node.Left, node.Right = node.Right, node.Left if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } return root } 231.2的幂(3) 题目 给定一个整数，编写一个函数来判断它是否是 2 的幂次方。 示例 1:输入: 1 输出: true 解释: 2^0 = 1 示例 2:输入: 16 输出: true 解释: 2^4 = 16 示例 3:输入: 218 输出: false 解题思路 No. 思路 时间复杂度 空间复杂度 01 迭代 O(log(n)) O(1) 02 位运算 O(1) O(1) 03 递归 O(log(n)) O(log(n)) func isPowerOfTwo(n int) bool { if n 1 { if n%2 == 1 { return false } n = n / 2 } return true } # func isPowerOfTwo(n int) bool { if n 232.用栈实现队列(3) 题目 使用栈实现队列的下列操作： push(x) -- 将一个元素放入队列的尾部。 pop() -- 从队列首部移除元素。 peek() -- 返回队列首部的元素。 empty() -- 返回队列是否为空。 示例: MyQueue queue = new MyQueue(); queue.push(1); queue.push(2); queue.peek(); // 返回 1 queue.pop(); // 返回 1 queue.empty(); // 返回 false 说明: 你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。 解题思路 No. 思路 时间复杂度 空间复杂度 01 使用切片实现 O(1) O(n) 02 使用2个栈实现 O(n) O(n) 03 使用2个切片实现 O(n) O(n) type MyQueue struct { a []int } func Constructor() MyQueue { return MyQueue{} } func (m *MyQueue) Push(x int) { m.a = append(m.a, x) } func (m *MyQueue) Pop() int { if len(m.a) == 0 { return 0 } first := m.a[0] m.a = m.a[1:] return first } func (m *MyQueue) Peek() int { if len(m.a) == 0 { return 0 } return m.a[0] } func (m *MyQueue) Empty() bool { if len(m.a) == 0 { return true } return false } # 使用2个栈实现 /* 入队: 直接入栈a 出队: 栈b为空，则把栈a中全部数据出栈进入栈b，然后出栈b,不为空直接出栈b */ type MyQueue struct { a, b *Stack } func Constructor() MyQueue { return MyQueue{ a: NewStack(), b: NewStack(), } } func (m *MyQueue) Push(x int) { m.a.Push(x) } func (m *MyQueue) Pop() int { if m.b.Len() == 0 { for m.a.Len() > 0 { m.b.Push(m.a.Pop()) } } return m.b.Pop() } func (m *MyQueue) Peek() int { res := m.Pop() m.b.Push(res) return res } func (m *MyQueue) Empty() bool { return m.a.Len() == 0 && m.b.Len() == 0 } type Stack struct { nums []int } func NewStack() *Stack { return &Stack{ nums: []int{}, } } func (s *Stack) Push(n int) { s.nums = append(s.nums, n) } func (s *Stack) Pop() int { res := s.nums[len(s.nums)-1] s.nums = s.nums[:len(s.nums)-1] return res } func (s *Stack) Len() int { return len(s.nums) } func (s *Stack) IsEmpty() bool { return s.Len() == 0 } # 使用2个切片实现 type MyQueue struct { a []int b []int } func Constructor() MyQueue { return MyQueue{} } func (m *MyQueue) Push(x int) { m.a = append(m.a, x) } func (m *MyQueue) Pop() int { m.Peek() temp := m.b[len(m.b)-1] m.b = m.b[:len(m.b)-1] return temp } func (m *MyQueue) Peek() int { if len(m.b) == 0 { for len(m.a) > 0 { m.b = append(m.b, m.a[len(m.a)-1]) m.a = m.a[:len(m.a)-1] } } if len(m.b) == 0 { return -1 } return m.b[len(m.b)-1] } func (m *MyQueue) Empty() bool { return len(m.a) == 0 && len(m.b) == 0 } 234.回文链表(4) 题目 请判断一个链表是否为回文链表。 示例 1:输入: 1->2 输出: false 示例 2:输入: 1->2->2->1 输出: true 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助遍历 O(n) O(n) 02 快慢指针反转链表 O(n) O(1) 03 栈辅助 O(n) O(n) 04 递归 O(n) O(n) func isPalindrome(head *ListNode) bool { m := make([]int, 0) for head != nil { m = append(m, head.Val) head = head.Next } i, j := 0, len(m)-1 for i 235.二叉搜索树的最近公共祖先(2) 题目 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x， 满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5] 示例 1:输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 示例 2:输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 输出: 2 解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉搜索树中。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(log(n)) O(log(n)) 02 迭代 O(log(n)) O(1) func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if p.Val > root.Val && q.Val > root.Val{ return lowestCommonAncestor(root.Right, p, q) }else if p.Val root.Val && q.Val > root.Val{ root = root.Right }else if p.Val 237.删除链表中的节点(1) 题目 请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。 现有一个链表 -- head = [4,5,1,9]，它可以表示为: 示例 1: 输入: head = [4,5,1,9], node = 5 输出: [4,1,9] 解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9. 示例 2:输入: head = [4,5,1,9], node = 1 输出: [4,5,9] 解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9. 说明: 链表至少包含两个节点。 链表中所有节点的值都是唯一的。 给定的节点为非末尾节点并且一定是链表中的一个有效节点。 不要从你的函数中返回任何结果。 解题思路 No. 思路 时间复杂度 空间复杂度 01 把当前节点替换成下一个节点 O(1) O(1) func deleteNode(node *ListNode) { node.Val = node.Next.Val node.Next = node.Next.Next } 242.有效的字母异位词(2) 题目 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。 示例 1:输入: s = \"anagram\", t = \"nagaram\"输出: true 示例 2:输入: s = \"rat\", t = \"car\"输出: false 说明:你可以假设字符串只包含小写字母。 进阶:如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(1) 02 排序比较 O(nlog(n)) O(n) func isAnagram(s string, t string) bool { if len(s) != len(t) { return false } sr := []rune(s) tr := []rune(t) rec := make(map[rune]int, len(sr)) for i := range sr { rec[sr[i]]++ rec[tr[i]]-- } for _, n := range rec { if n != 0 { return false } } return true } # func isAnagram(s string, t string) bool { if len(s) != len(t) { return false } sArr := make([]int, len(s)) tArr := make([]int, len(t)) for i := 0; i 257.二叉树的所有路径(2) 题目 给定一个二叉树，返回所有从根节点到叶子节点的路径。 说明: 叶子节点是指没有子节点的节点。 示例: 输入: 1 / \\ 2 3 \\ 5 输出: [\"1->2->5\", \"1->3\"] 解释: 所有根节点到叶子节点的路径为: 1->2->5, 1->3 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 迭代 O(n) O(n) # func binaryTreePaths(root *TreeNode) []string { if root == nil { return nil } res := make([]string, 0) var dfs func(string, *TreeNode) dfs = func(pre string, root *TreeNode) { if pre == \"\" { pre = strconv.Itoa(root.Val) } else { pre += \"->\" + strconv.Itoa(root.Val) } if root.Left != nil { dfs(pre, root.Left) } if root.Right != nil { dfs(pre, root.Right) } if root.Left == nil && root.Right == nil { res = append(res, pre) } } dfs(\"\", root) return res } # func binaryTreePaths(root *TreeNode) []string { res := make([]string, 0) if root == nil { return res } var queue []*TreeNode var stringQueue []string queue = append(queue, root) stringQueue = append(stringQueue, strconv.Itoa(root.Val)) for len(queue) > 0 { node := queue[0] path := stringQueue[0] queue = queue[1:] stringQueue = stringQueue[1:] if node.Left == nil && node.Right == nil { res = append(res, path) } if node.Left != nil { queue = append(queue, node.Left) stringQueue = append(stringQueue, path+\"->\"+strconv.Itoa(node.Left.Val)) } if node.Right != nil { queue = append(queue, node.Right) stringQueue = append(stringQueue, path+\"->\"+strconv.Itoa(node.Right.Val)) } } return res } 258.各位相加(4) 题目 给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。 示例: 输入: 38 输出: 2 解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于 2 是一位数，所以返回 2。 进阶: 你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 找规律1 O(1) O(1) 02 找规律2 O(1) O(1) 03 模拟计算-字符串 O(log(n)) O(1) 04 模拟计算-递归 O(log(n)) O(log(n)) # 找规律1 func addDigits(num int) int { if num = 10 { num = sumDigits(num) } return num } func sumDigits(num int) int { sumVal := 0 str := strconv.Itoa(num) for i := range str { sumVal = sumVal + int(str[i]-'0') } return sumVal } # 模拟计算-递归 func addDigits(num int) int { sum := 0 for num != 0 { sum = sum + num%10 num = num / 10 } if sum/10 == 0 { return sum } return addDigits(sum) } 263.丑数(2) 题目 丑数就是只包含质因数 2, 3, 5 的正整数。 示例 1:输入: 6 输出: true 解释: 6 = 2 × 3 示例 2:输入: 8 输出: true 解释: 8 = 2 × 2 × 2 示例 3: 输入: 14 输出: false 解释: 14 不是丑数，因为它包含了另外一个质因数 7。 说明： 1 是丑数。 输入不会超过 32 位有符号整数的范围: [−231, 231 − 1]。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(log(n)) O(log(n)) 02 迭代 O(log(n)) O(1) func isUgly(num int) bool { if num 268.缺失数字(5) 题目 给定一个包含 0, 1, 2, ..., n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。 示例 1:输入: [3,0,1]输出: 2 示例 2:输入: [9,6,4,2,3,5,7,0,1] 输出: 8 说明:你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现? 解题思路 No. 思路 时间复杂度 空间复杂度 01 数学计算 O(n) O(1) 02 排序遍历 O(nlog(n)) O(1) 03 异或-位运算 O(n) O(1) 04 交换排序(就地排序) O(n) O(1) 05 哈希辅助 O(n) O(n) func missingNumber(nums []int) int { n := len(nums) sum := n * (n + 1) / 2 for i := 0; i 278.第一个错误的版本(2) 题目 你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。 由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。 假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。 实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。 示例: 给定 n = 5，并且 version = 4 是第一个错误的版本。 调用 isBadVersion(3) -> false 调用 isBadVersion(5) -> true 调用 isBadVersion(4) -> true 所以，4 是第一个错误的版本。 解题思路 No. 思路 时间复杂度 空间复杂度 01 二分查找 O(log(n)) O(1) 02 二分查找 O(log(n)) O(1) func firstBadVersion(n int) int { low := 1 high := n for low 283.移动零(3) 题目 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例: 输入: [0,1,0,3,12] 输出: [1,3,12,0,0] 说明: 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。 解题思路 No. 思路 时间复杂度 空间复杂度 01 前移补零 O(n) O(1) 02 遇零交换 O(n) O(1) 03 数组辅助 O(n) O(n) func moveZeroes(nums []int) { length := 0 for i := 0; i 290.单词规律(2) 题目 给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。 这里的 遵循 指完全匹配， 例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。 示例1:输入: pattern = \"abba\", str = \"dog cat cat dog\"输出: true 示例 2:输入:pattern = \"abba\", str = \"dog cat cat fish\"输出: false 示例 3:输入: pattern = \"aaaa\", str = \"dog cat cat dog\"输出: false 示例 4:输入: pattern = \"abba\", str = \"dog dog dog dog\" 输出: false 说明: 你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母。 解题思路 No. 思路 时间复杂度 空间复杂度 01 双哈希相互映射 O(n) O(n) 02 单哈希相互映射 O(n) O(n) func wordPattern(pattern string, str string) bool { pa := strings.Split(pattern, \"\") sa := strings.Split(str, \" \") if len(pa) != len(sa) { return false } length := len(pa) pMap := make(map[string]string, length) sMap := make(map[string]string, length) for i := 0; i 292.Nim 游戏(1) 题目 你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。 你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。 示例: 输入: 4 输出: false 解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛； 因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。 解题思路 No. 思路 时间复杂度 空间复杂度 01 推理 O(1) O(1) func canWinNim(n int) bool { // return n&3 != 0 return n%4 != 0 } 299.猜数字游戏(2) 题目 你正在和你的朋友玩 猜数字（Bulls and Cows）游戏：你写下一个数字让你的朋友猜。 每次他猜测后，你给他一个提示，告诉他有多少位数字和确切位置都猜对了（称为“Bulls”, 公牛）， 有多少位数字猜对了但是位置不对（称为“Cows”, 奶牛）。 你的朋友将会根据提示继续猜，直到猜出秘密数字。 请写出一个根据秘密数字和朋友的猜测数返回提示的函数，用 A 表示公牛，用 B 表示奶牛。 请注意秘密数字和朋友的猜测数都可能含有重复数字。 示例 1:输入: secret = \"1807\", guess = \"7810\"输出: \"1A3B\" 解释: 1 公牛和 3 奶牛。公牛是 8，奶牛是 0, 1 和 7。 示例 2:输入: secret = \"1123\", guess = \"0111\"输出: \"1A1B\" 解释: 朋友猜测数中的第一个 1 是公牛，第二个或第三个 1 可被视为奶牛。 说明: 你可以假设秘密数字和朋友的猜测数都只包含数字，并且它们的长度永远相等。 解题思路 No. 思路 时间复杂度 空间复杂度 01 双哈希辅助 O(n) O(1) 02 单哈希辅助 O(n) O(1) func getHint(secret string, guess string) string { length := len(secret) right := 0 wrongLoc := 0 m := make(map[byte]int) n := make(map[byte]int) for i := 0; i 0{ wrongNum = wrongNum + m[i] } } // wrongLoc = 总数 - 猜对的数 - 猜错的数 wrongLoc := length - right - wrongNum return fmt.Sprintf(\"%dA%dB\", right, wrongLoc) } 0201-0300-Medium 201.数字范围按位与 题目 给定范围 [m, n]，其中 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 双哈希辅助 O(n) O(1) 207.课程表 题目 解题思路 208.实现 Trie (前缀树) 题目 解题思路 209.长度最小的子数组 题目 给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组， 并返回其长度。如果不存在符合条件的子数组，返回 0。 示例：输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。 进阶：如果你已经完成了 O(n) 时间复杂度的解法, 请尝试 O(n log n) 时间复杂度的解法。 解题思路 No. 思路 时间复杂度 空间复杂度 01 双哈希辅助 O(n) O(1) 216.组合总和III(1) 题目 找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。 说明： 所有数字都是正整数。 解集不能包含重复的组合。 示例 1:输入: k = 3, n = 7 输出: [[1,2,4]] 示例 2:输入: k = 3, n = 9 输出: [[1,2,6], [1,3,5], [2,3,4]] 解题思路 No. 思路 时间复杂度 空间复杂度 01 回溯算法 O(n*C(9,n)) O(n) var res [][]int func combinationSum3(k int, n int) [][]int { res = make([][]int, 0) arr := make([]int, 0) dfs(k, n, 1, arr) return res } func dfs(k, n int, level int, arr []int) { if k == 0 || n Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-07-27 09:28:24 "},"docs/source/question/0301-0400.html":{"url":"docs/source/question/0301-0400.html","title":"0301-0400","keywords":"","body":"0301-0400-Easy 0301-0400-Easy 303.区域和检索-数组不可变(2) 326.3的幂(3) 342.4的幂(4) 344.反转字符串(3) 345.反转字符串中的元音字母(2) 349.两个数组的交集(3) 350.两个数组的交集 II(3) 367.有效的完全平方数(4) 371.两整数之和(2) 374.猜数字大小(2) 383.赎金信(3) 387.字符串中的第一个唯一字符(3) 389.找不同(5) 392.判断子序列(4) 303.区域和检索-数组不可变(2) 题目 给定一个整数数组 nums，求出数组从索引 i 到 j (i ≤ j) 范围内元素的总和，包含 i, j 两点。 示例： 给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange() sumRange(0, 2) -> 1 sumRange(2, 5) -> -1 sumRange(0, 5) -> -3 说明: 你可以假设数组不可变。 会多次调用 sumRange 方法。 解题思路 No. 思路 时间复杂度 空间复杂度 01 一维前缀和 O(1) O(n) 02 遍历计算 O(n) O(1) type NumArray struct { arr []int } func Constructor(nums []int) NumArray { size := len(nums) arr := make([]int, size+1) for i := 1; i 326.3的幂(3) 题目 给定一个整数，写一个函数来判断它是否是 3 的幂次方。 示例 1: 输入: 27 输出: true 示例 2: 输入: 0 输出: false 示例 3: 输入: 9 输出: true 示例 4: 输入: 45 输出: false 进阶：你能不使用循环或者递归来完成本题吗？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 迭代 I O(1) 02 转3进制判断 O(log(n)) O(1) 03 递归 O(log(n)) O(log(n)) func isPowerOfThree(n int) bool { if n 1 { if n % 3 != 0{ return false } n = n / 3 } return n == 1 } # func isPowerOfThree(n int) bool { if n 342.4的幂(4) 题目 给定一个整数 (32 位有符号整数)，请编写一个函数来判断它是否是 4 的幂次方。 示例 1: 输入: 16 输出: true 示例 2: 输入: 5 输出: false 进阶：你能不使用循环或者递归来完成本题吗？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 迭代 O(log(n)) O(1) 02 递归 O(log(n)) O(log(n)) 03 位运算 O(1) O(1) 04 转4进制 O(log(n)) O(1) func isPowerOfFour(num int) bool { if num 1 { if num%4 != 0 { return false } num = num / 4 } return num == 1 } # func isPowerOfFour(num int) bool { if num 344.反转字符串(3) 题目 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。 示例 1： 输入：[\"h\",\"e\",\"l\",\"l\",\"o\"] 输出：[\"o\",\"l\",\"l\",\"e\",\"h\"] 示例 2： 输入：[\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"] 输出：[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"] 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n) O(1) 02 递归 O(n) O(n) 03 单指针 O(n) O(1) func reverseString(s []byte) { i, j := 0, len(s)-1 for i 345.反转字符串中的元音字母(2) 题目 编写一个函数，以字符串作为输入，反转该字符串中的元音字母。 示例 1:输入: \"hello\"输出: \"holle\" 示例 2:输入: \"leetcode\"输出: \"leotcede\" 说明:元音字母不包含字母\"y\"。 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n) O(1) 02 数组辅助替换 O(n) O(n) func reverseVowels(s string) string { bytes := []byte(s) length := len(s) i, j := 0, length-1 for i 349.两个数组的交集(3) 题目 给定两个数组，编写一个函数来计算它们的交集。 示例 1:输入: nums1 = [1,2,2,1], nums2 = [2,2]输出: [2] 示例 2:输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [9,4] 说明: 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。 解题思路 No. 思路 时间复杂度 空间复杂度 01 单哈希辅助 O(n) O(n) 02 双哈希辅助 O(n) O(n) 03 排序双指针 O(nlog(n)) O(n) func intersection(nums1 []int, nums2 []int) []int { res := make([]int, 0) m := make(map[int]int) for _, v := range nums1 { m[v] = 1 } for _, v := range nums2 { if m[v] == 1 { res = append(res, v) m[v] += 1 } } return res } # func intersection(nums1 []int, nums2 []int) []int { m1 := make(map[int]bool) m2 := make(map[int]bool) res := make([]int, 0) for _, v := range nums1 { m1[v] = true } for _, v := range nums2 { if m1[v] != false { m2[v] = true } } for k := range m2 { res = append(res, k) } return res } # func intersection(nums1 []int, nums2 []int) []int { sort.Ints(nums1) sort.Ints(nums2) res := make([]int, 0) i := 0 j := 0 for i nums2[j] { j++ } else { if len(res) == 0 || res[len(res)-1] != nums1[i] { res = append(res, nums1[i]) } i++ j++ } } return res } 350.两个数组的交集 II(3) 题目 给定两个数组，编写一个函数来计算它们的交集。 示例 1: 输入: nums1 = [1,2,2,1], nums2 = [2,2] 输出: [2,2] 示例 2: 输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出: [4,9] 说明：输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。 我们可以不考虑输出结果的顺序。 进阶: 如果给定的数组已经排好序呢？你将如何优化你的算法？ 如果 nums1 的大小比 nums2 小很多，哪种方法更优？ 如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 单哈希辅助 O(n) O(n) 02 双哈希辅助 O(n) O(n) 03 排序双指针 O(nlog(n)) O(n) func intersect(nums1 []int, nums2 []int) []int { m1 := make(map[int]int) res := make([]int, 0) for _, v := range nums1 { m1[v] += 1 } for _, v := range nums2 { if m1[v] > 0 { res = append(res, v) m1[v]-- } } return res } # func intersect(nums1 []int, nums2 []int) []int { m1 := make(map[int]int) m2 := make(map[int]int) res := make([]int, 0) for _, v := range nums1 { m1[v]++ } for _, v := range nums2 { if m1[v] != 0 && m1[v] > m2[v] { m2[v]++ } } for k := range m2 { for i := 0; i nums2[j] { j++ } else { res = append(res, nums1[i]) i++ j++ } } return res } 367.有效的完全平方数(4) 题目 给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。 说明：不要使用任何内置的库函数，如 sqrt。 示例 1：输入：16 输出：True 示例 2：输入：14 输出：False 解题思路 No. 思路 时间复杂度 空间复杂度 01 二分查找 O(log(n)) O(1) 02 牛顿迭代法 O(log(n)) O(1) 03 数学法 O(n^1/2) O(1) 04 暴力法 O(n^1/2) O(1) func isPerfectSquare(num int) bool { if num num { right = mid - 1 } else { left = mid + 1 } } return false } # func isPerfectSquare(num int) bool { if num num { x = (x + num/x) / 2 } return x*x == num } # func isPerfectSquare(num int) bool { i := 1 for num > 0 { num = num - i i = i + 2 } return num == 0 } # func isPerfectSquare(num int) bool { i := 1 for i * i 371.两整数之和(2) 题目 不使用运算符 + 和 - ，计算两整数a,b之和。 示例 1:输入: a = 1, b = 2 输出: 3 示例 2:输入: a = -2, b = 3 输出: 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 迭代 O(1) O(1) 02 递归 O(1) O(1) func getSum(a int, b int) int { for b != 0 { a, b = a^b, (a&b) 374.猜数字大小(2) 题目 我们正在玩一个猜数字游戏。 游戏规则如下： 我从 1 到 n 选择一个数字。 你需要猜我选择了哪个数字。 每次你猜错了，我会告诉你这个数字是大了还是小了。 你调用一个预先定义好的接口 guess(int num)，它会返回 3 个可能的结果（-1，1 或 0）： -1 : 我的数字比较小 1 : 我的数字比较大 0 : 恭喜！你猜对了！ 示例 :输入: n = 10, pick = 6 输出: 6 解题思路 No. 思路 时间复杂度 空间复杂度 01 二分查找 O(log(n)) O(1) 02 递归 O(log(n)) O(log(n)) func guessNumber(n int) int { low := 1 high := n for low 383.赎金信(3) 题目 给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串， 判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。 如果可以构成，返回 true ；否则返回 false。 (题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。 杂志字符串中的每个字符只能在赎金信字符串中使用一次。) 注意：你可以假设两个字符串均只含有小写字母。 canConstruct(\"a\", \"b\") -> false canConstruct(\"aa\", \"ab\") -> false canConstruct(\"aa\", \"aab\") -> true 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组辅助 O(n) O(1) 02 哈希辅助 O(n) O(1) 03 排序双指针 O(nlog(n)) O(n) func canConstruct(ransomNote string, magazine string) bool { index := [26]int{} for i := 0; i magazineArr[j] { j++ } else if ransomNoteArr[i] 387.字符串中的第一个唯一字符(3) 题目 给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。 案例: s = \"leetcode\"返回 0. s = \"loveleetcode\",返回 2. 注意事项：您可以假定该字符串只包含小写字母。 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组辅助 O(n) O(1) 02 哈希辅助 O(n) O(1) 03 暴力法 O(n^2) O(1) func firstUniqChar(s string) int { m := [26]int{} for i := 0; i 389.找不同(5) 题目 给定两个字符串 s 和 t，它们只包含小写字母。 字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。 请找出在 t 中被添加的字母。 示例:输入：s = \"abcd\"t = \"abcde\"输出：e 解释：'e' 是那个被添加的字母。 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组辅助 O(n) O(1) 02 哈希辅助 O(n) O(1) 03 位计算 O(n) O(1) 04 数学计算 O(n) O(1) 05 排序遍历 O(nlog(n)) O(1) func findTheDifference(s string, t string) byte { m := [26]int{} bytest := []byte(t) bytess := []byte(s) for _, v := range bytest { m[v-'a']++ } for _, v := range bytess { m[v-'a']-- } for k, _ := range m { if m[k] == 1 { return byte(k + 'a') } } return 0 } # func findTheDifference(s string, t string) byte { m := make(map[byte]int) bytest := []byte(t) bytess := []byte(s) for _, v := range bytest { m[v]++ } for _, v := range bytess { m[v]-- } for k, _ := range m { if m[k] == 1 { return k } } return 0 } # func findTheDifference(s string, t string) byte { ch := byte(0) for _, value := range s { ch ^= byte(value) } for _, value := range t { ch ^= byte(value) } return ch } # func findTheDifference(s string, t string) byte { ch := byte(0) for _, value := range t { ch += byte(value) } for _, value := range s { ch -= byte(value) } return ch } # func findTheDifference(s string, t string) byte { sArr := strings.Split(s, \"\") tArr := strings.Split(t, \"\") sort.Strings(sArr) sort.Strings(tArr) for i := 0; i 392.判断子序列(4) 题目 给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 你可以认为 s 和 t 中仅包含英文小写字母。 字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 = 10亿， 你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n) O(1) 02 单指针遍历 O(n^2) O(1) 03 二分查找 O(nlog(n)) o 04 动态规划 O(n^2) O(n^2) func isSubsequence(s string, t string) bool { if len(s) > len(t){ return false } i := 0 j := 0 for i prev { right = mid } else { left = mid + 1 } } if left > right || m[value][left] len(t) { return false } dp := make([][]bool, len(s)+1) for i := 0; i 0301-0400-Medium 384.打乱数组(2) 题目 打乱一个没有重复元素的数组。 示例: // 以数字集合 1, 2 和 3 初始化数组。 int[] nums = {1,2,3}; Solution solution = new Solution(nums); // 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。 solution.shuffle(); // 重设数组到它的初始状态[1,2,3]。 solution.reset(); // 随机返回数组[1,2,3]打乱后的结果。 solution.shuffle(); 解题思路 No. 思路 时间复杂度 空间复杂度 01 内置函数 O(n^2) O(n) 02 内置函数 O(n^2) O(n) type Solution struct { nums []int } func Constructor(nums []int) Solution { return Solution{nums: nums} } func (this *Solution) Reset() []int { return this.nums } func (this *Solution) Shuffle() []int { arr := make([]int, len(this.nums)) copy(arr, this.nums) rand.Shuffle(len(arr), func(i, j int) { arr[i], arr[j] = arr[j], arr[i] }) return arr } # type Solution struct { nums []int } func Constructor(nums []int) Solution { return Solution{nums: nums} } func (this *Solution) Reset() []int { return this.nums } func (this *Solution) Shuffle() []int { arr := make([]int, len(this.nums)) copy(arr, this.nums) res := make([]int, len(this.nums)) for i := 0; i Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-07-21 16:43:44 "},"docs/source/question/0401-0500.html":{"url":"docs/source/question/0401-0500.html","title":"0401-0500","keywords":"","body":"0401-0500-Easy 0401-0500-Easy 401.二进制手表(3) 404.左叶子之和(2) 405.数字转换为十六进制数(2) 409.最长回文串(2) 412.Fizz Buzz(1) 414.第三大的数(2) 415.字符串相加(2) 434.字符串中的单词数(2) 437.路径总和III(4) 441.排列硬币(3) 443.压缩字符串(1) 447.回旋镖的数量(1) 448.找到所有数组中消失的数字(3) 453.最小移动次数使数组元素相等(2) 455.分发饼干(1) 459.重复的子字符串(2) 461.汉明距离(3) 463.岛屿的周长(3) 475.供暖器(2) 476.数字的补数(3) 482.密钥格式化(2) 485.最大连续1的个数(2) 492.构造矩形(1) 496.下一个更大元素 I(3) 500.键盘行(4) 401.二进制手表(3) 题目 二进制手表顶部有 4 个 LED 代表小时（0-11），底部的 6 个 LED 代表分钟（0-59）。 每个 LED 代表一个 0 或 1，最低位在右侧。 例如，上面的二进制手表读取 “3:25”。 给定一个非负整数 n 代表当前 LED 亮着的数量，返回所有可能的时间。 案例:输入: n = 1 返回: [\"1:00\", \"2:00\", \"4:00\", \"8:00\", \"0:01\", \"0:02\", \"0:04\", \"0:08\", \"0:16\", \"0:32\"] 注意事项: 输出的顺序没有要求。 小时不会以零开头，比如 “01:00” 是不允许的，应为 “1:00”。 分钟必须由两位数组成，可能会以零开头，比如 “10:2” 是无效的，应为 “10:02”。 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法 O(1) O(1) 02 暴力法 O(1) O(1) 03 回溯法 O(2^n) O(n) func binCount(num int) int { count := make([]int, 0) for num != 0 { temp := num % 2 count = append(count, temp) num = num / 2 } countNum := 0 for i := 0; i 404.左叶子之和(2) 题目 计算给定二叉树的所有左叶子之和。 示例： 3 / \\ 9 20 / \\ 15 7 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 迭代 O(n) O(n) func sumOfLeftLeaves(root *TreeNode) int { if root == nil { return 0 } if root.Left == nil { return sumOfLeftLeaves(root.Right) } if root.Left.Left == nil && root.Left.Right == nil { return root.Left.Val + sumOfLeftLeaves(root.Right) } return sumOfLeftLeaves(root.Left) + sumOfLeftLeaves(root.Right) } # func sumOfLeftLeaves(root *TreeNode) int { sum := 0 if root == nil{ return 0 } queue := make([]*TreeNode,0) queue = append(queue, root) for len(queue) > 0{ node := queue[0] queue = queue[1:] if node.Left != nil && node.Left.Left == nil && node.Left.Right == nil{ sum = sum + node.Left.Val } if node.Left != nil{ queue = append(queue, node.Left) } if node.Right != nil{ queue = append(queue, node.Right) } } return sum } 405.数字转换为十六进制数(2) 题目 给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。 注意: 十六进制中所有字母(a-f)都必须是小写。 十六进制字符串中不能包含多余的前导零。 如果要转化的数为0，那么以单个字符'0'来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。 给定的数确保在32位有符号整数范围内。 不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。 示例 1： 输入:26 输出:\"1a\" 示例 2： 输入:-1 输出:\"ffffffff\" 解题思路 No. 思路 时间复杂度 空间复杂度 01 位运算 O(1) O(1) 02 遍历 O(1) O(1) var h = []string{ \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", } func toHex(num int) string { hex := \"\" if num == 0 { return \"0\" } for i := 0; i > 4 } return hex } # var h = []string{ \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", } func toHex(num int) string { res := \"\" if num == 0{ return \"0\" } if num 409.最长回文串(2) 题目 给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。 在构造过程中，请注意区分大小写。比如 \"Aa\" 不能当做一个回文字符串。 注意:假设字符串的长度不会超过 1010。 示例 1:输入:\"abccccdd\"输出:7 解释:我们可以构造的最长的回文串是\"dccaccd\", 它的长度是 7。 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组辅助 O(n) O(1) 02 哈希辅助 O(n) O(1) func longestPalindrome(s string) int { ret := 0 a := [123]int{} for i := range s { a[s[i]]++ } hasOdd := 0 for i := range a { if a[i] == 0 { continue } if a[i] % 2 == 0 { ret += a[i] } else { ret += a[i] - 1 hasOdd = 1 } } return ret + hasOdd } # func longestPalindrome(s string) int { ret := 0 a := make(map[byte]int) for i := range s { a[s[i]]++ } hasOdd := 0 for i := range a { if a[i] == 0 { continue } if a[i]%2 == 0 { ret += a[i] } else { ret += a[i] - 1 hasOdd = 1 } } return ret + hasOdd } 412.Fizz Buzz(1) 题目 写一个程序，输出从 1 到 n 数字的字符串表示。 1. 如果 n 是3的倍数，输出“Fizz”； 2. 如果 n 是5的倍数，输出“Buzz”； 3.如果 n 同时是3和5的倍数，输出 “FizzBuzz”。 示例：n = 15, 返回: [ \"1\", \"2\", \"Fizz\", \"4\", \"Buzz\", \"Fizz\", \"7\", \"8\", \"Fizz\", \"Buzz\", \"11\", \"Fizz\", \"13\", \"14\", \"FizzBuzz\" ] 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) func fizzBuzz(n int) []string { ret := make([]string, n) for i := range ret { x := i + 1 switch { case x%15 == 0: ret[i] = \"FizzBuzz\" case x%5 == 0: ret[i] = \"Buzz\" case x%3 == 0: ret[i] = \"Fizz\" default: ret[i] = strconv.Itoa(x) } } return ret } 414.第三大的数(2) 题目 给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。 示例 1:输入: [3, 2, 1]输出: 1 解释: 第三大的数是 1. 示例 2:输入: [1, 2]输出: 2 解释: 第三大的数不存在, 所以返回最大的数 2 . 示例 3:输入: [2, 2, 3, 1]输出: 1 解释: 注意，要求返回第三大的数，是指第三大且唯一出现的数。存在两个值为2的数，它们都排第二。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 排序遍历 O(nlog(n)) O(1) func thirdMax(nums []int) int { max1, max2, max3 := math.MinInt64, math.MinInt64, math.MinInt64 for _, n := range nums { if n == max1 || n == max2 { continue } switch { case max1 = 0; i-- { if nums[i] != nums[i+1] { k-- } if k == 0 { return nums[i] } } return maxValue } 415.字符串相加(2) 题目 给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。 注意： num1 和num2 的长度都小于 5100. num1 和num2 都只包含数字 0-9. num1 和num2 都不包含任何前导零。 你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。 解题思路 No. 思路 时间复杂度 空间复杂度 01 模拟遍历 O(n) O(1) 02 逆置进位模拟 O(n) O(1) func addStrings(num1 string, num2 string) string { if len(num1) > len(num2) { num1, num2 = num2, num1 } n1, n2 := len(num1), len(num2) a1, a2 := []byte(num1), []byte(num2) carry := byte(0) buf := make([]byte, n2+1) buf[0] = '1' for i := 1; i '9' { buf[n2+1-i] = buf[n2+1-i] - 10 carry = byte(1) } else { carry = byte(0) } } if carry == 1 { return string(buf) } return string(buf[1:]) } # func addStrings(num1 string, num2 string) string { if len(num1) > len(num2) { num1, num2 = num2, num1 } n1, n2 := len(num1), len(num2) a1, a2 := []byte(num1), []byte(num2) a1 = reverse(a1) a2 = reverse(a2) carry := 0 buf := make([]byte, 0) for i := 0; i 9 { buf = append(buf, byte(temp-10+'0')) carry = 1 } else { buf = append(buf, byte(temp+'0')) carry = 0 } } if carry == 1 { buf = append(buf, byte('1')) } return string(reverse(buf)) } func reverse(arr []byte) []byte { for i := 0; i 434.字符串中的单词数(2) 题目 统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。 请注意，你可以假定字符串里不包括任何不可打印的字符。 示例:输入: \"Hello, my name is John\"输出: 5 解释: 这里的单词是指连续的不是空格的字符，所以 \"Hello,\" 算作 1 个单词。 解题思路 No. 思路 时间复杂度 空间复杂度 01 内置函数 O(n) O(n) 02 遍历 O(n) O(1) func countSegments(s string) int { if len(s) == 0 { return 0 } return len(strings.Fields(s)) } # func countSegments(s string) int { count := 0 for i := 0; i 437.路径总和III(4) 题目 给定一个二叉树，它的每个结点都存放着一个整数值。 找出路径和等于给定数值的路径总数。 路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。 二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。 示例： root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \\ 5 -3 / \\ \\ 3 2 11 / \\ \\ 3 -2 1 返回 3。和等于 8 的路径有: 1. 5 -> 3 2. 5 -> 2 -> 1 3. -3 -> 11 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n^2) O(n) 02 2次递归 O(n^2) O(n) 03 迭代+递归 O(n^2) O(n) 04 保存路径 O(n^2) O(n) func pathSum(root *TreeNode, sum int) int { if root == nil { return 0 } res := 0 var helper func(*TreeNode, int) helper = func(node *TreeNode, sum int) { if node == nil { return } sum = sum - node.Val // 路径不需要从根节点开始，也不需要在叶子节点结束 if sum == 0 { res++ } helper(node.Left, sum) helper(node.Right, sum) } helper(root, sum) return res + pathSum(root.Left, sum) + pathSum(root.Right, sum) } # func helper(node *TreeNode, sum int) int { if node == nil { return 0 } sum = sum - node.Val res := 0 if sum == 0 { res = 1 } return res + helper(node.Left, sum) + helper(node.Right, sum) } func pathSum(root *TreeNode, sum int) int { if root == nil { return 0 } return helper(root, sum) + pathSum(root.Left, sum) + pathSum(root.Right, sum) } # 迭代+递归 func helper(node *TreeNode, sum int, curSum int) int { res := 0 curSum = curSum + node.Val if curSum == sum { res++ } if node.Left != nil { res += helper(node.Left, sum, curSum) } if node.Right != nil { res += helper(node.Right, sum, curSum) } return res } func pathSum(root *TreeNode, sum int) int { if root == nil { return 0 } queue := make([]*TreeNode, 0) queue = append(queue, root) res := 0 for len(queue) > 0 { node := queue[0] queue = queue[1:] tempSum := 0 res += helper(node, sum, tempSum) if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } return res } # func helper(node *TreeNode, sum int, path []int, level int) int { if node == nil { return 0 } res := 0 if sum == node.Val { res = 1 } temp := node.Val for i := level - 1; i >= 0; i-- { temp = temp + path[i] if temp == sum { res++ } } path[level] = node.Val return res + helper(node.Left, sum, path, level+1) + helper(node.Right, sum, path, level+1) } func pathSum(root *TreeNode, sum int) int { return helper(root, sum, make([]int, 1001), 0) } 441.排列硬币(3) 题目 你总共有 n 枚硬币，你需要将它们摆成一个阶梯形状，第 k 行就必须正好有 k 枚硬币。 给定一个数字 n，找出可形成完整阶梯行的总行数。 n 是一个非负整数，并且在32位有符号整型的范围内。 示例 1:n = 5 硬币可排列成以下几行: ¤ ¤ ¤ ¤ ¤ 因为第三行不完整，所以返回2. 示例 2:n = 8 硬币可排列成以下几行: ¤ ¤ ¤ ¤ ¤ ¤ ¤ ¤ 因为第四行不完整，所以返回3. 解题思路 No. 思路 时间复杂度 空间复杂度 01 数学法 O(1) O(1) 02 迭代 O(n^1/2) O(1) 03 二分查找 O(log(n)) O(1) func arrangeCoins(n int) int { return int(math.Sqrt(float64(2*n)+0.25) - 0.5) } # func arrangeCoins(n int) int { i := 1 for i 443.压缩字符串(1) 题目 给定一组字符，使用原地算法将其压缩。 压缩后的长度必须始终小于或等于原数组长度。 数组的每个元素应该是长度为1 的字符（不是 int 整数类型）。 在完成原地修改输入数组后，返回数组的新长度。 进阶：你能否仅使用O(1) 空间解决问题？ 示例 1：输入：[\"a\",\"a\",\"b\",\"b\",\"c\",\"c\",\"c\"] 输出：返回6，输入数组的前6个字符应该是：[\"a\",\"2\",\"b\",\"2\",\"c\",\"3\"] 说明：\"aa\"被\"a2\"替代。\"bb\"被\"b2\"替代。\"ccc\"被\"c3\"替代。 示例 2：输入：[\"a\"] 输出：返回1，输入数组的前1个字符应该是：[\"a\"] 说明：没有任何字符串被替代。 示例 3：输入：[\"a\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"] 输出：返回4，输入数组的前4个字符应该是：[\"a\",\"b\",\"1\",\"2\"]。 说明：由于字符\"a\"不重复，所以不会被压缩。\"bbbbbbbbbbbb\"被“b12”替代。 注意每个数字在数组中都有它自己的位置。 注意： 所有字符都有一个ASCII值在[35, 126]区间内。 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n) O(1) func compress(chars []byte) int { j := 0 count := 1 for i := 0; i 1 { for _, num := range strconv.Itoa(count) { chars[j] = byte(num) j++ } } count = 1 } } return j } 447.回旋镖的数量(1) 题目 给定平面上 n 对不同的点，“回旋镖” 是由点表示的元组 (i, j, k) ， 其中 i 和 j 之间的距离和 i 和 k 之间的距离相等（需要考虑元组的顺序）。 找到所有回旋镖的数量。你可以假设 n 最大为 500，所有点的坐标在闭区间 [-10000, 10000] 中。 示例: 输入:[[0,0],[1,0],[2,0]] 输出:2 解释:两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]] 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助+遍历 O(n^2) O(n) func numberOfBoomerangs(points [][]int) int { res := 0 size := len(points) if size 448.找到所有数组中消失的数字(3) 题目 给定一个范围在 1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。 找到所有在 [1, n] 范围之间没有出现在数组中的数字。 您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。 示例:输入:[4,3,2,7,8,2,3,1]输出:[5,6] 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历交换 O(n) O(1) 02 遍历置反 O(n) O(1) 03 哈希辅助 O(n) O(n) func findDisappearedNumbers(nums []int) []int { for i := 0; i 0{ nums[value-1] = -nums[value-1] } } res := make([]int, 0) for key, value := range nums { if value > 0{ res = append(res, key+1) } } return res } # func findDisappearedNumbers(nums []int) []int { m := make(map[int]int) for i := 0; i 453.最小移动次数使数组元素相等(2) 题目 给定一个长度为 n 的非空整数数组，找到让数组所有元素相等的最小移动次数。每次移动可以使 n - 1 个元素增加 1。 示例:输入:[1,2,3]输出:3 解释:只需要3次移动（注意每次移动会增加两个元素的值）： [1,2,3] => [2,3,3] => [3,4,3] => [4,4,4] 解题思路 No. 思路 时间复杂度 空间复杂度 01 数学公式 O(n) O(1) 02 排序遍历 O(nlog(n)) O(1) func minMoves(nums []int) int { sum := 0 min := nums[0] for _, n := range nums { sum += n if min > n { min = n } } return sum - min*len(nums) } # func minMoves(nums []int) int { sum := 0 sort.Ints(nums) for i := 1; i 455.分发饼干(1) 题目 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。 对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸； 并且每块饼干 j ，都有一个尺寸 sj 。 如果 sj >= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。 你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 注意：你可以假设胃口值为正。一个小朋友最多只能拥有一块饼干。 示例 1:输入: [1,2,3], [1,1] 输出: 1 解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。 虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。 示例 2:输入: [1,2], [1,2,3] 输出: 2 解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。 你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2. 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序双指针 O(nlog(n)) O(1) func findContentChildren(g []int, s []int) int { sort.Ints(g) sort.Ints(s) var i, j int for i 459.重复的子字符串(2) 题目 给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。 给定的字符串只含有小写英文字母，并且长度不超过10000。 示例 1:输入: \"abab\"输出: True 解释: 可由子字符串 \"ab\" 重复两次构成。 示例 2:输入: \"aba\"输出: False 示例 3:输入: \"abcabcabcabc\"输出: True 解释: 可由子字符串 \"abc\" 重复四次构成。 (或者子字符串 \"abcabc\" 重复两次构成。) 解题思路 No. 思路 时间复杂度 空间复杂度 01 2倍去除首尾匹配 O(n) O(1) 02 暴力匹配 O(n^2) I func repeatedSubstringPattern(s string) bool { if len(s) == 0 { return false } size := len(s) ss := (s + s)[1 : size*2-1] return strings.Contains(ss, s) } # func repeatedSubstringPattern(s string) bool { if len(s) == 0 { return false } size := len(s) for i := 1; i 461.汉明距离(3) 题目 两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。 给出两个整数 x 和 y，计算它们之间的汉明距离。 注意： 0 ≤ x, y 解题思路 No. 思路 时间复杂度 空间复杂度 01 位运算+遍历统计 O(1) O(1) 02 位运算 O(1) O(1) 03 内置函数 O(1) O(1) func hammingDistance(x int, y int) int { x = x ^ y res := 0 for x > 0 { if x&1 == 1{ res++ } x = x >> 1 } return res } # func hammingDistance(x int, y int) int { x = x ^ y res := 0 for x > 0 { res++ x = x & (x-1) } return res } # func hammingDistance(x int, y int) int { x = x ^ y return bits.OnesCount(uint(x)) } 463.岛屿的周长(3) 题目 给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。 网格中的格子水平和垂直方向相连（对角线方向不相连）。 整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。 岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。 网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。 示例 : 输入: [[0,1,0,0], [1,1,1,0], [0,1,0,0], [1,1,0,0]] 输出: 16 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法 O(n^2) O(1) 02 暴力法 O(n^2) O(1) 03 深度优先搜索 O(n^2) O(n^2) func islandPerimeter(grid [][]int) int { var dx = []int{-1, 1, 0, 0} var dy = []int{0, 0, -1, 1} m, n := len(grid), len(grid[0]) res := 0 for i := 0; i 0 && grid[i-1][j] == 1 { res -= 2 } if j > 0 && grid[i][j-1] == 1 { res -= 2 } } } return res } # func islandPerimeter(grid [][]int) int { m, n := len(grid), len(grid[0]) for i := 0; i 475.供暖器(2) 题目 冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。 现在，给出位于一条水平线上的房屋和供暖器的位置，找到可以覆盖所有房屋的最小加热半径。 所以，你的输入将会是房屋和供暖器的位置。你将输出供暖器的最小加热半径。 说明: 给出的房屋和供暖器的数目是非负数且不会超过 25000。 给出的房屋和供暖器的位置均是非负数且不会超过10^9。 只要房屋位于供暖器的半径内(包括在边缘上)，它就可以得到供暖。 所有供暖器都遵循你的半径标准，加热的半径也一样。 示例 1:输入: [1,2,3],[2] 输出: 1 解释: 仅在位置2上有一个供暖器。如果我们将加热半径设为1，那么所有房屋就都能得到供暖。 示例 2:输入: [1,2,3,4],[1,4] 输出: 1 解释: 在位置1, 4上有两个供暖器。我们需要将加热半径设为1，这样所有房屋就都能得到供暖。 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序双指针 O(nlog(n)) O(1) 02 排序二分查找 O(nlog(n)) O(1) func findRadius(houses []int, heaters []int) int { if len(heaters) == 0 { return 0 } sort.Ints(houses) sort.Ints(heaters) res := 0 j := 0 for i := 0; i =确保出现重复的供暖器会往后走 for j = Abs(houses[i], heaters[j+1]) { j++ } res = Max(Abs(houses[i], heaters[j]), res) } return res } func Abs(a, b int) int { if a > b { return a - b } return b - a } func Max(a, b int) int { if a > b { return a } return b } # func findRadius(houses []int, heaters []int) int { if len(heaters) == 0 { return 0 } sort.Ints(houses) sort.Ints(heaters) res := 0 length := len(heaters) for i := 0; i houses[i] { if left == 0 { dis = heaters[0] - houses[i] } else { dis = Min(heaters[left]-houses[i], houses[i]-heaters[left-1]) } } res = Max(res, dis) } return res } func Min(a, b int) int { if a > b { return b } return a } func Max(a, b int) int { if a > b { return a } return b } 476.数字的补数(3) 题目 给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。 示例 1:输入: 5 输出: 2 解释: 5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。 示例 2:输入: 1 输出: 0 解释: 1 的二进制表示为 1（没有前导零位），其补数为 0。所以你需要输出 0 。 注意: 给定的整数保证在 32 位带符号整数的范围内。 你可以假定二进制数不包含前导零位。 本题与 1009 https://leetcode-cn.com/problems/complement-of-base-10-integer/ 相同 解题思路 No. 思路 时间复杂度 空间复杂度 01 位运算 O(log(n)) O(1) 02 位运算 O(log(n)) O(1) 03 遍历 O(log(n)) O(1) func findComplement(num int) int { temp := 1 for num >= temp { temp = temp 0 { temp = temp >> 1 res = res 0 { temp := num % 2 if temp == 0 { res = res + exp exp = exp * 2 } else { exp = exp * 2 } num = num / 2 } return res } 482.密钥格式化(2) 题目 有一个密钥字符串 S ，只包含字母，数字以及 '-'（破折号）。 其中， N 个 '-' 将字符串分成了 N+1 组。 给你一个数字 K，请你重新格式化字符串，除了第一个分组以外，每个分组要包含 K 个字符； 而第一个分组中，至少要包含 1 个字符。 两个分组之间需要用 '-'（破折号）隔开，并且将所有的小写字母转换为大写字母。 给定非空字符串 S 和数字 K，按照上面描述的规则进行格式化。 示例 1：输入：S = \"5F3Z-2e-9-w\", K = 4 输出：\"5F3Z-2E9W\" 解释：字符串 S 被分成了两个部分，每部分 4 个字符；注意，两个额外的破折号需要删掉。 示例 2：输入：S = \"2-5g-3-J\", K = 2 输出：\"2-5G-3J\" 解释：字符串 S 被分成了 3 个部分，按照前面的规则描述， 第一部分的字符可以少于给定的数量，其余部分皆为 2 个字符。 提示: S 的长度可能很长，请按需分配大小。K 为正整数。 S 只包含字母数字（a-z，A-Z，0-9）以及破折号'-' S 非空 解题思路 No. 思路 时间复杂度 空间复杂度 01 内置函数 O(n) O(1) 02 遍历 O(n) O(1) func licenseKeyFormatting(S string, K int) string { arr := strings.Join(strings.Split(strings.ToUpper(S), \"-\"), \"\") count := len(arr) / K first := len(arr) % K if first > 0 { count++ } str := arr[:first] if first != 0 { count = count - 1 } for i := 0; i = 0; i-- { value := temp[i] if value >= 'a' { value = value - 'a' + 'A' } if value == '-' { continue } count++ res = append([]rune{value}, res...) if count == K { res = append([]rune{'-'}, res...) count = 0 } } if len(res) == 0 { return \"\" } if res[0] == '-' { res = res[1:] } return string(res) } 485.最大连续1的个数(2) 题目 给定一个二进制数组， 计算其中最大连续1的个数。 示例 1:输入: [1,1,0,1,1,1]输出: 3 解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3. 注意： 输入的数组只包含 0 和1。 输入数组的长度是正整数，且不超过 10,000。 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n) O(1) 02 单指针 O(n) O(1) func findMaxConsecutiveOnes(nums []int) int { max := 0 for i, j := 0, -1; i max { max = count } count = 0 } } if count > max { max = count } return max } 492.构造矩形(1) 题目 作为一位web开发者， 懂得怎样去规划一个页面的尺寸是很重要的。 现给定一个具体的矩形页面面积，你的任务是设计一个长度为 L 和宽度为 W 且满足以下要求的矩形的页面。要求： 1. 你设计的矩形页面必须等于给定的目标面积。 2. 宽度 W 不应大于长度 L，换言之，要求 L >= W 。 3. 长度 L 和宽度 W 之间的差距应当尽可能小。 你需要按顺序输出你设计的页面的长度 L 和宽度 W。 示例： 输入: 4 输出: [2, 2] 解释: 目标面积是 4， 所有可能的构造方案有 [1,4], [2,2], [4,1]。 但是根据要求2，[1,4] 不符合要求; 根据要求3，[2,2] 比 [4,1] 更能符合要求. 所以输出长度 L 为 2， 宽度 W 为 2。 说明: 给定的面积不大于 10,000,000 且为正整数。 你设计的页面的长度和宽度必须都是正整数。 解题思路 No. 思路 时间复杂度 空间复杂度 01 开方向下遍历 O(n) O(1) func constructRectangle(area int) []int { for i := int(math.Sqrt(float64(area))); i > 1; i-- { if area%i == 0 { return []int{area / i, i} } } return []int{area, 1} } 496.下一个更大元素 I(3) 题目 给定两个没有重复元素的数组nums1 和 nums2 ，其中nums1 是 nums2 的子集。 找到 nums1 中每个元素在 nums2 中的下一个比其大的值。 nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。 如果不存在，对应位置输出 -1 。 示例 1: 输入: nums1 = [4,1,2], nums2 = [1,3,4,2]. 输出: [-1,3,-1] 解释: 对于num1中的数字4，你无法在第二个数组中找到下一个更大的数字，因此输出 -1。 对于num1中的数字1，第二个数组中数字1右边的下一个较大数字是 3。 对于num1中的数字2，第二个数组中没有下一个更大的数字，因此输出 -1。 示例 2: 输入: nums1 = [2,4], nums2 = [1,2,3,4]. 输出: [3,-1] 解释: 对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。 对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出 -1 。 提示： nums1和nums2中所有元素是唯一的。 nums1和nums2 的数组大小都不超过1000。 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n^2) O(n) 02 哈希辅助 O(n^2) O(n) 02 栈+哈希辅助 O(n) O(n) func nextGreaterElement(nums1 []int, nums2 []int) []int { m := make(map[int]int) for i, n := range nums2 { m[n] = i } res := make([]int, len(nums1)) for i, n := range nums1 { res[i] = -1 for j := m[n] + 1; j nums2[i] { m[nums2[i]] = nums2[j] break } } } for key, value := range nums1 { if _, ok := m[value]; ok { res[key] = m[value] } else { res[key] = -1 } } return res } # func nextGreaterElement(nums1 []int, nums2 []int) []int { m := make(map[int]int) res := make([]int, len(nums1)) stack := make([]int, 0) for i := 0; i 0 { for len(stack) > 0 && nums2[i] > stack[len(stack)-1] { top := stack[len(stack)-1] m[top] = nums2[i] stack = stack[:len(stack)-1] } } stack = append(stack, nums2[i]) } for key, value := range nums1 { if _, ok := m[value]; ok { res[key] = m[value] } else { res[key] = -1 } } return res } 500.键盘行(4) 题目 给定一个单词列表，只返回可以使用在键盘同一行的字母打印出来的单词。键盘如下图所示。 示例： 输入: [\"Hello\", \"Alaska\", \"Dad\", \"Peace\"] 输出: [\"Alaska\", \"Dad\"] 注意： 你可以重复使用键盘上同一字符。 你可以假设输入的字符串将只包含字母。 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n^2) O(1) 02 哈希辅助 O(n^2) O(1) 03 遍历 O(n^2) O(1) 04 内置函数 O(n^2) O(1) func findWords(words []string) []string { m := make(map[byte]int) m['q'] = 1 m['w'] = 1 m['e'] = 1 m['r'] = 1 m['t'] = 1 m['y'] = 1 m['u'] = 1 m['i'] = 1 m['o'] = 1 m['p'] = 1 m['a'] = 2 m['s'] = 2 m['d'] = 2 m['f'] = 2 m['g'] = 2 m['h'] = 2 m['j'] = 2 m['k'] = 2 m['l'] = 2 m['z'] = 3 m['x'] = 3 m['c'] = 3 m['v'] = 3 m['b'] = 3 m['n'] = 3 m['m'] = 3 res := make([]string, 0) for i := 0; i 0401-0500-Medium 498.对角线遍历 题目 给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素， 对角线遍历如下图所示。 示例: 输入: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] 输出: [1,2,4,7,5,3,6,8,9] 说明:给定矩阵中的元素总数不会超过 100000 。 解题思路 Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-07-26 03:16:42 "},"docs/source/question/0501-0600.html":{"url":"docs/source/question/0501-0600.html","title":"0501-0600","keywords":"","body":"0501-0600-Easy 0501-0600-Easy 501.二叉搜索树中的众数(2) 504.七进制数(3) 506.相对名次(1) 507.完美数(1) 509.斐波那契数(6) 520.检测大写字母(2) 521.最长特殊序列Ⅰ(1) 530.二叉搜索树的最小绝对差(3) 532.数组中的K-diff数对(3) 538.把二叉搜索树转换为累加树(2) 541.反转字符串II(2) 543.二叉树的直径(2) 551.学生出勤记录 I(2) 557.反转字符串中的单词 III(2) 559.N叉树的最大深度(2) 561.数组拆分 I(2) 563.二叉树的坡度(2) 566.重塑矩阵(2) 572.另一个树的子树(3) 575.分糖果(2) 581.最短无序连续子数组(3) 589.N叉树的前序遍历(2) 590.N叉树的后序遍历(2) 594.最长和谐子序列(2) 598.范围求和 II(1) 599.两个列表的最小索引总和(2) 501.二叉搜索树中的众数(2) 题目 给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。 假定 BST 有如下定义： 结点左子树中所含结点的值小于等于当前结点的值 结点右子树中所含结点的值大于等于当前结点的值 左子树和右子树都是二叉搜索树 例如： 给定 BST [1,null,2,2], 1 \\ 2 / 2 返回[2]. 提示：如果众数超过1个，不需考虑输出顺序 进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内） 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归+哈希辅助 O(n) O(n) 02 递归+中序遍历 O(n) O(log(n)) func findMode(root *TreeNode) []int { m := map[int]int{} dfs(root, m) max := -1 res := make([]int, 0) for i, v := range m { if max 504.七进制数(3) 题目 给定一个整数，将其转化为7进制，并以字符串形式输出。 示例 1:输入: 100 输出: \"202\" 示例 2: 输入: -7 输出: \"-10\" 注意: 输入范围是 [-1e7, 1e7] 。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(log(n)) O(1) 02 内置函数 O(log(n)) O(1) 03 递归 O(log(n)) O(log(n)) func convertToBase7(num int) string { if num == 0 { return \"0\" } minus := \"\" if num 0 { s = fmt.Sprintf(\"%d\", num%7) + s num = num / 7 } return minus + s } # func convertToBase7(num int) string { return strconv.FormatInt(int64(num), 7) } # func convertToBase7(num int) string { if num 506.相对名次(1) 题目 给出 N 名运动员的成绩，找出他们的相对名次并授予前三名对应的奖牌。 前三名运动员将会被分别授予 “金牌”，“银牌” 和“ 铜牌” （\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\"）。 (注：分数越高的选手，排名越靠前。) 示例 1: 输入: [5, 4, 3, 2, 1] 输出: [\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\", \"4\", \"5\"] 解释: 前三名运动员的成绩为前三高的， 因此将会分别被授予 “金牌”，“银牌”和“铜牌” (\"Gold Medal\", \"Silver Medal\" and \"Bronze Medal\"). 余下的两名运动员，我们只需要通过他们的成绩计算将其相对名次即可。 提示: N 是一个正整数并且不会超过 10000。 所有运动员的成绩都不相同。 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序+遍历 O(nlog(n)) O(n) func findRelativeRanks(nums []int) []string { temp := make([]int, len(nums)) copy(temp, nums) sort.Ints(temp) m := make(map[int]string) for i := 0; i 507.完美数(1) 题目 对于一个 正整数，如果它和除了它自身以外的所有正因子之和相等，我们称它为“完美数”。 给定一个 整数 n， 如果他是完美数，返回 True，否则返回 False 示例：输入: 28 输出: True 解释: 28 = 1 + 2 + 4 + 7 + 14 提示：输入的数字 n 不会超过 100,000,000. (1e8) 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n^1/2) O(1) func checkPerfectNumber(num int) bool { if num == 1 { return false } sum := 1 for i := 2; i 509.斐波那契数(6) 题目 斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。 该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), 其中 N > 1. 给定 N，计算 F(N)。 示例 1：输入：2输出：1 解释：F(2) = F(1) + F(0) = 1 + 0 = 1. 示例 2：输入：3输出：2 解释：F(3) = F(2) + F(1) = 1 + 1 = 2. 示例 3：输入：4输出：3 解释：F(4) = F(3) + F(2) = 2 + 1 = 3. 提示： 0 ≤ N ≤ 30 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 遍历+数组 O(n) O(n) 03 递归 O(2^n) O(n) 04 公式法 O(1) O(1) 05 矩阵快速幂 O(log(n)) O(1) 06 矩阵快速幂 O(n) O(1) func fib(N int) int { if N == 0 { return 0 } if N == 1 { return 1 } n1, n2 := 0, 1 for i := 2; i 0 { if N%2 == 1 { ans = multi(ans, m) } m = multi(m, m) N = N >> 1 } return ans.b } /* a b c d */ type matrix struct { a, b, c, d int } // 矩阵乘法 func multi(x, y matrix) matrix { newA := x.a*y.a + x.b*y.c newB := x.a*y.b + x.b*y.d newC := x.c*y.a + x.d*y.c newD := x.c*y.b + x.d*y.d return matrix{ a: newA, b: newB, c: newC, d: newD, } } # 6 func fib(N int) int { if N == 0 { return 0 } /* ans = [Fn+1 Fn Fn Fn-1] = [ 1 0 0 1] */ ans := matrix{ a: 1, b: 0, c: 0, d: 1, } m := matrix{ a: 1, b: 1, c: 1, d: 0, } for N > 0 { ans = multi(ans, m) N-- } return ans.b } /* a b c d */ type matrix struct { a, b, c, d int } // 矩阵乘法 func multi(x, y matrix) matrix { newA := x.a*y.a + x.b*y.c newB := x.a*y.b + x.b*y.d newC := x.c*y.a + x.d*y.c newD := x.c*y.b + x.d*y.d return matrix{ a: newA, b: newB, c: newC, d: newD, } } 520.检测大写字母(2) 题目 给定一个单词，你需要判断单词的大写使用是否正确。 我们定义，在以下情况时，单词的大写用法是正确的： 全部字母都是大写，比如\"USA\"。 单词中所有字母都不是大写，比如\"leetcode\"。 如果单词不只含有一个字母，只有首字母大写， 比如 \"Google\"。 否则，我们定义这个单词没有正确使用大写字母。 示例 1:输入: \"USA\"输出: True 示例 2:输入: \"FlaG\"输出: False 注意: 输入是由大写和小写拉丁字母组成的非空单词。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 正则 O(n) O(1) func detectCapitalUse(word string) bool { if word == \"\" { return false } count := 0 for i := 0; i = 'A' && word[i] = 'A' && word[0] 521.最长特殊序列Ⅰ(1) 题目 给你两个字符串，请你从这两个字符串中找出最长的特殊序列。 「最长特殊序列」定义如下：该序列为某字符串独有的最长子序列（即不能是其他字符串的子序列）。 子序列 可以通过删去字符串中的某些字符实现，但不能改变剩余字符的相对顺序。空序列为所有字符串的子序列，任何字符串为其自身的子序列。 输入为两个字符串，输出最长特殊序列的长度。如果不存在，则返回 -1。 示例 1：输入: \"aba\", \"cdc\" 输出: 3 解释: 最长特殊序列可为 \"aba\" (或 \"cdc\")，两者均为自身的子序列且不是对方的子序列。 示例 2：输入：a = \"aaa\", b = \"bbb\"输出：3 示例 3：输入：a = \"aaa\", b = \"aaa\"输出：-1 提示： 两个字符串长度均处于区间 [1 - 100] 。 字符串中的字符仅含有 'a'~'z' 。 解题思路 No. 思路 时间复杂度 空间复杂度 01 比较 O(1) O(1) func findLUSlength(a string, b string) int { if a == b { return -1 } return max(len(a), len(b)) } func max(a, b int) int { if a > b { return a } return b } 530.二叉搜索树的最小绝对差(3) 题目 给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。 示例： 输入： 1 \\ 3 / 2 输出：1 解释： 最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。 提示： 树中至少有 2 个节点。 本题与 783 https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/ 相同 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归+中序遍历 O(n) O(log(n)) 02 递归+遍历 O(n) O(n) 03 迭代 O(n) O(n) var minDiff, previous int func getMinimumDifference(root *TreeNode) int { minDiff, previous = math.MaxInt32, math.MaxInt32 dfs(root) return minDiff } func dfs(root *TreeNode) { if root == nil { return } dfs(root.Left) newDiff := diff(previous, root.Val) if minDiff > newDiff { minDiff = newDiff } previous = root.Val dfs(root.Right) } func diff(a, b int) int { if a > b { return a - b } return b - a } # func getMinimumDifference(root *TreeNode) int { arr := make([]int, 0) dfs(root, &arr) minDiff := arr[1] - arr[0] for i := 2; i arr[i]-arr[i-1] { minDiff = arr[i] - arr[i-1] } } return minDiff } func dfs(root *TreeNode, arr *[]int) { if root == nil { return } dfs(root.Left, arr) *arr = append(*arr, root.Val) dfs(root.Right, arr) } 532.数组中的K-diff数对(3) 题目 给定一个整数数组和一个整数 k, 你需要在数组里找到不同的 k-diff 数对。 这里将 k-diff 数对定义为一个整数对 (i, j), 其中 i 和 j 都是数组中的数字，且两数之差的绝对值是 k. 示例 1: 输入: [3, 1, 4, 1, 5], k = 2 输出: 2 解释: 数组中有两个 2-diff 数对, (1, 3) 和 (3, 5)。 尽管数组中有两个1，但我们只应返回不同的数对的数量。 示例 2:输入:[1, 2, 3, 4, 5], k = 1 输出: 4 解释: 数组中有四个 1-diff 数对, (1, 2), (2, 3), (3, 4) 和 (4, 5)。 示例 3:输入: [1, 3, 1, 5, 4], k = 0 输出: 1 解释: 数组中只有一个 0-diff 数对，(1, 1)。 注意: 数对 (i, j) 和数对 (j, i) 被算作同一数对。 数组的长度不超过10,000。 所有输入的整数的范围在 [-1e7, 1e7]。 解题思路 No. 思路 时间复杂度 空间复杂度 01 单哈希辅助 O(n) O(n) 02 双哈希辅助 O(n) O(n) 03 排序遍历 O(nlog(n)) O(1) func findPairs(nums []int, k int) int { if k 1 { res++ } } return res } else { for n := range record { if record[n-k] > 0 { res++ } } return res } } # func findPairs(nums []int, k int) int { if k 538.把二叉搜索树转换为累加树(2) 题目 给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)， 使得每个节点的值是原来的节点值加上所有大于它的节点值之和。 例如： 输入: 原始二叉搜索树: 5 / \\ 2 13 输出: 转换为累加树: 18 / \\ 20 13 注意： 本题和 1038: https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/ 相同 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 栈辅助 O(n) O(n) func convertBST(root *TreeNode) *TreeNode { sum := 0 dfs(root, &sum) return root } func dfs(root *TreeNode, sum *int) { if root == nil { return } dfs(root.Right, sum) *sum = *sum + root.Val root.Val = *sum dfs(root.Left, sum) } # func convertBST(root *TreeNode) *TreeNode { if root == nil { return root } stack := make([]*TreeNode, 0) temp := root sum := 0 for { if temp != nil { stack = append(stack, temp) temp = temp.Right } else if len(stack) != 0 { temp = stack[len(stack)-1] stack = stack[:len(stack)-1] temp.Val = temp.Val + sum sum = temp.Val temp = temp.Left } else { break } } return root } 541.反转字符串II(2) 题目 给定一个字符串和一个整数 k，你需要对从字符串开头算起的每个 2k 个字符的前k个字符进行反转。 如果剩余少于 k 个字符，则将剩余的所有全部反转。 如果有小于 2k 但大于或等于 k 个字符，则反转前 k 个字符，并将剩余的字符保持原样。 示例: 输入: s = \"abcdefg\", k = 2 输出: \"bacdfeg\" 要求: 该字符串只包含小写的英文字母。 给定字符串的长度和 k 在[1, 10000]范围内。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 遍历 O(n) O(1) func reverseStr(s string, k int) string { arr := []byte(s) for i := 0; i 543.二叉树的直径(2) 题目 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。 这条路径可能穿过也可能不穿过根结点。 示例 : 给定二叉树 1 / \\ 2 3 / \\ 4 5 返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。 注意：两结点之间的路径长度是以它们之间边的数目表示。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 栈辅助 O(n) O(n) var res int func diameterOfBinaryTree(root *TreeNode) int { res = 0 dfs(root) return res } func dfs(root *TreeNode) int { if root == nil { return 0 } left := dfs(root.Left) right := dfs(root.Right) path := max(left, right) res = max(left+right, res) // 当前节点最大直径与当前保存最大值比较 return path + 1 // 以该节点为根的最大深度 } func max(a, b int) int { if a > b { return a } return b } # func diameterOfBinaryTree(root *TreeNode) int { if root == nil { return 0 } max := 0 stack := make([]*TreeNode, 0) m := make(map[*TreeNode]int) cur := root var prev *TreeNode for cur != nil || len(stack) != 0 { for cur != nil { stack = append(stack, cur) cur = cur.Left } cur = stack[len(stack)-1] if cur.Right == nil || cur.Right == prev { cur = stack[len(stack)-1] stack = stack[:len(stack)-1] leftLen := 0 rightLen := 0 if v, ok := m[cur.Left]; ok { leftLen = v } if v, ok := m[cur.Right]; ok { rightLen = v } if leftLen > rightLen { m[cur] = leftLen + 1 } else { m[cur] = rightLen + 1 } if max 551.学生出勤记录 I(2) 题目 给定一个字符串来代表一个学生的出勤记录，这个记录仅包含以下三个字符： 'A' : Absent，缺勤 'L' : Late，迟到 'P' : Present，到场 如果一个学生的出勤记录中不超过一个'A'(缺勤)并且不超过两个连续的'L'(迟到),那么这个学生会被奖赏。 你需要根据这个学生的出勤记录判断他是否会被奖赏。 示例 1:输入: \"PPALLP\"输出: True 示例 2:输入: \"PPALLL\"输出: False 解题思路 No. 思路 时间复杂度 空间复杂度 01 内置函数 O(n) O(1) 02 遍历 O(n) O(1) func checkRecord(s string) bool { if strings.Count(s, \"A\") 557.反转字符串中的单词 III(2) 题目 给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。 示例 1: 输入: \"Let's take LeetCode contest\" 输出: \"s'teL ekat edoCteeL tsetnoc\" 注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。 解题思路分析 No. 思路 时间复杂度 空间复杂度 01 内置函数 O(n) O(n) 02 遍历 O(n) O(n) func reverseWords(s string) string { strS := strings.Split(s, \" \") for i, s := range strS { strS[i] = reverse(s) } return strings.Join(strS, \" \") } func reverse(s string) string { arr := []byte(s) i, j := 0, len(arr)-1 for i 559.N叉树的最大深度(2) 题目 给定一个 N 叉树，找到其最大深度。 最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。 例如，给定一个 3叉树 : 我们应返回其最大深度，3。 说明: 树的深度不会超过 1000。 树的节点总不会超过 5000。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 迭代 O(n) O(n) func maxDepth(root *Node) int { if root == nil { return 0 } depth := 0 for _, node := range root.Children { depth = max(depth, maxDepth(node)) } return depth + 1 } func max(a, b int) int { if a > b { return a } return b } # func maxDepth(root *Node) int { if root == nil { return 0 } queue := make([]*Node, 0) depth := 0 queue = append(queue, root) for len(queue) > 0 { length := len(queue) for i := 0; i b { return a } return b } 561.数组拆分 I(2) 题目 给定长度为 2n 的数组, 你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), ..., (an, bn) ， 使得从1 到 n 的 min(ai, bi) 总和最大。 示例 1:输入: [1,4,3,2]输出: 4 解释: n 等于 2, 最大总和为 4 = min(1, 2) + min(3, 4). 提示: n 是正整数,范围在 [1, 10000]. 数组中的元素范围在 [-10000, 10000]. 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序遍历 O(nlog(n)) P 02 数组辅助 O(n) O(1) func arrayPairSum(nums []int) int { sort.Ints(nums) sum := 0 for k, v := range nums { if k%2 == 0 { sum = sum + v } } return sum } # func arrayPairSum(nums []int) int { var arr [20010]int for _, num := range nums { arr[num+10000]++ } sum := 0 needAdd := true for num, count := range arr { for count > 0 { if needAdd { sum = sum + num - 10000 } needAdd = !needAdd count-- } } return sum } 563.二叉树的坡度(2) 题目 给定一个二叉树，计算整个树的坡度。 一个树的节点的坡度定义即为，该节点左子树的结点之和和右子树结点之和的差的绝对值。空结点的的坡度是0。 整个树的坡度就是其所有节点的坡度之和。 示例: 输入: 1 / \\ 2 3 输出: 1 解释: 结点的坡度 2 : 0 结点的坡度 3 : 0 结点的坡度 1 : |2-3| = 1 树的坡度 : 0 + 0 + 1 = 1 注意: 任何子树的结点的和不会超过32位整数的范围。 坡度的值不会超过32位整数的范围。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 迭代 O(n) O(n) var total int func findTilt(root *TreeNode) int { total = 0 dfs(root) return total } func dfs(root *TreeNode) int { if root == nil { return 0 } left := dfs(root.Left) right := dfs(root.Right) total = total + abs(left, right) return left + right + root.Val // 返回节点之和 } func abs(a, b int) int { if a > b { return a - b } return b - a } # func findTilt(root *TreeNode) int { if root == nil { return 0 } stack := make([]*TreeNode, 0) stack = append(stack, root) list := make([]*TreeNode, 0) total := 0 for len(stack) > 0 { node := stack[len(stack)-1] stack = stack[0 : len(stack)-1] list = append([]*TreeNode{node}, list...) if node.Left != nil { stack = append(stack, node.Left) } if node.Right != nil { stack = append(stack, node.Right) } } for i := range list { node := list[i] left := 0 right := 0 if node.Left != nil { left = node.Left.Val } if node.Right != nil { right = node.Right.Val } total = total + abs(left, right) node.Val = left + right + node.Val } return total } func abs(a, b int) int { if a > b { return a - b } return b - a } 566.重塑矩阵(2) 题目 在MATLAB中，有一个非常有用的函数 reshape，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。 给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。 重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。 如果具有给定参数的reshape操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。 示例 1:输入: nums = [[1,2], [3,4]] r = 1, c = 4 输出: [[1,2,3,4]] 解释:行遍历nums的结果是 [1,2,3,4]。新的矩阵是 1 * 4 矩阵, 用之前的元素值一行一行填充新矩阵。 示例 2:输入: nums = [[1,2], [3,4]] r = 2, c = 4 输出: [[1,2], [3,4]] 解释:没有办法将 2 * 2 矩阵转化为 2 * 4 矩阵。 所以输出原矩阵。 注意： 给定矩阵的宽和高范围在 [1, 100]。 给定的 r 和 c 都是正数。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n^2) O(n^2) 02 遍历 O(n^2) O(n^2) func matrixReshape(nums [][]int, r int, c int) [][]int { row, col := len(nums), len(nums[0]) if (row*col != r*c) || (row == r && col == c) { return nums } res := make([][]int, r) for i := 0; i 572.另一个树的子树(3) 题目 给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。 s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。 示例 1: 给定的树 s: 3 / \\ 4 5 / \\ 1 2 给定的树 t： 4 / \\ 1 2 返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。 示例 2: 给定的树 s： 3 / \\ 4 5 / \\ 1 2 / 0 给定的树 t： 4 / \\ 1 2 返回 false。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n^2) O(log(n)) 02 递归+字符串辅助 O(n) O(log(n)) 03 栈辅助 O(n) O(n) func isSubtree(s *TreeNode, t *TreeNode) bool { if s == nil { return false } return isSame(s, t) || isSubtree(s.Left, t) || isSubtree(s.Right, t) } func isSame(s *TreeNode, t *TreeNode) bool { if s == nil || t == nil{ return t == s } return isSame(s.Left, t.Left) && isSame(s.Right, t.Right) && s.Val == t.Val } # func isSubtree(s *TreeNode, t *TreeNode) bool { sStr := dfs(s, \"\") tStr := dfs(t, \"\") return strings.Contains(sStr, tStr) } func dfs(s *TreeNode, pre string) string { if s == nil { return pre } return fmt.Sprintf(\"#%d%s%s\", s.Val, dfs(s.Left, \"l\"), dfs(s.Right, \"r\")) } # func isSubtree(s *TreeNode, t *TreeNode) bool { sStr := preOrder(s) tStr := preOrder(t) return strings.Contains(sStr, tStr) } func preOrder(root *TreeNode) string { if root == nil { return \"\" } res := \"!\" stack := make([]*TreeNode,0) temp := root for { for temp != nil{ res += strconv.Itoa(temp.Val) res += \"!\" stack = append(stack, temp) temp = temp.Left } res += \"#!\" if len(stack) > 0{ node := stack[len(stack)-1] stack = stack[:len(stack)-1] temp = node.Right }else { break } } return res } 575.分糖果(2) 题目 给定一个偶数长度的数组，其中不同的数字代表着不同种类的糖果，每一个数字代表一个糖果。 你需要把这些糖果平均分给一个弟弟和一个妹妹。返回妹妹可以获得的最大糖果的种类数。 示例 1:输入: candies = [1,1,2,2,3,3] 输出: 3 解析: 一共有三种种类的糖果，每一种都有两个。 最优分配方案：妹妹获得[1,2,3],弟弟也获得[1,2,3]。这样使妹妹获得糖果的种类数最多。 示例 2 : 输入: candies = [1,1,2,3] 输出: 2 解析: 妹妹获得糖果[2,3],弟弟获得糖果[1,1]，妹妹有两种不同的糖果，弟弟只有一种。 这样使得妹妹可以获得的糖果种类数最多。 注意: 数组的长度为[2, 10,000]，并且确定为偶数。 数组中数字的大小在范围[-100,000, 100,000]内。 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(n) 02 排序遍历 O(nlog(n)) O(1) func distributeCandies(candies []int) int { n := len(candies) r := make(map[int]bool, n) for _, c := range candies { r[c] = true } return min(len(r), n/2) } func min(a, b int) int { if a = half { return half } return count } 581.最短无序连续子数组(3) 题目 给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。 你找到的子数组应是最短的，请输出它的长度。 示例 1:输入: [2, 6, 4, 8, 10, 9, 15] 输出: 5 解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。 说明 : 输入的数组长度范围在 [1, 10,000]。 输入的数组可能包含重复元素 ，所以升序的意思是 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n) O(1) 02 2次遍历 O(n) O(1) 03 排序遍历 O(nlog(n)) O(n) func findUnsortedSubarray(nums []int) int { length := len(nums) left, right := 0, -1 min, max := nums[length-1], nums[0] for i := 1; i = nums[j] { min = nums[j] } else { left = j } } return right - left + 1 } # func findUnsortedSubarray(nums []int) int { length := len(nums) right := -1 max := nums[0] for i := 1; i = 0; i-- { if min >= nums[i] { min = nums[i] } else { left = i } } return right - left + 1 } # func findUnsortedSubarray(nums []int) int { temp := make([]int,len(nums)) copy(temp,nums) sort.Ints(temp) i, j := 0, len(nums)-1 for i 589.N叉树的前序遍历(2) 题目 给定一个 N 叉树，返回其节点值的前序遍历。 例如，给定一个 3叉树 : 返回其前序遍历: [1,3,5,6,2,4]。 说明: 递归法很简单，你可以使用迭代法完成此题吗? 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 迭代 O(n) O(n) var res []int func preorder(root *Node) []int { res = make([]int, 0) dfs(root) return res } func dfs(root *Node) { if root == nil { return } res = append(res, root.Val) for _, value := range root.Children { dfs(value) } } # func preorder(root *Node) []int { res := make([]int, 0) if root == nil { return res } stack := make([]*Node, 0) stack = append(stack, root) for len(stack) > 0 { temp := stack[len(stack)-1] stack = stack[:len(stack)-1] res = append(res, temp.Val) for i := len(temp.Children) - 1; i >= 0; i-- { stack = append(stack, temp.Children[i]) } } return res } 590.N叉树的后序遍历(2) 题目 给定一个 N 叉树，返回其节点值的后序遍历。 例如，给定一个 3叉树 : 返回其后序遍历: [5,6,3,2,4,1]. 说明: 递归法很简单，你可以使用迭代法完成此题吗? 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 迭代 O(n) O(n) var res []int func postorder(root *Node) []int { res = make([]int, 0) dfs(root) return res } func dfs(root *Node) { if root == nil { return } for _, value := range root.Children { dfs(value) } res = append(res, root.Val) } # // 后序：(左右)根 // 前序：根(左右)=>根(右左)=>左右根 func postorder(root *Node) []int { res := make([]int, 0) if root == nil { return res } stack := make([]*Node, 0) stack = append(stack, root) for len(stack) > 0 { temp := stack[len(stack)-1] stack = stack[:len(stack)-1] res = append(res, temp.Val) for i := 0; i 594.最长和谐子序列(2) 题目 和谐数组是指一个数组里元素的最大值和最小值之间的差别正好是1。 现在，给定一个整数数组，你需要在所有可能的子序列中找到最长的和谐子序列的长度。 示例 1:输入: [1,3,2,2,5,2,3,7]输出: 5 原因: 最长的和谐数组是：[3,2,2,2,3]. 说明: 输入的数组长度最大不超过20,000. 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(n) 02 排序遍历 O(nlog(n)) O(1) func findLHS(nums []int) int { m := make(map[int]int, len(nums)) for _, n := range nums { m[n]++ } res := 0 for key, value := range m { value2, ok := m[key+1] if ok { t := value + value2 if res 1 { left++ } if nums[i]-nums[left] == 1 { if res 598.范围求和 II(1) 题目 给定一个初始元素全部为 0，大小为 m*n 的矩阵 M 以及在 M 上的一系列更新操作。 操作用二维数组表示，其中的每个操作用一个含有两个正整数 a 和 b 的数组表示， 含义是将所有符合 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 数学 O(n) O(1) func maxCount(m int, n int, ops [][]int) int { for _, o := range ops { m = min(m, o[0]) n = min(n, o[1]) } return m * n } func min(a, b int) int { if a 599.两个列表的最小索引总和(2) 题目 假设Andy和Doris想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。 你需要帮助他们用最少的索引和找出他们共同喜爱的餐厅。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设总是存在一个答案。 示例 1:输入: [\"Shogun\", \"Tapioca Express\", \"Burger King\", \"KFC\"] [\"Piatti\", \"The Grill at Torrey Pines\", \"Hungry Hunter Steakhouse\", \"Shogun\"] 输出: [\"Shogun\"] 解释: 他们唯一共同喜爱的餐厅是“Shogun”。 示例 2: 输入: [\"Shogun\", \"Tapioca Express\", \"Burger King\", \"KFC\"] [\"KFC\", \"Shogun\", \"Burger King\"] 输出: [\"Shogun\"] 解释: 他们共同喜爱且具有最小索引和的餐厅是“Shogun”，它有最小的索引和1(0+1)。 提示: 两个列表的长度范围都在 [1, 1000]内。 两个列表中的字符串的长度将在[1，30]的范围内。 下标从0开始，到列表的长度减1。 两个列表都没有重复的元素。 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(n) 02 暴力法 O(n^2) I func findRestaurant(list1 []string, list2 []string) []string { if len(list1) > len(list2) { list1, list2 = list2, list1 } m2 := make(map[string]int, len(list2)) for i := range list2 { m2[list2[i]] = i } min := 2000 res := make([]string, 0, 1000) for key, value := range list1 { if key2, ok := m2[value]; ok { if min == key+key2 { res = append(res, value) } if min > key+key2 { min = key + key2 res = []string{value} } } } return res } # func findRestaurant(list1 []string, list2 []string) []string { min := 2000 res := make([]string, 0, 1000) for key1, value1 := range list1 { for key2, value2 := range list2{ if value1 == value2{ if min == key1+key2 { res = append(res, value1) } if min > key1+key2 { min = key1 + key2 res = []string{value1} } } } } return res } Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-06-16 09:58:05 "},"docs/source/question/0601-0700.html":{"url":"docs/source/question/0601-0700.html","title":"0601-0700","keywords":"","body":"0601-0700-Easy 0601-0700-Easy 605.种花问题(3) 606.根据二叉树创建字符串(2) 617.合并二叉树(2) 628.三个数的最大乘积(2) 633.平方数之和(2) 637.二叉树的层平均值(2) 643.子数组最大平均数 I(3) 645.错误的集合(5) 653.两数之和IV输入BST(4) 657.机器人能否返回原点(2) 661.图片平滑器(2) 665.非递减数列(3) 669.修剪二叉搜索树(2) 671.二叉树中第二小的节点(3) 674.最长连续递增序列(3) 680.验证回文字符串 Ⅱ(2) 682.棒球比赛(1) 686.重复叠加字符串匹配(2) 687.最长同值路径(3) 690.员工的重要性(2) 693.交替位二进制数(4) 696.计数二进制子串(3) 697.数组的度(3) 700.二叉搜索树中的搜索(2) 605.种花问题(3) 题目 假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。 可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。 给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。 能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。 示例 1:输入: flowerbed = [1,0,0,0,1], n = 1 输出: True 示例 2:输入: flowerbed = [1,0,0,0,1], n = 2 输出: False 注意: 数组内已种好的花不会违反种植规则。 输入的数组长度范围为 [1, 20000]。 n 是非负整数，且不会超过输入数组的大小。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 遍历统计 O(n) O(1) 03 补数+遍历统计 O(n) O(1) func canPlaceFlowers(flowerbed []int, n int) bool { length := len(flowerbed) // 判断条件 // 1:当前元素是0 // 2.前一个元素是0，或者当前是第一个元素 // 3.后一个元素是0，或者当前是最后一个元素 for i := 0; i 606.根据二叉树创建字符串(2) 题目 你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。 空节点则用一对空括号 \"()\" 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。 示例 1: 输入: 二叉树: [1,2,3,4] 1 / \\ 2 3 / 4 输出: \"1(2(4))(3)\" 解释: 原本将是“1(2(4)())(3())”， 在你省略所有不必要的空括号对之后， 它将是“1(2(4))(3)”。 示例 2: 输入: 二叉树: [1,2,3,null,4] 1 / \\ 2 3 \\ 4 输出: \"1(2()(4))(3)\" 解释: 和第一个示例相似， 除了我们不能省略第一个对括号来中断输入和输出之间的一对一映射关系。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 迭代 O(n) O(n) func tree2str(t *TreeNode) string { if t == nil { return \"\" } res := strconv.Itoa(t.Val) if t.Left == nil && t.Right == nil { return res } res += \"(\" + tree2str(t.Left) + \")\" if t.Right != nil{ res += \"(\" + tree2str(t.Right) + \")\" } return res } # func tree2str(t *TreeNode) string { if t == nil { return \"\" } stack := make([]*TreeNode, 0) m := make(map[*TreeNode]bool) stack = append(stack, t) res := \"\" for len(stack) > 0 { node := stack[len(stack)-1] if _, ok := m[node]; ok { stack = stack[:len(stack)-1] res = res + \")\" } else { m[node] = true res = res + \"(\" + strconv.Itoa(node.Val) if node.Left == nil && node.Right != nil { res = res + \"()\" } if node.Right != nil { stack = append(stack, node.Right) } if node.Left != nil { stack = append(stack, node.Left) } } } return res[1 : len(res)-1] } 617.合并二叉树(2) 题目 给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。 你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值， 否则不为 NULL 的节点将直接作为新二叉树的节点。 示例 1: 输入: Tree 1 Tree 2 1 2 / \\ / \\ 3 2 1 3 / \\ \\ 5 4 7 输出: 合并后的树: 3 / \\ 4 5 / \\ \\ 5 4 7 注意: 合并必须从两个树的根节点开始。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 迭代 O(n) O(n) func mergeTrees(t1 *TreeNode, t2 *TreeNode) *TreeNode { if t1 == nil { return t2 } if t2 == nil { return t1 } t1.Val = t1.Val + t2.Val t1.Left = mergeTrees(t1.Left, t2.Left) t1.Right = mergeTrees(t1.Right, t2.Right) return t1 } # func mergeTrees(t1 *TreeNode, t2 *TreeNode) *TreeNode { if t1 == nil { return t2 } if t2 == nil { return t1 } list := make([]*TreeNode, 0) list = append(list, t1) list = append(list, t2) for len(list) > 0 { node1 := list[0] node2 := list[1] node1.Val = node1.Val + node2.Val if node1.Left != nil && node2.Left != nil { list = append(list, node1.Left) list = append(list, node2.Left) } else if node1.Left == nil && node2.Left != nil { node1.Left = node2.Left } if node1.Right != nil && node2.Right != nil { list = append(list, node1.Right) list = append(list, node2.Right) } else if node1.Right == nil && node2.Right != nil { node1.Right = node2.Right } list = list[2:] } return t1 } 628.三个数的最大乘积(2) 题目 给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。 示例 1:输入: [1,2,3]输出: 6 示例 2:输入: [1,2,3,4]输出: 24 注意: 给定的整型数组长度范围是[3,104]，数组中所有的元素范围是[-1000, 1000]。 输入的数组中任意三个数的乘积不会超出32位有符号整数的范围。 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序 O(nlog(n)) O(1) 02 遍历 O(n) O(1) func maximumProduct(nums []int) int { sort.Ints(nums) return max(nums[0]*nums[1]*nums[len(nums)-1], nums[len(nums)-3]*nums[len(nums)-2]*nums[len(nums)-1]) } func max(a, b int) int { if a > b { return a } return b } # func maximumProduct(nums []int) int { max1, max2, max3 := math.MinInt32, math.MinInt32, math.MinInt32 min1, min2 := math.MaxInt32, math.MaxInt32 for i := 0; i = max1 { max3 = max2 max2 = max1 max1 = nums[i] } else if nums[i] >= max2 { max3 = max2 max2 = nums[i] } else if nums[i] >= max3 { max3 = nums[i] } } return max(min1*min2*max1, max1*max2*max3) } func max(a, b int) int { if a > b { return a } return b } 633.平方数之和(2) 题目 给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c。 示例1:输入: 5 输出: True 解释: 1 * 1 + 2 * 2 = 5 示例2:输入: 3 输出: False 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(log(n)) O(1) 02 遍历 O(log(n)) O(1) func judgeSquareSum(c int) bool { if c c { j-- } else { return true } } return false } # func judgeSquareSum(c int) bool { for i := 0; i 637.二叉树的层平均值(2) 题目 给定一个非空二叉树, 返回一个由每层节点平均值组成的数组. 示例 1: 输入: 3 / \\ 9 20 / \\ 15 7 输出: [3, 14.5, 11] 解释:第0层的平均值是 3, 第1层是 14.5, 第2层是 11. 因此返回 [3, 14.5, 11]. 注意： 节点值的范围在32位有符号整数范围内。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 迭代 O(n) O(n) func averageOfLevels(root *TreeNode) []float64 { var sum, node []int res := make([]float64, 0) sum = append(sum, root.Val) node = append(node, 1) sum, node = dfs(root, sum, node, 1) for i := 0; i = len(sum) { sum = append(sum, 0) node = append(node, 0) } if root.Left != nil { sum[level] += root.Left.Val node[level]++ } if root.Right != nil { sum[level] += root.Right.Val node[level]++ } sum, node = dfs(root.Left, sum, node, level+1) sum, node = dfs(root.Right, sum, node, level+1) return sum, node } # func averageOfLevels(root *TreeNode) []float64 { res := make([]float64, 0) list := make([]*TreeNode, 0) list = append(list, root) for len(list) > 0 { length := len(list) sum := 0 for i := 0; i 643.子数组最大平均数 I(3) 题目 给定 n 个整数，找出平均数最大且长度为 k 的连续子数组，并输出该最大平均数。 示例 1:输入: [1,12,-5,-6,50,3], k = 4 输出: 12.75 解释: 最大平均数 (12-5-6+50)/4 = 51/4 = 12.75 注意: 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历+滑动窗口 O(n) O(1) 02 遍历+暴力法 O(n^2) O(1) 03 遍历+累计求和 O(n) O(n) func findMaxAverage(nums []int, k int) float64 { temp := 0 for i := 0; i len(nums){ break } sum := 0 for j := i; j max{ max = sum } } return float64(max) / float64(k) } # func findMaxAverage(nums []int, k int) float64 { sum := make([]int, len(nums)) sum[0] = nums[0] for i := 1; i max { max = sum[i] - sum[i-k] } } return float64(max) / float64(k) } 645.错误的集合(5) 题目 集合 S 包含从1到 n 的整数。不幸的是，因为数据错误， 导致集合里面某一个元素复制了成了集合里面的另外一个元素的值，导致集合丢失了一个整数并且有一个元素重复。 给定一个数组 nums 代表了集合 S 发生错误后的结果。 你的任务是首先寻找到重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。 示例 1:输入: nums = [1,2,2,4]输出: [2,3] 注意: 给定数组的长度范围是 [2, 10000]。 给定的数组是无序的。 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组辅助 O(n) O(n) 02 置反 O(n) O(1) 03 位运算 O(n) O(1) 04 哈希辅助 O(n) O(n) 05 排序 O(nlog(n)) O(1) func findErrorNums(nums []int) []int { newNums := make([]int, len(nums)) var repeatNum int for _, v := range nums { if newNums[v-1] != 0 { repeatNum = v } newNums[v-1] = v } for i, v := range newNums { if v == 0 { return []int{repeatNum, i + 1} } } return []int{0, 0} } # func findErrorNums(nums []int) []int { repeatNum := 0 for i := 0; i 0 { misNum = i + 1 break } } return []int{repeatNum, misNum} } func abs(a int) int { if a > 0 { return a } return -a } # func findErrorNums(nums []int) []int { res := 0 // 异或得到repeatedNum^misNum for i := 0; i 653.两数之和IV输入BST(4) 题目 给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。 案例 1: 输入: 5 / \\ 3 6 / \\ \\ 2 4 7 Target = 9 输出: True 案例 2: 输入: 5 / \\ 3 6 / \\ \\ 2 4 7 Target = 28 输出: False 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归+哈希辅助 O(n) O(n) 02 递归 O(nlog(n)) O(log(n)) 03 迭代 O(n) O(n) 04 递归+二分查找 O(n) O(n) func findTarget(root *TreeNode, k int) bool { if root == nil { return false } m := map[int]int{} return dfs(root, k, m) } func dfs(node *TreeNode, k int, m map[int]int) bool { if node == nil { return false } if _, ok := m[k-node.Val]; ok { return true } m[node.Val] = node.Val return dfs(node.Left, k, m) || dfs(node.Right, k, m) } # func dfs(root, searchRoot *TreeNode, k int) bool { if root == nil { return false } found := findNode(searchRoot, k-root.Val) if found != nil && found != root { return true } return dfs(root.Left, searchRoot, k) || dfs(root.Right, searchRoot, k) } func findNode(root *TreeNode, target int) *TreeNode { if root == nil { return nil } if root.Val == target { return root } if root.Val 0 { node := queue[len(queue)-1] queue = queue[:len(queue)-1] if _, ok := m[k-node.Val]; ok { return true } if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } m[node.Val] = 1 } return false } # var arr []int func findTarget(root *TreeNode, k int) bool { if root == nil { return false } arr = make([]int, 0) dfs(root) i := 0 j := len(arr) - 1 for i k { j-- } else { i++ } } return false } func dfs(node *TreeNode) { if node == nil { return } dfs(node.Left) arr = append(arr, node.Val) dfs(node.Right) } 657.机器人能否返回原点(2) 题目 在二维平面上，有一个机器人从原点 (0, 0) 开始。 给出它的移动顺序，判断这个机器人在完成移动后是否在 (0, 0) 处结束。 移动顺序由字符串表示。字符 move[i] 表示其第 i 次移动。 机器人的有效动作有 R（右），L（左），U（上）和 D（下）。 如果机器人在完成所有动作后返回原点，则返回 true。否则，返回 false。 注意：机器人“面朝”的方向无关紧要。 “R” 将始终使机器人向右移动一次，“L” 将始终向左移动等。 此外，假设每次移动机器人的移动幅度相同。 示例 1:输入: \"UD\" 出: true 解释：机器人向上移动一次，然后向下移动一次。 所有动作都具有相同的幅度，因此它最终回到它开始的原点。因此，我们返回 true。 示例 2:输入: \"LL\"输出: false 解释：机器人向左移动两次。它最终位于原点的左侧，距原点有两次 “移动” 的距离。 我们返回 false，因为它在移动结束时没有返回原点。 解题思路 No. 思路 时间复杂度 空间复杂度 01 内置函数-字符统计 O(n) O(1) 02 模拟 O(n) O(1) func judgeCircle(moves string) bool { return strings.Count(moves, \"U\") == strings.Count(moves, \"D\") && strings.Count(moves, \"L\") == strings.Count(moves, \"R\") } # func judgeCircle(moves string) bool { x, y := 0, 0 for i := range moves { switch i { case 'U': y = y + 1 case 'D': y = y - 1 case 'L': x = x - 1 case 'R': x = x + 1 } } return x == 0 && y == 0 } 661.图片平滑器(2) 题目 包含整数的二维矩阵 M 表示一个图片的灰度。你需要设计一个平滑器来让每一个单元的灰度成为平均灰度 (向下舍入) ， 平均灰度的计算是周围的8个单元和它本身的值求平均，如果周围的单元格不足八个，则尽可能多的利用它们。 示例 1: 输入: [[1,1,1], [1,0,1], [1,1,1]] 输出: [[0, 0, 0], [0, 0, 0], [0, 0, 0]] 解释: 对于点 (0,0), (0,2), (2,0), (2,2): 平均(3/4) = 平均(0.75) = 0 对于点 (0,1), (1,0), (1,2), (2,1): 平均(5/6) = 平均(0.83333333) = 0 对于点 (1,1): 平均(8/9) = 平均(0.88888889) = 0 注意: 给定矩阵中的整数范围为 [0, 255]。 矩阵的长和宽的范围均为 [1, 150]。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n^2) O(n^2) 02 遍历 O(n^2) O(n^2) func imageSmoother(M [][]int) [][]int { res := make([][]int, len(M)) for i := range res { res[i] = make([]int, len(M[0])) for j := range res[i] { res[i][j] = getValue(M, i, j) } } return res } func getValue(M [][]int, r, c int) int { value, count := 0, 0 for i := r - 1; i 665.非递减数列(3) 题目 给你一个长度为 n 的整数数组，请你判断在 最多 改变 1 个元素的情况下，该数组能否变成一个非递减数列。 我们是这样定义一个非递减数列的： 对于数组中所有的 i (1 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法 O(n^2) O(n) 02 遍历修改前后 O(n) O(n) 03 遍历 O(n) ) func checkPossibility(nums []int) bool { for i := 0; i nums[i+1] { return false } } return true } # func checkPossibility(nums []int) bool { for i := 1; i nums[i]{ pre := deepCopy(nums) pre[i-1] = pre[i] next := deepCopy(nums) next[i] = next[i-1] return sort.IsSorted(sort.IntSlice(pre)) || sort.IsSorted(sort.IntSlice(next)) } } return true } func deepCopy(nums []int) []int { res := make([]int, len(nums)) copy(res,nums) return res } # func checkPossibility(nums []int) bool { count := 0 for i := 0; i nums[i+1] { if count == 1 { return false } else if i == 0 { // 4 2 3 => 2 2 3 nums[i] = nums[i+1] count++ } else if nums[i-1] > nums[i+1] { // 3 4 2 => 3 4 4 nums[i+1] = nums[i] count++ } else { // 1 4 2 => 1 2 2 nums[i] = nums[i+1] count++ } } } return true } 669.修剪二叉搜索树(2) 题目 给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。 通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R>=L) 。 你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。 示例 1: 输入: 1 / \\ 0 2 L = 1 R = 2 输出: 1 \\ 2 示例 2: 输入: 3 / \\ 0 4 \\ 2 / 1 L = 1 R = 3 输出: 3 / 2 / 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 迭代 O(n) O(n) func trimBST(root *TreeNode, L int, R int) *TreeNode { if root == nil { return nil } if root.Val R { if root.Val 0 { cur = stack[len(stack)-1] stack = stack[:len(stack)-1] if cur.Left != nil { if cur.Left.Val >= L { // 左节点>=L，继续向左 stack = append(stack, cur.Left) } else { // 在当前左节点，向它的右节点找到满足 R { temp = temp.Left } cur.Right = temp if temp != nil { stack = append(stack, temp) } } } } return root } 671.二叉树中第二小的节点(3) 题目 给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。 如果一个节点有两个子节点的话，那么这个节点的值不大于它的子节点的值。 给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。 示例 1: 输入: 2 / \\ 2 5 / \\ 5 7 输出: 5 说明: 最小的值是 2 ，第二小的值是 5 。 示例 2: 输入: 2 / \\ 2 2 输出: -1 说明: 最小的值是 2, 但是不存在第二小的值。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归+数组辅助 O(n) O(n) 02 递归 O(n) O(log(n)) 03 迭代 O(n) O(n) var arr []int func findSecondMinimumValue(root *TreeNode) int { arr = make([]int, 0) dfs(root) min, second := math.MaxInt32, math.MaxInt32 flag := 0 for i := 0; i val { return root.Val } left := dfs(root.Left, val) right := dfs(root.Right, val) if left == -1 { return right } if right == -1 { return left } return min(left, right) } func min(a, b int) int { if a > b { return b } return a } # func findSecondMinimumValue(root *TreeNode) int { min, second := root.Val, math.MaxInt32 queue := make([]*TreeNode, 0) queue = append(queue, root) flag := 0 for len(queue) > 0 { node := queue[len(queue)-1] queue = queue[:len(queue)-1] if node.Val 674.最长连续递增序列(3) 题目 给定一个未经排序的整数数组，找到最长且连续的的递增序列。 示例 1:输入: [1,3,5,4,7] 输出: 3 解释: 最长连续递增序列是 [1,3,5], 长度为3。 尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。 示例 2:输入: [2,2,2,2,2] 输出: 1 解释: 最长连续递增序列是 [2], 长度为1。 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n) O(1) 02 动态规划 O(n) O(n) 03 遍历 O(n) O(1) func findLengthOfLCIS(nums []int) int { if len(nums) == 0 { return 0 } res := 1 i, j := 0, 1 for j res{ res = dp[i] } } return res } 680.验证回文字符串 Ⅱ(2) 题目 给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。 示例 1:输入: \"aba\" 输出: True 示例 2:输入: \"abca\"输出: True 解释: 你可以删除c字符。 注意: 字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n) O(1) 02 递归 O(n) O(n) func validPalindrome(s string) bool { i := 0 j := len(s) - 1 for i 682.棒球比赛(1) 题目 你现在是棒球比赛记录员。 给定一个字符串列表，每个字符串可以是以下四种类型之一： 1.整数（一轮的得分）：直接表示您在本轮中获得的积分数。 2. \"+\"（一轮的得分）：表示本轮获得的得分是前两轮有效 回合得分的总和。 3. \"D\"（一轮的得分）：表示本轮获得的得分是前一轮有效 回合得分的两倍。 4. \"C\"（一个操作，这不是一个回合的分数）：表示您获得的最后一个有效 回合的分数是无效的，应该被移除。 每一轮的操作都是永久性的，可能会对前一轮和后一轮产生影响。 你需要返回你在所有回合中得分的总和。 示例 1:输入: [\"5\",\"2\",\"C\",\"D\",\"+\"] 输出: 30 解释: 第1轮：你可以得到5分。总和是：5。 第2轮：你可以得到2分。总和是：7。 操作1：第2轮的数据无效。总和是：5。 第3轮：你可以得到10分（第2轮的数据已被删除）。总数是：15。 第4轮：你可以得到5 + 10 = 15分。总数是：30。 示例 2:输入: [\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"] 输出: 27 解释: 第1轮：你可以得到5分。总和是：5。 第2轮：你可以得到-2分。总数是：3。 第3轮：你可以得到4分。总和是：7。 操作1：第3轮的数据无效。总数是：3。 第4轮：你可以得到-4分（第三轮的数据已被删除）。总和是：-1。 第5轮：你可以得到9分。总数是：8。 第6轮：你可以得到-4 + 9 = 5分。总数是13。 第7轮：你可以得到9 + 5 = 14分。总数是27。 注意： 输入列表的大小将介于1和1000之间。 列表中的每个整数都将介于-30000和30000之间。 解题思路 No. 思路 时间复杂度 空间复杂度 01 模拟-栈辅助 O(n) O(n) func calPoints(ops []string) int { stacks := make([]int, 0) for i := range ops { switch ops[i] { case \"+\": r1 := stacks[len(stacks)-1] r2 := stacks[len(stacks)-2] stacks = append(stacks, r1+r2) case \"D\": r1 := stacks[len(stacks)-1] stacks = append(stacks, 2*r1) case \"C\": stacks = stacks[:len(stacks)-1] default: tempInt, _ := strconv.Atoi(ops[i]) stacks = append(stacks, tempInt) } } res := 0 for _, value := range stacks { res = res + value } return res } 686.重复叠加字符串匹配(2) - 题目 － 题目 167ff051e1bed62c3e84043cdd3460ecc3db1eae 给定两个字符串 A 和 B, 寻找重复叠加字符串A的最小次数， 使得字符串B成为叠加后的字符串A的子串，如果不存在则返回 -1。 举个例子，A = \"abcd\"，B = \"cdabcdab\"。 答案为 3， 因为 A 重复叠加三遍后为 “abcdabcdabcd”， 此时 B 是其子串；A 重复叠加两遍后为\"abcdabcd\"，B 并不是其子串。 注意: A 与 B 字符串的长度在1和10000区间范围内。 解题思路 No. 思路 时间复杂度 空间复杂度 01 内置函数 O(n) O(n) 02 遍历 O(n) O(n) func repeatedStringMatch(A string, B string) int { times := len(B) / len(A) // 要确保B是A的子串，就要最少重复len(B)/len(A)次A次，最多len(B)/len(A)+2次 // 如长度为 len(B) = 6, len(A) = 3,至少重复2次 // 长度为len(B) = 7, len(A) = 3, 至少重复3次 // 另外如B=\"cabcabca\", A=\"abc\",需要重复4次 for i := times; i 687.最长同值路径(3) 题目 给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。 注意：两个节点之间的路径长度由它们之间的边数表示。 示例 1: 输入: 5 / \\ 4 5 / \\ \\ 1 1 5 输出:2 示例 2: 输入: 1 / \\ 4 5 / \\ \\ 4 4 5 输出:2 注意: 给定的二叉树不超过10000个结点。 树的高度不超过1000。 - 解题思路 － 解题思路 167ff051e1bed62c3e84043cdd3460ecc3db1eae No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 递归 O(n) O(log(n)) 03 迭代+栈辅助 O(n) O(n) var maxLen int func longestUnivaluePath(root *TreeNode) int { maxLen = 0 dfs(root) return maxLen } func dfs(root *TreeNode) int { if root == nil { return 0 } left := dfs(root.Left) right := dfs(root.Right) l, r := 0, 0 if root.Left != nil && root.Val == root.Left.Val { l = left + 1 } if root.Right != nil && root.Val == root.Right.Val { r = right + 1 } if l+r > maxLen { maxLen = l + r } return max(l, r) } func max(a, b int) int { if a > b { return a } return b } # var maxLen int func longestUnivaluePath(root *TreeNode) int { maxLen = 0 if root == nil { return 0 } dfs(root, root.Val) return maxLen } func dfs(root *TreeNode, val int) int { if root == nil { return 0 } left := dfs(root.Left, root.Val) right := dfs(root.Right, root.Val) if left+right > maxLen { maxLen = left + right } if root.Val == val { return max(left, right) + 1 } return 0 } func max(a, b int) int { if a > b { return a } return b } # 参考543.二叉树的直径做法 func longestUnivaluePath(root *TreeNode) int { res := 0 stack := make([]*TreeNode, 0) m := make(map[*TreeNode]int) cur := root var prev *TreeNode for cur != nil || len(stack) != 0 { for cur != nil { stack = append(stack, cur) cur = cur.Left } cur = stack[len(stack)-1] if cur.Right == nil || cur.Right == prev { cur = stack[len(stack)-1] stack = stack[:len(stack)-1] leftLen := 0 rightLen := 0 if v, ok := m[cur.Left]; ok { leftLen = v } if v, ok := m[cur.Right]; ok { rightLen = v } var left, right int if cur.Left != nil && cur.Val == cur.Left.Val { left = leftLen + 1 } if cur.Right != nil && cur.Val == cur.Right.Val { right = rightLen + 1 } if left+right > res { res = left + right } if left > right { m[cur] = left } else { m[cur] = right } prev = cur cur = nil } else { cur = cur.Right } } return res } 690.员工的重要性(2) 题目 给定一个保存员工信息的数据结构，它包含了员工唯一的id，重要度 和 直系下属的id。 比如，员工1是员工2的领导，员工2是员工3的领导。他们相应的重要度为15, 10, 5。 那么员工1的数据结构是[1, 15, [2]]，员工2的数据结构是[2, 10, [3]]，员工3的数据结构是[3, 5, []]。 注意虽然员工3也是员工1的一个下属，但是由于并不是直系下属，因此没有体现在员工1的数据结构中。 现在输入一个公司的所有员工信息，以及单个员工id，返回这个员工和他所有下属的重要度之和。 示例 1:输入: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1 输出: 11 解释: 员工1自身的重要度是5，他有两个直系下属2和3，而且2和3的重要度均为3。因此员工1的总重要度是 5 + 3 + 3 = 11。 注意: 一个员工最多有一个直系领导，但是可以有多个直系下属 员工数量不超过2000。 解题思路 No. 思路 时间复杂度 空间复杂度 01 深度优先搜索-递归 O(n) O(log(n)) 02 广度优先搜索-迭代 O(n) O(n) func getImportance(employees []*Employee, id int) int { if len(employees) == 0 { return 0 } var root *Employee for i := 0; i 0 { node := list[0] list = list[1:] res = res + node.Importance for i := range node.Subordinates { if value, ok := m[node.Subordinates[i]]; ok { list = append(list, value) } } } return res } 693.交替位二进制数(4) 题目 给定一个正整数，检查他是否为交替位二进制数：换句话说，就是他的二进制数相邻的两个位数永不相等。 示例 1: 输入: 5 输出: True 解释:5的二进制数是: 101 示例 2:输入: 7 输出: False 解释: 7的二进制数是: 111 示例 3:输入: 11 输出: False 解释: 11的二进制数是: 1011 示例 4:输入: 10 输出: True 解释: 10的二进制数是: 1010 解题思路 No. 思路 时间复杂度 空间复杂度 01 转字符串+遍历 O(1) O(1) 02 位运算 O(1) O(1) 03 位运算 O(1) O(1) 04 遍历 O(1) O(1) func hasAlternatingBits(n int) bool { str := strconv.FormatInt(int64(n), 2) for i := 1; i >1=101 3. n=n^(n>>1)=1010^101=1111 4. n&(n+1)=1111&(10000)=0 示例2: 1. n=101 2. n>>1=10 3. n=n^(n>>1)=101^10=111 4. n&(n+1)=111&(1000)=0 */ func hasAlternatingBits(n int) bool { n = n ^ (n >> 1) return n&(n+1) == 0 } # // n (10|01)&3(11)=10|01 func hasAlternatingBits(n int) bool { temp := n & 3 if temp != 1 && temp != 2 { return false } for n > 0 { if n&3 != temp { return false } n = n >> 2 } return true } # // n (10|01)&3(11)=10|01 func hasAlternatingBits(n int) bool { temp := n & 3 if temp != 1 && temp != 2 { return false } for n > 0 { if n&3 != temp { return false } n = n >> 2 } return true } # func hasAlternatingBits(n int) bool { pre := n & 1 n = n >> 1 for n > 0 { if n&1 == pre { return false } pre = n & 1 n = n >> 1 } return true } 696.计数二进制子串(3) 题目 给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量， 并且这些子字符串中的所有0和所有1都是组合在一起的。 重复出现的子串要计算它们出现的次数。 示例 1 :输入: \"00110011\" 输出: 6 解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。 请注意，一些重复出现的子串要计算它们出现的次数。 另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。 示例 2 :输入: \"10101\"输出: 4 解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。 注意： s.length 在1到50,000之间。 s 只包含“0”或“1”字符。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 遍历 O(n) O(n) 03 暴力法 O(n^2) O(1) func countBinarySubstrings(s string) int { res := 0 cur := 1 pre := 0 for i := 0; i cur { res = res + cur } else { res = res + pre } pre = cur cur = 1 } } if pre > cur { return res + cur } return res + pre } # func countBinarySubstrings(s string) int { res := 0 arr := make([]int, 0) arr = append(arr, 1) for i := 1; i arr[i+1] { res = res + arr[i+1] } else { res = res + arr[i] } } return res } # var count int func countBinarySubstrings(s string) int { count = 0 for i := 1; i = 0 && right 697.数组的度(3) 题目 给定一个非空且只包含非负数的整数数组 nums, 数组的度的定义是指数组里任一元素出现频数的最大值。 你的任务是找到与 nums 拥有相同大小的度的最短连续子数组，返回其长度。 示例 1:输入: [1, 2, 2, 3, 1]输出: 2 解释: 输入数组的度是2，因为元素1和2的出现频数最大，均为2. 连续子数组里面拥有相同度的有如下所示: [1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2] 最短连续子数组[2, 2]的长度为2，所以返回2. 示例 2:输入: [1,2,2,3,1,4,2] 输出: 6 注意: nums.length 在1到50,000区间范围内。 nums[i] 是一个在0到49,999范围内的整数。 解题思路 No. 思路 时间复杂度 空间复杂度 01 自定义结构体+遍历 O(n) O(n) 02 哈希辅助 O(n) O(n) 03 哈希辅助 O(n) O(n) type node struct { count int left int right int } func findShortestSubArray(nums []int) int { m := make(map[int]*node, 0) for k, v := range nums { if nd, ok := m[v]; ok { nd.count = nd.count + 1 nd.right = k } else { m[v] = &node{ count: 1, left: k, right: k, } } } maxNode := new(node) for _, v := range m { if v.count > maxNode.count { maxNode = v } else if v.count == maxNode.count && v.right-v.left length) { maxCount = count[n] minLen = length } } } if len(count) == size { return 1 } return minLen } # func findShortestSubArray(nums []int) int { size := len(nums) if size maxLen { maxLen = len(v) res = v[len(v)-1] - v[0] + 1 } else if len(v) == maxLen && v[len(v)-1]-v[0]+1 700.二叉搜索树中的搜索(2) 题目 给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。 例如， 给定二叉搜索树: 4 / \\ 2 7 / \\ 1 3 和值: 2 你应该返回如下子树: 2 / \\ 1 3 在上述示例中，如果要找的值是 5，但因为没有节点值为 5，我们应该返回 NULL。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 迭代 O(n) O(n) func searchBST(root *TreeNode, val int) *TreeNode { if root == nil { return nil } if root.Val val { return searchBST(root.Left, val) } return root } # func searchBST(root *TreeNode, val int) *TreeNode { if root == nil { return nil } stack := make([]*TreeNode, 0) if root.Val == val { return root } else if root.Val > val && root.Left != nil { stack = append(stack, root.Left) } else if root.Val 0 { node := stack[len(stack)-1] stack = stack[:len(stack)-1] if node.Val == val { return node } else if node.Val > val && node.Left != nil { stack = append(stack, node.Left) } else if node.Val Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-06-16 09:58:05 "},"docs/source/question/0701-0800.html":{"url":"docs/source/question/0701-0800.html","title":"0701-0800","keywords":"","body":"0701-0800-Easy 0701-0800-Easy 703.数据流中的第K大元素(2) 704.二分查找(3) 705.设计哈希集合 706.设计哈希映射 709.转换成小写字母(2) 717.1比特与2比特字符(3) 720.词典中最长的单词(2) 724.寻找数组的中心索引(2) 728.自除数(2) 733.图像渲染(2) 744.寻找比目标字母大的最小字母(3) 746.使用最小花费爬楼梯(3) 747.至少是其他数字两倍的最大数(3) 748.最短完整词(3) 762.二进制表示中质数个计算置位(2) 766.托普利茨矩阵(2) 771.宝石与石头(3) 783.二叉搜索树节点最小距离(3) 784.字母大小写全排列(4) 788.旋转数字(4) 796.旋转字符串(2) 703.数据流中的第K大元素(2) 题目 设计一个找到数据流中第K大元素的类（class）。注意是排序后的第K大元素，不是第K个不同的元素。 你的 KthLargest 类需要一个同时接收整数 k 和整数数组nums 的构造器，它包含数据流中的初始元素。 每次调用 KthLargest.add，返回当前数据流中第K大的元素。 示例: int k = 3; int[] arr = [4,5,8,2]; KthLargest kthLargest = new KthLargest(3, arr); kthLargest.add(3); // returns 4 kthLargest.add(5); // returns 5 kthLargest.add(10); // returns 5 kthLargest.add(9); // returns 8 kthLargest.add(4); // returns 8 说明: 你可以假设 nums 的长度≥ k-1 且k ≥ 1。 解题思路 No. 思路 时间复杂度 空间复杂度 01 最小堆+内置heap O(nlog(n)) O(n) 02 小根堆 O(nlog(n)) O(n) type KthLargest struct { k int heap intHeap } func Constructor(k int, nums []int) KthLargest { h := intHeap(nums) heap.Init(&h) for len(h) > k { heap.Pop(&h) } return KthLargest{ k: k, heap: h, } } func (k *KthLargest) Add(val int) int { heap.Push(&k.heap, val) if len(k.heap) > k.k { heap.Pop(&k.heap) } return k.heap[0] } // 内置heap，实现接口 /* type Interface interface { sort.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // remove and return element Len() - 1. } */ type intHeap []int func (h intHeap) Len() int { return len(h) } func (h intHeap) Less(i, j int) bool { return h[i] len(k.nums) { k.nums = append(k.nums, val) Up(k.nums) } else { if val > k.nums[0] { // 在堆顶，向下调整 k.nums[0] = val Down(k.nums, 0) } } return k.nums[0] } func Down(nums []int, index int) { length := len(nums) minIndex := index for { left := 2*index + 1 right := 2*index + 2 if left = 0; i-- { minIndex := i left := 2*i + 1 right := 2*i + 2 if left 704.二分查找(3) 题目 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ， 写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例 1:输入: nums = [-1,0,3,5,9,12], target = 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 示例 2:输入: nums = [-1,0,3,5,9,12], target = 2 输出: -1 解释: 2 不存在 nums 中因此返回 -1 提示： 你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间。 解题思路 No. 思路 时间复杂度 空间复杂度 01 二分查找 O(log(n)) O(1) 02 遍历 O(n) O(1) 03 递归 O(log(n)) O(log(n)) func search(nums []int, target int) int { left, right:= 0, len(nums)-1 for left target: right = mid - 1 default: return mid } } return -1 } # func search(nums []int, target int) int { if nums[0] > target || nums[len(nums)-1] target { return -1 } } return -1 } # func search(nums []int, target int) int { if len(nums) == 0 { return -1 } mid := len(nums) / 2 if nums[mid] == target { return mid } else if nums[mid] > target { return search(nums[:mid], target) } else { result := search(nums[mid+1:], target) if result == -1 { return result } return mid + 1 + result } } 705.设计哈希集合(2) 题目 不使用任何内建的哈希表库设计一个哈希集合 具体地说，你的设计应该包含以下的功能 add(value)：向哈希集合中插入一个值。 contains(value) ：返回哈希集合中是否存在这个值。 remove(value)：将给定值从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。 示例: MyHashSet hashSet = new MyHashSet(); hashSet.add(1); hashSet.add(2); hashSet.contains(1); // 返回 true hashSet.contains(3); // 返回 false (未找到) hashSet.add(2); hashSet.contains(2); // 返回 true hashSet.remove(2); hashSet.contains(2); // 返回 false (已经被删除) 注意： 所有的值都在 [0, 1000000]的范围内。 操作的总数目在[1, 10000]范围内。 不要使用内建的哈希集合库。 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组实现 O(1) O(n) 02 数组实现 O(n^1/2) ) type MyHashSet struct { table []bool } func Constructor() MyHashSet { return MyHashSet{ table: make([]bool, 1000001), } } func (m *MyHashSet) Add(key int) { m.table[key] = true } func (m *MyHashSet) Remove(key int) { m.table[key] = false } func (m *MyHashSet) Contains(key int) bool { return m.table[key] } # type MyHashSet struct { table [10000][]int } func Constructor() MyHashSet { return MyHashSet{ table: [10000][]int{}, } } func (m *MyHashSet) Add(key int) { for _, v := range m.table[key%10000] { if v == key { return } } m.table[key%10000] = append(m.table[key%10000], key) } func (m *MyHashSet) Remove(key int) { for k, v := range m.table[key%10000] { if v == key { m.table[key%10000] = append(m.table[key%10000][:k], m.table[key%10000][k+1:]...) } } } func (m *MyHashSet) Contains(key int) bool { for _, v := range m.table[key%10000] { if v == key { return true } } return false } 706.设计哈希映射(2) 题目 具体地说，你的设计应该包含以下的功能 put(key, value)：向哈希映射中插入(键,值)的数值对。如果键对应的值已经存在，更新这个值。 get(key)：返回给定的键所对应的值，如果映射中不包含这个键，返回-1。 remove(key)：如果映射中存在这个键，删除这个数值对。 示例： MyHashMap hashMap = new MyHashMap(); hashMap.put(1, 1); hashMap.put(2, 2); hashMap.get(1); // 返回 1 hashMap.get(3); // 返回 -1 (未找到) hashMap.put(2, 1); // 更新已有的值 hashMap.get(2); // 返回 1 hashMap.remove(2); // 删除键为2的数据 hashMap.get(2); // 返回 -1 (未找到) 注意： 所有的值都在 [0, 1000000]的范围内。 操作的总数目在[1, 10000]范围内。 不要使用内建的哈希库。 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组实现 O(1) O(n) 02 数组实现 O(n^1/2) O(n^1/2) type MyHashMap struct { table []int } func Constructor() MyHashMap { return MyHashMap{ table: make([]int, 1000001), } } func (this *MyHashMap) Put(key int, value int) { this.table[key] = value + 1 } func (this *MyHashMap) Get(key int) int { return this.table[key] - 1 } func (this *MyHashMap) Remove(key int) { this.table[key] = 0 } # type MyHashMap struct { keys [10000][]int value [10000][]int } func Constructor() MyHashMap { return MyHashMap{ keys: [10000][]int{}, value: [10000][]int{}, } } func (m *MyHashMap) Put(key int, value int) { for k, v := range m.keys[key%10000] { if v == key { m.value[key%10000][k] = value return } } m.keys[key%10000] = append(m.keys[key%10000], key) m.value[key%10000] = append(m.value[key%10000], value) } func (m *MyHashMap) Get(key int) int { for k, v := range m.keys[key%10000] { if v == key { return m.value[key%10000][k] } } return -1 } func (m *MyHashMap) Remove(key int) { for k, v := range m.keys[key%10000] { if v == key { m.keys[key%10000] = append(m.keys[key%10000][:k], m.keys[key%10000][k+1:]...) m.value[key%10000] = append(m.value[key%10000][:k], m.value[key%10000][k+1:]...) } } } 709.转换成小写字母(2) 题目 实现函数 ToLowerCase()，该函数接收一个字符串参数 str， 并将该字符串中的大写字母转换成小写字母，之后返回新的字符串。 示例 1：输入: \"Hello\" 输出: \"hello\" 示例 2：输入: \"here\" 输出: \"here\" 示例 3：输入: \"LOVELY\" 输出: \"lovely\" 解题思路 No. 思路 时间复杂度 空间复杂度 01 内置函数 O(n) O(n) 02 遍历 O(n) O(n) func toLowerCase(str string) string { return strings.ToLower(str) } # func toLowerCase(str string) string { arr := []byte(str) for i := 0; i ='A' && arr[i] 717.1比特与2比特字符(3) 题目 现给一个由若干比特组成的字符串。问最后一个字符是否必定为一个一比特字符。给定的字符串总是由0结束。 示例 1:输入: bits = [1, 0, 0] 输出: True 解释: 唯一的编码方式是一个两比特字符和一个一比特字符。所以最后一个字符是一比特字符。 示例 2:输入: bits = [1, 1, 1, 0] 输出: False 解释: 唯一的编码方式是两比特字符和两比特字符。所以最后一个字符不是一比特字符。 注意: 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 遍历 O(n) O(1) 03 递归 O(n) O(n) func isOneBitCharacter(bits []int) bool { n := len(bits) i := 0 for i = 0; i-- { if bits[i] == 0 { break } else { count++ } } // return count & 1 == 0 return count%2 == 0 } # func isOneBitCharacter(bits []int) bool { return helper(bits, 0) } func helper(bits []int, left int) bool { if left == len(bits)-1 { return bits[left] == 0 } if left 720.词典中最长的单词(2) 题目 给出一个字符串数组words组成的一本英语词典。 从中找出最长的一个单词，该单词是由words词典中其他单词逐步添加一个字母组成。 若其中有多个可行的答案，则返回答案中字典序最小的单词。 若无答案，则返回空字符串。 示例 1:输入: words = [\"w\",\"wo\",\"wor\",\"worl\", \"world\"] 输出: \"world\" 解释: 单词\"world\"可由\"w\", \"wo\", \"wor\", 和 \"worl\"添加一个字母组成。 示例 2:输入: words = [\"a\", \"banana\", \"app\", \"appl\", \"ap\", \"apply\", \"apple\"] 输出: \"apple\" 解释: \"apply\"和\"apple\"都能由词典中的单词组成。但是\"apple\"得字典序小于\"apply\"。 注意: 所有输入的字符串都只包含小写字母。 words数组长度范围为[1,1000]。 words[i]的长度范围为[1,30]。 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序+遍历 O(nlog(n)) O(n) 02 trie树 O(n) O(n) func longestWord(words []string) string { if len(words) == 0 { return \"\" } else if len(words) == 1 && len(words[0]) > 1 { return \"\" } sort.Strings(words) m := make(map[string]bool) res := words[0] for _, w := range words { n := len(w) if n == 1 { m[w] = true } else if m[w[:n-1]] { m[w] = true if len(res) 0 { node := stack[len(stack)-1] stack = stack[:len(stack)-1] if node.index > 0 || node == t { if node != t { word := words[node.index-1] if len(word) > len(res) || (len(word) == len(res) && word 724.寻找数组的中心索引(2) 题目 给定一个整数类型的数组 nums，请编写一个能够返回数组“中心索引”的方法。 我们是这样定义数组中心索引的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。 如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。 示例 1:输入: nums = [1, 7, 3, 6, 5, 6] 输出: 3 解释: 索引3 (nums[3] = 6) 的左侧数之和(1 + 7 + 3 = 11)，与右侧数之和(5 + 6 = 11)相等。 同时, 3 也是第一个符合要求的中心索引。 示例 2:输入: nums = [1, 2, 3] 输出: -1 解释: 数组中不存在满足此条件的中心索引。 说明: nums 的长度范围为 [0, 10000]。 任何一个 nums[i] 将会是一个范围在 [-1000, 1000]的整数。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 遍历 O(n) O(n) func pivotIndex(nums []int) int { sum := 0 for i := range nums { sum = sum + nums[i] } left := 0 for i := range nums { if left*2+nums[i] == sum { return i } left = left + nums[i] } return -1 } # func pivotIndex(nums []int) int { if len(nums) == 0 { return -1 } arr := make([]int, len(nums)) arr[0] = nums[0] for i := 1; i len(nums)-1 { right = 0 } else { right = arr[len(nums)-1] - arr[i] } if left == right { return i } } return -1 } 728.自除数(2) 题目 自除数 是指可以被它包含的每一位数除尽的数。 例如，128 是一个自除数，因为 128 % 1 == 0，128 % 2 == 0，128 % 8 == 0。 还有，自除数不允许包含 0 。 给定上边界和下边界数字，输出一个列表，列表的元素是边界（含边界）内所有的自除数。 示例 1：输入： 上边界left = 1, 下边界right = 22 输出： [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22] 注意： 每个输入参数的边界满足 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(n) 02 遍历 O(n) O(n) func selfDividingNumbers(left int, right int) []int { res := make([]int, 0) for i := left; i 0 { d := temp % 10 temp = temp / 10 if d == 0 || n%d != 0 { return false } } return true } # func selfDividingNumbers(left int, right int) []int { res := make([]int, 0) for i := left; i 733.图像渲染(2) 题目 有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。 给你一个坐标 (sr, sc) 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 newColor，让你重新上色这幅图像。 为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点， 接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。 将所有有记录的像素点的颜色值改为新的颜色值。 最后返回经过上色渲染后的图像。 示例 1:输入: image = [[1,1,1],[1,1,0],[1,0,1]] sr = 1, sc = 1, newColor = 2 输出: [[2,2,2],[2,2,0],[2,0,1]] 解析: 在图像的正中间，(坐标(sr,sc)=(1,1)), 在路径上所有符合条件的像素点的颜色都被更改成2。 注意，右下角的像素没有更改为2， 因为它不是在上下左右四个方向上与初始点相连的像素点。 注意: image 和 image[0] 的长度在范围 [1, 50] 内。 给出的初始点将满足 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 广度优先搜索 O(n^2) O(n^2) 02 深度优先搜索 O(n^2) O(n^2) var dx = []int{-1, 1, 0, 0} var dy = []int{0, 0, -1, 1} func floodFill(image [][]int, sr int, sc int, newColor int) [][]int { oldColor := image[sr][sc] if oldColor == newColor { return image } m, n := len(image), len(image[0]) list := make([][]int, 1) list[0] = []int{sr, sc} for len(list) > 0 { node := list[0] list = list[1:] image[node[0]][node[1]] = newColor for i := 0; i = len(image) || sc >= len(image[sr]) || image[sr][sc] == newColor { return image } oldColor := image[sr][sc] image[sr][sc] = newColor for i := 0; i 744.寻找比目标字母大的最小字母(3) 题目 给你一个排序后的字符列表 letters ，列表中只包含小写英文字母。 另给出一个目标字母 target，请你寻找在这一有序列表里比目标字母大的最小字母。 在比较时，字母是依序循环出现的。举个例子： 如果目标字母 target = 'z' 并且字符列表为 letters = ['a', 'b']，则答案返回 'a' 示例： 输入:letters = [\"c\", \"f\", \"j\"] target = \"a\" 输出: \"c\" 输入:letters = [\"c\", \"f\", \"j\"] target = \"c\" 输出: \"f\" 输入:letters = [\"c\", \"f\", \"j\"] target = \"d\" 输出: \"f\" 输入:letters = [\"c\", \"f\", \"j\"] target = \"g\" 输出: \"j\" 输入:letters = [\"c\", \"f\", \"j\"] target = \"j\" 输出: \"c\" 输入:letters = [\"c\", \"f\", \"j\"] target = \"k\" 输出: \"c\" 提示： letters长度范围在[2, 10000]区间内。 letters 仅由小写字母组成，最少包含两个不同的字母。 目标字母target 是一个小写字母。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 内置函数 O(n) O(1) 03 二分查找 O(log(n)) O(1) func nextGreatestLetter(letters []byte, target byte) byte { for i := 0; i target { return letters[i] } } return letters[0] } # func nextGreatestLetter(letters []byte, target byte) byte { n := len(letters) i := sort.Search(n, func(i int) bool { return target 746.使用最小花费爬楼梯(3) 题目 数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost[i](索引从0开始)。 每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。 您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。 示例 1:输入: cost = [10, 15, 20] 输出: 15 解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。 示例 2:输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]输出: 6 解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。 注意： cost 的长度将会在 [2, 1000]。 每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划-一维数组 O(n) O(n) 02 动态规划 O(n) O(1) 03 递归 O(n) O(n) /* 用dp[i]表示爬i个台阶所需要的成本，所以dp[0]=0，dp[1]=0 每次爬i个楼梯，计算的都是从倒数第一个结束，还是从倒数第二个结束 动态转移方程为: dp[i] = min{dp[i-2]+cost[i-2] , dp[i-1]+cost[i-1]}; */ func minCostClimbingStairs(cost []int) int { n := len(cost) dp := make([]int, n+1) dp[0] = 0 dp[1] = 0 for i := 2; i 747.至少是其他数字两倍的最大数(3) 题目 在一个给定的数组nums中，总是存在一个最大元素 。 查找数组中的最大元素是否至少是数组中每个其他数字的两倍。 如果是，则返回最大元素的索引，否则返回-1。 示例 1:输入: nums = [3, 6, 1, 0] 输出: 1 解释: 6是最大的整数, 对于数组中的其他整数,6大于数组中其他元素的两倍。 6的索引是1, 所以我们返回1. 示例 2:输入: nums = [1, 2, 3, 4] 输出: -1 解释: 4没有超过3的两倍大, 所以我们返回 -1. 提示: nums 的长度范围在[1, 50]. 每个 nums[i] 的整数范围在 [0, 100]. 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 遍历 O(n) O(1) 03 排序 O(nlog(n)) P func dominantIndex(nums []int) int { n := len(nums) if n == 1 { return 0 } maxIndex, secondMaxIndex := 0, 1 if nums[maxIndex] = 2*nums[secondMaxIndex] { return maxIndex } return -1 } # func dominantIndex(nums []int) int { n := len(nums) if n == 1 { return 0 } maxValue := nums[0] index := 0 for i := 1; i maxValue { maxValue = nums[i] index = i } } for i := 0; i maxValue { return -1 } } return index } # func dominantIndex(nums []int) int { n := len(nums) if n == 1 { return 0 } temp := make([]int, len(nums)) copy(temp, nums) sort.Ints(temp) maxValue := temp[len(temp)-1] if maxValue 748.最短完整词(3) 题目 如果单词列表（words）中的一个单词包含牌照（licensePlate）中所有的字母，那么我们称之为完整词。 在所有完整词中，最短的单词我们称之为最短完整词。 单词在匹配牌照中的字母时不区分大小写，比如牌照中的 \"P\" 依然可以匹配单词中的 \"p\" 字母。 我们保证一定存在一个最短完整词。当有多个单词都符合最短完整词的匹配条件时取单词列表中最靠前的一个。 牌照中可能包含多个相同的字符，比如说：对于牌照 \"PP\"，单词 \"pair\" 无法匹配，但是 \"supper\" 可以匹配。 示例 1：输入：licensePlate = \"1s3 PSt\", words = [\"step\", \"steps\", \"stripe\", \"stepple\"] 输出：\"steps\" 说明：最短完整词应该包括 \"s\"、\"p\"、\"s\" 以及 \"t\"。 对于 \"step\" 它只包含一个 \"s\" 所以它不符合条件。同时在匹配过程中我们忽略牌照中的大小写。 示例 2：输入：licensePlate = \"1s3 456\", words = [\"looks\", \"pest\", \"stew\", \"show\"] 输出：\"pest\" 说明：存在 3 个包含字母 \"s\" 且有着最短长度的完整词，但我们返回最先出现的完整词。 注意: 牌照（licensePlate）的长度在区域[1, 7]中。 牌照（licensePlate）将会包含数字、空格、或者字母（大写和小写）。 单词列表（words）长度在区间 [10, 1000] 中。 每一个单词 words[i] 都是小写，并且长度在区间 [1, 15] 中。 解题思路 No. 思路 时间复杂度 空间复杂度 01 双哈希遍历 O(n) O(1) 02 双数组遍历 O(n) O(1) 03 排序+遍历 O(n) O(n) func shortestCompletingWord(licensePlate string, words []string) string { m := make(map[byte]int) licensePlate = strings.ToLower(licensePlate) for i := 0; i = 'a' && licensePlate[i] = len(res) && res != \"\" { continue } tempM := make(map[byte]int) for j := 0; j = 'a' && licensePlate[i] = len(res) && res != \"\" { continue } tempM := make([]int, 26) for j := 0; j = 'a' && licensePlate[i] 762.二进制表示中质数个计算置位(2) 题目 给定两个整数 L 和 R ，找到闭区间 [L, R] 范围内，计算置位位数为质数的整数个数。 （注意，计算置位代表二进制表示中1的个数。例如 21 的二进制表示 10101 有 3 个计算置位。还有，1 不是质数。） 示例 1: 输入: L = 6, R = 10 输出: 4 解释: 6 -> 110 (2 个计算置位，2 是质数) 7 -> 111 (3 个计算置位，3 是质数) 9 -> 1001 (2 个计算置位，2 是质数) 10-> 1010 (2 个计算置位，2 是质数) 示例 2: 输入: L = 10, R = 15 输出: 5 解释: 10 -> 1010 (2 个计算置位, 2 是质数) 11 -> 1011 (3 个计算置位, 3 是质数) 12 -> 1100 (2 个计算置位, 2 是质数) 13 -> 1101 (3 个计算置位, 3 是质数) 14 -> 1110 (3 个计算置位, 3 是质数) 15 -> 1111 (4 个计算置位, 4 不是质数) 注意: L, R 是 L 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 遍历+内置函数 O(n) O(1) func countPrimeSetBits(L int, R int) int { primes := [...]int{ 2: 1, 3: 1, 5: 1, 7: 1, 11: 1, 13: 1, 17: 1, 19: 1, 23: 1, 29: 1, 31: 1, } res := 0 for i := L; i 0; n >>= 1 { // bits = bits + n & 1 bits = bits + n % 2 } res = res + primes[bits] } return res } 766.托普利茨矩阵(2) 题目 如果一个矩阵的每一方向由左上到右下的对角线上具有相同元素，那么这个矩阵是托普利茨矩阵。 给定一个 M x N 的矩阵，当且仅当它是托普利茨矩阵时返回 True。 示例 1:输入: matrix = [ [1,2,3,4], [5,1,2,3], [9,5,1,2] ] 输出: True 解释: 在上述矩阵中, 其对角线为:\"[9]\", \"[5, 5]\", \"[1, 1, 1]\", \"[2, 2, 2]\", \"[3, 3]\", \"[4]\"。 各条对角线上的所有元素均相同, 因此答案是True。 示例 2:输入: matrix = [ [1,2], [2,2] ] 输出: False 解释: 对角线\"[1, 2]\"上的元素不同。 说明: matrix 是一个包含整数的二维数组。 matrix 的行数和列数均在 [1, 20]范围内。 matrix[i][j] 包含的整数在 [0, 99]范围内。 进阶: 如果矩阵存储在磁盘上，并且磁盘内存是有限的，因此一次最多只能将一行矩阵加载到内存中，该怎么办？ 如果矩阵太大以至于只能一次将部分行加载到内存中，该怎么办？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n^2) O(1) 02 哈希辅助 O(n^2) O(n) func isToeplitzMatrix(matrix [][]int) bool { m, n := len(matrix), len(matrix[0]) for i := 0; i 771.宝石与石头(3) 题目 给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。 J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此\"a\"和\"A\"是不同类型的石头。 示例 1:输入: J = \"aA\", S = \"aAAbbbb\"输出: 3 示例 2:输入: J = \"z\", S = \"ZZ\"输出: 0 注意: S 和 J 最多含有50个字母。 J 中的字符不重复。 解题思路 No. 思路 时间复杂度 空间复杂度 01 内置函数+遍历 O(n^2) O(1) 02 哈希辅助+遍历 O(n) O(n) 03 遍历 O(n^2) O(1) func numJewelsInStones(J string, S string) int { res := 0 for _, v := range J { res = res + strings.Count(S, string(v)) } return res } # func numJewelsInStones(J string, S string) int { m := make(map[byte]bool) for i := range J { m[J[i]] = true } res := 0 for i := range S { if m[S[i]] { res++ } } return res } # func numJewelsInStones(J string, S string) int { res := 0 for _, v := range J { for _, s := range S { if v == s { res++ } } } return res } 783.二叉搜索树节点最小距离(3) 题目 给定一个二叉搜索树的根节点 root，返回树中任意两节点的差的最小值。 示例：输入: root = [4,2,6,1,3,null,null] 输出: 1 解释:注意，root是树节点对象(TreeNode object)，而不是数组。 给定的树 [4,2,6,1,3,null,null] 可表示为下图: 4 / \\ 2 6 / \\ 1 3 最小的差值是 1, 它是节点1和节点2的差值, 也是节点3和节点2的差值。 注意： 二叉树的大小范围在 2 到 100。 二叉树总是有效的，每个节点的值都是整数，且不重复。 本题与 530：https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/ 相同 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归+中序遍历 O(n) O(log(n)) 02 递归+遍历 O(n) O(n) 03 迭代 O(n) O(n) var minDiff, previous int func minDiffInBST(root *TreeNode) int { minDiff, previous = math.MaxInt32, math.MaxInt32 dfs(root) return minDiff } func dfs(root *TreeNode) { if root == nil { return } dfs(root.Left) newDiff := diff(previous, root.Val) if minDiff > newDiff { minDiff = newDiff } previous = root.Val dfs(root.Right) } func diff(a, b int) int { if a > b { return a - b } return b - a } # func minDiffInBST(root *TreeNode) int { arr := make([]int, 0) dfs(root, &arr) min := arr[1] - arr[0] for i := 2; i arr[i]-arr[i-1] { min = arr[i] - arr[i-1] } } return min } func dfs(root *TreeNode, arr *[]int) { if root == nil { return } dfs(root.Left, arr) *arr = append(*arr, root.Val) dfs(root.Right, arr) } # func minDiffInBST(root *TreeNode) int { arr := make([]int, 0) stack := make([]*TreeNode, 0) min := math.MaxInt32 for root != nil || len(stack) > 0 { for root != nil { stack = append(stack, root) root = root.Left } node := stack[len(stack)-1] stack = stack[:len(stack)-1] arr = append(arr, node.Val) if len(arr) > 1 { temp := node.Val - arr[len(arr)-2] if min > temp { min = temp } } root = node.Right } return min } 784.字母大小写全排列(4) 题目 给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。 返回所有可能得到的字符串集合。 示例: 输入: S = \"a1b2\" 输出: [\"a1b2\", \"a1B2\", \"A1b2\", \"A1B2\"] 输入: S = \"3z4\" 输出: [\"3z4\", \"3Z4\"] 输入: S = \"12345\" 输出: [\"12345\"] 注意： S 的长度不超过12。 S 仅由数字和字母组成。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历-逐位添加 O(n*2^n) O(n*2^n) 02 递归 O(n*2^n) O(n*2^n) 03 遍历-遇字母翻倍 O(n*2^n) O(n*2^n) 04 回溯-递归 O(n*2^n) O(n*2^n) func letterCasePermutation(S string) []string { res := make([]string, 1) for i := 0; i = \"0\" && string(S[i]) = 'a' { n := len(res) for j := 0; j = 'a' && arr[level] = 'A' && arr[level] 788.旋转数字(4) 题目 我们称一个数 X 为好数, 如果它的每位数字逐个地被旋转 180 度后， 我们仍可以得到一个有效的，且和 X 不同的数。要求每位数字都要被旋转。 如果一个数的每位数字被旋转以后仍然还是一个数字， 则这个数是有效的。0, 1, 和 8 被旋转后仍然是它们自己； 2 和 5 可以互相旋转成对方（在这种情况下，它们以不同的方向旋转，换句话说，2 和 5 互为镜像）； 6 和 9 同理，除了这些以外其他的数字旋转以后都不再是有效的数字。 现在我们有一个正整数 N, 计算从 1 到 N 中有多少个数 X 是好数？ 示例：输入: 10 输出: 4 解释: 在[1, 10]中有四个好数： 2, 5, 6, 9。注意 1 和 10 不是好数, 因为他们在旋转之后不变。 提示：N 的取值范围是 [1, 10000]。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(nlog(n)) O(1) 02 遍历+递归 O(nlog(n)) O(log(n)) 03 遍历+转字符串 O(nlog(n)) O(log(n)) 04 动态规划 O(n) O(n) func rotatedDigits(N int) int { count := 0 for i := 2; i 0 { switch n % 10 { case 2, 5, 6, 9: valid = true case 3, 4, 7: return false } n = n / 10 } return valid } # func rotatedDigits(N int) int { count := 0 for i := 2; i = 10 { dp = append(dp, make([]int, N-9)...) } res := 0 for i := 0; i 796.旋转字符串(2) 题目 给定两个字符串, A 和 B。 A 的旋转操作就是将 A 最左边的字符移动到最右边。 例如, 若 A = 'abcde'，在移动一次之后结果就是'bcdea' 。 如果在若干次旋转操作之后，A 能变成B，那么返回True。 示例 1: 输入: A = 'abcde', B = 'cdeab' 输出: true 示例 2:输入: A = 'abcde', B = 'abced' 输出: false 注意：A 和 B 长度不超过 100。 解题思路 No. 思路 时间复杂度 空间复杂度 01 内置函数 O(n) O(1) 02 遍历 O(n) O(1) func rotateString(A string, B string) bool { return len(A) == len(B) && strings.Contains(A+A, B) } # func rotateString(A string, B string) bool { if A == B { return true } if len(A) != len(B) { return false } for i := 0; i Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-06-27 23:05:31 "},"docs/source/question/0801-0900.html":{"url":"docs/source/question/0801-0900.html","title":"0801-0900","keywords":"","body":"0801-0900-Easy 0801-0900-Easy 804.唯一摩尔斯密码词(1) 806.写字符串需要的行数(1) 811.子域名访问计数(2) 812.最大三角形面积(2) 819.最常见的单词(2) 821.字符的最短距离(3) 824.山羊拉丁文(2) 830.较大分组的位置(2) 832.翻转图像(2) 836.矩形重叠(3) 840.矩阵中的幻方(2) 844.比较含退格的字符串(2) 849.到最近的人的最大距离(4) 852.山脉数组的峰顶索引(2) 859.亲密字符串(2) 860.柠檬水找零(1) 867.转置矩阵(1) 868.二进制间距(3) 872.叶子相似的树(2) 874.模拟行走机器人(2) 876.链表的中间结点(3) 883.三维形体投影面积(2) 884.两句话中的不常见单词(2) 888.公平的糖果交换(2) 892.三维形体的表面积(2) 893.特殊等价字符串组(2) 896.单调数列(3) 897.递增顺序查找树(3) 804.唯一摩尔斯密码词(1) 题目 国际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串， 比如: \"a\" 对应 \".-\", \"b\" 对应 \"-...\", \"c\" 对应 \"-.-.\", 等等。 为了方便，所有26个英文字母对应摩尔斯密码表如下： [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\", \"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"] 给定一个单词列表，每个单词可以写成每个字母对应摩尔斯密码的组合。 例如，\"cab\" 可以写成 \"-.-..--...\"，(即 \"-.-.\" + \"-...\" + \".-\"字符串的结合)。 我们将这样一个连接过程称作单词翻译。 返回我们可以获得所有词不同单词翻译的数量。 例如: 输入: words = [\"gin\", \"zen\", \"gig\", \"msg\"] 输出: 2 解释: 各单词翻译如下: \"gin\" -> \"--...-.\" \"zen\" -> \"--...-.\" \"gig\" -> \"--...--.\" \"msg\" -> \"--...--.\" 共有 2 种不同翻译, \"--...-.\" 和 \"--...--.\". 注意: 单词列表words 的长度不会超过 100。 每个单词 words[i]的长度范围为 [1, 12]。 每个单词 words[i]只包含小写字母。 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(n) var table = []string{ \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\", } func uniqueMorseRepresentations(words []string) int { res := make(map[string]bool) for _, w := range words { b := \"\" for i := 0; i 806.写字符串需要的行数(1) 题目 我们要把给定的字符串 S 从左到右写到每一行上，每一行的最大宽度为100个单位， 如果我们在写某个字母的时候会使这行超过了100 个单位，那么我们应该把这个字母写到下一行。 我们给定了一个数组 widths ，这个数组 widths[0] 代表 'a' 需要的单位， widths[1] 代表 'b' 需要的单位，...， widths[25] 代表 'z' 需要的单位。 现在回答两个问题：至少多少行能放下S，以及最后一行使用的宽度是多少个单位？ 将你的答案作为长度为2的整数列表返回。 示例 1:输入: widths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10] S = \"abcdefghijklmnopqrstuvwxyz\" 输出: [3, 60] 解释: 所有的字符拥有相同的占用单位10。所以书写所有的26个字母， 我们需要2个整行和占用60个单位的一行。 示例 2:输入: widths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10] S = \"bbbcccdddaaa\" 输出: [2, 4] 解释: 除去字母'a'所有的字符都是相同的单位10，并且字符串 \"bbbcccdddaa\" 将会覆盖 9 * 10 + 2 * 4 = 98 个单位. 最后一个字母 'a' 将会被写到第二行，因为第一行只剩下2个单位了。 所以，这个答案是2行，第二行有4个单位宽度。 注: 字符串 S 的长度在 [1, 1000] 的范围。 S 只包含小写字母。 widths 是长度为 26的数组。 widths[i] 值的范围在 [2, 10]。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历-模拟 O(n) O(1) func numberOfLines(widths []int, S string) []int { res := []int{0, 0} if len(S) == 0 { return res } res[0] = 1 for i := 0; i 100 { res[0]++ res[1] = widths[S[i]-'a'] } else { res[1] = res[1] + widths[S[i]-'a'] } } return res } 811.子域名访问计数(2) 题目 一个网站域名，如\"discuss.leetcode.com\"，包含了多个子域名。 作为顶级域名，常用的有\"com\"，下一级则有\"leetcode.com\"，最低的一级为\"discuss.leetcode.com\"。 当我们访问域名\"discuss.leetcode.com\"时，也同时访问了其父域名\"leetcode.com\"以及顶级域名 \"com\"。 给定一个带访问次数和域名的组合，要求分别计算每个域名被访问的次数。 其格式为访问次数+空格+地址，例如：\"9001 discuss.leetcode.com\"。 接下来会给出一组访问次数和域名组合的列表cpdomains 。 要求解析出所有域名的访问次数，输出格式和输入格式相同，不限定先后顺序。 示例 1:输入: [\"9001 discuss.leetcode.com\"] 输出: [\"9001 discuss.leetcode.com\", \"9001 leetcode.com\", \"9001 com\"] 说明: 例子中仅包含一个网站域名：\"discuss.leetcode.com\"。 按照前文假设，子域名\"leetcode.com\"和\"com\"都会被访问，所以它们都被访问了9001次。 示例 2输入: [\"900 google.mail.com\", \"50 yahoo.com\", \"1 intel.mail.com\", \"5 wiki.org\"] 输出: [\"901 mail.com\",\"50 yahoo.com\",\"900 google.mail.com\",\"5 wiki.org\",\"5 org\", \"1 intel.mail.com\",\"951 com\"] 说明: 按照假设，会访问\"google.mail.com\" 900次，\"yahoo.com\" 50次， \"intel.mail.com\" 1次，\"wiki.org\" 5次。 而对于父域名，会访问\"mail.com\" 900+1 = 901次，\"com\" 900 + 50 + 1 = 951次，和 \"org\" 5 次。 注意事项： cpdomains 的长度小于 100。 每个域名的长度小于100。 每个域名地址包含一个或两个\".\"符号。 输入中任意一个域名的访问次数都小于10000。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历-哈希辅助 O(n) O(n) 02 遍历-哈希辅助 O(n) O(n) func subdomainVisits(cpdomains []string) []string { m := make(map[string]int) for _, domains := range cpdomains { domain, count := parse(domains) isNew := true for isNew { m[domain] = m[domain] + count domain, isNew = cut(domain) } } return getResult(m) } func parse(s string) (string, int) { ss := strings.Split(s, \" \") count, _ := strconv.Atoi(ss[0]) return ss[1], count } func cut(s string) (string, bool) { index := strings.Index(s, \".\") if index == -1 { return \"\", false } return s[index+1:], true } func getResult(m map[string]int) []string { res := make([]string, 0, len(m)) for k, v := range m { res = append(res, fmt.Sprintf(\"%d %s\", v, k)) } return res } # func subdomainVisits(cpdomains []string) []string { m := make(map[string]int) for _, domains := range cpdomains { arr := strings.Split(domains, \" \") count, _ := strconv.Atoi(arr[0]) tempArr := getSubdomains(arr[1]) for i := 0; i = 0; i-- { if s[i] == '.' { res = append(res, s[i+1:]) } } res = append(res, s) return res } 812.最大三角形面积(2) 题目 给定包含多个点的集合，从其中取三个点组成三角形，返回能组成的最大三角形的面积。 示例:输入: points = [[0,0],[0,1],[1,0],[0,2],[2,0]] 输出: 2 解释: 这五个点如下图所示。组成的橙色三角形是最大的，面积为2。 注意: 3 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法-鞋带公式 O(n^3) O(1) 02 暴力法-海伦公式 O(n^3) O(1) func largestTriangleArea(points [][]int) float64 { maxArea := 0.0 n := len(points) for i := 0; i maxArea { maxArea = area(points[i], points[j], points[k]) } } } } return maxArea } // 三角形面积=|(x1 * y2 + x2 * y3 + x3 * y1 - y1 * x2 - y2 * x3 - y3 * x1)|/2 func area(p1, p2, p3 []int) float64 { return abs( p1[0]*p2[1]+p2[0]*p3[1]+p3[0]*p1[1]- p1[0]*p3[1]-p2[0]*p1[1]-p3[0]*p2[1]) / 2 } func abs(num int) float64 { if num maxArea { maxArea = area } } } } return maxArea } // 求两点距离 func length(p1, p2 []int) float64 { l := (p1[0]-p2[0])*(p1[0]-p2[0]) + (p1[1]-p2[1])*(p1[1]-p2[1]) return math.Sqrt(float64(l)) } 819.最常见的单词(2) 题目 给定一个段落 (paragraph) 和一个禁用单词列表 (banned)。返回出现次数最多，同时不在禁用列表中的单词。 题目保证至少有一个词不在禁用列表中，而且答案唯一。 禁用列表中的单词用小写字母表示，不含标点符号。段落中的单词不区分大小写。答案都是小写字母。 示例：输入: paragraph = \"Bob hit a ball, the hit BALL flew far after it was hit.\" banned = [\"hit\"] 输出: \"ball\" 解释: \"hit\" 出现了3次，但它是一个禁用的单词。 \"ball\" 出现了2次 (同时没有其他单词出现2次)，所以它是段落里出现次数最多的，且不在禁用列表中的单词。 注意，所有这些单词在段落里不区分大小写，标点符号需要忽略（即使是紧挨着单词也忽略， 比如 \"ball,\"）， \"hit\"不是最终的答案，虽然它出现次数更多，但它在禁用单词列表中。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助遍历+内置函数 O(n) O(n) 02 哈希辅助遍历 O(n) O(n) func mostCommonWord(paragraph string, banned []string) string { isBanned := make(map[string]bool) for _, b := range banned { isBanned[b] = true } chars := []string{\"!\", \"?\", \",\", \"'\", \";\", \".\"} for _, c := range chars { paragraph = strings.Replace(paragraph, c, \" \", -1) } p := strings.ToLower(paragraph) ss := strings.Fields(p) count := make(map[string]int) for _, v := range ss { if isBanned[v] { continue } count[v]++ } res := \"\" max := 0 for s, c := range count { if max = 'A' && paragraph[j] = 'a' && b = 'A' && b 821.字符的最短距离(3) 题目 给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。 示例 1:输入: S = \"loveleetcode\", C = 'e' 输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0] 说明: 字符串 S 的长度范围为 [1, 10000]。 C 是一个单字符，且保证是字符串 S 里的字符。 S 和 C 中的所有字母均为小写字母。 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针遍历 O(n) O(1) 02 遍历-往两边找 O(n^2) O(1) 03 遍历-数组辅助 O(n^2) O(n) func shortestToChar(S string, C byte) []int { n := len(S) res := make([]int, n) for i := range res { res[i] = 100001 } left, right := -n, 2*n for i := 0; i n-1 跟左边的C比较得到最近的距离 // j从n-1->0 跟右边的C比较得到最近的距离 res[i] = min(res[i], dist(i, left)) res[j] = min(res[j], dist(j, right)) } return res } func min(a, b int) int { if a j { return i - j } return j - i } # func shortestToChar(S string, C byte) []int { n := len(S) res := make([]int, n) for i := 0; i j-i { min = j - i } break } } for j := i - 1; j >= 0; j-- { if S[j] == C { if min > i-j { min = i - j } break } } res[i] = min } return res } # func shortestToChar(S string, C byte) []int { n := len(S) res := make([]int, n) arr := make([]int, 0) for i := 0; i dist(i, value) { min = dist(i, value) } } res[i] = min } return res } func dist(i, j int) int { if i > j { return i - j } return j - i } 824.山羊拉丁文(2) 题目 给定一个由空格分割单词的句子 S。每个单词只包含大写或小写字母。 我们要将句子转换为 “Goat Latin”（一种类似于 猪拉丁文 - Pig Latin 的虚构语言）。 山羊拉丁文的规则如下： 如果单词以元音开头（a, e, i, o, u），在单词后添加\"ma\"。 例如，单词\"apple\"变为\"applema\"。 如果单词以辅音字母开头（即非元音字母），移除第一个字符并将它放到末尾，之后再添加\"ma\"。 例如，单词\"goat\"变为\"oatgma\"。 根据单词在句子中的索引，在单词最后添加与索引相同数量的字母'a'，索引从1开始。 例如，在第一个单词后添加\"a\"，在第二个单词后添加\"aa\"，以此类推。 返回将 S 转换为山羊拉丁文后的句子。 示例 1:输入: \"I speak Goat Latin\" 输出: \"Imaa peaksmaaa oatGmaaaa atinLmaaaaa\" 示例 2:输入: \"The quick brown fox jumped over the lazy dog\" 输出: \"heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa\" 说明: S 中仅包含大小写字母和空格。单词间有且仅有一个空格。 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 内置函数 O(n) O(n) 02 遍历 O(n) O(n) func toGoatLatin(S string) string { ss := strings.Split(S, \" \") for i := range ss { ss[i] = handle(ss[i], i) } return strings.Join(ss, \" \") } func handle(s string, i int) string { postfix := \"ma\" + strings.Repeat(\"a\", i+1) if isBeginWithVowel(s) { return s + postfix } return s[1:] + s[0:1] + postfix } func isBeginWithVowel(s string) bool { switch s[0] { case 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U': return true default: return false } } # func toGoatLatin(S string) string { res := \"\" begin := 1 count := 1 temp := \"\" for i := 0; i 830.较大分组的位置(2) 题目 在一个由小写字母构成的字符串 S 中，包含由一些连续的相同字符所构成的分组。 例如，在字符串 S = \"abbxxxxzyy\" 中，就含有 \"a\", \"bb\", \"xxxx\", \"z\" 和 \"yy\" 这样的一些分组。 我们称所有包含大于或等于三个连续字符的分组为较大分组。找到每一个较大分组的起始和终止位置。 最终结果按照字典顺序输出。 示例 1:输入: \"abbxxxxzzy\"输出: [[3,6]] 解释: \"xxxx\" 是一个起始于 3 且终止于 6 的较大分组。 示例 2:输入: \"abc\"输出: [] 解释: \"a\",\"b\" 和 \"c\" 均不是符合要求的较大分组。 示例 3:输入: \"abcdddeeeeaabbbcd\"输出: [[3,5],[6,9],[12,14]] 说明: 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n) O(1) 02 双指针 O(n) O(1) func largeGroupPositions(S string) [][]int { res := make([][]int, 0, len(S)/3) left := 0 for right := 0; right = 3 { res = append(res, []int{left, right}) } left = right + 1 } } return res } # func largeGroupPositions(S string) [][]int { res := make([][]int, 0, len(S)/3) left, right := 0, 1 for ; right 3 { res[len(res)-1][1] = right } } return res } 832.翻转图像(2) 题目 给定一个二进制矩阵 A，我们想先水平翻转图像，然后反转图像并返回结果。 水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 [1, 1, 0] 的结果是 [0, 1, 1]。 反转图片的意思是图片中的 0 全部被 1 替换， 1 全部被 0 替换。例如，反转 [0, 1, 1] 的结果是 [1, 0, 0]。 示例 1: 输入: [[1,1,0],[1,0,1],[0,0,0]] 输出: [[1,0,0],[0,1,0],[1,1,1]] 解释: 首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]； 然后反转图片: [[1,0,0],[0,1,0],[1,1,1]] 示例 2: 输入: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]] 输出: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] 解释: 首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]； 然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] 说明: 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历+双指针 O(n^2) O(1) 02 遍历 O(n^2) O(1) func flipAndInvertImage(A [][]int) [][]int { for k := 0; k 836.矩形重叠(3) 题目 矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。 如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。 给出两个矩形，判断它们是否重叠并返回结果。 示例 1：输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3] 输出：true 示例 2：输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1] 输出：false 提示： 两个矩形 rec1 和 rec2 都以含有四个整数的列表的形式给出。 矩形中的所有坐标都处于 -10^9 和 10^9 之间。 x 轴默认指向右，y 轴默认指向上。 你可以仅考虑矩形是正放的情况。 解题思路 No. 思路 时间复杂度 空间复杂度 01 正面条件判断 O(1) O(1) 02 不满足条件判断 O(1) O(1) 03 投影 O(1) O(1) func isRectangleOverlap(rec1 []int, rec2 []int) bool { // 满足条件 if rec1[1] = rec2[2] // 上方：rec1[1] >= rec2[3] // 下方：rec1[3] = rec2[2] || rec1[1] >= rec2[3] { return false } return true } # func isRectangleOverlap(rec1 []int, rec2 []int) bool { return min(rec1[2], rec2[2]) > max(rec1[0], rec2[0]) && min(rec1[3], rec2[3]) > max(rec1[1], rec2[1]) } func max(a, b int) int { if a > b { return a } return b } func min(a, b int) int { if a > b { return b } return a } 840.矩阵中的幻方(2) 题目 3 x 3 的幻方是一个填充有从 1 到 9 的不同数字的 3 x 3 矩阵， 其中每行，每列以及两条对角线上的各数之和都相等。 给定一个由整数组成的 grid，其中有多少个 3 × 3 的 “幻方” 子矩阵？（每个子矩阵都是连续的）。 示例：输入: [[4,3,8,4], [9,5,1,9], [2,7,6,2]] 输出: 1 解释: 下面的子矩阵是一个 3 x 3 的幻方： 438 951 276 而这一个不是： 384 519 762 总的来说，在本示例所给定的矩阵中只有一个 3 x 3 的幻方子矩阵。 提示: 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法 O(n^2) O(1) 02 暴力法-打表 O(n^2) O(1) func numMagicSquaresInside(grid [][]int) int { m, n := len(grid), len(grid[0]) res := 0 for i := 0; i+2 844.比较含退格的字符串(2) 题目 给定 S 和 T 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 # 代表退格字符。 注意：如果对空文本输入退格字符，文本继续为空。 示例 1：输入：S = \"ab#c\", T = \"ad#c\"输出：true 解释：S 和 T 都会变成 “ac”。 示例 2：输入：S = \"ab##\", T = \"c#d#\"输出：true 解释：S 和 T 都会变成 “”。 示例 3：输入：S = \"a##c\", T = \"#a#c\"输出：true 解释：S 和 T 都会变成 “c”。 示例 4：输入：S = \"a#c\", T = \"b\" 输出：false 解释：S 会变成 “c”，但 T 仍然是 “b”。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历-数组模拟栈操作 O(n) O(n) 02 遍历-从后往前 O(n) O(n) func backspaceCompare(S string, T string) bool { return check(S) == check(T) } func check(str string) string { res := make([]string, 0) for _, v := range str { if string(v) == \"#\" { if len(res) != 0 { res = res[:len(res)-1] } } else { res = append(res, string(v)) } } return strings.Join(res, \"\") } # func backspaceCompare(S string, T string) bool { return check(S) == check(T) } func check(S string) string { str := \"\" count := 0 for i := len(S) - 1; i >= 0; i-- { if S[i] == '#' { count++ } else { if count != 0 { count-- continue } str = string(S[i]) + str } } return str } 849.到最近的人的最大距离(4) 题目 在一排座位（ seats）中，1 代表有人坐在座位上，0 代表座位上是空的。 至少有一个空座位，且至少有一人坐在座位上。 亚历克斯希望坐在一个能够使他与离他最近的人之间的距离达到最大化的座位上。 返回他到离他最近的人的最大距离。 示例 1：输入：[1,0,0,0,1,0,1]输出：2 解释：如果亚历克斯坐在第二个空位（seats[2]）上，他到离他最近的人的距离为 2 。 如果亚历克斯坐在其它任何一个空位上，他到离他最近的人的距离为 1 。 因此，他到离他最近的人的最大距离是 2 。 示例 2：输入：[1,0,0,0]输出：3 解释： 如果亚历克斯坐在最后一个座位上，他离最近的人有 3 个座位远。 这是可能的最大距离，所以答案是 3 。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历-数组辅助 O(n) O(n) 02 遍历-双指针 O(n) I 03 遍历 O(n) O(n) 04 遍历 O(n) O(1) func maxDistToClosest(seats []int) int { n := len(seats) left := make([]int, n) right := make([]int, n) for i := 0; i 0 { left[i] = left[i-1] + 1 } } for i := n - 1; i >= 0; i-- { if seats[i] == 1 { right[i] = 0 } else if seats[i] != 1 && i res { res = min(left[i], right[i]) } } } return res } func min(a, b int) int { if a > b { return b } return a } # func maxDistToClosest(seats []int) int { n := len(seats) res := 0 left := -1 right := 0 for i := 0; i res { res = min(leftLen, rightLen) } } } return res } func min(a, b int) int { if a > b { return b } return a } # func maxDistToClosest(seats []int) int { n := len(seats) var arr []int for i := 0; i max { max = arr[i+1] - arr[i] } } max = max / 2 // 判断首尾 if arr[0] > max { max = arr[0] } if n-arr[len(arr)-1]-1 > max { max = n - arr[len(arr)-1] - 1 } return max } # func maxDistToClosest(seats []int) int { res := 0 count := 0 for i := 0; i b { return a } return b } 852.山脉数组的峰顶索引(2) 题目 我们把符合下列属性的数组 A 称作山脉： A.length >= 3 存在 0 A[i+1] > ... > A[A.length - 1] 给定一个确定为山脉的数组，返回任何满足 A[0] A[i+1] > ... > A[A.length - 1] 的 i 的值。 示例 1：输入：[0,1,0]输出：1 示例 2：输入：[0,2,1,0]输出：1 提示： 3 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 二分查找 O(log(n)) O(1) func peakIndexInMountainArray(A []int) int { n := len(A) for i := 0; i A[i+1] { return i } } return 0 } # func peakIndexInMountainArray(A []int) int { left, right := 0, len(A)-1 for { mid := left + (right-left)/2 if A[mid] > A[mid+1] && A[mid] > A[mid-1] { return mid } if A[mid] > A[mid-1] { left = mid + 1 } else { right = mid - 1 } } } 859.亲密字符串(2) 题目 给定两个由小写字母构成的字符串 A 和 B ，只要我们可以通过交换 A 中的两个字母得到与 B 相等的结果， 就返回 true ；否则返回 false 。 示例 1： 输入： A = \"ab\", B = \"ba\" 输出： true 示例 2： 输入： A = \"ab\", B = \"ab\"输出： false 示例 3: 输入： A = \"aa\", B = \"aa\" 输出： true 示例 4： 输入： A = \"aaaaaaabc\", B = \"aaaaaaacb\" 输出： true 示例 5： 输入： A = \"\", B = \"aa\" 输出： false 提示： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 遍历 O(n) O(1) func buddyStrings(A string, B string) bool { if len(A) != len(B) { return false } if A == B { return hasDouble(A) } count := 2 strA, strB := \"\", \"\" i := 0 for ; count > 0 && i = 1 { return true } seen[b] = 1 } return false } 860.柠檬水找零(1) 题目 在柠檬水摊上，每一杯柠檬水的售价为 5 美元。 顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。 每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。 你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。 注意，一开始你手头没有任何零钱。 如果你能给每位顾客正确找零，返回 true ，否则返回 false 。 示例 1：输入：[5,5,5,10,20] 输出：true 解释： 前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。 第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。 第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。 由于所有客户都得到了正确的找零，所以我们输出 true。 示例 2：输入：[5,5,10] 输出：true 示例 3：输入：[10,10] 输出：false 示例 4：输入：[5,5,10,10,20] 输出：false 解释： 前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。 对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。 对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。 由于不是每位顾客都得到了正确的找零，所以答案是 false。 提示： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历+模拟 O(n) O(1) func lemonadeChange(bills []int) bool { fives, tens := 0, 0 for _, b := range bills { switch b { case 5: fives++ case 10: fives-- tens++ case 20: if tens > 0 { tens-- fives-- } else { fives = fives - 3 } } if fives 867.转置矩阵(1) 题目 给定一个矩阵 A， 返回 A 的转置矩阵。 矩阵的转置是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。 示例 1：输入：[[1,2,3],[4,5,6],[7,8,9]]输出：[[1,4,7],[2,5,8],[3,6,9]] 示例 2：输入：[[1,2,3],[4,5,6]]输出：[[1,4],[2,5],[3,6]] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n^2) O(n^2) func transpose(A [][]int) [][]int { m, n := len(A), len(A[0]) res := make([][]int, n) for i := 0; i 868.二进制间距(3) 题目 给定一个正整数 N，找到并返回 N 的二进制表示中两个连续的 1 之间的最长距离。 如果没有两个连续的 1，返回 0 。 示例 1：输入：22 输出：2 解释：22 的二进制是 0b10110 。 在 22 的二进制表示中，有三个 1，组成两对连续的 1 。 第一对连续的 1 中，两个 1 之间的距离为 2 。 第二对连续的 1 中，两个 1 之间的距离为 1 。 答案取两个距离之中最大的，也就是 2 。 示例 2：输入：5 输出：2 解释：5 的二进制是 0b101 。 示例 3：输入：6 输出：1 解释： 6 的二进制是 0b110 。 示例 4：输入：8 输出：0 解释： 8 的二进制是 0b1000 。 在 8 的二进制表示中没有连续的 1，所以返回 0 。 提示：1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历-数组辅助 O(log(n)) O(log(n)) 02 遍历 O(log(n)) O(1) 03 遍历-内置函数 O(log(n)) O(log(n)) func binaryGap(N int) int { arr := make([]int, 0) index := 0 for N > 0 { if N%2 == 1 { arr = append(arr, index) } index++ N = N / 2 } res := 0 for i := 0; i res { res = arr[i+1] - arr[i] } } return res } # func binaryGap(N int) int { res := 0 count := 0 for N > 0 { if N%2 == 1 { if count > res { res = count } count = 1 } else if count > 0 { count++ } N = N / 2 } return res } # func binaryGap(N int) int { res := 0 str := strconv.FormatInt(int64(N), 2) j := -1 for i := 0; i res { res = i - j } j = i } } } return res } 872.叶子相似的树(2) 题目 请考虑一颗二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个叶值序列 。 举个例子，如上图所示，给定一颗叶值序列为 (6, 7, 4, 9, 8) 的树。 如果有两颗二叉树的叶值序列是相同，那么我们就认为它们是 叶相似 的。 如果给定的两个头结点分别为 root1 和 root2 的树是叶相似的，则返回 true；否则返回 false 。 提示： 给定的两颗树可能会有 1 到 200 个结点。 给定的两颗树上的值介于 0 到 200 之间。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 迭代 O(n) O(n) var a1, a2 []int func leafSimilar(root1 *TreeNode, root2 *TreeNode) bool { a1 = make([]int, 0) a2 = make([]int, 0) dfs(root1, &a1) dfs(root2, &a2) if len(a1) != len(a2) { return false } for i := 0; i 0 { node := stack[len(stack)-1] stack = stack[:len(stack)-1] if node.Left == nil && node.Right == nil { *arr = append(*arr, node.Val) } if node.Right != nil { stack = append(stack, node.Right) } if node.Left != nil { stack = append(stack, node.Left) } } } 874.模拟行走机器人(2) 题目 机器人在一个无限大小的网格上行走，从点 (0, 0) 处开始出发，面向北方。该机器人可以接收以下三种类型的命令： -2：向左转 90 度 -1：向右转 90 度 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历-模拟 O(n) O(n) 02 遍历-模拟 O(n) O(n) // 上、右、下、左 var dx = []int{0, 1, 0, -1} var dy = []int{1, 0, -1, 0} func robotSim(commands []int, obstacles [][]int) int { i := 0 // 方向， 0上， 1右， 2下， 3左 x := 0 y := 0 res := 0 m := map[string]bool{} for _, v := range obstacles { str := strconv.Itoa(v[0]) + \",\" + strconv.Itoa(v[1]) m[str] = true } for _, v := range commands { if v == -2 { i = (i + 3) % 4 // 左转 } else if v == -1 { i = (i + 1) % 4 // 右转 } else { for v > 0 { ddx := x + dx[i] ddy := y + dy[i] tp := strconv.Itoa(ddx) + \",\" + strconv.Itoa(ddy) if _, ok := m[tp]; ok { // 有障碍物，停止 break } else { x = ddx y = ddy if x*x+y*y > res { res = x*x + y*y } } v-- } } } return res } # var dx = []int{0, 1, 0, -1} var dy = []int{1, 0, -1, 0} func robotSim(commands []int, obstacles [][]int) int { m := make(map[string]bool, 10000) for _, o := range obstacles { i, j := o[0], o[1] m[encode(i, j)] = true } x, y, res := 0, 0, 0 index := 0 for _, c := range commands { index = (index + 4) % 4 switch { case c == -2: index-- case c == -1: index++ default: dx1, dy1 := dx[index], dy[index] for c > 0 && !m[encode(x+dx1, y+dy1)] { c-- x = x + dx1 y = y + dy1 } if x*x+y*y > res { res = x*x + y*y } } } return res } func encode(x, y int) string { return strconv.Itoa(x) + \",\" + strconv.Itoa(y) } 876.链表的中间结点(3) 题目 给定一个带有头结点 head 的非空单链表，返回链表的中间结点。 如果有两个中间结点，则返回第二个中间结点。 示例 1：输入：[1,2,3,4,5] 输出：此列表中的结点 3 (序列化形式：[3,4,5]) 返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。 注意，我们返回了一个 ListNode 类型的对象 ans，这样： ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL. 示例 2：输入：[1,2,3,4,5,6] 输出：此列表中的结点 4 (序列化形式：[4,5,6]) 由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。 提示： 给定链表的结点数介于 1 和 100 之间。 解题思路 No. 思路 时间复杂度 空间复杂度 01 快慢指针 O(n) O(1) 02 数组辅助 O(n) O(n) 03 遍历统计 O(n) O(1) func middleNode(head *ListNode) *ListNode { slow, fast := head, head for fast != nil && fast.Next != nil { slow = slow.Next fast = fast.Next.Next } return slow } # func middleNode(head *ListNode) *ListNode { res := make([]*ListNode, 0) for head != nil { res = append(res, head) head = head.Next } return res[len(res)/2] } # func middleNode(head *ListNode) *ListNode { count := 0 temp := head for temp != nil { count++ temp = temp.Next } mid := count / 2 for head != nil { if mid == 0 { return head } head = head.Next mid-- } return head } 883.三维形体投影面积(2) 题目 在 N * N 的网格中，我们放置了一些与 x，y，z 三轴对齐的 1 * 1 * 1 立方体。 每个值 v = grid[i][j] 表示 v 个正方体叠放在单元格 (i, j) 上。 现在，我们查看这些立方体在 xy、yz 和 zx 平面上的投影。 投影就像影子，将三维形体映射到一个二维平面上。 在这里，从顶部、前面和侧面看立方体时，我们会看到“影子”。 返回所有三个投影的总面积。 示例 1：输入：[[2]] 输出：5 示例 2：输入：[[1,2],[3,4]] 输出：17 解释： 这里有该形体在三个轴对齐平面上的三个投影(“阴影部分”)。 示例 3：输入：[[1,0],[0,2]] 输出：8 示例 4：输入：[[1,1,1],[1,0,1],[1,1,1]] 输出：14 示例 5：输入：[[2,2,2],[2,1,2],[2,2,2]] 输出：21 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n^2) O(1) 02 遍历 O(n^2) O(1) // 1.xy面，grid[i][j]>0的个数累加 // 2.xz面, 行的最大值累加 // 3.yz面, 列的最大值累加 func projectionArea(grid [][]int) int { yz := [51]int{} xz := [51]int{} res := 0 for i, line := range grid { for j, k := range line { if k == 0 { continue } res++ yz[i] = max(yz[i], k) xz[j] = max(xz[j], k) } } for i := range yz { res = res + yz[i] + xz[i] } return res } func max(a, b int) int { if a > b { return a } return b } # func projectionArea(grid [][]int) int { res := 0 for i := 0; i 0 { res++ } if yz 884.两句话中的不常见单词(2) 题目 给定两个句子 A 和 B 。 （句子是一串由空格分隔的单词。每个单词仅由小写字母组成。） 如果一个单词在其中一个句子中只出现一次，在另一个句子中却没有出现，那么这个单词就是不常见的。 返回所有不常用单词的列表。 您可以按任何顺序返回列表。 示例 1：输入：A = \"this apple is sweet\", B = \"this apple is sour\"输出：[\"sweet\",\"sour\"] 示例 2：输入：A = \"apple apple\", B = \"banana\"输出：[\"banana\"] 提示： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助+内置函数 O(n) O(n) 02 哈希辅助+遍历 O(n) O(n) func uncommonFromSentences(A string, B string) []string { m := map[string]int{} arrA := strings.Fields(A) arrB := strings.Fields(B) for _, v := range arrA { m[v]++ } for _, v := range arrB { m[v]++ } res := make([]string, 0) for k, v := range m { if v == 1 { res = append(res, k) } } return res } # func uncommonFromSentences(A string, B string) []string { m := map[string]int{} A = A + \" \" + B + \" \" j := 0 for i := 0; i 888.公平的糖果交换(2) 题目 爱丽丝和鲍勃有不同大小的糖果棒：A[i] 是爱丽丝拥有的第 i 块糖的大小，B[j] 是鲍勃拥有的第 j 块糖的大小。 因为他们是朋友，所以他们想交换一个糖果棒，这样交换后，他们都有相同的糖果总量。 （一个人拥有的糖果总量是他们拥有的糖果棒大小的总和。） 返回一个整数数组 ans，其中 ans[0] 是爱丽丝必须交换的糖果棒的大小，ans[1] 是 Bob 必须交换的糖果棒的大小。 如果有多个答案，你可以返回其中任何一个。保证答案存在。 示例 1：输入：A = [1,1], B = [2,2] 输出：[1,2] 示例 2：输入：A = [1,2], B = [2,3] 输出：[1,2] 示例 3：输入：A = [2], B = [1,3] 输出：[2,3] 示例 4：输入：A = [1,2,5], B = [2,4] 输出：[5,4] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历+哈希辅助 O(n) O(n) 02 暴力法 O(n^2) O(1) func fairCandySwap(A []int, B []int) []int { m := make(map[int]bool) sumA := 0 sumB := 0 for _, v := range A { sumA = sumA + v m[v] = true } for _, v := range B { sumB = sumB + v } half := (sumA - sumB) / 2 a, b := 0, 0 // sumA-A[i]+B[j] == sumB-B[j]+A[i] // sumA-sumB=2(A[i]-B[j]) // (sumA-sumB)/2 = A[i]-B[j] for _, b = range B { a = b + half if m[a] == true { return []int{a, b} } } return nil } # func fairCandySwap(A []int, B []int) []int { sumA := 0 sumB := 0 for _, v := range A { sumA = sumA + v } for _, v := range B { sumB = sumB + v } for i := 0; i 892.三维形体的表面积(2) 题目 在 N * N 的网格上，我们放置一些 1 * 1 * 1 的立方体。 每个值 v = grid[i][j] 表示 v 个正方体叠放在对应单元格 (i, j) 上。 请你返回最终形体的表面积。 示例 1：输入：[[2]] 输出：10 示例 2：输入：[[1,2],[3,4]] 输出：34 示例 3：输入：[[1,0],[0,2]] 输出：16 示例 4：输入：[[1,1,1],[1,0,1],[1,1,1]] 输出：32 示例 5：输入：[[2,2,2],[2,1,2],[2,2,2]]输出：46 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n^2) O(1) 02 遍历 O(n^2) O(1) // 第1步：总表面积是个数*6 // 第2步：同一位置，从2层以上开始，每升高一层，减少2个面 // 第3步：左右位置，每相邻一个，减少2个面 // 第4步：前后位置，每相邻一个，减少2个面 func surfaceArea(grid [][]int) int { sum := 0 for i, rows := range grid { for j, _ := range rows { sum = sum + grid[i][j]*6 if grid[i][j] > 1 { sum = sum - (grid[i][j]-1)*2 } if j > 0 { sum = sum - min(grid[i][j], grid[i][j-1])*2 } if i > 0 { sum = sum - min(grid[i][j], grid[i-1][j])*2 } } } return sum } func min(a, b int) int { if a > b { return b } return a } # // 上、右、下、左 var dx = []int{0, 1, 0, -1} var dy = []int{1, 0, -1, 0} func surfaceArea(grid [][]int) int { sum := 0 for i, rows := range grid { for j, _ := range rows { sum = sum + grid[i][j]*6 if grid[i][j] > 1 { sum = sum - (grid[i][j]-1)*2 } for k := 0; k = 0 && x = 0 && y b { return b } return a } 893.特殊等价字符串组(2) 题目 你将得到一个字符串数组 A。 如果经过任意次数的移动，S == T，那么两个字符串 S 和 T 是特殊等价的。 一次移动包括选择两个索引 i 和 j，且 i ％ 2 == j ％ 2，交换 S[j] 和 S [i]。 现在规定，A 中的特殊等价字符串组是 A 的非空子集 S， 这样不在 S 中的任何字符串与 S 中的任何字符串都不是特殊等价的。 返回 A 中特殊等价字符串组的数量。 示例 1：输入：[\"a\",\"b\",\"c\",\"a\",\"c\",\"c\"] 输出：3 解释：3 组 [\"a\",\"a\"]，[\"b\"]，[\"c\",\"c\",\"c\"] 示例 2：输入：[\"aa\",\"bb\",\"ab\",\"ba\"] 输出：4 解释：4 组 [\"aa\"]，[\"bb\"]，[\"ab\"]，[\"ba\"] 示例 3：输入：[\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"] 输出：3 解释：3 组 [\"abc\",\"cba\"]，[\"acb\",\"bca\"]，[\"bac\",\"cab\"] 示例 4：输入：[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] 输出：1 解释：1 组 [\"abcd\",\"cdab\",\"adcb\",\"cbad\"] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历+哈希辅助 O(n) O(n) 02 遍历+哈希辅助 O(n) O(n) func numSpecialEquivGroups(A []string) int { groups := make(map[[26]int]bool) for _, a := range A { count := [26]int{} i := 0 for i = 0; i 896.单调数列(3) 题目 如果数组是单调递增或单调递减的，那么它是单调的。 如果对于所有 i = A[j]，那么数组 A 是单调递减的。 当给定的数组 A 是单调数组时返回 true，否则返回 false。 示例 1：输入：[1,2,2,3]输出：true 示例 2：输入：[6,5,4,4]输出：true 示例 3：输入：[1,3,2]输出：false 示例 4：输入：[1,2,4,5]输出：true 示例 5：输入：[1,1,1]输出：true 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 遍历 O(n) O(1) 03 遍历 O(n) O(1) func isMonotonic(A []int) bool { toEnd := true toFirst := true for i := 0; i A[i+1] { toEnd = false } if A[i] A[i+1] { return false } } return true } func desc(A []int) bool { for i := 0; i 0 && A[i] > A[i+1] { return false } else if temp 897.递增顺序查找树(3) 题目 给你一个树，请你 按中序遍历 重新排列树，使树中最左边的结点现在是树的根， 并且每个结点没有左子结点，只有一个右子结点。 示例 ：输入：[5,3,6,2,4,null,8,1,null,null,null,7,9] 5 / \\ 3 6 / \\ \\ 2 4 8 / / \\ 1 7 9 输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9] 1 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6 \\ 7 \\ 8 \\ 9 提示： 给定树中的结点数介于 1 和 100 之间。 每个结点都有一个从 0 到 1000 范围内的唯一整数值。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归-数组辅助 O(n) O(n) 02 递归 O(n) O(log(n)) 03 迭代 O(n) O(n) func increasingBST(root *TreeNode) *TreeNode { arr := make([]int, 0) dfs(root, &arr) if len(arr) == 0 { return root } newRoot := &TreeNode{Val: arr[0]} cur := newRoot for i := 1; i 0 { node := stack[len(stack)-1] if node.Right != nil { stack = append(stack, node.Right) node.Right = nil continue } stack = stack[:len(stack)-1] node.Right = newRoot.Right newRoot.Right = node if node.Left != nil { stack = append(stack, node.Left) node.Left = nil } } return newRoot.Right } Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-06-16 09:58:05 "},"docs/source/question/0901-1000.html":{"url":"docs/source/question/0901-1000.html","title":"0901-1000","keywords":"","body":"0901-1000-Easy 0901-1000-Easy 905.按奇偶排序数组(4) 908.最小差值I(2) 914.卡牌分组 917.仅仅反转字母(4) 922.按奇偶排序数组 II(3) 925.长按键入(2) 929.独特的电子邮件地址(2) 933.最近的请求次数(2) 937.重新排列日志文件(2) 938.二叉搜索树的范围和(2) 941.有效的山脉数组(2) 942.增减字符串匹配(1) 944.删列造序(1) 949.给定数字能组成的最大时间(2) 953.验证外星语词典(2) 961.重复 N 次的元素(5) 965.单值二叉树(4) 970.强整数(2) 976.三角形的最大周长(2) 977.有序数组的平方(3) 985.查询后的偶数和(1) 989.数组形式的整数加法(4) 993.二叉树的堂兄弟节点(2) 997.找到小镇的法官(2) 999.可以被一步捕获的棋子数(2) 905.按奇偶排序数组(4) 题目 给定一个非负整数数组 A，返回一个数组，在该数组中， A 的所有偶数元素之后跟着所有奇数元素。 你可以返回满足此条件的任何数组作为答案。 示例：输入：[3,1,2,4] 输出：[2,4,3,1] 输出 [4,2,3,1]，[2,4,1,3] 和 [4,2,1,3] 也会被接受。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n) O(1) 02 双指针 O(n) O(1) 03 遍历 O(n) O(n) 04 遍历 O(n) O(1) func sortArrayByParity(A []int) []int { i := 0 j := len(A)-1 for i 908.最小差值I(2) 题目 给你一个整数数组 A，对于每个整数 A[i]，我们可以选择处于区间 [-K, K] 中的任意数 x ， 将 x 与 A[i] 相加，结果存入 A[i] 。 在此过程之后，我们得到一些数组 B。 返回 B 的最大值和 B 的最小值之间可能存在的最小差值。 示例 1：输入：A = [1], K = 0 输出：0 解释：B = [1] 示例 2：输入：A = [0,10], K = 2 输出：6 解释：B = [2,8] 示例 3：输入：A = [1,3,6], K = 3 输出：0 解释：B = [3,3,3] 或 B = [4,4,4] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序 O(nlog(n)) O(1) 02 遍历 O(n) O(1) func smallestRangeI(A []int, K int) int { if len(A) == 1 { return 0 } sort.Ints(A) if A[len(A)-1]-A[0] > 2*K { return A[len(A)-1] - A[0] - 2*K } return 0 } # func smallestRangeI(A []int, K int) int { if len(A) == 1 { return 0 } min := A[0] max := A[0] for i := 0; i max { max = A[i] } if A[i] 2*K { return max - min - 2*K } return 0 } 914.卡牌分组 题目 给定一副牌，每张牌上都写着一个整数。 此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组： 每组都有 X 张牌。 组内所有的牌上都写着相同的整数。 仅当你可选的 X >= 2 时返回 true。 示例 1：输入：[1,2,3,4,4,3,2,1] 输出：true 解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4] 示例 2：输入：[1,1,1,2,2,2,3,3] 输出：false 解释：没有满足要求的分组。 示例 3：输入：[1] 输出：false 解释：没有满足要求的分组。 示例 4：输入：[1,1] 输出：true 解释：可行的分组是 [1,1] 示例 5：输入：[1,1,2,2,2,2] 输出：true 解释：可行的分组是 [1,1]，[2,2]，[2,2] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助+求公约数 O(nlog(n)) O(n) 02 暴力法 O(n^2) O(n) func hasGroupsSizeX(deck []int) bool { if len(deck) 0 { return gcd(y, a) } return y } # func hasGroupsSizeX(deck []int) bool { if len(deck) 917.仅仅反转字母(4) 题目 给定一个字符串 S，返回 “反转后的” 字符串，其中不是字母的字符都保留在原地，而所有字母的位置发生反转。 示例 1：输入：\"ab-cd\" 输出：\"dc-ba\" 示例 2：输入：\"a-bC-dEf-ghIj\" 输出：\"j-Ih-gfE-dCba\" 示例 3：输入：\"Test1ng-Leet=code-Q!\" 输出：\"Qedo1ct-eeLg=ntse-T!\" 提示： S.length 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n) O(n) 02 双指针 O(n) O(n) 03 双指针-内置函数 O(n) O(n) 04 栈辅助 O(n) O(n) func reverseOnlyLetters(S string) string { i := 0 j := len(S) - 1 arr := []byte(S) for i = 'a' && b = 'A' && b = 'a' && b = 'A' && b 922.按奇偶排序数组 II(3) 题目 给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。 对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。 你可以返回任何满足上述条件的数组作为答案。 示例：输入：[4,2,5,7]输出：[4,5,2,7] 解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。 提示： 2 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n) O(1) 02 双指针 O(n) O(1) 03 数组辅助 O(n) O(n) func sortArrayByParityII(A []int) []int { i := 0 j := 1 for i = len(A) || j >= len(A) { break } A[i], A[j] = A[j], A[i] } return A } # func sortArrayByParityII(A []int) []int { i := 0 j := 1 for i 925.长按键入(2) 题目 你的朋友正在使用键盘输入他的名字 name。偶尔，在键入字符 c 时，按键可能会被长按， 而字符可能被输入 1 次或多次。 你将会检查键盘输入的字符 typed。 如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回 True。 示例 1： 输入：name = \"alex\", typed = \"aaleex\" 输出：true 解释：'alex' 中的 'a' 和 'e' 被长按。 示例 2： 输入：name = \"saeed\", typed = \"ssaaedd\" 输出：false 解释：'e' 一定需要被键入两次，但在 typed 的输出中不是这样。 示例 3： 输入：name = \"leelee\", typed = \"lleeelee\" 输出：true 示例 4： 输入：name = \"laiden\", typed = \"laiden\" 输出：true 解释：长按名字中的字符并不是必要的。 提示： name.length 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n) O(1) 02 遍历统计比较 O(n) O(1) func isLongPressedName(name string, typed string) bool { i := 0 j := 0 for j 929.独特的电子邮件地址(2) 题目 每封电子邮件都由一个本地名称和一个域名组成，以 @ 符号分隔。 例如，在 alice@leetcode.com中， alice 是本地名称，而 leetcode.com 是域名。 除了小写字母，这些电子邮件还可能包含 '.' 或 '+'。 如果在电子邮件地址的本地名称部分中的某些字符之间添加句点（'.'）， 则发往那里的邮件将会转发到本地名称中没有点的同一地址。 例如，\"alice.z@leetcode.com” 和 “alicez@leetcode.com” 会转发到同一电子邮件地址。 （请注意，此规则不适用于域名。） 如果在本地名称中添加加号（'+'），则会忽略第一个加号后面的所有内容。 这允许过滤某些电子邮件，例如 m.y+name@email.com 将转发到 my@email.com。 （同样，此规则不适用于域名。） 可以同时使用这两个规则。 给定电子邮件列表 emails，我们会向列表中的每个地址发送一封电子邮件。实际收到邮件的不同地址有多少？ 示例： 输入：[\"test.email+alex@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\", \"testemail+david@lee.tcode.com\"] 输出：2 解释：实际收到邮件的是 \"testemail@leetcode.com\" 和 \"testemail@lee.tcode.com\"。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助+内置函数 O(n^2) O(n) 02 哈希辅助 O(n^2) O(n) func numUniqueEmails(emails []string) int { m := make(map[string]bool) for i := 0; i 933.最近的请求次数(2) 题目 写一个 RecentCounter 类来计算最近的请求。 它只有一个方法：ping(int t)，其中 t 代表以毫秒为单位的某个时间。 返回从 3000 毫秒前到现在的 ping 数。 任何处于 [t - 3000, t] 时间范围之内的 ping 都将会被计算在内，包括当前（指 t 时刻）的 ping。 保证每次对 ping 的调用都使用比之前更大的 t 值。 示例： 输入：inputs = [\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\"], inputs = [[],[1],[100],[3001],[3002]] 输出：[null,1,2,3,3] 提示： 每个测试用例最多调用 10000 次 ping。 每个测试用例会使用严格递增的 t 值来调用 ping。 每次调用 ping 都有 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组操作 O(n) O(1) 02 数组操作 O(n) O(1) type RecentCounter struct { arr []int } func Constructor() RecentCounter { return RecentCounter{ arr: make([]int, 0), } } func (r *RecentCounter) Ping(t int) int { r.arr = append(r.arr, t) res := 1 for i := len(r.arr) - 2; i >= 0; i-- { if t-r.arr[i] 0 && r.arr[0] 937.重新排列日志文件(2) 题目 你有一个日志数组 logs。每条日志都是以空格分隔的字串。 对于每条日志，其第一个字为字母与数字混合的 标识符。 除标识符之外，所有字均由小写字母组成的，称为 字母日志 除标识符之外，所有字均由数字组成的，称为 数字日志 题目所用数据保证每个日志在其标识符后面至少有一个字。 请按下述规则将日志重新排序： 所有 字母日志 都排在 数字日志 之前。 字母日志 在内容不同时，忽略标识符后，按内容字母顺序排序；在内容相同时，按标识符排序； 数字日志 应该按原来的顺序排列。 返回日志的最终顺序。 示例 ： 输入：[\"a1 9 2 3 1\",\"g1 act car\",\"zo4 4 7\",\"ab1 off key dog\",\"a8 act zoo\"] 输出：[\"g1 act car\",\"a8 act zoo\",\"ab1 off key dog\",\"a1 9 2 3 1\",\"zo4 4 7\"] 提示： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 先分类后排序 O(nlog(n)) O(n) 02 先分类后自定义排序 O(nlog(n)) O(n) func reorderLogFiles(logs []string) []string { numLogs := make([]string, 0) wordLogs := make([]string, 0) for key := range logs { for i := 0; i 938.二叉搜索树的范围和(2) 题目 给定二叉搜索树的根结点 root，返回 L 和 R（含）之间的所有结点的值的和。 二叉搜索树保证具有唯一的值。 示例 1：输入：root = [10,5,15,3,7,null,18], L = 7, R = 15 输出：32 示例 2：输入：root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10 输出：23 提示： 树中的结点数量最多为 10000 个。 最终的答案保证小于 2^31。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 迭代 O(n) O(n) func rangeSumBST(root *TreeNode, L int, R int) int { if root == nil { return 0 } if root.Val R { return rangeSumBST(root.Left, L, R) } return root.Val + rangeSumBST(root.Right, L, R) + rangeSumBST(root.Left, L, R) } # func rangeSumBST(root *TreeNode, L int, R int) int { if root == nil { return 0 } stack := make([]*TreeNode, 0) if root.Val > R && root.Left != nil { stack = append(stack, root.Left) } else if root.Val 0 { node := stack[len(stack)-1] stack = stack[:len(stack)-1] if node.Val = L { if node.Left != nil { stack = append(stack, node.Left) } if node.Right != nil { stack = append(stack, node.Right) } res = res + node.Val } else if node.Val > R && node.Left != nil { stack = append(stack, node.Left) } else if node.Val 941.有效的山脉数组(2) 题目 定一个整数数组 A，如果它是有效的山脉数组就返回 true，否则返回 false。 让我们回顾一下，如果 A 满足下述条件，那么它是一个山脉数组： A.length >= 3 在 0 A[i+1] > ... > A[A.length - 1] 示例 1：输入：[2,1] 输出：false 示例 2：输入：[3,5,5] 输出：false 示例 3：输入：[0,3,2,1] 输出：true 提示： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 遍历-双指针 O(n) O(1) func validMountainArray(A []int) bool { if len(A) = len(A) || i == 1 { return false } for ; i A[i] { pre = A[i] } else if pre == A[i] { return false } else { return false } } return true } # func validMountainArray(A []int) bool { if len(A) 942.增减字符串匹配(1) 题目 给定只含 \"I\"（增大）或 \"D\"（减小）的字符串 S ，令 N = S.length。 返回 [0, 1, ..., N] 的任意排列 A 使得对于所有 i = 0, ..., N-1，都有： 如果 S[i] == \"I\"，那么 A[i] A[i+1] 示例 1：输出：\"IDID\" 输出：[0,4,1,3,2] 示例 2：输出：\"III\" 输出：[0,1,2,3] 示例 3：输出：\"DDI\" 输出：[3,2,0,1] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历-双指针 O(n) O(n) func diStringMatch(S string) []int { res := make([]int, len(S)+1) left := 0 right := len(S) for i := 0; i 944.删列造序(1) 题目 给定由 N 个小写字母字符串组成的数组 A，其中每个字符串长度相等。 你需要选出一组要删掉的列 D，对 A 执行删除操作，使 A 中剩余的每一列都是 非降序 排列的， 然后请你返回 D.length 的最小可能值。 删除 操作的定义是：选出一组要删掉的列，删去 A 中对应列中的所有字符， 形式上，第 n 列为 [A[0][n], A[1][n], ..., A[A.length-1][n]]）。（可以参见 删除操作范例） 示例 1：输入：[\"cba\", \"daf\", \"ghi\"] 输出：1 解释： 当选择 D = {1}，删除后 A 的列为：[\"c\",\"d\",\"g\"] 和 [\"a\",\"f\",\"i\"]，均为非降序排列。 若选择 D = {}，那么 A 的列 [\"b\",\"a\",\"h\"] 就不是非降序排列了。 示例 2：输入：[\"a\", \"b\"] 输出：0 解释：D = {} 示例 3：输入：[\"zyx\", \"wvu\", \"tsr\"] 输出：3 解释：D = {0, 1, 2} 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n^2) O(1) func minDeletionSize(A []string) int { res := 0 if len(A) == 1 { return res } for i := 0; i 949.给定数字能组成的最大时间(2) 题目 给定一个由 4 位数字组成的数组，返回可以设置的符合 24 小时制的最大时间。 最小的 24 小时制时间是 00:00，而最大的是 23:59。从 00:00 （午夜）开始算起，过得越久，时间越大。 以长度为 5 的字符串返回答案。如果不能确定有效时间，则返回空字符串。 示例 1：输入：[1,2,3,4] 输出：\"23:41\" 示例 2：输入：[5,5,5,5] 输出：\"\" 提示： A.length == 4 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法 O(1) O(1) 02 全排列 O(1) O(1) func largestTimeFromDigits(A []int) string { res := \"\" for i := 0; i res && res != \"\" { res = ans } else if res == \"\" { res = ans } } } } } } } return res } # var arr []string func largestTimeFromDigits(A []int) string { res := \"\" arr = make([]string, 0) dfs(A, 0, len(A)-1) for i := range arr { if (arr[i] > res && res != \"\") || (res == \"\") { res = arr[i] } } return res } func dfs(A []int, start, length int) { if start == length { hour := A[0]*10 + A[1] minute := A[2]*10 + A[3] if hour 953.验证外星语词典(2) 题目 某种外星语也使用英文小写字母，但可能顺序 order 不同。字母表的顺序（order）是一些小写字母的排列。 给定一组用外星语书写的单词 words，以及其字母表的顺序 order，只有当给定的单词在这种外星语中按字典序排列时， 返回 true；否则，返回 false。 示例 1： 输入：words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\" 输出：true 解释：在该语言的字母表中，'h' 位于 'l' 之前，所以单词序列是按字典序排列的。 示例 2： 输入：words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\" 输出：false 解释：在该语言的字母表中，'d' 位于 'l' 之后，那么 words[0] > words[1]，因此单词序列不是按字典序排列的。 示例 3： 输入：words = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\" 输出：false 解释：当前三个字符 \"app\" 匹配时，第二个字符串相对短一些，然后根据词典编纂规则 \"apple\" > \"app\"，因为 'l' > '∅'，其中 '∅' 是空白字符，定义为比任何其他字符都小（更多信息）。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助-替换 O(n) O(n) 02 遍历比较 O(n) O(1) func isAlienSorted(words []string, order string) bool { newWords := make([]string, len(words)) m := make(map[byte]int) for i := 0; i newWords[i+1] { return false } } return true } # func isAlienSorted(words []string, order string) bool { m := make(map[byte]int) for i := 0; i m[words[i+1][j]] { return false } if j == length-1 { if len(words[i]) > len(words[i+1]) { return false } } } } return true } 961.重复 N 次的元素(5) 题目 在大小为 2N 的数组 A 中有 N+1 个不同的元素，其中有一个元素重复了 N 次。 返回重复了 N 次的那个元素。 示例 1：输入：[1,2,3,3] 输出：3 示例 2：输入：[2,1,2,5,3,2] 输出：2 示例 3：输入：[5,1,5,2,5,3,5,4] 输出：5 提示： 4 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(n) 02 排序 O(nlog(n)) O(1) 03 哈希统计 O(n) O(n) 04 遍历 O(n) O(1) 05 暴力法 O(n^2) O(1) func repeatedNTimes(A []int) int { m := make(map[int]int) for i := 0; i 965.单值二叉树(4) 题目 如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。 只有给定的树是单值二叉树时，才返回 true；否则返回 false。 示例 1：输入：[1,1,1,1,1,null,1] 输出：true 示例 2：输入：[2,2,2,5,2] 输出：false 提示： 给定树的节点数范围是 [1, 100]。 每个节点的值都是整数，范围为 [0, 99] 。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归-数组辅助 O(n) O(n) 02 递归 O(n) O(log(n)) 03 递归 O(n) O(log(n)) 04 迭代 O(n) O(n) var arr []int func isUnivalTree(root *TreeNode) bool { if root == nil { return true } arr = make([]int, 0) dfs(root) for i := 1; i 0 { node := queue[len(queue)-1] queue = queue[:len(queue)-1] if node.Val != value { return false } if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } return true } 970.强整数(2) 题目 给定两个正整数 x 和 y，如果某一整数等于 x^i + y^j，其中整数 i >= 0 且 j >= 0， 那么我们认为该整数是一个强整数。 返回值小于或等于 bound 的所有强整数组成的列表。 你可以按任何顺序返回答案。在你的回答中，每个值最多出现一次。 示例 1：输入：x = 2, y = 3, bound = 10 输出：[2,3,4,5,7,9,10] 解释： 2 = 2^0 + 3^0 3 = 2^1 + 3^0 4 = 2^0 + 3^1 5 = 2^1 + 3^1 7 = 2^2 + 3^1 9 = 2^3 + 3^0 10 = 2^0 + 3^2 示例 2：输入：x = 3, y = 5, bound = 15 输出：[2,4,6,8,10,14] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(log(n)) O(log(n)^2) 02 遍历 O(log(n)) O(log(n)^2) func powerfulIntegers(x int, y int, bound int) []int { res := make([]int, 0) m := make(map[int]int) if bound 976.三角形的最大周长(2) 题目 给定由一些正数（代表长度）组成的数组 A，返回由其中三个长度组成的、面积不为零的三角形的最大周长。 如果不能形成任何面积不为零的三角形，返回 0。 示例 1：输入：[2,1,2] 输出：5 示例 2：输入：[1,2,1] 输出：0 示例 3：输入：[3,2,3,4] 输出：10 示例 4：输入：[3,6,2,3] 输出：8 提示： 3 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序 O(nlog(n)) O(1) 02 冒泡排序 O(n^2) O(1) func largestPerimeter(A []int) int { sort.Ints(A) for i := len(A) - 3; i >= 0; i-- { if A[i]+A[i+1] > A[i+2] { return A[i] + A[i+1] + A[i+2] } } return 0 } # func largestPerimeter(A []int) int { if len(A) A[j+1] { A[j], A[j+1] = A[j+1], A[j] } } if i >= 2 { index := len(A) - 1 - i if A[index]+A[index+1] > A[index+2] { return A[index] + A[index+1] + A[index+2] } } } if A[0]+A[1] > A[2] { return A[0] + A[1] + A[2] } return 0 } 977.有序数组的平方(3) 题目 给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。 示例 1：输入：[-4,-1,0,3,10] 输出：[0,1,9,16,100] 示例 2：输入：[-7,-3,2,3,11] 输出：[4,9,9,49,121] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n) O(n) 02 排序 O(nlog(n)) O(n) 03 直接插入排序 O(n^2) O(n) func sortedSquares(A []int) []int { res := make([]int, len(A)) i := 0 j := len(A) - 1 index := len(A) - 1 for i = 0; j-- { if value 985.查询后的偶数和(1) 题目 给出一个整数数组 A 和一个查询数组 queries。 对于第 i 次查询，有 val = queries[i][0], index = queries[i][1]， 我们会把 val 加到 A[index] 上。然后，第 i 次查询的答案是 A 中偶数值的和。 （此处给定的 index = queries[i][1] 是从 0 开始的索引，每次查询都会永久修改数组 A。） 返回所有查询的答案。你的答案应当以数组 answer 给出，answer[i] 为第 i 次查询的答案。 示例：输入：A = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]] 输出：[8,6,2,4] 解释：开始时，数组为 [1,2,3,4]。 将 1 加到 A[0] 上之后，数组为 [2,2,3,4]，偶数值之和为 2 + 2 + 4 = 8。 将 -3 加到 A[1] 上之后，数组为 [2,-1,3,4]，偶数值之和为 2 + 4 = 6。 将 -4 加到 A[0] 上之后，数组为 [-2,-1,3,4]，偶数值之和为 -2 + 4 = 2。 将 2 加到 A[3] 上之后，数组为 [-2,-1,3,6]，偶数值之和为 -2 + 6 = 4。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历模拟 O(n) O(n) func sumEvenAfterQueries(A []int, queries [][]int) []int { res := make([]int, 0) sum := 0 for _, value := range A { if value%2 == 0 { sum = sum + value } } for i := 0; i 989.数组形式的整数加法(4) 题目 对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。 例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。 给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。 示例 1：输入：A = [1,2,0,0], K = 34 输出：[1,2,3,4] 解释：1200 + 34 = 1234 示例 2： 输入：A = [2,7,4], K = 181 输出：[4,5,5] 解释：274 + 181 = 455 示例 3： 输入：A = [2,1,5], K = 806 输出：[1,0,2,1] 解释：215 + 806 = 1021 示例 4： 输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1 输出：[1,0,0,0,0,0,0,0,0,0,0] 解释：9999999999 + 1 = 10000000000 提示： 1 1，那么 A[0] != 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组辅助 O(n) O(n) 02 遍历 O(n) O(1) 03 遍历 O(n) O(n) 04 遍历 O(n) O(n) func addToArrayForm(A []int, K int) []int { B := make([]int, 0) for K > 0 { B = append([]int{K % 10}, B...) K = K / 10 } length := len(A) if len(B) > len(A) { length = len(B) } res := make([]int, length) flag := 0 i := len(A) - 1 j := len(B) - 1 count := 0 for i >= 0 && j >= 0 { sum := A[i] + B[j] + flag if sum >= 10 { sum = sum - 10 flag = 1 } else { flag = 0 } res[length-1-count] = sum i-- j-- count++ } for i >= 0 { sum := A[i] + flag if sum >= 10 { sum = sum - 10 flag = 1 } else { flag = 0 } res[length-1-count] = sum i-- count++ } for j >= 0 { sum := B[j] + flag if sum >= 10 { sum = sum - 10 flag = 1 } else { flag = 0 } res[length-1-count] = sum j-- count++ } if flag == 1 { return append([]int{1}, res...) } return res } # func addToArrayForm(A []int, K int) []int { A[len(A)-1] = A[len(A)-1] + K carry := 0 for i := len(A) - 1; i >= 0; i-- { carry = A[i] / 10 A[i] = A[i] % 10 if i > 0 { A[i-1] = A[i-1] + carry } } for carry > 0 { A = append([]int{carry % 10}, A...) carry = carry / 10 } return A } # func addToArrayForm(A []int, K int) []int { i := len(A) - 1 res := make([]int, 0) for i >= 0 || K > 0 { if i >= 0 { K = K + A[i] } res = append(res, K%10) K = K / 10 i-- } for i := 0; i = 0 || K > 0 { if i >= 0 { K = K + A[i] } res = append([]int{K % 10}, res...) K = K / 10 i-- } return res } 993.二叉树的堂兄弟节点(2) 题目 在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。 如果二叉树的两个节点深度相同，但父节点不同，则它们是一对堂兄弟节点。 我们给出了具有唯一值的二叉树的根节点 root，以及树中两个不同节点的值 x 和 y。 只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true。否则，返回 false。 示例 1：输入：root = [1,2,3,4], x = 4, y = 3 输出：false 示例 2：输入：root = [1,2,3,null,4,null,5], x = 5, y = 4 输出：true 示例 3：输入：root = [1,2,3,null,4], x = 2, y = 3 输出：false 提示： 二叉树的节点数介于 2 到 100 之间。 每个节点的值都是唯一的、范围为 1 到 100 的整数。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 迭代 O(n) O(n) 03 递归 O(n) O(n) func isCousins(root *TreeNode, x int, y int) bool { xNode, xDepth := dfs(root, x, 0) yNode, yDepth := dfs(root, y, 0) return xDepth == yDepth && xNode != yNode } func dfs(root *TreeNode, value int, level int) (*TreeNode, int) { if root == nil { return nil, -1 } if root.Val == value { return nil, 0 } if (root.Left != nil && root.Left.Val == value) || (root.Right != nil && root.Right.Val == value) { return root, level + 1 } leftNode, leftLevel := dfs(root.Left, value, level+1) if leftNode != nil { return leftNode, leftLevel } return dfs(root.Right, value, level+1) } # func isCousins(root *TreeNode, x int, y int) bool { if root == nil { return true } fatherM := make(map[int]int) levelM := make(map[int]int) queue := make([]*TreeNode, 0) queue = append(queue, root) level := 0 for len(queue) > 0 { length := len(queue) for i := 0; i 997.找到小镇的法官(2) 题目 在一个小镇里，按从 1 到 N 标记了 N 个人。传言称，这些人中有一个是小镇上的秘密法官。 如果小镇的法官真的存在，那么： 小镇的法官不相信任何人。 每个人（除了小镇法官外）都信任小镇的法官。 只有一个人同时满足属性 1 和属性 2 。 给定数组 trust，该数组由信任对 trust[i] = [a, b] 组成，表示标记为 a 的人信任标记为 b 的人。 如果小镇存在秘密法官并且可以确定他的身份，请返回该法官的标记。否则，返回 -1。 示例 1：输入：N = 2, trust = [[1,2]] 输出：2 示例 2：输入：N = 3, trust = [[1,3],[2,3]] 输出：3 示例 3：输入：N = 3, trust = [[1,3],[2,3],[3,1]] 输出：-1 示例 4：输入：N = 3, trust = [[1,2],[2,3]] 输出：-1 示例 5：输入：N = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]] 输出：3 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历-数组辅助 O(n) O(n) 02 遍历-双数组辅助 O(n) O(n) func findJudge(N int, trust [][]int) int { arr := make([]int, N+1) for i := range trust { arr[trust[i][0]] = -1 if arr[trust[i][1]] == -1 { continue } arr[trust[i][1]]++ } for i := 1; i 999.可以被一步捕获的棋子数(2) 题目 在一个 8 x 8 的棋盘上，有一个白色的车（Rook），用字符 'R' 表示。棋盘上还可能存在空方块， 白色的象（Bishop）以及黑色的卒（pawn），分别用字符 '.'，'B' 和 'p' 表示。 不难看出，大写字符表示的是白棋，小写字符表示的是黑棋。 车按国际象棋中的规则移动。东，西，南，北四个基本方向任选其一，然后一直向选定的方向移动， 直到满足下列四个条件之一： 棋手选择主动停下来。 棋子因到达棋盘的边缘而停下。 棋子移动到某一方格来捕获位于该方格上敌方（黑色）的卒，停在该方格内。 车不能进入/越过已经放有其他友方棋子（白色的象）的方格，停在友方棋子前。 你现在可以控制车移动一次，请你统计有多少敌方的卒处于你的捕获范围内（即，可以被一步捕获的棋子数）。 示例 1：输入： [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"], [\".\",\".\",\".\",\"R\",\".\",\".\",\".\",\"p\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"], [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"], [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]] 输出：3 解释：在本例中，车能够捕获所有的卒。 示例 2：输入： [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"p\",\"p\",\"p\",\"p\",\"p\",\".\",\".\"], [\".\",\"p\",\"p\",\"B\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"B\",\"R\",\"B\",\"p\",\".\",\".\"], [\".\",\"p\",\"p\",\"B\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"p\",\"p\",\"p\",\".\",\".\"], [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]] 输出：0 解释：象阻止了车捕获任何卒。 示例 3：输入： [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"], [\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\"p\",\"p\",\".\",\"R\",\".\",\"p\",\"B\",\".\"], [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"], [\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]] 输出：3 解释： 车可以捕获位置 b5，d6 和 f5 的卒。 提示： board.length == board[i].length == 8 board[i][j] 可以是 'R'，'.'，'B' 或 'p' 只有一个格子上存在 board[i][j] == 'R' 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(1) O(1) 02 遍历 O(1) O(1) func numRookCaptures(board [][]byte) int { res := 0 var x, y int for i := 0; i = 0 && board[x][i] != 'B'; i-- { if board[x][i] == 'p' { res++ break } } // 向下 for i := x; i = 0 && board[i][y] != 'B'; i-- { if board[i][y] == 'p' { res++ break } } return res } # func numRookCaptures(board [][]byte) int { res := 0 var x, y int var dx = []int{-1, 1, 0, 0} var dy = []int{0, 0, -1, 1} for i := 0; i = 0 && newX = 0 && newY Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-06-28 01:11:13 "},"docs/source/question/1001-1100.html":{"url":"docs/source/question/1001-1100.html","title":"1001-1100","keywords":"","body":"1001-1100-Easy 1001-1100-Easy 1002.查找常用字符(2) 1005.K次取反后最大化的数组和(4) 1009.十进制整数的反码(3) 1010.总持续时间可被60整除的歌曲(2) 1013.将数组分成和相等的三个部分(2) 1018.可被5整除的二进制前缀(1) 1021.删除最外层的括号(3) 1022.从根到叶的二进制数之和(2) 1025.除数博弈(2) 1029.两地调度(2) 1030.距离顺序排列矩阵单元格(3) 1033.移动石子直到连续(2) 1037.有效的回旋镖(3) 1042.不邻接植花(1) 1046.最后一块石头的重量(2) 1047.删除字符串中的所有相邻重复项(2) 1051.高度检查器(2) 1071.字符串的最大公因子(2) 1078.Bigram 分词(1) 1089.复写零(3) 1002.查找常用字符(2) 题目 给定仅有小写字母组成的字符串数组 A，返回列表中的每个字符串中都显示的全部字符（包括重复字符）组成的列表。 例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。 你可以按任意顺序返回答案。 示例 1：输入：[\"bella\",\"label\",\"roller\"] 输出：[\"e\",\"l\",\"l\"] 示例 2：输入：[\"cool\",\"lock\",\"cook\"] 输出：[\"c\",\"o\"] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历-数组辅助 O(n) O(n) 02 遍历-数组辅助 O(n) O(n) func commonChars(A []string) []string { arr := [26]int{} for _, v := range A[0] { arr[v-'a']++ } for i := 1; i 0 { for j := 0; j b { return b } return a } # func commonChars(A []string) []string { arr := make([][26]int, len(A)) for i := 0; i 0 { res = append(res, string(j+'a')) minValue-- } } return res } func min(a, b int) int { if a > b { return b } return a } 1005.K次取反后最大化的数组和(4) 题目 给定一个整数数组 A，我们只能用以下方法修改该数组： 我们选择某个个索引 i 并将 A[i] 替换为 -A[i]，然后总共重复这个过程 K 次。 （我们可以多次选择同一个索引 i。） 以这种方式修改数组后，返回数组可能的最大和。 示例 1：输入：A = [4,2,3], K = 1 输出：5 解释：选择索引 (1,) ，然后 A 变为 [4,-2,3]。 示例 2：输入：A = [3,-1,0,2], K = 3 输出：6 解释：选择索引 (1, 2, 2) ，然后 A 变为 [3,1,0,2]。 示例 3：输入：A = [2,-3,-1,5,-4], K = 2 输出：13 解释：选择索引 (1, 4) ，然后 A 变为 [2,3,-1,5,4]。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序+贪心 O(nlog(n)) O(1) 02 排序+贪心 O(nlog(n)) O(1) 03 数组辅助 O(n) O(1) 04 遍历-找最小 O(n^2) O(1) func largestSumAfterKNegations(A []int, K int) int { sort.Ints(A) i := 0 for i 0 { if A[i] 0 { A[i] = -A[i] if A[i] > 0 && A[i] > A[i+1] { i++ } K-- } return sum(A) } func sum(A []int) int { res := 0 for i := 0; i 0 { for arr[i] == 0 { i++ } if i > 100 { break } arr[i]-- arr[200-i]++ K-- } if K%2 == 1 && i != 100 { for j := i; j 0 { arr[j]-- arr[200-j]++ break } } } res := 0 for i := 0; i 0 { minIndex, minValue := findMin(A) if minValue > 0 { break } A[minIndex] = -A[minIndex] K-- } if K%2 == 1 { minIndex, _ := findMin(A) A[minIndex] = -A[minIndex] } res := 0 for i := 0; i A[i] { res = A[i] index = i } } return index, res } 1009.十进制整数的反码(3) 题目 每个非负整数 N 都有其二进制表示。例如， 5 可以被表示为二进制 \"101\"，11 可以用二进制 \"1011\" 表示， 依此类推。注意，除 N = 0 外，任何二进制表示中都不含前导零。 二进制的反码表示是将每个 1 改为 0 且每个 0 变为 1。例如，二进制数 \"101\" 的二进制反码为 \"010\"。 给你一个十进制数 N，请你返回其二进制表示的反码所对应的十进制整数。 示例 1：输入：5 输出：2 解释：5 的二进制表示为 \"101\"，其二进制反码为 \"010\"，也就是十进制中的 2 。 示例 2：输入：7 输出：0 解释：7 的二进制表示为 \"111\"，其二进制反码为 \"000\"，也就是十进制中的 0 。 示例 3：输入：10 输出：5 解释：10 的二进制表示为 \"1010\"，其二进制反码为 \"0101\"，也就是十进制中的 5 。 提示： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 位运算 O(log(n)) O(1) 02 位运算 O(log(n)) O(1) 03 遍历 O(log(n)) O(1) /* 101+010=1000=111+1 */ func bitwiseComplement(N int) int { temp := 2 for N >= temp { temp = temp 1 { temp = temp >> 1 res = res 0 { if N%2 == 0 { res = res + exp } exp = exp * 2 N = N / 2 } return res } 1010.总持续时间可被60整除的歌曲(2) 题目 在歌曲列表中，第 i 首歌曲的持续时间为 time[i] 秒。 返回其总持续时间（以秒为单位）可被 60 整除的歌曲对的数量。 形式上，我们希望索引的数字 i 和 j 满足 i 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(1) 02 数组辅助 O(n) O(1) func numPairsDivisibleBy60(time []int) int { m := make(map[int]int) for i := 0; i 0 { res = res + v*value m[key] = 0 m[60-key] = 0 } } } return res } # func numPairsDivisibleBy60(time []int) int { res := 0 arr := make([]int,60) for i := range time{ if time[i] % 60 == 0{ res = res + arr[0] }else { res = res + arr[60-time[i]%60] } arr[time[i]%60]++ } return res } 1013.将数组分成和相等的三个部分(2) 题目 给你一个整数数组 A，只有可以将其划分为三个和相等的非空部分时才返回 true，否则返回 false。 形式上，如果可以找出索引 i+1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 双指针 O(n) O(1) func canThreePartsEqualSum(A []int) bool { length := len(A) if length = 3 { return true } return false } # func canThreePartsEqualSum(A []int) bool { length := len(A) if length 1018.可被5整除的二进制前缀(1) 题目 给定由若干 0 和 1 组成的数组 A。我们定义 N_i： 从 A[0] 到 A[i] 的第 i 个子数组被解释为一个二进制数（从最高有效位到最低有效位）。 返回布尔值列表 answer，只有当 N_i 可以被 5 整除时，答案 answer[i] 为 true，否则为 false。 示例 1：输入：[0,1,1] 输出：[true,false,false] 解释： 输入数字为 0, 01, 011；也就是十进制中的 0, 1, 3 。只有第一个数可以被 5 整除，因此 answer[0] 为真。 示例 2：输入：[1,1,1] 输出：[false,false,false] 示例 3：输入：[0,1,1,1,1,1] 输出：[true,false,false,false,true,false] 示例 4：输入：[1,1,1,0,1] 输出：[false,false,false,false,false] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历-求余 O(n) O(n) func prefixesDivBy5(A []int) []bool { res := make([]bool, len(A)) temp := 0 for i := 0; i 1021.删除最外层的括号(3) 题目 有效括号字符串为空 (\"\")、\"(\" + A + \")\" 或 A + B，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。 例如，\"\"，\"()\"，\"(())()\" 和 \"(()(()))\" 都是有效的括号字符串。 如果有效字符串 S 非空，且不存在将其拆分为 S = A+B 的方法，我们称其为原语（primitive）， 其中 A 和 B 都是非空有效括号字符串。 给出一个非空有效字符串 S，考虑将其进行原语化分解， 使得：S = P_1 + P_2 + ... + P_k，其中 P_i 是有效括号字符串原语。 对 S 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 S 。 示例 1：输入：\"(()())(())\" 输出：\"()()()\" 解释： 输入字符串为 \"(()())(())\"，原语化分解得到 \"(()())\" + \"(())\"， 删除每个部分中的最外层括号后得到 \"()()\" + \"()\" = \"()()()\"。 示例 2：输入：\"(()())(())(()(()))\" 输出：\"()()()()(())\" 解释： 输入字符串为 \"(()())(())(()(()))\"，原语化分解得到 \"(()())\" + \"(())\" + \"(()(()))\"， 删除每个部分中的最外层括号后得到 \"()()\" + \"()\" + \"()(())\" = \"()()()()(())\"。 示例 3：输入：\"()()\" 输出：\"\" 解释： 输入字符串为 \"()()\"，原语化分解得到 \"()\" + \"()\"， 删除每个部分中的最外层括号后得到 \"\" + \"\" = \"\"。 提示： S.length 解题思路 No. 思路 时间复杂度 空间复杂度 01 栈 O(n) O(n) 02 遍历 O(n) O(1) 03 栈 O(n) O(n) func removeOuterParentheses(S string) string { if len(S) == 0 { return \"\" } res := \"\" stack := make([]byte, 0) stack = append(stack, S[0]) last := 0 for i := 1; i 0 && S[i] == ')' && stack[len(stack)-1] == '(' { stack = stack[:len(stack)-1] if len(stack) == 0 { res = res + S[last+1:i] last = i + 1 } } else { stack = append(stack, S[i]) } } return res } # func removeOuterParentheses(S string) string { res := \"\" count := 0 last := 0 for i := 0; i 0 { res = res + string(S[i]) } if S[i] == '(' { stack = append(stack, S[i]) } } return res } 1022.从根到叶的二进制数之和(2) 题目 给出一棵二叉树，其上每个结点的值都是 0 或 1 。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。 例如，如果路径为 0 -> 1 -> 1 -> 0 -> 1，那么它表示二进制数 01101，也就是 13 。 对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。 以 10^9 + 7 为模，返回这些数字之和。 示例：输入：[1,0,1,0,1,0,1] 输出：22 解释：(100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22 提示： 树中的结点数介于 1 和 1000 之间。 node.val 为 0 或 1 。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 迭代 O(n) O(n) var res int func sumRootToLeaf(root *TreeNode) int { res = 0 dfs(root, 0) return res } func dfs(root *TreeNode, sum int) { if root == nil { return } sum = sum*2 + root.Val if root.Left == nil && root.Right == nil { res = (res + sum) % 1000000007 } dfs(root.Left, sum) dfs(root.Right, sum) } # type Node struct { node *TreeNode sum int } func sumRootToLeaf(root *TreeNode) int { res := 0 stack := make([]Node, 0) stack = append(stack, Node{ node: root, sum: 0, }) for len(stack) > 0 { node, sum := stack[len(stack)-1].node, stack[len(stack)-1].sum stack = stack[:len(stack)-1] sum = sum*2 + node.Val if node.Left == nil && node.Right == nil { res = (res + sum) % 1000000007 } if node.Left != nil { stack = append(stack, Node{ node: node.Left, sum: sum, }) } if node.Right != nil { stack = append(stack, Node{ node: node.Right, sum: sum, }) } } return res } 1025.除数博弈(2) 题目 爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。 最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作： 选出任一 x，满足 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 找规律 O(1) O(1) 02 动态规划 O(n^2) O(n) func divisorGame(N int) bool { return N % 2 == 0 } # func divisorGame(N int) bool { dp := make([]bool, N+1) dp[1] = false // 1的时候爱丽丝没有选择，失败 for i := 2; i 1029.两地调度(2) 题目 公司计划面试 2N 人。第 i 人飞往 A 市的费用为 costs[i][0]，飞往 B 市的费用为 costs[i][1]。 返回将每个人都飞到某座城市的最低费用，要求每个城市都有 N 人抵达。 示例：输入：[[10,20],[30,200],[400,50],[30,20]] 输出：110 解释： 第一个人去 A 市，费用为 10。 第二个人去 A 市，费用为 30。 第三个人去 B 市，费用为 50。 第四个人去 B 市，费用为 20。 最低总费用为 10 + 30 + 50 + 20 = 110，每个城市都有一半的人在面试。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序 O(nlog(n)) O(1) 02 动态规划 O(n^2) O(n^2) func twoCitySchedCost(costs [][]int) int { sort.Slice(costs, func(i, j int) bool { return costs[i][0]-costs[i][1] i的情况，比如i=3, j=4 // 因为不存在3个人飞往A市次数为4次的情况 dp[i][j] = 100000000 } } for i := 1; i b { return b } return a } 1030.距离顺序排列矩阵单元格(3) 题目 给出 R 行 C 列的矩阵，其中的单元格的整数坐标为 (r, c)，满足 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 广度优先搜索 O(n^2) O(n^2) 02 排序 O(nlog(n)) O(n^2) 03 哈希辅助 O(n^2) I var dx = []int{-1, 1, 0, 0} var dy = []int{0, 0, -1, 1} func allCellsDistOrder(R int, C int, r0 int, c0 int) [][]int { res := make([][]int, 0) visited := make([][]bool, R) for i := 0; i 0 { x1, y1 := list[0][0], list[0][1] res = append(res, []int{x1, y1}) list = list[1:] for i := 0; i b { return a - b } return b - a } # func allCellsDistOrder(R int, C int, r0 int, c0 int) [][]int { res := make([][]int, 0) m := make(map[int][][]int) max := 0 for i := 0; i max { max = length } } } for i := 0; i b { return a - b } return b - a } 1033.移动石子直到连续(2) 题目 三枚石子放置在数轴上，位置分别为 a，b，c。 每一回合，我们假设这三枚石子当前分别位于位置 x, y, z 且 x 解题思路 No. 思路 时间复杂度 空间复杂度 01 找规律 O(1) O(1) 02 找规律 O(1) O(1) func numMovesStones(a int, b int, c int) []int { arr := []int{a, b, c} sort.Ints(arr) a, b, c = arr[0], arr[1], arr[2] if a 2 && c-b > 2 { return []int{2, c - a - 2} } else { return []int{1, c - a - 2} } } return []int{0, 0} } # func numMovesStones(a int, b int, c int) []int { if a > b { a, b = b, a } if b > c { b, c = c, b } if a > b { a, b = b, a } if a 2 && c-b > 2 { return []int{2, c - a - 2} } else { return []int{1, c - a - 2} } } return []int{0, 0} } 1037.有效的回旋镖(3) 题目 回旋镖定义为一组三个点，这些点各不相同且不在一条直线上。 给出平面上三个点组成的列表，判断这些点是否可以构成回旋镖。 示例 1：输入：[[1,1],[2,3],[3,2]] 输出：true 示例 2：输入：[[1,1],[2,2],[3,3]] 输出：false 提示： points.length == 3 points[i].length == 2 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 斜率公式 O(1) O(1) 02 鞋带公式 O(1) O(1) 03 判断是否组成三角形 O(1) O(1) // k1=(y1-y0)/(x1-x0) = k2 = (y2-y1)/(x2-x1) // (x1-x0)*(y2-y1) = (x2-x1)*(y1-y0) func isBoomerang(points [][]int) bool { return (points[1][0]-points[0][0])*(points[2][1]-points[1][1]) != (points[2][0]-points[1][0])*(points[1][1]-points[0][1]) } # // 鞋带公式 // S=|(x1 * y2 + x2 * y3 + x3 * y1 - y1 * x2 - y2 * x3 - y3 * x1)|/2 // S!=0组成三角形 func isBoomerang(points [][]int) bool { return points[0][0]*points[1][1]+points[1][0]*points[2][1]+points[2][0]*points[0][1] != points[0][1]*points[1][0]+points[1][1]*points[2][0]+points[2][1]*points[0][0] } # func isBoomerang(points [][]int) bool { side1 := side(points[0], points[1]) side2 := side(points[1], points[2]) side3 := side(points[0], points[2]) return side1+side2 > side3 && side2+side3 > side1 && side1+side3 > side2 } func side(arr1, arr2 []int) float64 { res := (arr1[0]-arr2[0])*(arr1[0]-arr2[0]) + (arr1[1]-arr2[1])*(arr1[1]-arr2[1]) return math.Sqrt(float64(res)) } 1042.不邻接植花(1) 题目 有 N 个花园，按从 1 到 N 标记。在每个花园中，你打算种下四种花之一。 paths[i] = [x, y] 描述了花园 x 到花园 y 的双向路径。 另外，没有花园有 3 条以上的路径可以进入或者离开。 你需要为每个花园选择一种花，使得通过路径相连的任何两个花园中的花的种类互不相同。 以数组形式返回选择的方案作为答案 answer，其中 answer[i] 为在第 (i+1) 个花园中种植的花的种类。 花的种类用 1, 2, 3, 4 表示。保证存在答案。 示例 1：输入：N = 3, paths = [[1,2],[2,3],[3,1]] 输出：[1,2,3] 示例 2：输入：N = 4, paths = [[1,2],[3,4]] 输出：[1,2,1,2] 示例 3：输入：N = 4, paths = [[1,2],[2,3],[3,4],[4,1],[1,3],[2,4]] 输出：[1,2,3,4] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 邻接表 O(n^2) O(n) func gardenNoAdj(N int, paths [][]int) []int { res := make([]int, N+1) arr := make([][]int, N+1) for i := 0; i 0 { delete(m, res[arr[i][j]]) } } for k := range m { res[i] = k break } } return res[1:] } 1046.最后一块石头的重量(2) 题目 有一堆石头，每块石头的重量都是正整数。 每一回合，从中选出两块 最重的 石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x 解题思路 No. 思路 时间复杂度 空间复杂度 01 内置堆 O(nlog(n)) O(n) 02 排序 O(n^2*log(n)) O(1) type IntHeap []int func (h IntHeap) Len() int { return len(h) } // 小根堆 func (h IntHeap) Less(i, j int) bool { return h[i] > h[j] } func (h IntHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] } func (h *IntHeap) Push(x interface{}) { *h = append(*h, x.(int)) } func (h *IntHeap) Pop() interface{} { value := (*h)[len(*h)-1] *h = (*h)[:len(*h)-1] return value } func lastStoneWeight(stones []int) int { intHeap := make(IntHeap, 0) heap.Init(&intHeap) for i := 0; i 1 { a := heap.Pop(&intHeap).(int) b := heap.Pop(&intHeap).(int) if a > b { heap.Push(&intHeap, a-b) } } if intHeap.Len() > 0 { res := heap.Pop(&intHeap).(int) return res } return 0 } # func lastStoneWeight(stones []int) int { length := len(stones) if length == 1 { return stones[0] } sort.Ints(stones) for stones[length-2] != 0 { stones[length-1] = stones[length-1] - stones[length-2] stones[length-2] = 0 sort.Ints(stones) } return stones[length-1] } 1047.删除字符串中的所有相邻重复项(2) 题目 给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。 在 S 上反复执行重复项删除操作，直到无法继续删除。 在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。 示例：输入：\"abbaca\" 输出：\"ca\" 解释：例如，在 \"abbaca\" 中，我们可以删除 \"bb\" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。 之后我们得到字符串 \"aaca\"，其中又只有 \"aa\" 可以执行重复项删除操作，所以最后的字符串为 \"ca\"。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 栈 O(n) O(n) 02 遍历 O(n) O(n) func removeDuplicates(S string) string { stack := make([]int32, 0) for _, v := range S { stack = append(stack, v) for len(stack) > 1 && stack[len(stack)-1] == stack[len(stack)-2] { stack = stack[:len(stack)-2] } } return string(stack) } # func removeDuplicates(S string) string { arr := []byte(S) for { flag := false for i := 0; i 1051.高度检查器(2) 题目 学校在拍年度纪念照时，一般要求学生按照 非递减 的高度顺序排列。 请你返回能让所有学生以 非递减 高度排列的最小必要移动人数。 注意，当一组学生被选中时，他们之间可以以任何可能的方式重新排序，而未被选中的学生应该保持不动。 示例：输入：heights = [1,1,4,2,1,3] 输出：3 解释：当前数组：[1,1,4,2,1,3] 目标数组：[1,1,1,2,3,4] 在下标 2 处（从 0 开始计数）出现 4 vs 1 ，所以我们必须移动这名学生。 在下标 4 处（从 0 开始计数）出现 1 vs 3 ，所以我们必须移动这名学生。 在下标 5 处（从 0 开始计数）出现 3 vs 4 ，所以我们必须移动这名学生。 示例 2：输入：heights = [5,1,2,3,4] 输出：5 示例 3：输入：heights = [1,2,3,4,5] 输出：0 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序 O(nlog(n)) O(n) 02 数组辅助 O(n) O(1) func heightChecker(heights []int) int { temp := make([]int, len(heights)) copy(temp, heights) sort.Ints(temp) res := 0 for i := 0; i 0 { if heights[j] != i { res++ } arr[i]-- j++ } } return res } 1071.字符串的最大公因子(2) 题目 对于字符串 S 和 T，只有在 S = T + ... + T（T 与自身连接 1 次或多次）时，我们才认定 “T 能除尽 S”。 返回最长字符串 X，要求满足 X 能除尽 str1 且 X 能除尽 str2。 示例 1：输入：str1 = \"ABCABC\", str2 = \"ABC\" 输出：\"ABC\" 示例 2：输入：str1 = \"ABABAB\", str2 = \"ABAB\" 输出：\"AB\" 示例 3：输入：str1 = \"LEET\", str2 = \"CODE\" 输出：\"\" 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 辗转相除法 O(n) O(n) 02 遍历 O(n^2) O(n) func gcdOfStrings(str1 string, str2 string) string { if str1+str2 != str2+str1 { return \"\" } if str1 > str2 { str1, str2 = str2, str1 } return str1[:gcd(len(str2), len(str1))] } func gcd(a, b int) int { if b == 0 { return a } return gcd(b, a%b) } # func gcdOfStrings(str1 string, str2 string) string { min := len(str1) if min > len(str2) { min = len(str2) } for i := len(str2); i >= 1; i-- { if len(str1)%i == 0 && len(str2)%i == 0 && str1[:i] == str2[:i] { a := strings.Repeat(str1[:i], len(str1)/i) b := strings.Repeat(str2[:i], len(str2)/i) if a == str1 && b == str2 { return str1[:i] } } } return \"\" } 1078.Bigram 分词(1) 题目 给出第一个词 first 和第二个词 second， 考虑在某些文本 text 中可能以 \"first second third\" 形式出现的情况， 其中 second 紧随 first 出现，third 紧随 second 出现。 对于每种这样的情况，将第三个词 \"third\" 添加到答案中，并返回答案。 示例 1： 输入：text = \"alice is a good girl she is a good student\", first = \"a\", second = \"good\" 输出：[\"girl\",\"student\"] 示例 2： 输入：text = \"we will we will rock you\", first = \"we\", second = \"will\" 输出：[\"we\",\"rock\"] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(n) func findOcurrences(text string, first string, second string) []string { arr := strings.Fields(text) res := make([]string, 0) for i := 0; i 1089.复写零(3) 题目 给你一个长度固定的整数数组 arr，请你将该数组中出现的每个零都复写一遍，并将其余的元素向右平移。 注意：请不要在超过该数组长度的位置写入元素。 要求：请对输入的数组 就地 进行上述修改，不要从函数返回任何东西。 示例 1：输入：[1,0,2,3,0,4,5,0] 输出：null 解释：调用函数后，输入的数组将被修改为：[1,0,0,2,3,0,0,4] 示例 2：输入：[1,2,3] 输出：null 解释：调用函数后，输入的数组将被修改为：[1,2,3] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 遍历后移 O(n^2) O(1) 03 数组辅助 O(n) O(n) func duplicateZeros(arr []int) { count := 0 for i := 0; i = 0; i-- { if arr[i] == 0 { count-- if i+count i; j-- { arr[j] = arr[j-1] } i++ } } } # func duplicateZeros(arr []int) { newArr := make([]int, 0) for i := 0; i Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-06-28 01:11:13 "},"docs/source/question/1101-1200.html":{"url":"docs/source/question/1101-1200.html","title":"1101-1200","keywords":"","body":"1101-1200-Easy 1101-1200-Easy 1103.分糖果 II(3) 1108.IP地址无效化(2) 1122.数组的相对排序(3) 1128.等价多米诺骨牌对的数量(2) 1137.第N个泰波那契数(3) 1154.一年中的第几天(2) 1160.拼写单词(3) 1170.比较字符串最小字母出现频次(2) 1175.质数排列(1) 1184.公交站间的距离(2) 1185.一周中的第几天(3) 1189.“气球”的最大数量(3) 1200.最小绝对差(2) 1103.分糖果 II(3) 题目 排排坐，分糖果。 我们买了一些糖果 candies，打算把它们分给排好队的 n = num_people 个小朋友。 给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 n 颗糖果。 然后，我们再回到队伍的起点，给第一个小朋友 n + 1 颗糖果，第二个小朋友 n + 2 颗， 依此类推，直到给最后一个小朋友 2 * n 颗糖果。 重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。 注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。 返回一个长度为 num_people、元素之和为 candies 的数组， 以表示糖果的最终分发情况（即 ans[i] 表示第 i 个小朋友分到的糖果数）。 示例 1：输入：candies = 7, num_people = 4 输出：[1,2,3,1] 解释： 第一次，ans[0] += 1，数组变为 [1,0,0,0]。 第二次，ans[1] += 2，数组变为 [1,2,0,0]。 第三次，ans[2] += 3，数组变为 [1,2,3,0]。 第四次，ans[3] += 1（因为此时只剩下 1 颗糖果），最终数组变为 [1,2,3,1]。 示例 2：输入：candies = 10, num_people = 3 输出：[5,2,3] 解释： 第一次，ans[0] += 1，数组变为 [1,0,0]。 第二次，ans[1] += 2，数组变为 [1,2,0]。 第三次，ans[2] += 3，数组变为 [1,2,3]。 第四次，ans[0] += 4，最终数组变为 [5,2,3]。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法 O(n^(1/2)) O(n) 02 暴力法 O(n^(1/2)) O(n) 03 等差数列求和公式 O(n^(1/2)) O(n) func distributeCandies(candies int, num_people int) []int { res := make([]int, num_people) i := 0 count := 0 for candies > 0 { count++ if candies >= count { res[i%num_people] += count } else { res[i%num_people] += candies } i++ candies = candies - count } return res } # func distributeCandies(candies int, num_people int) []int { res := make([]int, num_people) count := 1 for candies > 0 { for i := 0; i = count { res[i] = res[i] + count candies = candies - count } else { res[i] = res[i] + candies candies = 0 } count++ } } return res } # func distributeCandies(candies int, num_people int) []int { res := make([]int, num_people) times := 1 for times*(times+1)/2 i { n = n + 1 } // 等差数列{an}的通项公式为：an=a1+(n-1)d。 // 前n项和公式为：Sn=n*a1+n(n-1)d/2或Sn=n(a1+an)/2 // Sn=n(a1+a1+(n-1)d)/2=n(2a1+(n-1)d)/2 // (i+1)为首项，num_people为公差，n为数列长度，的等差数列的和 res[i] = n * (2*(i+1) + (n-1)*num_people) / 2 if times%num_people == i { res[i] = res[i] + last } } return res } 1108.IP地址无效化(2) 题目 给你一个有效的 IPv4 地址 address，返回这个 IP 地址的无效化版本。 所谓无效化 IP 地址，其实就是用 \"[.]\" 代替了每个 \".\"。 示例 1：输入：address = \"1.1.1.1\" 输出：\"1[.]1[.]1[.]1\" 示例 2：输入：address = \"255.100.50.0\" 输出：\"255[.]100[.]50[.]0\" 提示： 给出的 address 是一个有效的 IPv4 地址 解题思路 No. 思路 时间复杂度 空间复杂度 01 内置函数 O(n) O(n) 02 遍历 O(n) O(n) func defangIPaddr(address string) string { return strings.ReplaceAll(address, \".\", \"[.]\") } # func defangIPaddr(address string) string { res := \"\" for i := range address { if address[i] == '.' { res = res + \"[.]\" } else { res = res + string(address[i]) } } return res } 1122.数组的相对排序(3) 题目 给你两个数组，arr1 和 arr2， arr2 中的元素各不相同 arr2 中的每个元素都出现在 arr1 中 对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。 未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。 示例： 输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6] 输出：[2,2,2,1,4,3,3,9,6,7,19] 提示： arr1.length, arr2.length 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(nlog(n)) O(n) 02 暴力法 O(n^2) I 03 数组辅助 O(n) O(1) func relativeSortArray(arr1 []int, arr2 []int) []int { if len(arr2) == 0 { sort.Ints(arr1) return arr1 } res := make([]int, 0) m := make(map[int]int) for i := range arr1 { m[arr1[i]]++ } for i := 0; i 0 { tempArr = append(tempArr, key) value-- } } sort.Ints(tempArr) res = append(res, tempArr...) return res } # func relativeSortArray(arr1 []int, arr2 []int) []int { count := 0 for i := 0; i 0 { arr1[count] = arr2[i] temp[arr2[i]]-- count++ } } for i := 0; i 0 { arr1[count] = i temp[i]-- count++ } } return arr1 } 1128.等价多米诺骨牌对的数量(2) 题目 给你一个由一些多米诺骨牌组成的列表 dominoes。 如果其中某一张多米诺骨牌可以通过旋转 0 度或 180 度得到另一张多米诺骨牌，我们就认为这两张牌是等价的。 形式上，dominoes[i] = [a, b] 和 dominoes[j] = [c, d] 等价的前提是 a==c 且 b==d，或是 a==d 且 b==c。 在 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(1) 02 数组辅助 O(n) O(1) func numEquivDominoPairs(dominoes [][]int) int { m := make(map[string]int) for i := 0; i b { a, b = b, a } m[fmt.Sprintf(\"%d,%d\", a, b)]++ } res := 0 for _, v := range m { res = res + v*(v-1)/2 } return res } # func numEquivDominoPairs(dominoes [][]int) int { res := 0 arr := make([]int, 101) for i := 0; i b { a, b = b, a } res = res + arr[a*10+b] arr[a*10+b]++ } return res } 1137.第N个泰波那契数(3) 题目 泰波那契序列 Tn 定义如下： T0 = 0, T1 = 1, T2 = 1, 且在 n >= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2 给你整数 n，请返回第 n 个泰波那契数 Tn 的值。 示例 1：输入：n = 4 输出：4 解释： T_3 = 0 + 1 + 1 = 2 T_4 = 1 + 1 + 2 = 4 示例 2： 输入：n = 25 输出：1389537 提示： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n) O(n) 02 递推 O(n) O(1) 03 递归 O(n) O(n) func tribonacci(n int) int { arr := make([]int, n+3) arr[0] = 0 arr[1] = 1 arr[2] = 1 for i := 3; i 1154.一年中的第几天(2) 题目 给你一个按 YYYY-MM-DD 格式表示日期的字符串 date，请你计算并返回该日期是当年的第几天。 通常情况下，我们认为 1 月 1 日是每年的第 1 天，1 月 2 日是每年的第 2 天，依此类推。 每个月的天数与现行公元纪年法（格里高利历）一致。 示例 1：输入：date = \"2019-01-09\" 输出：9 示例 2：输入：date = \"2019-02-10\" 输出：41 示例 3：输入：date = \"2003-03-01\" 输出：60 示例 4：输入：date = \"2004-03-01\" 输出：61 提示： date.length == 10 date[4] == date[7] == '-'，其他的 date[i] 都是数字。 date 表示的范围从 1900 年 1 月 1 日至 2019 年 12 月 31 日。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(1) O(1) 02 内置函数 O(1) O(1) func dayOfYear(date string) int { arr := strings.Split(date, \"-\") year, _ := strconv.Atoi(arr[0]) month, _ := strconv.Atoi(arr[1]) day, _ := strconv.Atoi(arr[2]) res := 0 for i := 0; i 1160.拼写单词(3) 题目 给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。 假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串）， 那么我们就认为你掌握了这个单词。 注意：每次拼写（指拼写词汇表中的一个单词）时，chars 中的每个字母都只能用一次。 返回词汇表 words 中你掌握的所有单词的 长度之和。 示例 1：输入：words = [\"cat\",\"bt\",\"hat\",\"tree\"], chars = \"atach\" 输出：6 解释： 可以形成字符串 \"cat\" 和 \"hat\"，所以答案是 3 + 3 = 6。 示例 2：输入：words = [\"hello\",\"world\",\"leetcode\"], chars = \"welldonehoneyr\" 输出：10 解释： 可以形成字符串 \"hello\" 和 \"world\"，所以答案是 5 + 5 = 10。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n^2) O(1) 02 遍历-内置函数 O(n^2) O(1) 03 数组辅助 O(n^2) O(1) func countCharacters(words []string, chars string) int { m := make(map[byte]int) for i := range chars { m[chars[i]]++ } res := 0 for i := 0; i len(m) { continue } for k, v := range temp { if v > m[k] { flag = false break } } if flag == true { res = res + len(words[i]) } } return res } # func countCharacters(words []string, chars string) int { res := 0 for i := 0; i strings.Count(chars, string(v)) { flag = false continue } } if flag == true { res = res + len(words[i]) } } return res } # func countCharacters(words []string, chars string) int { m := make([]int, 26) for i := range chars { m[chars[i]-'a']++ } res := 0 for i := 0; i len(m) { continue } for k, v := range temp { if v > m[k] { flag = false break } } if flag == true { res = res + len(words[i]) } } return res } 1170.比较字符串最小字母出现频次(2) 题目 我们来定义一个函数 f(s)，其中传入参数 s 是一个非空字符串； 该函数的功能是统计 s 中（按字典序比较）最小字母的出现频次。 例如，若 s = \"dcce\"，那么 f(s) = 2，因为最小的字母是 \"c\"，它出现了 2 次。 现在，给你两个字符串数组待查表 queries 和词汇表 words，请你返回一个整数数组 answer 作为答案， 其中每个 answer[i] 是满足 f(queries[i]) f(\"cc\")。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组辅助 O(n^2) O(n) 02 排序+二分查找 O(nlog(n)) O(n) func numSmallerByFrequency(queries []string, words []string) []int { queriesArr := make([]int, len(queries)) wordsArr := make([]int, len(words)) res := make([]int, 0) for i := 0; i value { right = mid } else { left = mid + 1 } } if target[left] 1175.质数排列(1) 题目 请你帮忙给从 1 到 n 的数设计排列方案，使得所有的「质数」都应该被放在「质数索引」（索引从 1 开始）上； 你需要返回可能的方案总数。 让我们一起来回顾一下「质数」：质数一定是大于 1 的，并且不能用两个小于它的正整数的乘积来表示。 由于答案可能会很大，所以请你返回答案 模 mod 10^9 + 7 之后的结果即可。 示例 1：输入：n = 5 输出：12 解释：举个例子，[1,2,5,4,3] 是一个有效的排列，但 [5,2,3,4,1] 不是， 因为在第二种情况里质数 5 被错误地放在索引为 1 的位置上。 示例 2：输入：n = 100 输出：682289015 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历-全排列 O(n^3/2) O(1) func numPrimeArrangements(n int) int { primeNum := 0 for i := 2; i 1184.公交站间的距离(2) 题目 环形公交路线上有 n 个站，按次序从 0 到 n - 1 进行编号。 我们已知每一对相邻公交站之间的距离， distance[i] 表示编号为 i 的车站和编号为 (i + 1) % n 的车站之间的距离。 环线上的公交车都可以按顺时针和逆时针的方向行驶。 返回乘客从出发点 start 到目的地 destination 之间的最短距离。 示例 1：输入：distance = [1,2,3,4], start = 0, destination = 1 输出：1 解释：公交站 0 和 1 之间的距离是 1 或 9，最小值是 1。 示例 2：输入：distance = [1,2,3,4], start = 0, destination = 2 输出：3 解释：公交站 0 和 2 之间的距离是 3 或 7，最小值是 3。 示例 3：输入：distance = [1,2,3,4], start = 0, destination = 3 输出：4 解释：公交站 0 和 3 之间的距离是 6 或 4，最小值是 4。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 遍历 O(n) O(1) func distanceBetweenBusStops(distance []int, start int, destination int) int { x := 0 y := 0 for i := start; i != destination; i = (i + 1) % len(distance) { x = x + distance[i] } for i := destination; i != start; i = (i + 1) % len(distance) { y = y + distance[i] } if x > y { return y } return x } # func distanceBetweenBusStops(distance []int, start int, destination int) int { x := 0 sum := 0 for i := 0; i = start && i = destination && i x { return x } return sum - x } 1185.一周中的第几天(3) 题目 给你一个日期，请你设计一个算法来判断它是对应一周中的哪一天。 输入为三个整数：day、month 和 year，分别表示日、月、年。 您返回的结果必须是这几个值中的一个 {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"}。 示例 1：输入：day = 31, month = 8, year = 2019 输出：\"Saturday\" 示例 2：输入：day = 18, month = 7, year = 1999 输出：\"Sunday\" 示例 3：输入：day = 15, month = 8, year = 1993 输出：\"Sunday\" 提示： 给出的日期一定是在 1971 到 2100 年之间的有效日期。 解题思路 No. 思路 时间复杂度 空间复杂度 01 内置函数 O(1) O(1) 02 公式 O(1) O(1) 03 遍历 O(1) O(1) func dayOfTheWeek(day int, month int, year int) string { t, _ := time.Parse(\"2006-01-02\", fmt.Sprintf(\"%04d-%02d-%02d\", year, month, day)) return t.Weekday().String() } # // 蔡勒公式 // 基姆拉尔森计算公式 // https://baike.baidu.com/item/%E8%94%A1%E5%8B%92%E5%85%AC%E5%BC%8F // https://www.cnblogs.com/SeekHit/p/7498408.html // Week = (y+y/4-y/100+y/400+2*m+3*(m+1)/5+d) mod 7； func dayOfTheWeek(day int, month int, year int) string { arr := []string{\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"} if month == 1 || month == 2 { month = month + 12 year-- } week := (year + year/4 - year/100 + year/400 + 2*month + 3*(month+1)/5 + day) % 7 return arr[week] } # var arr = []string{\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"} var monthDate = []int{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31} func dayOfTheWeek(day int, month int, year int) string { day1 := totalDay(1993, 8, 15) day2 := totalDay(year, month, day) diff := 6 - day1%7 return arr[(day2+diff)%7] } func totalDay(year, month, day int) int { total := 0 for i := 1971; i 1189.“气球”的最大数量(3) 题目 给你一个字符串 text，你需要使用 text 中的字母来拼凑尽可能多的单词 \"balloon\"（气球）。 字符串 text 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词 \"balloon\"。 示例 1：输入：text = \"nlaebolko\" 输出：1 示例 2：输入：text = \"loonbalxballpoon\" 输出：2 示例 3：输入：text = \"leetcode\" 输出：0 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历-数组辅助 O(n) O(1) 02 遍历-数组辅助 O(n) O(1) 03 内置函数 O(n) O(1) func maxNumberOfBalloons(text string) int { m := make([]int, 26) str := \"ablon\" for i := 0; i 0 { m[text[i]-'a']++ } } min := math.MaxInt32 for k, v := range m { if v == 0 { continue } if k+'a' == 'l' || k+'a' == 'o' { v = (v - 1) / 2 } else { v = v - 1 } if v 1200.最小绝对差(2) 题目 给你个整数数组 arr，其中每个元素都 不相同。 请你找到所有具有最小绝对差的元素对，并且按升序的顺序返回。 示例 1：输入：arr = [4,2,1,3] 输出：[[1,2],[2,3],[3,4]] 示例 2：输入：arr = [1,3,6,10,15] 输出：[[1,3]] 示例 3：输入：arr = [3,8,-10,23,19,-4,-14,27] 输出：[[-14,-10],[19,23],[23,27]] 提示： 2 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序-遍历 O(nlog(n)) O(n) 02 排序-遍历 O(nlog(n)) O(n) func minimumAbsDifference(arr []int) [][]int { sort.Ints(arr) result := make([][]int, 0) min := arr[1] - arr[0] result = append(result, []int{arr[0], arr[1]}) for i := 2; i arr[i]-arr[i-1] { min = arr[i] - arr[i-1] } } for i := 1; i Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-06-28 01:11:13 "},"docs/source/question/1201-1300.html":{"url":"docs/source/question/1201-1300.html","title":"1201-1300","keywords":"","body":"1201-1300-Easy 1201-1300-Easy 1207.独一无二的出现次数(2) 1217.玩筹码(1) 1221.分割平衡字符串(3) 1232.缀点成线(3) 1237.找出给定方程的正整数解(3) 1252.奇数值单元格的数目(3) 1260.二维网格迁移(2) 1266.访问所有点的最小时间(1) 1275.找出井字棋的获胜者(2) 1281.整数的各位积和之差(2) 1287.有序数组中出现次数超过25\\x的元素(4) 1290.二进制链表转整数(3) 1295.统计位数为偶数的数字(2) 1299.将每个元素替换为右侧最大元素(3) 1207.独一无二的出现次数(2) 题目 给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。 如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。 示例 1：输入：arr = [1,2,2,1,1,3] 输出：true 解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。 示例 2：输入：arr = [1,2] 输出：false 示例 3：输入：arr = [-3,0,1,-3,1,1,1,-3,10,0] 输出：true 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(1) 02 数组辅助 O(n) O(1) func uniqueOccurrences(arr []int) bool { m := make(map[int]int) for _, v := range arr { m[v]++ } temp := make(map[int]bool) for _, v := range m { if temp[v] == true { return false } temp[v] = true } return true } # func uniqueOccurrences(arr []int) bool { tempArr := make([]int,2001) for _, v := range arr { tempArr[v+1000]++ } temp := make(map[int]bool) for _, v := range tempArr { if v == 0{ continue } if temp[v] == true { return false } temp[v] = true } return true } 1217.玩筹码(1) 题目 数轴上放置了一些筹码，每个筹码的位置存在数组 chips 当中。 你可以对 任何筹码 执行下面两种操作之一（不限操作次数，0 次也可以）： 将第 i 个筹码向左或者右移动 2 个单位，代价为 0。 将第 i 个筹码向左或者右移动 1 个单位，代价为 1。 最开始的时候，同一位置上也可能放着两个或者更多的筹码。 返回将所有筹码移动到同一位置（任意位置）上所需要的最小代价。 示例 1：输入：chips = [1,2,3] 输出：1 解释：第二个筹码移动到位置三的代价是 1，第一个筹码移动到位置三的代价是 0，总代价为 1。 示例 2：输入：chips = [2,2,2,3,3] 输出：2 解释：第四和第五个筹码移动到位置二的代价都是 1，所以最小总代价为 2。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 奇偶计数 O(n) O(1) /* 1、所有偶数移动到同一偶数位置，花费0 2、所有奇数移动到同一奇数位置，花费0 3、将较小移动到较多的位置。 */ func minCostToMoveChips(chips []int) int { odd := 0 even := 0 for i := 0; i even { return even } return odd } 1221.分割平衡字符串(3) 题目 在一个「平衡字符串」中，'L' 和 'R' 字符的数量是相同的。 给出一个平衡字符串 s，请你将它分割成尽可能多的平衡字符串。 返回可以通过分割得到的平衡字符串的最大数量。 示例 1：输入：s = \"RLRRLLRLRL\" 输出：4 解释：s 可以分割为 \"RL\", \"RRLL\", \"RL\", \"RL\", 每个子字符串中都包含相同数量的 'L' 和 'R'。 示例 2：输入：s = \"RLLLLRRRLR\" 输出：3 解释：s 可以分割为 \"RL\", \"LLLRRR\", \"LR\", 每个子字符串中都包含相同数量的 'L' 和 'R'。 示例 3：输入：s = \"LLLLRRRR\" 输出：1 解释：s 只能保持原样 \"LLLLRRRR\". 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 栈辅助 O(n) O(n) 02 遍历 O(n) O(1) 03 遍历 O(n) O(1) func balancedStringSplit(s string) int { res := 0 if len(s) == 0 { return res } stack := make([]byte, 0) stack = append(stack, s[0]) for i := 1; i 0 && ((s[i] == 'L' && stack[len(stack)-1] == 'R') || (s[i] == 'R' && stack[len(stack)-1] == 'L')) { stack = stack[:len(stack)-1] if len(stack) == 0 { res++ } } else { stack = append(stack, s[i]) } } return res } # func balancedStringSplit(s string) int { res := 0 if len(s) == 0 { return res } count := 0 if s[0] == 'L' { count++ } else { count-- } for i := 1; i 1232.缀点成线(3) 题目 在一个 XY 坐标系中有一些点，我们用数组 coordinates 来分别记录它们的坐标， 其中 coordinates[i] = [x, y] 表示横坐标为 x、纵坐标为 y 的点。 请你来判断，这些点是否在该坐标系中属于同一条直线上，是则返回 true，否则请返回 false。 示例 1：输入：coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]] 输出：true 示例 2：输入：coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]] 输出：false 提示： 2 解题思路 No. 思路 时间复杂度 空间复杂度 01 斜率公式 O(n) O(1) 02 鞋带公式 O(n) O(1) 03 判断三边长 O(n) O(1) // k=y/x k1=y1/x1 => xy1=x1y func checkStraightLine(coordinates [][]int) bool { x, y := coordinates[1][0]-coordinates[0][0], coordinates[1][1]-coordinates[0][1] for i := 2; i 0.00000005 || arr[2]-arr[1]-arr[0] 1237.找出给定方程的正整数解(3) 题目 给出一个函数 f(x, y) 和一个目标结果 z，请你计算方程 f(x,y) == z 所有可能的正整数 数对 x 和 y。 给定函数是严格单调的，也就是说： f(x, y) 解题思路 No. 思路 时间复杂度 空间复杂度 01 二分查找 O(nlog(n)) O(n) 02 双指针 O(n) O(n) 03 暴力法 O(n^2) O(n) func findSolution(customFunction func(int, int) int, z int) [][]int { res := make([][]int, 0) for i := 1; i v2 { continue } for left v { left = mid + 1 } else { right = mid - 1 } } } return res } # func findSolution(customFunction func(int, int) int, z int) [][]int { res := make([][]int, 0) i := 1 j := 1000 for i = 1 { if customFunction(i, j) == z { res = append(res, []int{i, j}) i++ j-- } else if customFunction(i, j) > z { j-- } else { i++ } } return res } # func findSolution(customFunction func(int, int) int, z int) [][]int { res := make([][]int, 0) for i := 1; i 1252.奇数值单元格的数目(3) 题目 给你一个 n 行 m 列的矩阵，最开始的时候，每个单元格中的值都是 0。 另有一个索引数组 indices，indices[i] = [ri, ci] 中的 ri 和 ci 分别表示指定的行和列（从 0 开始编号）。 你需要将每对 [ri, ci] 指定的行和列上的所有单元格的值加 1。 请你在执行完所有 indices 指定的增量操作后，返回矩阵中 「奇数值单元格」 的数目。 示例 1：输入：n = 2, m = 3, indices = [[0,1],[1,1]] 输出：6 解释：最开始的矩阵是 [[0,0,0],[0,0,0]]。 第一次增量操作后得到 [[1,2,1],[0,1,0]]。 最后的矩阵是 [[1,3,1],[1,3,1]]，里面有 6 个奇数。 示例 2：输入：n = 2, m = 2, indices = [[1,1],[0,0]] 输出：0 解释：最后的矩阵是 [[2,2],[2,2]]，里面没有奇数。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历模拟 O(n^2) O(n^2) 02 统计行列 O(n) O(n) 03 统计行列-遍历 O(n^2) O(n) func oddCells(n int, m int, indices [][]int) int { arr := make([][]int, n) for i := 0; i 1260.二维网格迁移(2) 题目 给你一个 m 行 n 列的二维网格 grid 和一个整数 k。你需要将 grid 迁移 k 次。 每次「迁移」操作将会引发下述活动： 位于 grid[i][j] 的元素将会移动到 grid[i][j + 1]。 位于 grid[i][n - 1] 的元素将会移动到 grid[i + 1][0]。 位于 grid[m - 1][n - 1] 的元素将会移动到 grid[0][0]。 请你返回 k 次迁移操作后最终得到的 二维网格。 示例 1：输入：grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1 输出：[[9,1,2],[3,4,5],[6,7,8]] 示例 2：输入：grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4 输出：[[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]] 示例 3：输入：grid = [[1,2,3],[4,5,6],[7,8,9]], k = 9 输出：[[1,2,3],[4,5,6],[7,8,9]] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历模拟 O(n^2) O(n^2) 02 计算下标 O(n^2) O(n^2) func shiftGrid(grid [][]int, k int) [][]int { for i := 0; i 1266.访问所有点的最小时间(1) 题目 平面上有 n 个点，点的位置用整数坐标表示 points[i] = [xi, yi]。 请你计算访问所有这些点需要的最小时间（以秒为单位）。 你可以按照下面的规则在平面上移动： 每一秒沿水平或者竖直方向移动一个单位长度， 或者跨过对角线（可以看作在一秒内向水平和竖直方向各移动一个单位长度）。 必须按照数组中出现的顺序来访问这些点。 示例 1：输入：points = [[1,1],[3,4],[-1,0]] 输出：7 解释：一条最佳的访问路径是： [1,1] -> [2,2] -> [3,3] -> [3,4] -> [2,3] -> [1,2] -> [0,1] -> [-1,0] 从 [1,1] 到 [3,4] 需要 3 秒 从 [3,4] 到 [-1,0] 需要 4 秒 一共需要 7 秒 示例 2：输入：points = [[3,2],[-2,2]] 输出：5 提示： points.length == n 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) func minTimeToVisitAllPoints(points [][]int) int { res := 0 for i := 1; i y { res = res + x } else { res = res + y } } return res } func length(a, b int) int { if a > b { return a - b } return b - a } 1275.找出井字棋的获胜者(2) 题目 A 和 B 在一个 3 x 3 的网格上玩井字棋。 井字棋游戏的规则如下： 玩家轮流将棋子放在空方格 (\" \") 上。 第一个玩家 A 总是用 \"X\" 作为棋子，而第二个玩家 B 总是用 \"O\" 作为棋子。 \"X\" 和 \"O\" 只能放在空方格中，而不能放在已经被占用的方格上。 只要有 3 个相同的（非空）棋子排成一条直线（行、列、对角线）时，游戏结束。 如果所有方块都放满棋子（不为空），游戏也会结束。 游戏结束后，棋子无法再进行任何移动。 给你一个数组 moves，其中每个元素是大小为 2 的另一个数组（元素分别对应网格的行和列）， 它按照 A 和 B 的行动顺序（先 A 后 B）记录了两人各自的棋子位置。 如果游戏存在获胜者（A 或 B），就返回该游戏的获胜者； 如果游戏以平局结束，则返回 \"Draw\"；如果仍会有行动（游戏未结束），则返回 \"Pending\"。 你可以假设 moves 都 有效（遵循井字棋规则），网格最初是空的，A 将先行动。 示例 1：输入：moves = [[0,0],[2,0],[1,1],[2,1],[2,2]] 输出：\"A\" 解释：\"A\" 获胜，他总是先走。 \"X \" \"X \" \"X \" \"X \" \"X \" \" \" -> \" \" -> \" X \" -> \" X \" -> \" X \" \" \" \"O \" \"O \" \"OO \" \"OOX\" 示例 2：输入：moves = [[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]] 输出：\"B\" 解释：\"B\" 获胜。 \"X \" \"X \" \"XX \" \"XXO\" \"XXO\" \"XXO\" \" \" -> \" O \" -> \" O \" -> \" O \" -> \"XO \" -> \"XO \" \" \" \" \" \" \" \" \" \" \" \"O \" 示例 3：输入：moves = [[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]] 输出：\"Draw\" 输出：由于没有办法再行动，游戏以平局结束。 \"XXO\" \"OOX\" \"XOX\" 示例 4：输入：moves = [[0,0],[1,1]] 输出：\"Pending\" 解释：游戏还没有结束。 \"X \" \" O \" \" \" 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历模拟 O(1) O(1) 02 遍历模拟 O(1) O(1) func tictactoe(moves [][]int) string { arrA := make([]int, 0) arrB := make([]int, 0) for i := 0; i 1281.整数的各位积和之差(2) 题目 给你一个整数 n，请你帮忙计算并返回该整数「各位数字之积」与「各位数字之和」的差。 示例 1：输入：n = 234 输出：15 解释： 各位数之积 = 2 * 3 * 4 = 24 各位数之和 = 2 + 3 + 4 = 9 结果 = 24 - 9 = 15 示例 2：输入：n = 4421 输出：21 解释： 各位数之积 = 4 * 4 * 2 * 1 = 32 各位数之和 = 4 + 4 + 2 + 1 = 11 结果 = 32 - 11 = 21 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(log(n)) O(1) 02 转字符串遍历 O(log(n)) O(1) func subtractProductAndSum(n int) int { sum := 0 mul := 1 for n > 0 { value := n % 10 n = n / 10 sum = sum + value mul = mul * value } return mul - sum } func subtractProductAndSum(n int) int { sum := 0 mul := 1 str := strconv.Itoa(n) for i := 0; i 1287.有序数组中出现次数超过25%的元素(4) 题目 给你一个非递减的 有序 整数数组，已知这个数组中恰好有一个整数，它的出现次数超过数组元素总数的 25%。 请你找到并返回这个整数 示例：输入：arr = [1,2,2,6,6,6,6,7,10] 输出：6 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历统计 O(n) O(1) 02 遍历 O(n) O(1) 03 二分查找 O(log(n)) O(1) 04 遍历 O(n) O(1) func findSpecialInteger(arr []int) int { count := 1 res := arr[0] for i := 1; i len(arr)/4 { return arr[i] } } else { res = arr[i] count = 1 } } return res } # func findSpecialInteger(arr []int) int { step := len(arr) / 4 for i := 0; i length { return value } } return arr[3*length] } func leftSearch(arr []int, value int) int { left := 0 right := len(arr) for left = value { right = mid } else { left = mid + 1 } } return left } func rightSearch(arr []int, value int) int { left := 0 right := len(arr) for left value { right = mid } else { left = mid + 1 } } return right - 1 } # func findSpecialInteger(arr []int) int { length := len(arr) / 4 for i := 1; i 0 { if arr[left] == arr[left-1] { left-- } else { break } } right := length * i for right length { return value } } return arr[3*length] } 1290.二进制链表转整数(3) 题目 给你一个单链表的引用结点 head。链表中每个结点的值不是 0 就是 1。 已知此链表是一个整数数字的二进制表示形式。 请你返回该链表所表示数字的 十进制值 。 示例 1：输入：head = [1,0,1] 输出：5 解释：二进制数 (101) 转化为十进制数 (5) 示例 2：输入：head = [0] 输出：0 示例 3：输入：head = [1] 输出：1 示例 4：输入：head = [1,0,0,1,0,0,1,1,1,0,0,0,0,0,0] 输出：18880 示例 5：输入：head = [0,0] 输出：0 提示： 链表不为空。 链表的结点总数不超过 30。 每个结点的值不是 0 就是 1。 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组辅助 O(n) O(n) 02 遍历 O(n) O(1) 03 递归 O(n) O(n) func getDecimalValue(head *ListNode) int { arr := make([]int, 0) for head != nil { arr = append(arr, head.Val) head = head.Next } res := 0 for i := 0; i 1295.统计位数为偶数的数字(2) 题目 给你一个整数数组 nums，请你返回其中位数为 偶数 的数字的个数。 示例 1：输入：nums = [12,345,2,6,7896] 输出：2 解释： 12 是 2 位数字（位数为偶数） 345 是 3 位数字（位数为奇数） 2 是 1 位数字（位数为奇数） 6 是 1 位数字 位数为奇数） 7896 是 4 位数字（位数为偶数） 因此只有 12 和 7896 是位数为偶数的数字 示例 2：输入：nums = [555,901,482,1771]输出：1 解释： 只有 1771 是位数为偶数的数字。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 转字符串 O(n) O(1) func findNumbers(nums []int) int { res := 0 for i := 0; i 0 { value = value / 10 count++ } if count%2 == 0 { res++ } } return res } # func findNumbers(nums []int) int { res := 0 for i := 0; i 1299.将每个元素替换为右侧最大元素(3) 题目 给你一个数组 arr ，请你将每个元素用它右边最大的元素替换，如果是最后一个元素，用 -1 替换。 完成所有替换操作后，请你返回这个数组。 示例：输入：arr = [17,18,5,4,6,1] 输出：[18,6,6,6,1,-1] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 暴力法 O(n^2) O(1) 03 遍历-数组辅助 O(n) O(n) func replaceElements(arr []int) []int { max := -1 for i := len(arr) - 1; i >= 0; i-- { if arr[i] > max { arr[i], max = max, arr[i] } else { arr[i] = max } } return arr } # func replaceElements(arr []int) []int { for i := 0; i max { max = arr[j] } } arr[i] = max } return arr } # func replaceElements(arr []int) []int { res := make([]int, len(arr)) res[len(res)-1] = -1 for i := len(arr) - 2; i >= 0; i-- { if arr[i+1] > res[i+1] { res[i] = arr[i+1] } else { res[i] = res[i+1] } } return res } Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-06-28 01:11:13 "},"docs/source/question/1301-1400.html":{"url":"docs/source/question/1301-1400.html","title":"1301-1400","keywords":"","body":"1301-1400-Easy 1301-1400-Easy 1304.和为零的N个唯一整数(2) 1309.解码字母到整数映射(3) 1313.解压缩编码列表(1) 1317.将整数转换为两个无零整数的和(2) 1323.6和9组成的最大数字(3) 1331.数组序号转换(2) 1332.删除回文子序列(2) 1337.方阵中战斗力最弱的K行(2) 1342.将数字变成0的操作次数(3) 1346.检查整数及其两倍数是否存在(3) 1351.统计有序矩阵中的负数(4) 1356.根据数字二进制下1的数目排序(3) 1360.日期之间隔几天(2) 1365.有多少小于当前数字的数字(3) 1370.上升下降字符串(2) 1374.生成每种字符都是奇数个的字符串(2) 1380.矩阵中的幸运数(2) 1385.两个数组间的距离值(2) 1389.按既定顺序创建目标数组(3) 1394.找出数组中的幸运数(2) 1399.统计最大组的数目(2) 1304.和为零的N个唯一整数(2) 题目 给你一个整数 n，请你返回 任意 一个由 n 个 各不相同 的整数组成的数组，并且这 n 个数相加和为 0 。 示例 1：输入：n = 5 输出：[-7,-1,1,3,4] 解释：这些数组也是正确的 [-5,-1,1,2,3]，[-3,-1,2,-2,4]。 示例 2：输入：n = 3 输出：[-1,0,1] 示例 3：输入：n = 1 输出：[0] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 1负N正 O(n) O(n) 02 半正半负 O(n) O(n) func sumZero(n int) []int { res := make([]int, n) sum := 0 for i := 0; i 1309.解码字母到整数映射(3) 题目 给你一个字符串 s，它由数字（'0' - '9'）和 '#' 组成。我们希望按下述规则将 s 映射为一些小写英文字符： 字符（'a' - 'i'）分别用（'1' - '9'）表示。 字符（'j' - 'z'）分别用（'10#' - '26#'）表示。 返回映射之后形成的新字符串。 题目数据保证映射始终唯一。 示例 1：输入：s = \"10#11#12\" 输出：\"jkab\" 解释：\"j\" -> \"10#\" , \"k\" -> \"11#\" , \"a\" -> \"1\" , \"b\" -> \"2\". 示例 2：输入：s = \"1326#\" 输出：\"acz\" 示例 3：输入：s = \"25#\" 输出：\"y\" 示例 4：输入：s = \"12345678910#11#12#13#14#15#16#17#18#19#20#21#22#23#24#25#26#\" 输出：\"abcdefghijklmnopqrstuvwxyz\" 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 反向遍历 O(n) O(n) 02 正向遍历 O(n) O(n) 03 内置函数 O(n) O(n) func freqAlphabets(s string) string { res := \"\" for i := len(s) - 1; i >= 0; { if s[i] == '#' { value, _ := strconv.Atoi(string(s[i-2 : i])) res = string('a'+value-1) + res i = i - 3 } else { value, _ := strconv.Atoi(string(s[i])) res = string('a'+value-1) + res i = i - 1 } } return res } # func freqAlphabets(s string) string { res := \"\" for i := 0; i 1313.解压缩编码列表(1) 题目 给你一个以行程长度编码压缩的整数列表 nums 。 考虑每对相邻的两个元素 [freq, val] = [nums[2*i], nums[2*i+1]] （其中 i >= 0 ）， 每一对都表示解压后子列表中有 freq 个值为 val 的元素，你需要从左到右连接所有子列表以生成解压后的列表。 请你返回解压后的列表。 示例：输入：nums = [1,2,3,4] 输出：[2,4,4,4] 解释：第一对 [1,2] 代表着 2 的出现频次为 1，所以生成数组 [2]。 第二对 [3,4] 代表着 4 的出现频次为 3，所以生成数组 [4,4,4]。 最后将它们串联到一起 [2] + [4,4,4] = [2,4,4,4]。 示例 2：输入：nums = [1,1,2,3] 输出：[1,3,3] 提示： 2 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n^2) O(n^2) func decompressRLElist(nums []int) []int { res := make([]int, 0) for i := 0; i 1317.将整数转换为两个无零整数的和(2) 题目 「无零整数」是十进制表示中 不含任何 0 的正整数。 给你一个整数 n，请你返回一个 由两个整数组成的列表 [A, B]，满足： A 和 B 都是无零整数 A + B = n 题目数据保证至少有一个有效的解决方案。 如果存在多个有效解决方案，你可以返回其中任意一个。 示例 1：输入：n = 2 输出：[1,1] 解释：A = 1, B = 1. A + B = n 并且 A 和 B 的十进制表示形式都不包含任何 0 。 示例 2：输入：n = 11 输出：[2,9] 示例 3：输入：n = 10000 输出：[1,9999] 示例 4：输入：n = 69 输出：[1,68] 示例 5：输入：n = 1010 输出：[11,999] 提示：2 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(nlog(n)) O(1) 02 遍历 O(nlog(n)) O(1) func getNoZeroIntegers(n int) []int { for i := 1; i 0 { if num%10 == 0 { return false } num = num / 10 } return true } 1323.6和9组成的最大数字(3) 题目 给你一个仅由数字 6 和 9 组成的正整数 num。 你最多只能翻转一位数字，将 6 变成 9，或者把 9 变成 6 。 请返回你可以得到的最大数字。 示例 1：输入：num = 9669 输出：9969 解释： 改变第一位数字可以得到 6669 。 改变第二位数字可以得到 9969 。 改变第三位数字可以得到 9699 。 改变第四位数字可以得到 9666 。 其中最大的数字是 9969 。 示例 2：输入：num = 9996 输出：9999 解释：将最后一位从 6 变到 9，其结果 9999 是最大的数。 示例 3：输入：num = 9999 输出：9999 解释：无需改变就已经是最大的数字了。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历-转字符串 O(log(n)) O(log(n)) 02 遍历-转数组 O(log(n)) O(log(n)) 03 内置函数 O(log(n)) O(log(n)) func maximum69Number(num int) int { arr := []byte(strconv.Itoa(num)) for i := 0; i 0 { arr = append(arr, num%10) num = num / 10 } res := 0 flag := true for i := len(arr) - 1; i >= 0; i-- { if arr[i] == 6 && flag == true { res = res*10 + 9 flag = false } else { res = res*10 + arr[i] } } return res } # func maximum69Number(num int) int { str := strconv.Itoa(num) str = strings.Replace(str, \"6\", \"9\", 1) res, _ := strconv.Atoi(string(str)) return res } 1331.数组序号转换(2) 题目 给你一个整数数组 arr ，请你将数组中的每个元素替换为它们排序后的序号。 序号代表了一个元素有多大。序号编号的规则如下： 序号从 1 开始编号。 一个元素越大，那么序号越大。如果两个元素相等，那么它们的序号相同。 每个数字的序号都应该尽可能地小。 示例 1：输入：arr = [40,10,20,30] 输出：[4,1,2,3] 解释：40 是最大的元素。 10 是最小的元素。 20 是第二小的数字。 30 是第三小的数字。 示例 2：输入：arr = [100,100,100] 输出：[1,1,1] 解释：所有元素有相同的序号。 示例 3：输入：arr = [37,12,28,9,100,56,80,5,12] 输出：[5,3,4,2,8,6,7,1,3] 提示： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历-哈希辅助 O(nlog(n)) O(n) 02 数组辅助 O(n) O(10^9) func arrayRankTransform(arr []int) []int { temp := make([]int, len(arr)) copy(temp, arr) sort.Ints(temp) m := make(map[int]int) count := 1 for i := 0; i 0 { continue } m[temp[i]] = count count++ } res := make([]int, len(arr)) for i := 0; i = max { max = arr[i] } } length := max - min + 1 temp := make([]int, length) for i := 0; i 1332.删除回文子序列(2) 题目 给你一个字符串 s，它仅由字母 'a' 和 'b' 组成。每一次删除操作都可以从 s 中删除一个回文子序列。 返回删除给定字符串中所有字符（字符串为空）的最小删除次数。 「子序列」定义：如果一个字符串可以通过删除原字符串某些字符而不改变原字符顺序得到， 那么这个字符串就是原字符串的一个子序列。 「回文」定义：如果一个字符串向后和向前读是一致的，那么这个字符串就是一个回文。 示例 1：输入：s = \"ababa\" 输出：1 解释：字符串本身就是回文序列，只需要删除一次。 示例 2：输入：s = \"abb\" 输出：2 解释：\"abb\" -> \"bb\" -> \"\". 先删除回文子序列 \"a\"，然后再删除 \"bb\"。 示例 3：输入：s = \"baabb\" 输出：2 解释：\"baabb\" -> \"b\" -> \"\". 先删除回文子序列 \"baab\"，然后再删除 \"b\"。 示例 4：输入：s = \"\" 输出：0 提示： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n) O(1) 02 反转 O(n) O(n) /* 1.长度为0，返回0 2.字符串为回文子序列，返回1 3.字符串不为回文子序列，返回2，因为可以把a或者b一次都去除，题目没有要求去除的是连续的 */ func removePalindromeSub(s string) int { if len(s) == 0 { return 0 } for i, j := 0, len(s)-1; i = 0; i-- { temp = temp + string(s[i]) } if temp == s { return 1 } return 2 } 1337.方阵中战斗力最弱的K行(2) 题目 给你一个大小为 m * n 的方阵 mat，方阵由若干军人和平民组成，分别用 1 和 0 表示。 请你返回方阵中战斗力最弱的 k 行的索引，按从最弱到最强排序。 如果第 i 行的军人数量少于第 j 行，或者两行军人数量相同但 i 小于 j， 那么我们认为第 i 行的战斗力比第 j 行弱。 军人 总是 排在一行中的靠前位置，也就是说 1 总是出现在 0 之前。 示例 1：输入：mat = [[1,1,0,0,0], [1,1,1,1,0], [1,0,0,0,0], [1,1,0,0,0], [1,1,1,1,1]], k = 3 输出：[2,0,3] 解释： 每行中的军人数目： 行 0 -> 2 行 1 -> 4 行 2 -> 1 行 3 -> 2 行 4 -> 5 从最弱到最强对这些行排序后得到 [2,0,3,1,4] 示例 2：输入：mat = [[1,0,0,0], [1,1,1,1], [1,0,0,0], [1,0,0,0]], k = 2 输出：[0,2] 解释： 每行中的军人数目： 行 0 -> 1 行 1 -> 4 行 2 -> 1 行 3 -> 1 从最弱到最强对这些行排序后得到 [0,2,3,1] 提示： m == mat.length n == mat[i].length 2 解题思路 No. 思路 时间复杂度 空间复杂度 01 加权排序 O(n^2) O(n) 02 自定义排序 O(n^2) O(n) func kWeakestRows(mat [][]int, k int) []int { arr := make([]int, 0) for i := 0; i 1342.将数字变成0的操作次数(3) 题目 给你一个非负整数 num ，请你返回将它变成 0 所需要的步数。 如果当前数字是偶数，你需要把它除以 2 ；否则，减去 1 。 示例 1：输入：num = 14 输出：6 解释： 步骤 1) 14 是偶数，除以 2 得到 7 。 步骤 2） 7 是奇数，减 1 得到 6 。 步骤 3） 6 是偶数，除以 2 得到 3 。 步骤 4） 3 是奇数，减 1 得到 2 。 步骤 5） 2 是偶数，除以 2 得到 1 。 步骤 6） 1 是奇数，减 1 得到 0 。 示例 2：输入：num = 8 输出：4 解释： 步骤 1） 8 是偶数，除以 2 得到 4 。 步骤 2） 4 是偶数，除以 2 得到 2 。 步骤 3） 2 是偶数，除以 2 得到 1 。 步骤 4） 1 是奇数，减 1 得到 0 。 示例 3：输入：num = 123 输出：12 提示： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历模拟 O(log(n)) O(1) 02 递归 O(log(n)) O(log(n)) 02 递归 O(log(n)) O(log(n)) func numberOfSteps(num int) int { res := 0 for num > 0 { if num%2 == 1 { num = num - 1 } else { num = num / 2 } res++ } return res } # var res int func numberOfSteps(num int) int { res = 0 dfs(num) return res } func dfs(num int) { if num != 0 { res++ if num%2 == 1 { dfs(num - 1) } else { dfs(num / 2) } } } # func numberOfSteps(num int) int { if num == 0 { return 0 } else if num%2 == 1 { return 1 + numberOfSteps(num-1) } return 1 + numberOfSteps(num/2) } 1346.检查整数及其两倍数是否存在(3) 题目 给你一个整数数组 arr，请你检查是否存在两个整数 N 和 M，满足 N 是 M 的两倍（即，N = 2 * M）。 更正式地，检查是否存在两个下标 i 和 j 满足： i != j 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法 O(n^2) O(1) 02 哈希辅助 O(n) O(n) 03 排序+二分查找 O(nlog(n)) O(1) func checkIfExist(arr []int) bool { for i := 0; i 0 || (i%2 == 0 && m[arr[i]/2] > 0) { return true } m[arr[i]] = 1 } return false } # func checkIfExist(arr []int) bool { var target int sort.Ints(arr) for i := 0; i = 0 { target = 2 * arr[i] } else { if arr[i]%2 == -1 { continue } target = arr[i] / 2 } for left target { right = mid - 1 } else { left = mid + 1 } } } return false } 1351.统计有序矩阵中的负数(4) 题目 给你一个 m * n 的矩阵 grid，矩阵中的元素无论是按行还是按列，都以非递增顺序排列。 请你统计并返回 grid 中 负数 的数目。 示例 1：输入：grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]] 输出：8 解释：矩阵中共有 8 个负数。 示例 2：输入：grid = [[3,2],[1,0]] 输出：0 示例 3：输入：grid = [[1,-1],[-1,-1]] 输出：3 示例 4：输入：grid = [[-1]] 输出：1 提示： m == grid.length n == grid[i].length 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法 O(n^2) O(1) 02 二分查找 O(nlog(n)) O(1) 03 遍历 O(n^2) O(1) 04 右上角 O(n) O(1) func countNegatives(grid [][]int) int { res := 0 for i := 0; i = 0 { left = mid + 1 } else { right = mid - 1 } } return left } # func countNegatives(grid [][]int) int { res := 0 for i := 0; i = -1; j-- { if j == -1 { res = res + len(grid[i]) break } if grid[i][j] >= 0 { count := len(grid[i]) - 1 - j res = res + count break } } } return res } # func countNegatives(grid [][]int) int { res := 0 i := 0 j := len(grid[0])-1 for i = 0 { if grid[i][j] >=0{ res = res + len(grid[0])-j-1 i++ }else { j-- } } if j 1356.根据数字二进制下1的数目排序(3) 题目 给你一个整数数组 arr 。请你将数组中的元素按照其二进制表示中数字 1 的数目升序排序。 如果存在多个数字二进制中 1 的数目相同，则必须将它们按照数值大小升序排列。 请你返回排序后的数组。 示例 1：输入：arr = [0,1,2,3,4,5,6,7,8] 输出：[0,1,2,4,8,3,5,6,7] 解释：[0] 是唯一一个有 0 个 1 的数。 [1,2,4,8] 都有 1 个 1 。 [3,5,6] 有 2 个 1 。 [7] 有 3 个 1 。 按照 1 的个数排序得到的结果数组为 [0,1,2,4,8,3,5,6,7] 示例 2：输入：arr = [1024,512,256,128,64,32,16,8,4,2,1] 输出：[1,2,4,8,16,32,64,128,256,512,1024] 解释：数组中所有整数二进制下都只有 1 个 1 ，所以你需要按照数值大小将它们排序。 示例 3：输入：arr = [10000,10000] 输出：[10000,10000] 示例 4：输入：arr = [2,3,5,7,11,13,17,19] 输出：[2,3,5,17,7,11,13,19] 示例 5：输入：arr = [10,100,1000,10000] 输出：[10,100,10000,1000] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 自定义排序 O(log(n)^2*n) O(1) 02 排序+分组 O(nlog(n)) O(n) 03 内置函数 O(log(n)^2*n) O(1) func sortByBits(arr []int) []int { sort.Slice(arr, func(i, j int) bool { if countBit(arr[i]) == countBit(arr[j]) { return arr[i] 0 { if num%2 == 1 { res++ } num = num / 2 } return res } # func sortByBits(arr []int) []int { sort.Ints(arr) m := make(map[int][]int, 0) for i := 0; i 0 { if num%2 == 1 { res++ } num = num / 2 } return res } # func sortByBits(arr []int) []int { sort.Slice(arr, func(i, j int) bool { if bits.OnesCount32(uint32(arr[i])) == bits.OnesCount32(uint32(arr[j])) { return arr[i] 1360.日期之间隔几天(2) 题目 请你编写一个程序来计算两个日期之间隔了多少天。 日期以字符串形式给出，格式为 YYYY-MM-DD，如示例所示。 示例 1：输入：date1 = \"2019-06-29\", date2 = \"2019-06-30\" 输出：1 示例 2：输入：date1 = \"2020-01-15\", date2 = \"2019-12-31\" 输出：15 提示： 给定的日期是 1971 年到 2100 年之间的有效日期。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(1) O(1) 02 内置函数 O(1) O(1) func daysBetweenDates(date1 string, date2 string) int { v1 := totalDay(date1) v2 := totalDay(date2) if v1 > v2 { return v1 - v2 } return v2 - v1 } var monthDate = []int{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31} func totalDay(date string) int { var year, month, day int arr := strings.Split(date, \"-\") year, _ = strconv.Atoi(arr[0]) month, _ = strconv.Atoi(arr[1]) day, _ = strconv.Atoi(arr[2]) total := 0 for i := 1971; i 0 { return value } return -value } 1365.有多少小于当前数字的数字(3) 题目 给你一个数组 nums，对于其中每个元素 nums[i]，请你统计数组中比它小的所有数字的数目。 换而言之，对于每个 nums[i] 你必须计算出有效的 j 的数量，其中 j 满足 j != i 且 nums[j] 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(n) 02 暴力法 O(n^2) O(n) 03 排序 O(nlog(n)) O(n) func smallerNumbersThanCurrent(nums []int) []int { arr := make([]int, 101) res := make([]int, len(nums)) for i := 0; i nums[j] { res[i]++ } } } return res } # func smallerNumbersThanCurrent(nums []int) []int { temp := make([]int, len(nums)) copy(temp, nums) sort.Ints(temp) m := make(map[int]int) count := 0 m[temp[0]] = count for i := 1; i 1370.上升下降字符串(2) 题目 给你一个字符串 s ，请你根据下面的算法重新构造字符串： 从 s 中选出 最小 的字符，将它 接在 结果字符串的后面。 从 s 剩余字符中选出 最小 的字符，且该字符比上一个添加的字符大，将它 接在 结果字符串后面。 重复步骤 2 ，直到你没法从 s 中选择字符。 从 s 中选出 最大 的字符，将它 接在 结果字符串的后面。 从 s 剩余字符中选出 最大 的字符，且该字符比上一个添加的字符小，将它 接在 结果字符串后面。 重复步骤 5 ，直到你没法从 s 中选择字符。 重复步骤 1 到 6 ，直到 s 中所有字符都已经被选过。 在任何一步中，如果最小或者最大字符不止一个 ，你可以选择其中任意一个，并将其添加到结果字符串。 请你返回将 s 中字符重新排序后的 结果字符串 。 示例 1：输入：s = \"aaaabbbbcccc\" 输出：\"abccbaabccba\" 解释：第一轮的步骤 1，2，3 后，结果字符串为 result = \"abc\" 第一轮的步骤 4，5，6 后，结果字符串为 result = \"abccba\" 第一轮结束，现在 s = \"aabbcc\" ，我们再次回到步骤 1 第二轮的步骤 1，2，3 后，结果字符串为 result = \"abccbaabc\" 第二轮的步骤 4，5，6 后，结果字符串为 result = \"abccbaabccba\" 示例 2：输入：s = \"rat\" 输出：\"art\" 解释：单词 \"rat\" 在上述算法重排序以后变成 \"art\" 示例 3：输入：s = \"leetcode\" 输出：\"cdelotee\" 示例 4：输入：s = \"ggggggg\" 输出：\"ggggggg\" 示例 5：输入：s = \"spo\" 输出：\"ops\" 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组辅助 O(n) O(n) 02 哈希辅助 O(n) O(n) func sortString(s string) string { arr := make([]int, 26) for i := 0; i 0 { res = res + string(i+'a') arr[i]-- } } for i := 25; i >= 0; i-- { if arr[i] > 0 { res = res + string(i+'a') arr[i]-- } } } return res } # func sortString(s string) string { m := make(map[int]int, 26) for i := 0; i 0 { res = res + string(i+'a') m[i]-- } } for i := 25; i >= 0; i-- { if m[i] > 0 { res = res + string(i+'a') m[i]-- } } } return res } 1374.生成每种字符都是奇数个的字符串(2) 题目 给你一个整数 n，请你返回一个含 n 个字符的字符串，其中每种字符在该字符串中都恰好出现 奇数次 。 返回的字符串必须只含小写英文字母。如果存在多个满足题目要求的字符串，则返回其中任意一个即可。 示例 1：输入：n = 4 输出：\"pppz\" 解释：\"pppz\" 是一个满足题目要求的字符串，因为 'p' 出现 3 次，且 'z' 出现 1 次。 当然，还有很多其他字符串也满足题目要求，比如：\"ohhh\" 和 \"love\"。 示例 2：输入：n = 2 输出：\"xy\" 解释：\"xy\" 是一个满足题目要求的字符串，因为 'x' 和 'y' 各出现 1 次。 当然，还有很多其他字符串也满足题目要求，比如：\"ag\" 和 \"ur\"。 示例 3：输入：n = 7 输出：\"holasss\" 提示：1 解题思路 No. 思路 时间复杂度 空间复杂度 01 奇1偶2 O(n) O(n) 02 奇1偶2 O(n) O(n) func generateTheString(n int) string { if n % 2 == 0 { return strings.Repeat(\"a\", n-1)+\"b\" } return strings.Repeat(\"a\", n) } # func generateTheString(n int) string { res := \"\" if n%2 == 0 { res = \"a\" for i := 0; i 1380.矩阵中的幸运数(2) 题目 给你一个 m * n 的矩阵，矩阵中的数字 各不相同 。请你按 任意 顺序返回矩阵中的所有幸运数。 幸运数是指矩阵中满足同时下列两个条件的元素： 在同一行的所有元素中最小 在同一列的所有元素中最大 示例 1：输入：matrix = [[3,7,8],[9,11,13],[15,16,17]] 输出：[15] 解释：15 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。 示例 2：输入：matrix = [[1,10,4,2],[9,3,8,7],[15,16,17,12]] 输出：[12] 解释：12 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。 示例 3：输入：matrix = [[7,8],[1,2]] 输出：[7] 提示： m == mat.length n == mat[i].length 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n^2) O(n) 02 遍历 O(n^2) O(n) func luckyNumbers(matrix [][]int) []int { res := make([]int, 0) for i := 0; i matrix[i][j] { min = matrix[i][j] minIndex = j } } flag := true for j := 0; j min { flag = false break } } if flag == true { res = append(res, min) } } return res } # func luckyNumbers(matrix [][]int) []int { res := make([]int, 0) minArr := make([]int, 0) maxArr := make([]int, 0) for i := 0; i matrix[i][j] { min = matrix[i][j] } } minArr = append(minArr, min) } for i := 0; i 1385.两个数组间的距离值(2) 题目 给你两个整数数组 arr1 ， arr2 和一个整数 d ，请你返回两个数组之间的 距离值 。 「距离值」 定义为符合此描述的元素数目： 对于元素 arr1[i] ，不存在任何元素 arr2[j] 满足 |arr1[i]-arr2[j]| d=2 |4-9|=5 > d=2 |4-1|=3 > d=2 |4-8|=4 > d=2 对于 arr1[1]=5 我们有： |5-10|=5 > d=2 |5-9|=4 > d=2 |5-1|=4 > d=2 |5-8|=3 > d=2 对于 arr1[2]=8 我们有： |8-10|=2 d=2 |8-8|=0 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n^2) O(1) 02 二分查找 O(nlog(n)) O(1) func findTheDistanceValue(arr1 []int, arr2 []int, d int) int { res := 0 for i := 0; i 1389.按既定顺序创建目标数组(3) 题目 给你两个整数数组 nums 和 index。你需要按照以下规则创建目标数组： 目标数组 target 最初为空。 按从左到右的顺序依次读取 nums[i] 和 index[i]， 在 target 数组中的下标 index[i] 处插入值 nums[i] 。 重复上一步，直到在 nums 和 index 中都没有要读取的元素。 请你返回目标数组。 题目保证数字插入位置总是存在。 示例 1：输入：nums = [0,1,2,3,4], index = [0,1,2,2,1] 输出：[0,4,1,3,2] 解释： nums index target 0 0 [0] 1 1 [0,1] 2 2 [0,1,2] 3 2 [0,1,3,2] 4 1 [0,4,1,3,2] 示例 2：输入：nums = [1,2,3,4,0], index = [0,1,2,3,0] 输出：[0,1,2,3,4] 解释： nums index target 1 0 [1] 2 1 [1,2] 3 2 [1,2,3] 4 3 [1,2,3,4] 0 0 [0,1,2,3,4] 示例 3：输入：nums = [1], index = [0] 输出：[1] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历模拟 O(n^2) O(n) 02 遍历-切片操作 O(n^2) O(n) 03 遍历-定位 O(n^2) O(n) func createTargetArray(nums []int, index []int) []int { res := make([]int, len(nums)) for i := 0; i index[i]; j-- { res[j] = res[j-1] } res[index[i]] = nums[i] } return res } # func createTargetArray(nums []int, index []int) []int { res := make([]int, len(nums)) for i := 0; i = index[i] { index[j]++ } } } for i := 0; i 1394.找出数组中的幸运数(2) 题目 在整数数组中，如果一个整数的出现频次和它的数值大小相等，我们就称这个整数为「幸运数」。 给你一个整数数组 arr，请你从中找出并返回一个幸运数。 如果数组中存在多个幸运数，只需返回 最大 的那个。 如果数组中不含幸运数，则返回 -1 。 示例 1：输入：arr = [2,2,3,4] 输出：2 解释：数组中唯一的幸运数是 2 ，因为数值 2 的出现频次也是 2 。 示例 2：输入：arr = [1,2,2,3,3,3] 输出：3 解释：1、2 以及 3 都是幸运数，只需要返回其中最大的 3 。 示例 3：输入：arr = [2,2,2,3,3] 输出：-1 解释：数组中不存在幸运数。 示例 4：输入：arr = [5] 输出：-1 示例 5：输入：arr = [7,7,7,7,7,7,7] 输出：7 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(n) 02 数组辅助 O(n) O(1) func findLucky(arr []int) int { m := make(map[int]int) for i := 0; i = 1; i-- { if res[i] == i { return i } } return -1 } 1399.统计最大组的数目(2) 题目 给你一个整数 n 。请你先求出从 1 到 n 的每个整数 10 进制表示下的数位和（每一位上的数字相加）， 然后把数位和相等的数字放到同一个组中。 请你统计每个组中的数字数目，并返回数字数目并列最多的组有多少个。 示例 1：输入：n = 13 输出：4 解释：总共有 9 个组，将 1 到 13 按数位求和后这些组分别是： [1,10]，[2,11]，[3,12]，[4,13]，[5]，[6]，[7]，[8]，[9]。总共有 4 个组拥有的数字并列最多。 示例 2：输入：n = 2 输出：2 解释：总共有 2 个大小为 1 的组 [1]，[2]。 示例 3：输入：n = 15 输出：6 示例 4：输入：n = 24 输出：5 提示：1 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(nlog(n)) O(1) 02 数组辅助 O(nlog(n)) O(1) func countLargestGroup(n int) int { if n max { max = m[value] } } res := 0 for i := range m { if m[i] == max { res++ } } return res } func sum(n int) int { res := 0 for n > 0 { res = res + n%10 n = n / 10 } return res } # func countLargestGroup(n int) int { if n max { max = arr[value] } } res := 0 for i := range arr { if arr[i] == max { res++ } } return res } func sum(n int) int { res := 0 for n > 0 { res = res + n%10 n = n / 10 } return res } Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-06-28 01:11:13 "},"docs/source/question/1401-1500.html":{"url":"docs/source/question/1401-1500.html","title":"1401-1500","keywords":"","body":"1401-1500-Easy 1401-1500-Easy 1403.非递增顺序的最小子序列(2) 1408.数组中的字符串匹配(3) 1413.逐步求和得到正数的最小值(2) 1417.重新格式化字符串(2) 1422.分割字符串的最大得分(3) 1431.拥有最多糖果的孩子(2) 1436.旅行终点站(4) 1441.用栈操作构建数组(2) 1446.连续字符(2) 1450.在既定时间做作业的学生人数(1) 1455.检查单词是否为句中其他单词的前缀(2) 1460.通过翻转子数组使两个数组相等(3) 1464.数组中两元素的最大乘积(3) 1470.重新排列数组(2) 1475.商品折扣后的最终价格(2) 1480.一维数组的动态和(2) 1486.数组异或操作(1) 1403.非递增顺序的最小子序列(2) 题目 给你一个数组 nums，请你从中抽取一个子序列，满足该子序列的元素之和 严格 大于未包含在该子序列中的各元素之和。 如果存在多个解决方案，只需返回 长度最小 的子序列。如果仍然有多个解决方案，则返回 元素之和最大 的子序列。 与子数组不同的地方在于，「数组的子序列」不强调元素在原数组中的连续性， 也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。 注意，题目数据保证满足所有约束条件的解决方案是 唯一 的。同时，返回的答案应当按 非递增顺序 排列。 示例 1：输入：nums = [4,3,10,9,8] 输出：[10,9] 解释：子序列 [10,9] 和 [10,8] 是最小的、满足元素之和大于其他各元素之和的子序列。 但是 [10,9] 的元素之和最大。 示例 2：输入：nums = [4,4,7,6,7] 输出：[7,7,6] 解释：子序列 [7,7] 的和为 14 ，不严格大于剩下的其他元素之和（14 = 4 + 4 + 6）。 因此，[7,6,7] 是满足题意的最小子序列。注意，元素按非递增顺序返回。 示例 3：输入：nums = [6] 输出：[6] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序遍历 O(nlog(n)) O(n) 02 排序遍历 O(nlog(n)) O(1) func minSubsequence(nums []int) []int { sort.Ints(nums) sum := 0 for i := 0; i = 0; i-- { if sum nums[j] }) sum := 0 for i := 0; i target { return nums[:i+1] } } return nil } 1408.数组中的字符串匹配(3) 题目 给你一个字符串数组 words ，数组中的每个字符串都可以看作是一个单词。 请你按 任意 顺序返回 words 中是其他单词的子字符串的所有单词。 如果你可以删除 words[j] 最左侧和/或最右侧的若干字符得到 word[i] ， 那么字符串 words[i] 就是 words[j] 的一个子字符串。 示例 1：输入：words = [\"mass\",\"as\",\"hero\",\"superhero\"] 输出：[\"as\",\"hero\"] 解释：\"as\" 是 \"mass\" 的子字符串，\"hero\" 是 \"superhero\" 的子字符串。 [\"hero\",\"as\"] 也是有效的答案。 示例 2：输入：words = [\"leetcode\",\"et\",\"code\"] 输出：[\"et\",\"code\"] 解释：\"et\" 和 \"code\" 都是 \"leetcode\" 的子字符串。 示例 3：输入：words = [\"blue\",\"green\",\"bu\"] 输出：[] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历-内置函数 O(n^3) O(n) 02 遍历-内置函数 O(n^3) O(n) 03 排序 O(n^3) O(n) func stringMatching(words []string) []string { res := make([]string, 0) m := make(map[string]bool) for i := 0; i 1413.逐步求和得到正数的最小值(2) 题目 给你一个整数数组 nums 。你可以选定任意的 正数 startValue 作为初始值。 你需要从左到右遍历 nums 数组，并将 startValue 依次累加上 nums 数组中的值。 请你在确保累加和始终大于等于 1 的前提下，选出一个最小的 正数 作为 startValue 。 示例 1：输入：nums = [-3,2,-3,4,2] 输出：5 解释：如果你选择 startValue = 4，在第三次累加时，和小于 1 。 累加求和 startValue = 4 | startValue = 5 | nums (4 -3 ) = 1 | (5 -3 ) = 2 | -3 (1 +2 ) = 3 | (2 +2 ) = 4 | 2 (3 -3 ) = 0 | (4 -3 ) = 1 | -3 (0 +4 ) = 4 | (1 +4 ) = 5 | 4 (4 +2 ) = 6 | (5 +2 ) = 7 | 2 示例 2：输入：nums = [1,2] 输出：1 解释：最小的 startValue 需要是正数。 示例 3：输入：nums = [1,-2,-3] 输出：5 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 遍历 O(n) O(1) func minStartValue(nums []int) int { min := nums[0] sum := nums[0] for i := 1; i = 0 { return 1 } return 1 - min } # func minStartValue(nums []int) int { res := 1 sum := 0 for i := 0; i 1417.重新格式化字符串(2) 题目 给你一个混合了数字和字母的字符串 s，其中的字母均为小写英文字母。 请你将该字符串重新格式化，使得任意两个相邻字符的类型都不同。 也就是说，字母后面应该跟着数字，而数字后面应该跟着字母。 请你返回 重新格式化后 的字符串；如果无法按要求重新格式化，则返回一个 空字符串 。 示例 1：输入：s = \"a0b1c2\" 输出：\"0a1b2c\" 解释：\"0a1b2c\" 中任意两个相邻字符的类型都不同。 \"a0b1c2\", \"0a1b2c\", \"0c2a1b\" 也是满足题目要求的答案。 示例 2：输入：s = \"leetcode\" 输出：\"\" 解释：\"leetcode\" 中只有字母，所以无法满足重新格式化的条件。 示例 3：输入：s = \"1229857369\" 输出：\"\" 解释：\"1229857369\" 中只有数字，所以无法满足重新格式化的条件。 示例 4：输入：s = \"covid2019\" 输出：\"c2o0v1i9d\" 示例 5：输入：s = \"ab123\" 输出：\"1a2b3\" 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(n) 02 遍历 O(n) O(n) func reformat(s string) string { arr := make([]byte, 0) str := make([]byte, 0) res := \"\" for i := 0; i = '0' && s[i] 1 { return res } else { length := len(arr) if len(str) b { return a - b } return b - a } # func reformat(s string) string { res := make([]byte, 0) m1 := make([]byte, 0) m2 := make([]byte, 0) for i := range s { if s[i] >= '0' && s[i] 1422.分割字符串的最大得分(3) 题目 给你一个由若干 0 和 1 组成的字符串 s ， 请你计算并返回将该字符串分割成两个 非空 子字符串（即 左 子字符串和 右 子字符串）所能获得的最大得分。 「分割字符串的得分」为 左 子字符串中 0 的数量加上 右 子字符串中 1 的数量。 示例 1：输入：s = \"011101\" 输出：5 解释： 将字符串 s 划分为两个非空子字符串的可行方案有： 左子字符串 = \"0\" 且 右子字符串 = \"11101\"，得分 = 1 + 4 = 5 左子字符串 = \"01\" 且 右子字符串 = \"1101\"，得分 = 1 + 3 = 4 左子字符串 = \"011\" 且 右子字符串 = \"101\"，得分 = 1 + 2 = 3 左子字符串 = \"0111\" 且 右子字符串 = \"01\"，得分 = 1 + 1 = 2 左子字符串 = \"01110\" 且 右子字符串 = \"1\"，得分 = 2 + 1 = 3 示例 2：输入：s = \"00111\" 输出：5 解释：当 左子字符串 = \"00\" 且 右子字符串 = \"111\" 时，我们得到最大得分 = 2 + 3 = 5 示例 3：输入：s = \"1111\" 输出：3 提示： 2 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 暴力法 O(n^2) O(1) 03 数组辅助 O(n) O(n) func maxScore(s string) int { one := 0 for i := 0; i max { max = one + zero } } return max } # func maxScore(s string) int { max := 0 for i := 0; i max { max = zero + one } } return max } # func maxScore(s string) int { max := 0 arr := make([]int, len(s)+1) for i := 0; i max { max = v } } return max } 1431.拥有最多糖果的孩子(2) 题目 给你一个数组 candies 和一个整数 extraCandies ，其中 candies[i] 代表第 i 个孩子拥有的糖果数目。 对每一个孩子，检查是否存在一种方案，将额外的 extraCandies 个糖果分配给孩子们之后，此孩子有 最多 的糖果。 注意，允许有多个孩子同时拥有 最多 的糖果数目。 示例 1：输入：candies = [2,3,5,1,3], extraCandies = 3 输出：[true,true,true,false,true] 解释： 孩子 1 有 2 个糖果，如果他得到所有额外的糖果（3个），那么他总共有 5 个糖果，他将成为拥有最多糖果的孩子。 孩子 2 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。 孩子 3 有 5 个糖果，他已经是拥有最多糖果的孩子。 孩子 4 有 1 个糖果，即使他得到所有额外的糖果，他也只有 4 个糖果，无法成为拥有糖果最多的孩子。 孩子 5 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。 示例 2：输入：candies = [4,2,1,1,2], extraCandies = 1 输出：[true,false,false,false,false] 解释：只有 1 个额外糖果，所以不管额外糖果给谁，只有孩子 1 可以成为拥有糖果最多的孩子。 示例 3：输入：candies = [12,1,12], extraCandies = 10 输出：[true,false,true] 提示： 2 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历比较 O(n) O(n) 02 暴力法 O(n^2) O(n) func kidsWithCandies(candies []int, extraCandies int) []bool { res := make([]bool, len(candies)) max := 0 for i := 0; i max { max = candies[i] } } for i := 0; i = max { res[i] = true } } return res } # func kidsWithCandies(candies []int, extraCandies int) []bool { res := make([]bool, len(candies)) for i := 0; i 1436.旅行终点站(4) 题目 给你一份旅游线路图，该线路图中的旅行线路用数组 paths 表示， 其中 paths[i] = [cityAi, cityBi] 表示该线路将会从 cityAi 直接前往 cityBi 。 请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市。 题目数据保证线路图会形成一条不存在循环的线路，因此只会有一个旅行终点站。 示例 1： 输入：paths = [[\"London\",\"New York\"],[\"New York\",\"Lima\"],[\"Lima\",\"Sao Paulo\"]] 输出：\"Sao Paulo\" 解释：从 \"London\" 出发，最后抵达终点站 \"Sao Paulo\" 。 本次旅行的路线是 \"London\" -> \"New York\" -> \"Lima\" -> \"Sao Paulo\" 。 示例 2：输入：paths = [[\"B\",\"C\"],[\"D\",\"B\"],[\"C\",\"A\"]] 输出：\"A\" 解释：所有可能的线路是： \"D\" -> \"B\" -> \"C\" -> \"A\". \"B\" -> \"C\" -> \"A\". \"C\" -> \"A\". \"A\". 显然，旅行终点站是 \"A\" 。 示例 3：输入：paths = [[\"A\",\"Z\"]] 输出：\"Z\" 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(n) 02 哈希辅助 O(n) O(n) 03 出入度计算 O(n) O(n) 04 暴力法 O(n^2) O(1) func destCity(paths [][]string) string { m := make(map[string]string) for i := 0; i 1441.用栈操作构建数组(2) 题目 给你一个目标数组 target 和一个整数 n。每次迭代，需要从 list = {1,2,3..., n} 中依序读取一个数字。 请使用下述操作来构建目标数组 target ： Push：从 list 中读取一个新元素， 并将其推入数组中。 Pop：删除数组中的最后一个元素。 如果目标数组构建完成，就停止读取更多元素。 题目数据保证目标数组严格递增，并且只包含 1 到 n 之间的数字。 请返回构建目标数组所用的操作序列。 题目数据保证答案是唯一的。 示例 1：输入：target = [1,3], n = 3 输出：[\"Push\",\"Push\",\"Pop\",\"Push\"] 解释： 读取 1 并自动推入数组 -> [1] 读取 2 并自动推入数组，然后删除它 -> [1] 读取 3 并自动推入数组 -> [1,3] 示例 2：输入：target = [1,2,3], n = 3 输出：[\"Push\",\"Push\",\"Push\"] 示例 3：输入：target = [1,2], n = 4 输出：[\"Push\",\"Push\"] 解释：只需要读取前 2 个数字就可以停止。 示例 4：输入：target = [2,3,4], n = 4 输出：[\"Push\",\"Pop\",\"Push\",\"Push\",\"Push\"] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n) O(n) 02 双指针 O(n) O(n) func buildArray(target []int, n int) []string { res := make([]string, 0) j := 0 for i := 1; i = len(target) { break } if target[j] != i { res = append(res, \"Push\") res = append(res, \"Pop\") } else { res = append(res, \"Push\") j++ } } return res } # func buildArray(target []int, n int) []string { res := make([]string, 0) j := 1 for i := 0; i 1446.连续字符(2) 题目 给你一个字符串 s ，字符串的「能量」定义为：只包含一种字符的最长非空子字符串的长度。 请你返回字符串的能量。 示例 1：输入：s = \"leetcode\" 输出：2 解释：子字符串 \"ee\" 长度为 2 ，只包含字符 'e' 。 示例 2：输入：s = \"abbcccddddeeeeedcba\" 输出：5 解释：子字符串 \"eeeee\" 长度为 5 ，只包含字符 'e' 。 示例 3：输入：s = \"triplepillooooow\" 输出：5 示例 4：输入：s = \"hooraaaaaaaaaaay\" 输出：11 示例 5：输入：s = \"tourist\" 输出：1 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 双指针 O(n) O(1) func maxPower(s string) int { max := 1 count := 1 for i := 1; i max { max = count } } return max } # func maxPower(s string) int { max := 1 left := 0 right := 1 for right max { max = right - left } left = right } right++ } if right-left > max { return right - left } return max } 1450.在既定时间做作业的学生人数(1) 题目 给你两个整数数组 startTime（开始时间）和 endTime（结束时间），并指定一个整数 queryTime 作为查询时间。 已知，第 i 名学生在 startTime[i] 时开始写作业并于 endTime[i] 时完成作业。 请返回在查询时间 queryTime 时正在做作业的学生人数。 形式上，返回能够使 queryTime 处于区间 [startTime[i], endTime[i]]（含）的学生人数。 示例 1：输入：startTime = [1,2,3], endTime = [3,2,7], queryTime = 4 输出：1 解释：一共有 3 名学生。 第一名学生在时间 1 开始写作业，并于时间 3 完成作业，在时间 4 没有处于做作业的状态。 第二名学生在时间 2 开始写作业，并于时间 2 完成作业，在时间 4 没有处于做作业的状态。 第三名学生在时间 3 开始写作业，预计于时间 7 完成作业，这是是唯一一名在时间 4 时正在做作业的学生。 示例 2：输入：startTime = [4], endTime = [4], queryTime = 4 输出：1 解释：在查询时间只有一名学生在做作业。 示例 3：输入：startTime = [4], endTime = [4], queryTime = 5 输出：0 示例 4：输入：startTime = [1,1,1,1], endTime = [1,3,2,4], queryTime = 7 输出：0 示例 5：输入：startTime = [9,8,7,6,5,4,3,2,1], endTime = [10,10,10,10,10,10,10,10,10], queryTime = 5 输出：5 提示： startTime.length == endTime.length 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) func busyStudent(startTime []int, endTime []int, queryTime int) int { res := 0 for i := 0; i = startTime[i] && queryTime 1455.检查单词是否为句中其他单词的前缀(2) 题目 给你一个字符串 sentence 作为句子并指定检索词为 searchWord ，其中句子由若干用 单个空格 分隔的单词组成。 请你检查检索词 searchWord 是否为句子 sentence 中任意单词的前缀。 如果 searchWord 是某一个单词的前缀，则返回句子 sentence 中该单词所对应的下标（下标从 1 开始）。 如果 searchWord 是多个单词的前缀，则返回匹配的第一个单词的下标（最小下标）。 如果 searchWord 不是任何单词的前缀，则返回 -1 。 字符串 S 的 「前缀」是 S 的任何前导连续子字符串。 示例 1：输入：sentence = \"i love eating burger\", searchWord = \"burg\" 输出：4 解释：\"burg\" 是 \"burger\" 的前缀，而 \"burger\" 是句子中第 4 个单词。 示例 2：输入：sentence = \"this problem is an easy problem\", searchWord = \"pro\" 输出：2 解释：\"pro\" 是 \"problem\" 的前缀，而 \"problem\" 是句子中第 2 个也是第 6 个单词， 但是应该返回最小下标 2 。 示例 3：输入：sentence = \"i am tired\", searchWord = \"you\" 输出：-1 解释：\"you\" 不是句子中任何单词的前缀。 示例 4：输入：sentence = \"i use triple pillow\", searchWord = \"pill\" 输出：4 示例 5：输入：sentence = \"hello from the other side\", searchWord = \"they\" 输出：-1 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(n) 02 遍历 O(n) O(n) func isPrefixOfWord(sentence string, searchWord string) int { arr := strings.Split(sentence, \" \") for k, v := range arr { if strings.HasPrefix(v, searchWord) { return k + 1 } } return -1 } # func isPrefixOfWord(sentence string, searchWord string) int { arr := strings.Fields(sentence) for k, v := range arr { if len(v) >= len(searchWord) { if v[:len(searchWord)] == searchWord { return k + 1 } } } return -1 } 1460.通过翻转子数组使两个数组相等(3) 题目 给你两个长度相同的整数数组 target 和 arr 。 每一步中，你可以选择 arr 的任意 非空子数组 并将它翻转。你可以执行此过程任意次。 如果你能让 arr 变得与 target 相同，返回 True；否则，返回 False 。 示例 1：输入：target = [1,2,3,4], arr = [2,4,1,3] 输出：true 解释：你可以按照如下步骤使 arr 变成 target： 1- 翻转子数组 [2,4,1] ，arr 变成 [1,4,2,3] 2- 翻转子数组 [4,2] ，arr 变成 [1,2,4,3] 3- 翻转子数组 [4,3] ，arr 变成 [1,2,3,4] 上述方法并不是唯一的，还存在多种将 arr 变成 target 的方法。 示例 2：输入：target = [7], arr = [7] 输出：true 解释：arr 不需要做任何翻转已经与 target 相等。 示例 3：输入：target = [1,12], arr = [12,1] 输出：true 示例 4：输入：target = [3,7,9], arr = [3,7,11] 输出：false 解释：arr 没有数字 9 ，所以无论如何也无法变成 target 。 示例 5：输入：target = [1,1,1,1,1], arr = [1,1,1,1,1] 输出：true 提示： target.length == arr.length 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序遍历 O(nlog(n)) O(1) 02 数组辅助 O(n) O(1) 03 哈希辅助 O(n) O(1) func canBeEqual(target []int, arr []int) bool { sort.Ints(target) sort.Ints(arr) for i := 0; i 1464.数组中两元素的最大乘积(3) 题目 给你一个整数数组 nums，请你选择数组的两个不同下标 i 和 j，使 (nums[i]-1)*(nums[j]-1) 取得最大值。 请你计算并返回该式的最大值。 示例 1：输入：nums = [3,4,5,2] 输出：12 解释：如果选择下标 i=1 和 j=2（下标从 0 开始），则可以获得最大值， (nums[1]-1)*(nums[2]-1) = (4-1)*(5-1) = 3*4 = 12 。 示例 2：输入：nums = [1,5,4,5] 输出：16 解释：选择下标 i=1 和 j=3（下标从 0 开始），则可以获得最大值 (5-1)*(5-1) = 16 。 示例 3：输入：nums = [3,7] 输出：12 提示： 2 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序遍历 O(nlog(n)) O(1) 02 遍历 O(n) O(1) 03 暴力法 O(n^2) O(1) func maxProduct(nums []int) int { sort.Ints(nums) return (nums[len(nums)-1] - 1) * (nums[len(nums)-2] - 1) } # func maxProduct(nums []int) int { max := math.MinInt32 next := math.MinInt32 for i := 0; i max { next, max = max, nums[i] } else if nums[i] > next { next = nums[i] } } return (max - 1) * (next - 1) } # func maxProduct(nums []int) int { res := 0 for i := 0; i res { res = (nums[i] - 1) * (nums[j] - 1) } } } return res } 1470.重新排列数组(2) 题目 给你一个数组 nums ，数组中有 2n 个元素，按 [x1,x2,...,xn,y1,y2,...,yn] 的格式排列。 请你将数组按 [x1,y1,x2,y2,...,xn,yn] 格式重新排列，返回重排后的数组。 示例 1：输入：nums = [2,5,1,3,4,7], n = 3 输出：[2,3,5,4,1,7] 解释：由于 x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 ，所以答案为 [2,3,5,4,1,7] 示例 2：输入：nums = [1,2,3,4,4,3,2,1], n = 4 输出：[1,4,2,3,3,2,4,1] 示例 3：输入：nums = [1,1,2,2], n = 2 输出：[1,2,1,2] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组辅助 O(n) O(n) 02 前移遍历 O(n^1) O(1) func shuffle(nums []int, n int) []int { res := make([]int,0) for i := 0; i 1475.商品折扣后的最终价格(2) 题目 给你一个数组 prices ，其中 prices[i] 是商店里第 i 件商品的价格。 商店里正在进行促销活动，如果你要买第 i 件商品，那么你可以得到与 prices[j] 相等的折扣， 其中 j 是满足 j > i 且 prices[j] 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历模拟 O(n^2) O(1) 02 栈 O(n) O(n) func finalPrices(prices []int) []int { for i := 0; i 0 { index := stack[len(stack)-1] if prices[i] > prices[index] { break } prices[index] = prices[index] - prices[i] stack = stack[:len(stack)-1] } stack = append(stack, i) } return prices } 1480.一维数组的动态和(2) 题目 给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。 请返回 nums 的动态和。 示例 1：输入：nums = [1,2,3,4] 输出：[1,3,6,10] 解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。 示例 2：输入：nums = [1,1,1,1,1] 输出：[1,2,3,4,5] 解释：动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。 示例 3：输入：nums = [3,1,2,10,1] 输出：[3,4,6,16,17] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 数组辅助 O(n) O(n) func runningSum(nums []int) []int { for i := 1; i 1486.数组异或操作(1) 题目 给你两个整数，n 和 start 。 数组 nums 定义为：nums[i] = start + 2*i（下标从 0 开始）且 n == nums.length 。 请返回 nums 中所有元素按位异或（XOR）后得到的结果。 示例 1：输入：n = 5, start = 0 输出：8 解释：数组 nums 为 [0, 2, 4, 6, 8]，其中 (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8 。 \"^\" 为按位异或 XOR 运算符。 示例 2：输入：n = 4, start = 3 输出：8 解释：数组 nums 为 [3, 5, 7, 9]，其中 (3 ^ 5 ^ 7 ^ 9) = 8. 示例 3：输入：n = 1, start = 7 输出：7 示例 4：输入：n = 10, start = 5 输出：2 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) func xorOperation(n int, start int) int { res := 0 for i := 0; i 1491.去掉最低工资和最高工资后的工资平均值(2) 题目 给你一个整数数组 salary ，数组里每个数都是 唯一 的，其中 salary[i] 是第 i 个员工的工资。 请你返回去掉最低工资和最高工资以后，剩下员工工资的平均值。 示例 1：输入：salary = [4000,3000,1000,2000] 输出：2500.00000 解释：最低工资和最高工资分别是 1000 和 4000 。 去掉最低工资和最高工资以后的平均工资是 (2000+3000)/2= 2500 示例 2：输入：salary = [1000,2000,3000] 输出：2000.00000 解释：最低工资和最高工资分别是 1000 和 3000 。 去掉最低工资和最高工资以后的平均工资是 (2000)/1= 2000 示例 3：输入：salary = [6000,5000,4000,3000,2000,1000] 输出：3500.00000 示例 4：输入：salary = [8000,9000,2000,3000,6000,1000] 输出：4750.00000 提示： 3 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序遍历 O(nlog(n)) O(1) 02 遍历 O(n) O(1) func average(salary []int) float64 { sort.Ints(salary) sum := 0 for i := 1; i max { max = salary[i] } if salary[i] 1496.判断路径是否相交(1) 题目 给你一个字符串 path，其中 path[i] 的值可以是 'N'、'S'、'E' 或者 'W'， 分别表示向北、向南、向东、向西移动一个单位。 机器人从二维平面上的原点 (0, 0) 处开始出发，按 path 所指示的路径行走。 如果路径在任何位置上出现相交的情况，也就是走到之前已经走过的位置，请返回 True ；否则，返回 False 。 示例 1：输入：path = \"NES\" 输出：false 解释：该路径没有在任何位置相交。 示例 2：输入：path = \"NESWW\" 输出：true 解释：该路径经过原点两次。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(n) func isPathCrossing(path string) bool { m := make(map[string]bool) m[\"0,0\"] = true x := 0 y := 0 for i := 0; i 1401-1500-Medium 1418.点菜展示表(1) 题目 给你一个数组 orders，表示客户在餐厅中完成的订单，确切地说， orders[i]=[customerNamei,tableNumberi,foodItemi] ，其中 customerNamei 是客户的姓名， tableNumberi 是客户所在餐桌的桌号，而 foodItemi 是客户点的餐品名称。 请你返回该餐厅的 点菜展示表 。在这张表中，表中第一行为标题，其第一列为餐桌桌号 “Table” ， 后面每一列都是按字母顺序排列的餐品名称。 接下来每一行中的项则表示每张餐桌订购的相应餐品数量，第一列应当填对应的桌号，后面依次填写下单的餐品数量。 注意：客户姓名不是点菜展示表的一部分。此外，表中的数据行应该按餐桌桌号升序排列。 示例 1： 输入：orders = [[\"David\",\"3\",\"Ceviche\"],[\"Corina\",\"10\",\"Beef Burrito\"], [\"David\",\"3\",\"Fried Chicken\"],[\"Carla\",\"5\",\"Water\"], [\"Carla\",\"5\",\"Ceviche\"],[\"Rous\",\"3\",\"Ceviche\"]] 输出：[[\"Table\",\"Beef Burrito\",\"Ceviche\",\"Fried Chicken\",\"Water\"], [\"3\",\"0\",\"2\",\"1\",\"0\"],[\"5\",\"0\",\"1\",\"0\",\"1\"],[\"10\",\"1\",\"0\",\"0\",\"0\"]] 解释：点菜展示表如下所示： Table,Beef Burrito,Ceviche,Fried Chicken,Water 3 ,0 ,2 ,1 ,0 5 ,0 ,1 ,0 ,1 10 ,1 ,0 ,0 ,0 对于餐桌 3：David 点了 \"Ceviche\" 和 \"Fried Chicken\"，而 Rous 点了 \"Ceviche\" 而餐桌 5：Carla 点了 \"Water\" 和 \"Ceviche\" 餐桌 10：Corina 点了 \"Beef Burrito\" 示例 2：输入：orders = [[\"James\",\"12\",\"Fried Chicken\"],[\"Ratesh\",\"12\",\"Fried Chicken\"], [\"Amadeus\",\"12\",\"Fried Chicken\"],[\"Adam\",\"1\",\"Canadian Waffles\"], [\"Brianna\",\"1\",\"Canadian Waffles\"]] 输出：[[\"Table\",\"Canadian Waffles\",\"Fried Chicken\"],[\"1\",\"2\",\"0\"],[\"12\",\"0\",\"3\"]] 解释：对于餐桌 1：Adam 和 Brianna 都点了 \"Canadian Waffles\" 而餐桌 12：James, Ratesh 和 Amadeus 都点了 \"Fried Chicken\" 示例 3： 输入：orders = [[\"Laura\",\"2\",\"Bean Burrito\"],[\"Jhon\",\"2\",\"Beef Burrito\"],[\"Melissa\",\"2\",\"Soda\"]] 输出：[[\"Table\",\"Bean Burrito\",\"Beef Burrito\",\"Soda\"],[\"2\",\"1\",\"1\",\"1\"]] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(nlog(n)) O(n) func displayTable(orders [][]string) [][]string { res := make([][]string, 0) titles := make([]string, 0) idArr := make([]int, 0) m := make(map[string]bool) m2 := make(map[string]map[string]int) for i := 0; i 1442.形成两个异或相等数组的三元组数目(3) 题目 给你一个整数数组 arr 。 现需要从数组中取三个下标 i、j 和 k ，其中 (0 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法 O(n^3) O(1) 02 遍历 O(n^2) O(1) 03 哈希辅助 O(n) O(n) func countTriplets(arr []int) int { res := 0 for i := 1; i 0 { // 相同异或结果，分别出现在下标[a,b,c,d] // 则[a,d]有d-a-1个满足条件的 // sum = (d-a-1)+(d-b-1)+(d-c-1) // ==> nd - [(a+1) + (b+1) + (c+1)] // 同理得[a,b], [a,c] res = res + i*countM[temp] - sumM[temp] } countM[temp]++ sumM[temp] = sumM[temp] + (i + 1) } return res } 1487.保证文件名唯一(2) 题目 给你一个长度为 n 的字符串数组 names 。 你将会在文件系统中创建 n 个文件夹：在第 i 分钟，新建名为 names[i] 的文件夹。 由于两个文件 不能 共享相同的文件名，因此如果新建文件夹使用的文件名已经被占用， 系统会以 (k) 的形式为新文件夹的文件名添加后缀，其中 k 是能保证文件名唯一的 最小正整数 。 返回长度为 n 的字符串数组，其中 ans[i] 是创建第 i 个文件夹时系统分配给该文件夹的实际名称。 示例 1： 输入：names = [\"pes\",\"fifa\",\"gta\",\"pes(2019)\"] 输出：[\"pes\",\"fifa\",\"gta\",\"pes(2019)\"] 解释：文件系统将会这样创建文件名： \"pes\" --> 之前未分配，仍为 \"pes\" \"fifa\" --> 之前未分配，仍为 \"fifa\" \"gta\" --> 之前未分配，仍为 \"gta\" \"pes(2019)\" --> 之前未分配，仍为 \"pes(2019)\" 示例 2： 输入：names = [\"gta\",\"gta(1)\",\"gta\",\"avalon\"] 输出：[\"gta\",\"gta(1)\",\"gta(2)\",\"avalon\"] 解释：文件系统将会这样创建文件名： \"gta\" --> 之前未分配，仍为 \"gta\" \"gta(1)\" --> 之前未分配，仍为 \"gta(1)\" \"gta\" --> 文件名被占用，系统为该名称添加后缀 (k)，由于 \"gta(1)\" 也被占用，所以 k = 2 。 实际创建的文件名为 \"gta(2)\" 。 \"avalon\" --> 之前未分配，仍为 \"avalon\" 示例 3： 输入：names = [\"onepiece\",\"onepiece(1)\",\"onepiece(2)\",\"onepiece(3)\",\"onepiece\"] 输出：[\"onepiece\",\"onepiece(1)\",\"onepiece(2)\",\"onepiece(3)\",\"onepiece(4)\"] 解释：当创建最后一个文件夹时，最小的正有效 k 为 4 ，文件名变为 \"onepiece(4)\"。 示例 4： 输入：names = [\"wano\",\"wano\",\"wano\",\"wano\"] 输出：[\"wano\",\"wano(1)\",\"wano(2)\",\"wano(3)\"] 解释：每次创建文件夹 \"wano\" 时，只需增加后缀中 k 的值即可。 示例 5： 输入：names = [\"kaido\",\"kaido(1)\",\"kaido\",\"kaido(1)\"] 输出：[\"kaido\",\"kaido(1)\",\"kaido(2)\",\"kaido(1)(1)\"] 解释：注意，如果含后缀文件名被占用，那么系统也会按规则在名称后添加新的后缀 (k) 。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助-递归 O(n) O(n) 02 哈希辅助 O(n) O(n) func getFolderNames(names []string) []string { m := make(map[string]int) for i, name := range names { if value, ok := m[name]; ok { names[i] = getName(m, name, value) m[names[i]] = 1 } else { m[name] = 1 } } return names } func getName(m map[string]int, name string, n int) string { newName := name + fmt.Sprintf(\"(%d)\", n) if _, ok := m[newName]; ok { return getName(m, name, n+1) } m[name] = n + 1 return newName } # func getFolderNames(names []string) []string { m := make(map[string]int) res := make([]string, 0) for _, name := range names { if value, ok := m[name]; ok { for { newName := name + fmt.Sprintf(\"(%d)\", value) if _, ok2 := m[newName]; ok2 { value++ continue } res = append(res, newName) m[newName] = 1 m[name] = value break } } else { res = append(res, name) m[name] = 1 } } return res } 1492.n的第k个因子(2) 题目 给你两个正整数 n 和 k 。 如果正整数 i 满足 n % i == 0 ，那么我们就说正整数 i 是整数 n 的因子。 考虑整数 n 的所有因子，将它们 升序排列 。请你返回第 k 个因子。如果 n 的因子数少于 k ，请你返回 -1 。 示例 1：输入：n = 12, k = 3输出：3 解释：因子列表包括 [1, 2, 3, 4, 6, 12]，第 3 个因子是 3 。 示例 2：输入：n = 7, k = 2 输出：7 解释：因子列表包括 [1, 7] ，第 2 个因子是 7 。 示例 3：输入：n = 4, k = 4 输出：-1 解释：因子列表包括 [1, 2, 4] ，只有 3 个因子，所以我们应该返回 -1 。 示例 4：输入：n = 1, k = 1 输出：1 解释：因子列表包括 [1] ，第 1 个因子为 1 。 示例 5：输入：n = 1000, k = 3 输出：4 解释：因子列表包括 [1, 2, 4, 5, 8, 10, 20, 25, 40, 50, 100, 125, 200, 250, 500, 1000] 。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 遍历 O(n^1/2) O(1) func kthFactor(n int, k int) int { count := 0 for i := 1; i 0; i-- { if n%i == 0 { count++ if count == k { return n / i } } } return -1 } 1493.删掉一个元素以后全为 1 的最长子数组(3) 题目 给你一个二进制数组 nums ，你需要从中删掉一个元素。 请你在删掉元素的结果数组中，返回最长的且只包含 1 的非空子数组的长度。 如果不存在这样的子数组，请返回 0 。 提示 1：输入：nums = [1,1,0,1] 输出：3 解释：删掉位置 2 的数后，[1,1,1] 包含 3 个 1 。 示例 2：输入：nums = [0,1,1,1,0,1,1,0,1] 输出：5 解释：删掉位置 4 的数字后，[0,1,1,1,1,1,0,1] 的最长全 1 子数组为 [1,1,1,1,1] 。 示例 3：输入：nums = [1,1,1] 输出：2 解释：你必须要删除一个元素。 示例 4：输入：nums = [1,1,0,0,1,1,1,0,1] 输出：4 示例 5：输入：nums = [0,0,0] 输出：0 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组辅助 O(n) O(n) 02 遍历 O(n) O(1) 03 数组辅助 O(n) O(n) func longestSubarray(nums []int) int { n := len(nums) pre := make([]int, n) suf := make([]int, n) pre[0] = nums[0] for i := 1; i = 0; i-- { if nums[i] == 1 { suf[i] = suf[i+1] + 1 } else { suf[i] = 0 } } res := 0 for i := 0; i res { res = p + s } } return res } # func longestSubarray(nums []int) int { res := 0 p, q := 0, 0 // q=>中间有一个“非1”的和, p=>连续1的和 for i := 0; i res { res = q } } if res == len(nums) { return res - 1 } return res } # func longestSubarray(nums []int) int { arr := make([]int, 0) count := 0 for _, v := range nums { if v == 0 { arr = append(arr, count) count = 0 continue } count++ } arr = append(arr, count) if len(arr) == 1 { return arr[0] - 1 } res := 0 for i := 0; i res { res = arr[i] + arr[i+1] } } return res } Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-07-17 15:47:10 "},"docs/source/question/1501-1600.html":{"url":"docs/source/question/1501-1600.html","title":"1501-1600","keywords":"","body":"1501-1600-Easy 1502.判断能否形成等差数列(2) 题目 给你一个数字数组 arr 。 如果一个数列中，任意相邻两项的差总等于同一个常数，那么这个数列就称为 等差数列 。 如果可以重新排列数组形成等差数列，请返回 true ；否则，返回 false 。 示例 1：输入：arr = [3,5,1] 输出：true 解释：对数组重新排序得到 [1,3,5] 或者 [5,3,1] ，任意相邻两项的差分别为 2 或 -2 ，可以形成等差数列。 示例 2：输入：arr = [1,2,4] 输出：false 解释：无法通过重新排序得到等差数列。 提示： 2 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序遍历 O(nlog(n)) O(1) 02 哈希辅助 O(n) O(n) func canMakeArithmeticProgression(arr []int) bool { sort.Ints(arr) diff := arr[1] - arr[0] for i := 2; i = max { max = arr[i] } m[arr[i]] = true } diff := (max - min) / (len(arr) - 1) for i := 0; i 1507.转变日期格式(1) 题目 给你一个字符串 date ，它的格式为 Day Month Year ，其中： Day 是集合 {\"1st\", \"2nd\", \"3rd\", \"4th\", ..., \"30th\", \"31st\"} 中的一个元素。 Month 是集合 {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"} 中的一个元素。 Year 的范围在 [1900, 2100] 之间。 请你将字符串转变为 YYYY-MM-DD 的格式，其中： YYYY 表示 4 位的年份。 MM 表示 2 位的月份。 DD 表示 2 位的天数。 示例 1：输入：date = \"20th Oct 2052\" 输出：\"2052-10-20\" 示例 2：输入：date = \"6th Jun 1933\" 输出：\"1933-06-06\" 示例 3：输入：date = \"26th May 1960\" 输出：\"1960-05-26\" 提示： 给定日期保证是合法的，所以不需要处理异常输入。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历-内置函数 O(n) O(n) func reformatDate(date string) string { month := []string{\"\", \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"} arr := strings.Split(date, \" \") res := arr[2] + \"-\" for i := 1; i = '0' && arr[0][1] 1512.好数对的数目(3) 题目 给你一个整数数组 nums 。 如果一组数字 (i,j) 满足 nums[i] == nums[j] 且 i 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n^2) O(1) 02 数组辅助 O(n) O(1) 03 哈希辅助 O(n) O(1) func numIdenticalPairs(nums []int) int { res := 0 for i := 0; i 0 { res = res + v*(v-1)/2 } } return res } 1518.换酒问题(2) 题目 小区便利店正在促销，用 numExchange 个空酒瓶可以兑换一瓶新酒。你购入了 numBottles 瓶酒。 如果喝掉了酒瓶中的酒，那么酒瓶就会变成空的。 请你计算 最多 能喝到多少瓶酒。 示例 1：输入：numBottles = 9, numExchange = 3 输出：13 解释：你可以用 3 个空酒瓶兑换 1 瓶酒。 所以最多能喝到 9 + 3 + 1 = 13 瓶酒。 示例 2：输入：numBottles = 15, numExchange = 4 输出：19 解释：你可以用 4 个空酒瓶兑换 1 瓶酒。 所以最多能喝到 15 + 3 + 1 = 19 瓶酒。 示例 3：输入：numBottles = 5, numExchange = 5 输出：6 示例 4：输入：numBottles = 2, numExchange = 3 输出：2 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(log(n)) O(1) 02 计算 O(1) O(1) func numWaterBottles(numBottles int, numExchange int) int { res := numBottles for numBottles > 0 { times := numBottles / numExchange res = res + times numBottles = numBottles%numExchange + times if numBottles 1501-1600-Medium 1508.子数组和排序后的区间和(1) 题目 给你一个数组 nums ，它包含 n 个正整数。你需要计算所有非空连续子数组的和，并将它们按升序排序， 得到一个新的包含 n * (n + 1) / 2 个数字的数组。 请你返回在新数组中下标为 left 到 right （下标从 1 开始）的所有数字和（包括左右端点）。 由于答案可能很大，请你将它对 10^9 + 7 取模后返回。 示例 1：输入：nums = [1,2,3,4], n = 4, left = 1, right = 5 输出：13 解释：所有的子数组和为 1, 3, 6, 10, 2, 5, 9, 3, 7, 4 。 将它们升序排序后，我们得到新的数组 [1, 2, 3, 3, 4, 5, 6, 7, 9, 10] 。 下标从 le = 1 到 ri = 5 的和为 1 + 2 + 3 + 3 + 4 = 13 。 示例 2：输入：nums = [1,2,3,4], n = 4, left = 3, right = 4 输出：6 解释：给定数组与示例 1 一样，所以新数组为 [1, 2, 3, 3, 4, 5, 6, 7, 9, 10] 。 下标从 le = 3 到 ri = 4 的和为 3 + 3 = 6 。 示例 3：输入：nums = [1,2,3,4], n = 4, left = 1, right = 10 输出：50 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法 O(n^2log(n)) O(n^2) func rangeSum(nums []int, n int, left int, right int) int { arr := make([]int, 0) for i := 0; i 1509.三次操作后最大值与最小值的最小差(2) 题目 给你一个数组 nums ，每次操作你可以选择 nums 中的任意一个元素并将它改成任意值。 请你返回三次操作后， nums 中最大值与最小值的差的最小值。 示例 1：输入：nums = [5,3,2,4] 输出：0 解释：将数组 [5,3,2,4] 变成 [2,2,2,2]. 最大值与最小值的差为 2-2 = 0 。 示例 2：输入：nums = [1,5,0,10,14] 输出：1 解释：将数组 [1,5,0,10,14] 变成 [1,1,0,1,1] 。 最大值与最小值的差为 1-0 = 1 。 示例 3：输入：nums = [6,6,0,1,1,4,6] 输出：2 示例 4：输入：nums = [1,5,6,14,15] 输出：1 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序 O(nlog(n)) O(1) 02 排序 O(nlog(n)) O(1) func minDifference(nums []int) int { if len(nums) 1513.仅含1的子串数(2) 题目 给你一个二进制字符串 s（仅由 '0' 和 '1' 组成的字符串）。 返回所有字符都为 1 的子字符串的数目。 由于答案可能很大，请你将它对 10^9 + 7 取模后返回。 示例 1：输入：s = \"0110111\" 输出：9 解释：共有 9 个子字符串仅由 '1' 组成 \"1\" -> 5 次 \"11\" -> 3 次 \"111\" -> 1 次 示例 2：输入：s = \"101\" 输出：2 解释：子字符串 \"1\" 在 s 中共出现 2 次 示例 3：输入：s = \"111111\" 输出：21 解释：每个子字符串都仅由 '1' 组成 示例 4：输入：s = \"000\" 输出：0 提示： s[i] == '0' 或 s[i] == '1' 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 遍历 O(n) O(1) func numSub(s string) int { res := 0 count := 0 for i := 0; i 0 { res = (res + (count+1)*count/2) % 1000000007 } return res } # func numSub(s string) int { res := 0 count := 0 for i := 0; i 1514.概率最大的路径 题目 解题思路 Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 01:35:52 "},"docs/source/question/lcp.html":{"url":"docs/source/question/lcp.html","title":"lcp","keywords":"","body":"LCP LCP LCP01.猜数字(2) LCP02.分式化简(2) LCP06.拿硬币(2) LCP07.传递信息(5) LCP11.期望个数统计(2) LCP01.猜数字(2) 题目 小A 和 小B 在玩猜数字。小B 每次从 1, 2, 3 中随机选择一个，小A 每次也从 1, 2, 3 中选择一个猜。 他们一共进行三次这个游戏，请返回 小A 猜对了几次？ 输入的guess数组为 小A 每次的猜测，answer数组为 小B 每次的选择。 guess和answer的长度都等于3。 示例 1：输入：guess = [1,2,3], answer = [1,2,3] 输出：3 解释：小A 每次都猜对了。 示例 2：输入：guess = [2,2,3], answer = [3,2,1] 输出：1 解释：小A 只猜对了第二次。 限制： guess的长度 = 3 answer的长度 = 3 guess的元素取值为 {1, 2, 3} 之一。 answer的元素取值为 {1, 2, 3} 之一。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(1) O(1) 02 位运算-异或 O(1) O(1) func game(guess []int, answer []int) int { res := 0 for i := 0; i LCP02.分式化简(2) 题目 有一个同学在学习分式。他需要将一个连分数化成最简分数，你能帮助他吗？ 连分数是形如上图的分式。在本题中，所有系数都是大于等于0的整数。 输入的cont代表连分数的系数（cont[0]代表上图的a0，以此类推）。 返回一个长度为2的数组[n, m]，使得连分数的值等于n / m，且n, m最大公约数为1。 示例 1：输入：cont = [3, 2, 0, 2] 输出：[13, 4] 解释：原连分数等价于3 + (1 / (2 + (1 / (0 + 1 / 2))))。注意[26, 8], [-13, -4]都不是正确答案。 示例 2：输入：cont = [0, 0, 3] 输出：[3, 1] 解释：如果答案是整数，令分母为1即可。 限制： cont[i] >= 0 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 递归 O(n) O(n) func fraction(cont []int) []int { n, m := 1, cont[len(cont)-1] for i := len(cont) - 2; i >= 0; i-- { n, m = m, cont[i]*m+n } return []int{m, n} } # func fraction(cont []int) []int { if len(cont) == 1 { return []int{cont[0], 1} } n := fraction(cont[1:]) m := cont[0] return []int{m*n[0] + n[1], n[0]} } LCP03.机器人大冒险(1) 题目 力扣团队买了一个可编程机器人，机器人初始位置在原点(0, 0)。 小伙伴事先给机器人输入一串指令command，机器人就会无限循环这条指令的步骤进行移动。指令有两种： U: 向y轴正方向移动一格 R: 向x轴正方向移动一格。 不幸的是，在 xy 平面上还有一些障碍物，他们的坐标用obstacles表示。机器人一旦碰到障碍物就会被损毁。 给定终点坐标(x, y)，返回机器人能否完好地到达终点。如果能，返回true；否则返回false。 示例 1：输入：command = \"URR\", obstacles = [], x = 3, y = 2 输出：true 解释：U(0, 1) -> R(1, 1) -> R(2, 1) -> U(2, 2) -> R(3, 2)。 示例 2：输入：command = \"URR\", obstacles = [[2, 2]], x = 3, y = 2 输出：false 解释：机器人在到达终点前会碰到(2, 2)的障碍物。 示例 3：输入：command = \"URR\", obstacles = [[4, 2]], x = 3, y = 2 输出：true 解释：到达终点后，再碰到障碍物也不影响返回结果。 限制： 2 解题思路 No. 思路 时间复杂度 空间复杂度 01 数学计算 O(n) O(1) func robot(command string, obstacles [][]int, x int, y int) bool { if judge(command, x, y) == false { return false } for _, node := range obstacles { if x >= node[0] && y >= node[1] && judge(command, node[0], node[1]) { return false } } return true } func judge(command string, x, y int) bool { u := strings.Count(command, \"U\") r := strings.Count(command, \"R\") times := (x + y) / len(command) last := command[:(x+y)%len(command)] uNum := u*times + strings.Count(last, \"U\") rNum := r*times + strings.Count(last, \"R\") if uNum == y && rNum == x { return true } return false } LCP06.拿硬币(2) 题目 桌上有 n 堆力扣币，每堆的数量保存在数组 coins 中。 我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。 示例 1：输入：[4,2,1]输出：4 解释：第一堆力扣币最少需要拿 2 次，第二堆最少需要拿 1 次，第三堆最少需要拿 1 次，总共 4 次即可拿完。 示例 2： 输入：[2,3,10]输出：8 限制： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 内置函数 O(n) O(1) func minCount(coins []int) int { res := 0 for i := 0; i LCP07.传递信息(5) 题目 小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下： 有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0 每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。 传信息的关系是单向的（比如 A 可以向 B 传信息，但 B 不能向 A 传信息）。 每轮信息必须需要传递给另一个人，且信息可重复经过同一个人 给定总玩家数 n，以及按 [玩家编号,对应可传递玩家编号] 关系组成的二维数组 relation。 返回信息从小 A (编号 0 ) 经过 k 轮传递到编号为 n-1 的小伙伴处的方案数；若不能到达，返回 0。 示例 1： 输入：n = 5, relation = [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k = 3 输出：3 解释：信息从小 A 编号 0 处开始，经 3 轮传递，到达编号 4。 共有 3 种方案，分别是 0->2->0->4， 0->2->1->4， 0->2->3->4。 示例 2： 输入：n = 3, relation = [[0,2],[2,1]], k = 2 输出：0 解释：信息不能从小 A 处经过 2 轮传递到编号 2 限制： 2 解题思路 No. 思路 时间复杂度 空间复杂度 01 深度优先搜索 O(n^k) O(n^2) 02 深度优先搜索 O(n^k) O(n) 03 广度优先搜索 O(n^k) O(n^k) 04 动态规划 O(n^2) O(n) 05 动态规划 O(n^2) O(n^2) var ways [][]bool func numWays(n int, relation [][]int, k int) int { ways = make([][]bool, n) for i := range ways { ways[i] = make([]bool, n) } sum := 0 for i := 0; i = n { return 0 } if k == 0 && i == n-1 { return 1 } else { for j := 0; j K { return } for i := 0; i LCP08.剧情触发时间(2) 题目 在战略游戏中，玩家往往需要发展自己的势力来触发各种新的剧情。一个势力的主要属性有三种， 分别是文明等级（C），资源储备（R）以及人口数量（H）。在游戏开始时（第 0 天），三种属性的值均为 0。 随着游戏进程的进行，每一天玩家的三种属性都会对应增加，我们用一个二维数组 increase 来表示每天的增加情况。 这个二维数组的每个元素是一个长度为 3 的一维数组， 例如 [[1,2,1],[3,4,2]] 表示第一天三种属性分别增加 1,2,1 而第二天分别增加 3,4,2。 所有剧情的触发条件也用一个二维数组 requirements 表示。 这个二维数组的每个元素是一个长度为 3 的一维数组，对于某个剧情的触发条件 c[i], r[i], h[i]， 如果当前 C >= c[i] 且 R >= r[i] 且 H >= h[i] ，则剧情会被触发。 根据所给信息，请计算每个剧情的触发时间，并以一个数组返回。 如果某个剧情不会被触发，则该剧情对应的触发时间为 -1 。 示例 1： 输入： increase = [[2,8,4],[2,5,0],[10,9,8]] requirements = [[2,11,3],[15,10,7],[9,17,12],[8,1,14]] 输出: [2,-1,3,-1] 解释： 初始时，C = 0，R = 0，H = 0 第 1 天，C = 2，R = 8，H = 4 第 2 天，C = 4，R = 13，H = 4，此时触发剧情 0 第 3 天，C = 14，R = 22，H = 12，此时触发剧情 2 剧情 1 和 3 无法触发。 示例 2： 输入： increase = [[0,4,5],[4,8,8],[8,6,1],[10,10,0]] requirements = [[12,11,16],[20,2,6],[9,2,6],[10,18,3],[8,14,9]] 输出: [-1,4,3,3,3] 示例 3：输入： increase = [[1,1,1]] requirements = [[0,0,0]] 输出: [0] 限制： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 二分查找 O(nlog(n)) O(n) 02 内置函数 O(nlog(n)) O(n) func getTriggerTime(increase [][]int, requirements [][]int) []int { for i := 1; i increase[len(increase)-1][0] || R > increase[len(increase)-1][1] || H > increase[len(increase)-1][2] { res[i] = -1 continue } left, right := 0, len(increase)-1 index := -1 for left = C && increase[mid][1] >= R && increase[mid][2] >= H { index = mid + 1 right = mid - 1 } else { left = mid + 1 } } res[i] = index } return res } # func getTriggerTime(increase [][]int, requirements [][]int) []int { for i := 1; i increase[len(increase)-1][0] || R > increase[len(increase)-1][1] || H > increase[len(increase)-1][2] { res[i] = -1 continue } index := sort.Search(len(increase), func(j int) bool { return increase[j][0] >= requirements[i][0] && increase[j][1] >= requirements[i][1] && increase[j][2] >= requirements[i][2] }) if index == len(increase) { index = -2 } res[i] = index + 1 } return res } LCP11.期望个数统计(2) 题目 某互联网公司一年一度的春招开始了，一共有 n 名面试者入选。 每名面试者都会提交一份简历，公司会根据提供的简历资料产生一个预估的能力值，数值越大代表越有可能通过面试。 小 A 和小 B 负责审核面试者，他们均有所有面试者的简历，并且将各自根据面试者能力值从大到小的顺序浏览。 由于简历事先被打乱过，能力值相同的简历的出现顺序是从它们的全排列中等可能地取一个。 现在给定 n 名面试者的能力值 scores， 设 X 代表小 A 和小 B 的浏览顺序中出现在同一位置的简历数，求 X 的期望。 提示：离散的非负随机变量的期望计算公式为 1。在本题中，由于 X 的取值为 0 到 n 之间，期望计算公式可以是 2。 示例 1： 输入：scores = [1,2,3] 输出：3 解释：由于面试者能力值互不相同，小 A 和小 B 的浏览顺序一定是相同的。X的期望是 3 。 示例 2：输入：scores = [1,1] 输出：1 解释：设两位面试者的编号为 0, 1。 由于他们的能力值都是 1，小 A 和小 B 的浏览顺序都为从全排列 [[0,1],[1,0]] 中等可能地取一个。 如果小 A 和小 B 的浏览顺序都是 [0,1] 或者 [1,0] ，那么出现在同一位置的简历数为 2 ，否则是 0 。 所以 X 的期望是 (2+0+2+0) * 1/4 = 1 示例 3：输入：scores = [1,1,2] 输出：2 限制： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(n) 02 排序遍历 O(nlog(n)) O(1) func expectNumber(scores []int) int { m := make(map[int]bool) for i := 0; i LCP12.小张刷题计划(2) 题目 为了提高自己的代码能力，小张制定了 LeetCode 刷题计划，他选中了 LeetCode 题库中的 n 道题， 编号从 0 到 n-1，并计划在 m 天内按照题目编号顺序刷完所有的题目（注意，小张不能用多天完成同一题）。 在小张刷题计划中，小张需要用 time[i] 的时间完成编号 i 的题目。此外，小张还可以使用场外求助功能， 通过询问他的好朋友小杨题目的解法，可以省去该题的做题时间。为了防止“小张刷题计划”变成“小杨刷题计划”， 小张每天最多使用一次求助。 我们定义 m 天中做题时间最多的一天耗时为 T（小杨完成的题目不计入做题总时间）。 请你帮小张求出最小的 T是多少。 示例 1： 输入：time = [1,2,3,3], m = 2 输出：3 解释：第一天小张完成前三题，其中第三题找小杨帮忙；第二天完成第四题，并且找小杨帮忙。 这样做题时间最多的一天花费了 3 的时间，并且这个值是最小的。 示例 2：输入：time = [999,999,999], m = 4 输出：0 解释：在前三天中，小张每天求助小杨一次，这样他可以在三天内完成所有的题目并不花任何时间。 限制： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 二分查找 O(nlog(n)) O(1) 02 二分查找 O(nlog(n)) O(1) func minTime(time []int, m int) int { left, right, mid := 0, 0, 0 for i := 0; i maxValue { maxValue = arr[i] } if sum-maxValue > mid { count++ if count >= m { return false } sum = arr[i] maxValue = arr[i] } } return true } # func minTime(time []int, m int) int { left, right, mid := 0, 0, 0 for i := 0; i maxValue { maxValue = arr[i] } if sum-maxValue > mid { sum = arr[i] maxValue = arr[i] res++ } } return res } Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-07-18 05:26:13 "},"docs/source/question/mysql.html":{"url":"docs/source/question/mysql.html","title":"mysql","keywords":"","body":"mysql mysql 175.组合两个表(2) 176.第二高的薪水(3) 181.超过经理收入的员工(3) 182.查找重复的电子邮箱(2) 183.从不订购的客户(3) 193.删除重复的电子邮箱(2) 197.上升的温度(4) 595.大的国(2) 596.超过5名学生的课(2) 620.有趣的电影(2) 627.交换工资(3) 1179.重新格式化部门表(2) 175.组合两个表(2) 题目 SQL架构 Create table Person (PersonId int, FirstName varchar(255), LastName varchar(255)) Create table Address (AddressId int, PersonId int, City varchar(255), State varchar(255)) Truncate table Person insert into Person (PersonId, LastName, FirstName) values ('1', 'Wang', 'Allen') Truncate table Address insert into Address (AddressId, PersonId, City, State) values ('1', '2', 'New York City', 'New York') 表1: Person +-------------+---------+ | 列名 | 类型 | +-------------+---------+ | PersonId | int | | FirstName | varchar | | LastName | varchar | +-------------+---------+ PersonId 是上表主键 表2: Address +-------------+---------+ | 列名 | 类型 | +-------------+---------+ | AddressId | int | | PersonId | int | | City | varchar | | State | varchar | +-------------+---------+ AddressId 是上表主键 编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息： FirstName, LastName, City, State 解题思路 No. 思路 01 考察join的基本使用 02 考察join的基本使用 select FirstName, LastName, City, State from Person left join Address on Person.PersonId = Address.PersonId # select A.FirstName, A.LastName, B.City, B.State from Person A left join (select distinct PersonId, City, State from Address) B on A.PersonId=B.PersonId; 176.第二高的薪水(3) 题目 SQL架构 Create table If Not Exists Employee (Id int, Salary int) Truncate table Employee insert into Employee (Id, Salary) values ('1', '100') insert into Employee (Id, Salary) values ('2', '200') insert into Employee (Id, Salary) values ('3', '300') 编写一个 SQL 查询，获取 Employee 表中第二高的薪水（Salary） 。 +----+--------+ | Id | Salary | +----+--------+ | 1 | 100 | | 2 | 200 | | 3 | 300 | +----+--------+ 例如上述 Employee 表，SQL查询应该返回 200 作为第二高的薪水。 如果不存在第二高的薪水，那么查询应返回 null。 +---------------------+ | SecondHighestSalary | +---------------------+ | 200 | +---------------------+ 解题思路 No. 思路 01 把select语句包起来，使空的时候为null 02 使用ifnull 03 先查出最大的，然后查出比最大小的 select( select distinct Salary from Employee order by Salary desc limit 1 offset 1 ) as SecondHighestSalary; # select ifnull( (select distinct Salary from Employee order by Salary desc limit 1 offset 1),null ) as SecondHighestSalary; # select max(Salary) as SecondHighestSalary from Employee where Salary 181.超过经理收入的员工(3) 题目 SQL架构 Create table If Not Exists Employee (Id int, Name varchar(255), Salary int, ManagerId int) Truncate table Employee insert into Employee (Id, Name, Salary, ManagerId) values ('1', 'Joe', '70000', '3') insert into Employee (Id, Name, Salary, ManagerId) values ('2', 'Henry', '80000', '4') insert into Employee (Id, Name, Salary, ManagerId) values ('3', 'Sam', '60000', 'None') insert into Employee (Id, Name, Salary, ManagerId) values ('4', 'Max', '90000', 'None') Employee 表包含所有员工，他们的经理也属于员工。 每个员工都有一个 Id，此外还有一列对应员工的经理的 Id。 +----+-------+--------+-----------+ | Id | Name | Salary | ManagerId | +----+-------+--------+-----------+ | 1 | Joe | 70000 | 3 | | 2 | Henry | 80000 | 4 | | 3 | Sam | 60000 | NULL | | 4 | Max | 90000 | NULL | +----+-------+--------+-----------+ 给定 Employee 表，编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名。 在上面的表格中，Joe 是唯一一个收入超过他的经理的员工。 +----------+ | Employee | +----------+ | Joe | +----------+ 解题思路 No. 思路 01 使用笛卡尔乘积，和方法2一样 02 使用内链接 03 子查询 SELECT a.Name AS 'Employee' FROM Employee AS a, Employee AS b WHERE a.ManagerId = b.Id AND a.Salary > b.Salary; # SELECT a.Name AS 'Employee' FROM Employee AS a join Employee AS b on a.ManagerId = b.Id AND a.Salary > b.Salary; # select name as Employee from employee a where salary > (select salary from employee where a.managerid = id); 182.查找重复的电子邮箱(2) 题目 SQL架构 Create table If Not Exists Person (Id int, Email varchar(255)) Truncate table Person insert into Person (Id, Email) values ('1', 'a@b.com') insert into Person (Id, Email) values ('2', 'c@d.com') insert into Person (Id, Email) values ('3', 'a@b.com') 编写一个 SQL 查询，查找 Person 表中所有重复的电子邮箱。 示例： +----+---------+ | Id | Email | +----+---------+ | 1 | a@b.com | | 2 | c@d.com | | 3 | a@b.com | +----+---------+ 根据以上输入，你的查询应返回以下结果： +---------+ | Email | +---------+ | a@b.com | +---------+ 说明：所有电子邮箱都是小写字母。 解题思路 No. 思路 01 使用临时表 02 使用having子句 select Email from ( select Email, count(Email) as num from Person Group by Email ) as temp_table where num > 1; // select Email from Person group by Email having count(Email) > 1; 183.从不订购的客户(3) 题目 SQL架构 Create table If Not Exists Customers (Id int, Name varchar(255)) Create table If Not Exists Orders (Id int, CustomerId int) Truncate table Customers insert into Customers (Id, Name) values ('1', 'Joe') insert into Customers (Id, Name) values ('2', 'Henry') insert into Customers (Id, Name) values ('3', 'Sam') insert into Customers (Id, Name) values ('4', 'Max') Truncate table Orders insert into Orders (Id, CustomerId) values ('1', '3') insert into Orders (Id, CustomerId) values ('2', '1') 某网站包含两个表，Customers 表和 Orders 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。 Customers 表： +----+-------+ | Id | Name | +----+-------+ | 1 | Joe | | 2 | Henry | | 3 | Sam | | 4 | Max | +----+-------+ Orders 表： +----+------------+ | Id | CustomerId | +----+------------+ | 1 | 3 | | 2 | 1 | +----+------------+ 例如给定上述表格，你的查询应返回： +-----------+ | Customers | +-----------+ | Henry | | Max | +-----------+ 解题思路 No. 思路 01 使用not in 02 左连接 03 使用not exists select Customers.Name as Customers from Customers where Customers.Id not in ( select CustomerId from Orders ); # select a.Name as Customers from Customers as a left join Orders as b on a.Id=b.CustomerId where b.CustomerId is null; # select name Customers from customers c where not exists ( select 1 from orders o where o.customerid=c.id ) 193.删除重复的电子邮箱(2) 题目 编写一个 SQL 查询，来删除 Person 表中所有重复的电子邮箱，重复的邮箱里只保留 Id 最小 的那个。 +----+------------------+ | Id | Email | +----+------------------+ | 1 | john@example.com | | 2 | bob@example.com | | 3 | john@example.com | +----+------------------+ Id 是这个表的主键。 例如，在运行你的查询语句之后，上面的 Person 表应返回以下几行: +----+------------------+ | Id | Email | +----+------------------+ | 1 | john@example.com | | 2 | bob@example.com | +----+------------------+ 提示： 执行 SQL 之后，输出是整个 Person 表。 使用 delete 语句。 解题思路 No. 思路 01 使用delete+自连接 02 使用delete，根据group by和min()查询出最小的id # delete p1 from Person p1, Person P2 where p1.Email = p2.Email and p1.Id > p2.Id # delete from Person where id not in ( select id from ( select min(id) as id from Person group by Email ) as temp_table ) 197.上升的温度(4) 题目 SQL架构 Create table If Not Exists Weather (Id int, RecordDate date, Temperature int) Truncate table Weather insert into Weather (Id, RecordDate, Temperature) values ('1', '2015-01-01', '10') insert into Weather (Id, RecordDate, Temperature) values ('2', '2015-01-02', '25') insert into Weather (Id, RecordDate, Temperature) values ('3', '2015-01-03', '20') insert into Weather (Id, RecordDate, Temperature) values ('4', '2015-01-04', '30') 给定一个 Weather 表，编写一个 SQL 查询，来查找与之前（昨天的）日期相比温度更高的所有日期的 Id。 +---------+------------------+------------------+ | Id(INT) | RecordDate(DATE) | Temperature(INT) | +---------+------------------+------------------+ | 1 | 2015-01-01 | 10 | | 2 | 2015-01-02 | 25 | | 3 | 2015-01-03 | 20 | | 4 | 2015-01-04 | 30 | +---------+------------------+------------------+ 例如，根据上述给定的 Weather 表格，返回如下 Id: +----+ | Id | +----+ | 2 | | 4 | +----+ 解题思路 No. 思路 01 自连接和datediff()的使用 02 自连接和adddate()的使用 03 自连接和unix_timestamp()的使用 04 自连接和subdate()的使用 # select A.Id as \"Id\" from Weather A join Weather B on datediff(A.RecordDate, B.RecordDate) = 1 and A.Temperature > B.Temperature # select A.Id as \"Id\" from Weather A join Weather B on A.Temperature > B.Temperature and A.RecordDate = adddate(B.RecordDate, 1) # select A.Id as \"Id\" from Weather A join Weather B on unix_timestamp(A.RecordDate) = unix_timestamp(B.RecordDate) + 86400 and A.Temperature > B.Temperature # select A.Id as \"Id\" from Weather A join Weather B on A.Temperature > B.Temperature and B.RecordDate = subdate(A.RecordDate, 1) 595.大的国(2) 题目 Create table If Not Exists World (name varchar(255), continent varchar(255), area int, population int, gdp int) Truncate table World insert into World (name, continent, area, population, gdp) values ('Afghanistan', 'Asia', '652230', '25500100', '20343000000') insert into World (name, continent, area, population, gdp) values ('Albania', 'Europe', '28748', '2831741', '12960000000') insert into World (name, continent, area, population, gdp) values ('Algeria', 'Africa', '2381741', '37100000', '188681000000') insert into World (name, continent, area, population, gdp) values ('Andorra', 'Europe', '468', '78115', '3712000000') insert into World (name, continent, area, population, gdp) values ('Angola', 'Africa', '1246700', '20609294', '100990000000') 这里有张 World 表 +-----------------+------------+------------+--------------+---------------+ | name | continent | area | population | gdp | +-----------------+------------+------------+--------------+---------------+ | Afghanistan | Asia | 652230 | 25500100 | 20343000 | | Albania | Europe | 28748 | 2831741 | 12960000 | | Algeria | Africa | 2381741 | 37100000 | 188681000 | | Andorra | Europe | 468 | 78115 | 3712000 | | Angola | Africa | 1246700 | 20609294 | 100990000 | +-----------------+------------+------------+--------------+---------------+ 如果一个国家的面积超过300万平方公里，或者人口超过2500万，那么这个国家就是大国家。 编写一个SQL查询，输出表中所有大国家的名称、人口和面积。 例如，根据上表，我们应该输出: +--------------+-------------+--------------+ | name | population | area | +--------------+-------------+--------------+ | Afghanistan | 25500100 | 652230 | | Algeria | 37100000 | 2381741 | +--------------+-------------+--------------+ 解题思路 No. 思路 01 or的使用 02 union的使用 select name, population, area from world where area > 3000000 or population > 25000000 # # or具有全表扫描机制 # union具有索引列查询速度快 # Union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序； # Union All：对两个结果集进行并集操作，包括重复行，不进行排序； select name, population, area from world where area > 3000000 union select name, population, area from world where population > 25000000 596.超过5名学生的课(2) 题目 Create table If Not Exists courses (student varchar(255), class varchar(255)) Truncate table courses insert into courses (student, class) values ('A', 'Math') insert into courses (student, class) values ('B', 'English') insert into courses (student, class) values ('C', 'Math') insert into courses (student, class) values ('D', 'Biology') insert into courses (student, class) values ('E', 'Math') insert into courses (student, class) values ('F', 'Computer') insert into courses (student, class) values ('G', 'Math') insert into courses (student, class) values ('H', 'Math') insert into courses (student, class) values ('I', 'Math') 有一个courses 表 ，有: student (学生) 和 class (课程)。 请列出所有超过或等于5名学生的课。 例如,表: +---------+------------+ | student | class | +---------+------------+ | A | Math | | B | English | | C | Math | | D | Biology | | E | Math | | F | Computer | | G | Math | | H | Math | | I | Math | +---------+------------+ 应该输出: +---------+ | class | +---------+ | Math | +---------+ Note: 学生在每个课中不应被重复计算。 解题思路 No. 思路 01 group by + having 02 group by + 临时表 select class from courses group by class having count(distinct student) >= 5 # select class from (select class, count(distinct student) as num from courses group by class) as temp_table where num >= 5 620.有趣的电影(2) 题目 Create table If Not Exists cinema (id int, movie varchar(255), description varchar(255), rating float(2, 1)) Truncate table cinema insert into cinema (id, movie, description, rating) values ('1', 'War', 'great 3D', '8.9') insert into cinema (id, movie, description, rating) values ('2', 'Science', 'fiction', '8.5') insert into cinema (id, movie, description, rating) values ('3', 'irish', 'boring', '6.2') insert into cinema (id, movie, description, rating) values ('4', 'Ice song', 'Fantacy', '8.6') insert into cinema (id, movie, description, rating) values ('5', 'House card', 'Interesting', '9.1') 某城市开了一家新的电影院，吸引了很多人过来看电影。 该电影院特别注意用户体验，专门有个 LED显示板做电影推荐，上面公布着影评和相关电影描述。 作为该电影院的信息部主管，您需要编写一个 SQL查询， 找出所有影片描述为非 boring (不无聊) 的并且 id 为奇数 的影片，结果请按等级 rating 排列。 例如，下表 cinema: +---------+-----------+--------------+-----------+ | id | movie | description | rating | +---------+-----------+--------------+-----------+ | 1 | War | great 3D | 8.9 | | 2 | Science | fiction | 8.5 | | 3 | irish | boring | 6.2 | | 4 | Ice song | Fantacy | 8.6 | | 5 | House card| Interesting| 9.1 | +---------+-----------+--------------+-----------+ 对于上面的例子，则正确的输出是为： +---------+-----------+--------------+-----------+ | id | movie | description | rating | +---------+-----------+--------------+-----------+ | 5 | House card| Interesting| 9.1 | | 1 | War | great 3D | 8.9 | +---------+-----------+--------------+-----------+ 解题思路 No. 思路 01 mod的使用 02 常用操作 select * from cinema where mod(id,2)=1 and description != 'boring' order by rating desc # select * from cinema where id%2=1 and description != 'boring' order by rating desc 627.交换工资(3) 题目 create table if not exists salary(id int, name varchar(100), sex char(1), salary int) Truncate table salary insert into salary (id, name, sex, salary) values ('1', 'A', 'm', '2500') insert into salary (id, name, sex, salary) values ('2', 'B', 'f', '1500') insert into salary (id, name, sex, salary) values ('3', 'C', 'm', '5500') insert into salary (id, name, sex, salary) values ('4', 'D', 'f', '500') 给定一个 salary 表，如下所示，有 m = 男性 和 f = 女性 的值。 交换所有的 f 和 m 值（例如，将所有 f 值更改为 m，反之亦然）。 要求只使用一个更新（Update）语句，并且没有中间的临时表。 注意，您必只能写一个 Update 语句，请不要编写任何 Select 语句。 例如： | id | name | sex | salary | |----|------|-----|--------| | 1 | A | m | 2500 | | 2 | B | f | 1500 | | 3 | C | m | 5500 | | 4 | D | f | 500 | 运行你所编写的更新语句之后，将会得到以下表: | id | name | sex | salary | |----|------|-----|--------| | 1 | A | f | 2500 | | 2 | B | m | 1500 | | 3 | C | f | 5500 | | 4 | D | m | 500 | 解题思路 No. 思路 01 update+case 02 update+if 03 update+ascii互转 update salary set sex= CASE sex when 'm' then 'f' else 'm' END # update salary set sex=if(sex='f','m','f') # update salary set sex=char(ascii('m')+ascii('f')-ascii(sex)) 1179.重新格式化部门表(2) 题目 部门表 Department： Create table If Not Exists Department (id int, revenue int, month varchar(5)) Truncate table Department insert into Department (id, revenue, month) values ('1', '8000', 'Jan') insert into Department (id, revenue, month) values ('2', '9000', 'Jan') insert into Department (id, revenue, month) values ('3', '10000', 'Feb') insert into Department (id, revenue, month) values ('1', '7000', 'Feb') insert into Department (id, revenue, month) values ('1', '6000', 'Mar') +---------------+---------+ | Column Name | Type | +---------------+---------+ | id | int | | revenue | int | | month | varchar | +---------------+---------+ (id, month) 是表的联合主键。 这个表格有关于每个部门每月收入的信息。 月份（month）可以取下列值 [\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"]。 编写一个 SQL 查询来重新格式化表，使得新的表中有一个部门 id 列和一些对应 每个月 的收入（revenue）列。 查询结果格式如下面的示例所示： Department 表： +------+---------+-------+ | id | revenue | month | +------+---------+-------+ | 1 | 8000 | Jan | | 2 | 9000 | Jan | | 3 | 10000 | Feb | | 1 | 7000 | Feb | | 1 | 6000 | Mar | +------+---------+-------+ 查询得到的结果表： +------+-------------+-------------+-------------+-----+-------------+ | id | Jan_Revenue | Feb_Revenue | Mar_Revenue | ... | Dec_Revenue | +------+-------------+-------------+-------------+-----+-------------+ | 1 | 8000 | 7000 | 6000 | ... | null | | 2 | 9000 | null | null | ... | null | | 3 | null | 10000 | null | ... | null | +------+-------------+-------------+-------------+-----+-------------+ 注意，结果表有 13 列 (1个部门 id 列 + 12个月份的收入列)。 解题思路 No. 思路 01 group by+case when then end+sum/max 02 group by+if+sum/max select id, sum(case month when 'Jan' then revenue end) Jan_Revenue, sum(case month when 'Feb' then revenue end) Feb_Revenue, sum(case month when 'Mar' then revenue end) Mar_Revenue, sum(case month when 'Apr' then revenue end) Apr_Revenue, sum(case month when 'May' then revenue end) May_Revenue, sum(case month when 'Jun' then revenue end) Jun_Revenue, sum(case month when 'Jul' then revenue end) Jul_Revenue, sum(case month when 'Aug' then revenue end) Aug_Revenue, sum(case month when 'Sep' then revenue end) Sep_Revenue, sum(case month when 'Oct' then revenue end) Oct_Revenue, sum(case month when 'Nov' then revenue end) Nov_Revenue, sum(case month when 'Dec' then revenue end) Dec_Revenue from department group by id; # select id, sum(if(`month` = 'Jan', revenue, null)) as \"Jan_Revenue\", sum(if(`month` = 'Feb', revenue, null)) as \"Feb_Revenue\", sum(if(`month` = 'Mar', revenue, null)) as \"Mar_Revenue\", sum(if(`month` = 'Apr', revenue, null)) as \"Apr_Revenue\", sum(if(`month` = 'May', revenue, null)) as \"May_Revenue\", sum(if(`month` = 'Jun', revenue, null)) as \"Jun_Revenue\", sum(if(`month` = 'Jul', revenue, null)) as \"Jul_Revenue\", sum(if(`month` = 'Aug', revenue, null)) as \"Aug_Revenue\", sum(if(`month` = 'Sep', revenue, null)) as \"Sep_Revenue\", sum(if(`month` = 'Oct', revenue, null)) as \"Oct_Revenue\", sum(if(`month` = 'Nov', revenue, null)) as \"Nov_Revenue\", sum(if(`month` = 'Dec', revenue, null)) as \"Dec_Revenue\" from Department group by id; Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-06-28 01:11:13 "},"docs/source/question/bash.html":{"url":"docs/source/question/bash.html","title":"bash","keywords":"","body":"Bash Bash 193.有效电话号码(4) 195. 第十行(4) 193.有效电话号码(4) 题目 给定一个包含电话号码列表（一行一个电话号码）的文本文件 file.txt， 写一个 bash 脚本输出所有有效的电话号码。 你可以假设一个有效的电话号码必须满足以下两种格式： (xxx) xxx-xxxx 或 xxx-xxx-xxxx。（x 表示一个数字） 你也可以假设每行前后没有多余的空格字符。 示例: 假设 file.txt 内容如下： 987-123-4567 123 456 7890 (123) 456-7890 你的脚本应当输出下列有效的电话号码： 987-123-4567 (123) 456-7890 解题思路分析 No. 思路 01 正则表达式_cat_grep 02 正则表达式_grep 03 正则表达式_awk 04 正则表达式_grep # 正则表达式_cat_grep # (xxx) xxx-xxxx 或 xxx-xxx-xxxx # ^\\([0-9]{3}\\) [0-9]{3}-[0-9]{4}$ (xxx) xxx-xxxx # ^[0-9]{3}-[0-9]{3}-[0-9]{4}$ xxx-xxx-xxxx # grep -P 匹配正则 cat file.txt | grep -P \"^\\([0-9]{3}\\) [0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}$\" # (xxx) xxx-xxxx 或 xxx-xxx-xxxx grep -P \"^([0-9]{3}-|\\([0-9]{3}\\) )[0-9]{3}-[0-9]{4}$\" file.txt grep -E \"^([0-9]{3}-|\\([0-9]{3}\\) )[0-9]{3}-[0-9]{4}$\" file.txt # awk \"/^([0-9]{3}-|\\([0-9]{3}\\) )[0-9]{3}-[0-9]{4}$/\" file.txt # grep -P \"^(\\d{3}-|\\(\\d{3}\\) )\\d{3}-\\d{4}$\" file.txt 195. 第十行(4) 题目 给定一个文本文件 file.txt，请只打印这个文件中的第十行。 示例: 假设 file.txt 有如下内容： Line 1 Line 2 Line 3 Line 4 Line 5 Line 6 Line 7 Line 8 Line 9 Line 10 你的脚本应当显示第十行： Line 10 说明: 1. 如果文件少于十行，你应当输出什么？ 2. 至少有三种不同的解法，请尝试尽可能多的方法来解题。 解题思路分析 No. 思路 01 awk NR 02 tail head 03 sed # awk 'NR==10' file.txt # tail -n +10 file.txt | head -1 # sed -n 10p file.txt Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-04-09 17:47:55 "},"docs/source/question/offer.html":{"url":"docs/source/question/offer.html","title":"剑指offer","keywords":"","body":"剑指offer 剑指offer 参考资料 面试题03.数组中重复的数字(6) 面试题04.二维数组中的查找(6) 面试题05.替换空格(2) 面试题06.从尾到头打印链表(5) 面试题07.重建二叉树(3) 面试题09.用两个栈实现队列(1) 面试题10- I.斐波那契数列(5) 面试题10-II.青蛙跳台阶问题(3) 面试题11.旋转数组的最小数字(4) 面试题12.矩阵中的路径(2) 面试题13.机器人的运动范围(3) 面试题14- I.剪绳子(2) 面试题14-II.剪绳子 II(2) 面试题15.二进制中1的个数(4) 面试题16.数值的整数次方(2) 面试题17.打印从1到最大的n位数(4) 面试题18.删除链表的节点(2) 面试题19.正则表达式匹配(2) 面试题20.表示数值的字符串(1) 面试题21.调整数组顺序使奇数位于偶数前面(4) 面试题22.链表中倒数第k个节点(5) 面试题24.反转链表(4) 面试题25.合并两个排序的链表(3) 面试题26.树的子结构(2) 面试题27.二叉树的镜像(2) 面试题28.对称的二叉树(2) 面试题29.顺时针打印矩阵(2) 面试题30.包含min函数的栈(2) 面试题31.栈的压入弹出序列(2) 面试题32-I.从上到下打印二叉树(2) 面试题32-II.从上到下打印二叉树II(2) 面试题32-III.从上到下打印二叉树III(2) 面试题33.二叉搜索树的后序遍历序列(3) 面试题34.二叉树中和为某一值的路径(2) 面试题35.复杂链表的复制(3) 面试题38.字符串的排列(2) 面试题39.数组中出现次数超过一半的数字(5) 面试题40.最小的k个数(4) 面试题41.数据流中的中位数(1) 面试题42.连续子数组的最大和(4) 面试题43.1～n整数中1出现的次数(3) 面试题44.数字序列中某一位的数字(2) 面试题45.把数组排成最小的数(3) 面试题46.把数字翻译成字符串(4) 面试题47.礼物的最大价值(2) 面试题48.最长不含重复字符的子字符串(4) 面试题49.丑数(1) 面试题50.第一个只出现一次的字符(3) 面试题51.数组中的逆序对(1) 面试题52.两个链表的第一个公共节点(4) 面试题53-I.在排序数组中查找数字I(5) 面试题53-II.0～n-1中缺失的数字(6) 面试题54.二叉搜索树的第k大节点(3) 面试题55-I.二叉树的深度(2) 面试题55-II.平衡二叉树(2) 面试题56-I.数组中数字出现的次数(5) 面试题56-II.数组中数字出现的次数II(5) 面试题57.和为s的两个数字(2) 面试题57-II.和为s的连续正数序列(4) 面试题58-I.翻转单词顺序(3) 面试题58-II.左旋转字符串(2) 面试题59-I.滑动窗口的最大值(4) 面试题59-II.队列的最大值(2) 面试题60.n个骰子的点数(2) 面试题61.扑克牌中的顺子(3) 面试题62.圆圈中最后剩下的数字(2) 面试题63.股票的最大利润(3) 面试题64.求1 2 … n(2) 面试题65.不用加减乘除做加法(2) 面试题66.构建乘积数组(2) 面试题67.把字符串转换成整数(2) 参考资料 leetcode专栏链接 https://leetcode-cn.com/problemset/lcof/ http://zhedahht.blog.163.com/ 《剑指Offer》第二版源代码 C++ https://github.com/zhedahht/CodingInterviewChinese2 面试题03.数组中重复的数字(6) 题目 找出数组中重复的数字。 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。 数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。 请找出数组中任意一个重复的数字。 示例 1：输入：[2, 3, 1, 0, 2, 5, 3] 输出：2 或 3 限制： 2 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(n) 02 排序遍历 O(nlog(n)) O(1) 03 暴力法 O(n^2) O(1) 04 遍历-置换 O(n) O(1) 05 遍历-置反 O(n) O(1) 06 遍历-置换(书上方法) O(n) O(1) func findRepeatNumber(nums []int) int { m := make(map[int]int) for i := 0; i 0 { return 0 } countZero++ continue } if value 面试题04.二维数组中的查找(6) 题目 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。 请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 示例: 现有矩阵 matrix 如下： [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] 给定 target = 5，返回 true。 给定 target = 20，返回 false。 限制： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法 O(n^2) O(1) 02 暴力法-优化 O(n^2) O(1) 03 二分查找 O(nlog(n)) O(1) 04 左下角查找 O(n) O(1) 05 右上角查找(书上方法) O(n) O(1) 06 内置函数 O(n^2) O(1) func findNumberIn2DArray(matrix [][]int, target int) bool { if len(matrix) == 0 { return false } if len(matrix[0]) == 0 { return false } for i := 0; i = target { for j := 0; j = target { res := binarySearch(matrix[i], target) if res == true { return true } } } return false } func binarySearch(arr []int, target int) bool { left := 0 right := len(arr) - 1 for left target { right = mid - 1 } else { left = mid + 1 } } return false } # 4 func findNumberIn2DArray(matrix [][]int, target int) bool { if len(matrix) == 0 { return false } if len(matrix[0]) == 0 { return false } i := len(matrix) - 1 j := 0 for i >= 0 && j target { i-- } else { j++ } } return false } # 5 func findNumberIn2DArray(matrix [][]int, target int) bool { if len(matrix) == 0 { return false } if len(matrix[0]) == 0 { return false } i := 0 j := len(matrix[0]) - 1 for j >= 0 && i target { j-- } else { i++ } } return false } # 6 func findNumberIn2DArray(matrix [][]int, target int) bool { if len(matrix) == 0 { return false } if len(matrix[0]) == 0 { return false } for i := 0; i 面试题05.替换空格(2) 题目 请实现一个函数，把字符串 s 中的每个空格替换成\"%20\"。 示例 1：输入：s = \"We are happy.\" 输出：\"We%20are%20happy.\" 限制：0 解题思路 No. 思路 时间复杂度 空间复杂度 01 内置函数 O(n) O(n) 02 遍历 O(n) O(n) func replaceSpace(s string) string { return strings.Replace(s,\" \",\"%20\",-1) // return strings.ReplaceAll(s, \" \", \"%20\") } # func replaceSpace(s string) string { res := \"\" for i := 0; i 面试题06.从尾到头打印链表(5) 题目 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 示例 1：输入：head = [1,3,2] 输出：[2,3,1] 限制：0 解题思路 No. 思路 时间复杂度 空间复杂度 01 反转数组 O(n) O(n) 02 递归(书上方法) O(n) O(n) 03 反转链表 O(n) O(n) 04 栈辅助(书上方法) O(n) O(n) 05 统计+遍历 O(n) O(n) func reversePrint(head *ListNode) []int { res := make([]int, 0) for head != nil { res = append(res, head.Val) head = head.Next } i := 0 for i 0{ node := stack[len(stack)-1] stack = stack[:len(stack)-1] res = append(res, node.Val) } return res } # 5 func reversePrint(head *ListNode) []int { cur := head count := 0 for head != nil { count++ head = head.Next } res := make([]int, count) for cur != nil { res[count-1] = cur.Val count-- cur = cur.Next } return res } 面试题07.重建二叉树(3) 题目 输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。 假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 例如，给出 前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树： 3 / \\ 9 20 / \\ 15 7 限制：0 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(n) 02 迭代 O(n) O(n) 03 递归(书上方法) O(n) O(n) func buildTree(preorder []int, inorder []int) *TreeNode { for k := range inorder { if inorder[k] == preorder[0] { return &TreeNode{ Val: preorder[0], Left: buildTree(preorder[1:k+1], inorder[0:k]), Right: buildTree(preorder[k+1:], inorder[k+1:]), } } } return nil } # func buildTree(preorder []int, inorder []int) *TreeNode { if preorder == nil || len(preorder) == 0 { return nil } root := &TreeNode{ Val: preorder[0], } length := len(preorder) stack := make([]*TreeNode, 0) stack = append(stack, root) index := 0 for i := 1; i 0 && stack[len(stack)-1].Val == inorder[index] { node = stack[len(stack)-1] stack = stack[:len(stack)-1] index++ } node.Right = &TreeNode{Val: value} stack = append(stack, node.Right) } } return root } # func buildTree(preorder []int, inorder []int) *TreeNode { if len(preorder) == 0 { return nil } return helper(preorder, inorder) } func helper(preorder []int, inorder []int) *TreeNode { var root *TreeNode for k := range inorder { if inorder[k] == preorder[0] { root = &TreeNode{Val: preorder[0]} root.Left = helper(preorder[1:k+1], inorder[0:k]) root.Right = helper(preorder[k+1:], inorder[k+1:]) } } return root } 面试题09.用两个栈实现队列(1) 题目 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ， 分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) 示例 1：输入： [\"CQueue\",\"appendTail\",\"deleteHead\",\"deleteHead\"] [[],[3],[],[]] 输出：[null,null,3,-1] 示例 2：输入： [\"CQueue\",\"deleteHead\",\"appendTail\",\"appendTail\",\"deleteHead\",\"deleteHead\"] [[],[],[5],[2],[],[]] 输出：[null,-1,null,null,5,2] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 栈模拟队列 O(n) O(n) type stack []int func (s *stack) Push(value int) { *s = append(*s, value) } func (s *stack) Pop() int { value := (*s)[len(*s)-1] *s = (*s)[:len(*s)-1] return value } type CQueue struct { tail stack head stack } func Constructor() CQueue { return CQueue{} } // 1.入队，tail栈保存 // 2.出队, head不为空，出head；head为空，tail出到head里，最后出head func (this *CQueue) AppendTail(value int) { this.tail.Push(value) } func (this *CQueue) DeleteHead() int { if len(this.head) != 0 { return this.head.Pop() } else if len(this.tail) != 0 { for len(this.tail) > 0 { this.head.Push(this.tail.Pop()) } return this.head.Pop() } return -1 } 面试题10- I.斐波那契数列(5) 题目 写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下： F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), 其中 N > 1. 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例 1：输入：n = 2输出：1 示例 2：输入：n = 5输出：5 提示： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历(书上方法) O(n) O(1) 02 遍历+数组 O(n) O(n) 03 矩阵快速幂(书上方法) O(log(n)) O(1) 04 矩阵快速幂(书上方法) O(n) O(1) 05 递归 O(n) O(n) func fib(n int) int { if n == 0 { return 0 } if n == 1 { return 1 } n1, n2 := 0, 1 for i := 2; i 0{ if n % 2 == 1{ ans = multi(ans, m) } m = multi(m, m) n = n >> 1 } return ans.b } /* a b c d */ type matrix struct { a, b, c, d int } // 矩阵乘法 func multi(x, y matrix) matrix { newA := x.a*y.a + x.b*y.c newB := x.a*y.b + x.b*y.d newC := x.c*y.a + x.d*y.c newD := x.c*y.b + x.d*y.d return matrix{ a: newA% 1000000007, b: newB% 1000000007, c: newC% 1000000007, d: newD% 1000000007, } } # func fib(n int) int { if n == 0 { return 0 } /* ans = [Fn+1 Fn Fn Fn-1] = [ 1 0 0 1] */ ans := matrix{ a: 1, b: 0, c: 0, d: 1, } m := matrix{ a: 1, b: 1, c: 1, d: 0, } for n > 0 { if n%2 == 1 { ans = multi(ans, m) } m = multi(m, m) n = n >> 1 } return ans.b } /* a b c d */ type matrix struct { a, b, c, d int } // 矩阵乘法 func multi(x, y matrix) matrix { newA := x.a*y.a + x.b*y.c newB := x.a*y.b + x.b*y.d newC := x.c*y.a + x.d*y.c newD := x.c*y.b + x.d*y.d return matrix{ a: newA % 1000000007, b: newB % 1000000007, c: newC % 1000000007, d: newD % 1000000007, } } # 4 func fib(n int) int { if n == 0 { return 0 } /* ans = [Fn+1 Fn Fn Fn-1] = [ 1 0 0 1] */ ans := matrix{ a: 1, b: 0, c: 0, d: 1, } m := matrix{ a: 1, b: 1, c: 1, d: 0, } for n > 0 { ans = multi(ans, m) n-- } return ans.b } /* a b c d */ type matrix struct { a, b, c, d int } // 矩阵乘法 func multi(x, y matrix) matrix { newA := x.a*y.a + x.b*y.c newB := x.a*y.b + x.b*y.d newC := x.c*y.a + x.d*y.c newD := x.c*y.b + x.d*y.d return matrix{ a: newA % 1000000007, b: newB % 1000000007, c: newC % 1000000007, d: newD % 1000000007, } } # 5 var m = make(map[int]int) func fib(n int) int { if n == 0 { return 0 } if n == 1 { return 1 } if m[n] > 0 { return m[n] } m[n] = (fib(n-1) + fib(n-2)) % 1000000007 return m[n] } 面试题10-II.青蛙跳台阶问题(3) 题目 一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例 1：输入：n = 2输出：2 示例 2：输入：n = 7输出：21 提示： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n) O(n) 02 斐波那契 O(n) O(1) 03 递归 O(n) O(n) func numWays(n int) int { if n 0 { return m[n] } else { m[n] = (numWays(n-1) + numWays(n-2)) % 1000000007 } return m[n] } 面试题11.旋转数组的最小数字(4) 题目 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。 例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 示例 1：输入：[3,4,5,1,2]输出：1 示例 2：输入：[2,2,2,0,1]输出：0 注意：本题与主站 154 题相同： https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/ 解题思路 No. 思路 时间复杂度 空间复杂度 01 二分查找 O(log(n)) O(1) 02 排序 O(nlog(n)) O(1) 03 遍历 O(n) O(1) 04 二分查找(书上方法) O(log(n)) O(1) func minArray(numbers []int) int { left := 0 right := len(numbers) - 1 for left numbers[left] { left = mid + 1 } else if numbers[mid] = numbers[right] { if right-left == 1 { mid = right break } mid = (left + right) / 2 if numbers[left] == numbers[right] && numbers[mid] == numbers[left] { return minInorder(numbers, left, right) } if numbers[mid] >= numbers[left] { left = mid } else if numbers[mid] 面试题12.矩阵中的路径(2) 题目 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。 路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。 如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。 例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。 [[\"a\",\"b\",\"c\",\"e\"], [\"s\",\"f\",\"c\",\"s\"], [\"a\",\"d\",\"e\",\"e\"]] 但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后， 路径不能再次进入这个格子。 示例 1：输入：board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\" 输出：true 示例 2：输入：board = [[\"a\",\"b\"],[\"c\",\"d\"]], word = \"abcd\" 输出：false 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 深度优先搜索+回溯 O(n^2) O(n) 02 深度优先搜索+回溯+数组辅助(书上方法) O(n^2) O(n^2) func exist(board [][]byte, word string) bool { for i := 0; i = len(board) || j = len(board[0]) || board[i][j] != word[level] { return false } if level == len(word)-1 { return true } temp := board[i][j] board[i][j] = ' ' res := dfs(board, i+1, j, word, level+1) || dfs(board, i-1, j, word, level+1) || dfs(board, i, j+1, word, level+1) || dfs(board, i, j-1, word, level+1) board[i][j] = temp return res } # func exist(board [][]byte, word string) bool { visited := make([][]bool, len(board)) for i := 0; i = 0 && i = 0 && j 面试题13.机器人的运动范围(3) 题目 地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。 一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外）， 也不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。 但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？ 示例 1：输入：m = 2, n = 3, k = 1 输出：3 示例 2：输入：m = 3, n = 1, k = 0 输出：1 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 深度优先搜索(书上方法) O(n^2) O(n^2) 02 暴力法 O(n^2) O(n^2) 03 广度优先搜索 O(n^2) O(n^2) func movingCount(m int, n int, k int) int { if k = 0 && x = 0 && y 0 { sum = sum + num%10 num = num / 10 } return sum } # func movingCount(m int, n int, k int) int { if k = 0 && visited[i-1][j] == true) || (j-1 >= 0 && visited[i][j-1] == true) { value := getDigiSum(i) + getDigiSum(j) if value 0 { sum = sum + num%10 num = num / 10 } return sum } # func movingCount(m int, n int, k int) int { if k 0 { node := queue[0] queue = queue[1:] x := node[0] y := node[1] if getDigiSum(x)+getDigiSum(y) = 0 && getDigiSum(x-1)+getDigiSum(y) = 0 && getDigiSum(x)+getDigiSum(y-1) 0 { sum = sum + num%10 num = num / 10 } return sum } 面试题14- I.剪绳子(2) 题目 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1）， 每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？ 例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 示例 1： 输入: 2 输出: 1 解释: 2 = 1 + 1, 1 × 1 = 1 示例 2: 输入: 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36 提示：2 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划(书上方法) O(n^2) O(n) 02 贪心法 O(1) O(1) func cuttingRope(n int) int { if n max { max = length } dp[i] = max } } return dp[n] } # func cuttingRope(n int) int { if n 面试题14-II.剪绳子 II(2) 题目 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1）， 每段绳子的长度记为 k[0],k[1]...k[m] 。请问 k[0]*k[1]*...*k[m] 可能的最大乘积是多少？ 例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例 1：输入: 2 输出: 1 解释: 2 = 1 + 1, 1 × 1 = 1 示例 2:输入: 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36 提示：2 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n) O(n) 02 贪心法 O(n) O(1) func cuttingRope(n int) int { if n 面试题15.二进制中1的个数(4) 题目 请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。 例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。 示例 1： 输入：00000000000000000000000000001011 输出：3 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。 示例 2：输入：00000000000000000000000010000000 输出：1 解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。 示例 3：输入：11111111111111111111111111111101 输出：31 解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。 注意：本题与主站 191 题相同：https://leetcode-cn.com/problems/number-of-1-bits/ 解题思路 No. 思路 时间复杂度 空间复杂度 01 循环位计算 O(1) O(1) 02 位计算 n&(n-1)，会把该整数的最右边的1变成0(书上方法) O(1) O(1) 03 内置函数 O(1) O(1) 04 遍历(书上方法) O(1) O(1) func hammingWeight(num uint32) int { count := 0 for num != 0 { if num&1 == 1 { count++ } num = num >> 1 } return count } # func hammingWeight(num uint32) int { count := 0 for num != 0 { num = num & (num - 1) count++ } return count } # func hammingWeight(num uint32) int { return strings.Count(strconv.FormatInt(int64(num), 2), \"1\") // return strings.Count(fmt.Sprintf(\"%b\",num),\"1\") } # func hammingWeight(num uint32) int { count := 0 flag := uint32(1) for flag != 0{ if num & flag == flag{ count++ } flag = flag 面试题16.数值的整数次方(4) 题目 实现函数double Power(double base, int exponent)，求base的exponent次方。 不得使用库函数，同时不需要考虑大数问题。 示例 1:输入: 2.00000, 10 输出: 1024.00000 示例 2:输入: 2.10000, 3 输出: 9.26100 示例 3:输入: 2.00000, -2 输出: 0.25000 解释: 2-2 = 1/22 = 1/4 = 0.25 说明: -100.0 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归(书上方法) O(log(n)) O(log(n)) 02 迭代 O(log(n)) O(1) 03 计算 O(log(n)) O(1) 04 递归 O(log(n)) O(1) func myPow(x float64, n int) float64 { if n == 0 { return 1 } if n == 1 { return x } res := 1.0 if n > 0 { res = myPow(x, n/2) return res * res * myPow(x, n%2) } else { res = myPow(x, -n/2) res = res * res * myPow(x, -n%2) return 1 / res } } # func myPow(x float64, n int) float64 { if n == 0 { return 1 } if n == 1 { return x } res := 1.0 if n = 1 { if n%2 == 1 { res = res * x n-- } else { x = x * x n = n / 2 } } return res } # func myPow(x float64, n int) float64 { return math.Pow(x, float64(n)) } # func myPow(x float64, n int) float64 { if n == 0 { return 1 } if n 面试题17.打印从1到最大的n位数(4) 题目 输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。 比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。 示例 1: 输入: n = 1 输出: [1,2,3,4,5,6,7,8,9] 说明： 用返回一个整数列表来代替打印 n 为正整数 解题思路 No. 思路 时间复杂度 空间复杂度 01 求最大 O(10^n) O(10^n) 02 求最大 O(10^n) O(10^n) 03 递归+全排列(书上方法) O(10^n) O(10^n) 04 模拟进位(书上方法) O(10^n) O(10^n) func printNumbers(n int) []int { res := make([]int, 0) maxValue := 0 for n > 0 { maxValue = maxValue*10 + 9 n-- } for i := 1; i = 0; i-- { sum := int(arr[i]-'0') + nTakeOver if i == len(arr)-1 { sum++ } if sum >= 10 { if i == 0 { isOverflow = true } else { sum = sum - 10 nTakeOver = 1 arr[i] = rune('0' + sum) } } else { arr[i] = rune('0' + sum) break } } return isOverflow } func printNum(arr []rune) string { res := \"\" isBeginning := true for i := 0; i 面试题18.删除链表的节点(2) 题目 给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。 返回删除后的链表的头节点。 注意：此题对比原题有改动 示例 1:输入: head = [4,5,1,9], val = 5 输出: [4,1,9] 解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9. 示例 2:输入: head = [4,5,1,9], val = 1 输出: [4,5,9] 解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9. 说明： 题目保证链表中节点的值互不相同 若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点 解题思路 No. 思路 时间复杂度 空间复杂度 01 哨兵结点+链表遍历 O(n) O(1) 02 递归 O(n) O(n) func deleteNode(head *ListNode, val int) *ListNode { headPre := &ListNode{Next: head} temp := headPre for temp.Next != nil { if temp.Next.Val == val { temp.Next = temp.Next.Next break } else { temp = temp.Next } } return headPre.Next } # func deleteNode(head *ListNode, val int) *ListNode { if head == nil { return nil } head.Next = deleteNode(head.Next, val) if head.Val == val { return head.Next } return head } 面试题19.正则表达式匹配(2) 题目 请实现一个函数用来匹配包含'. '和'*'的正则表达式。模式中的字符'.'表示任意一个字符， 而'*'表示它前面的字符可以出现任意次（含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。 例如，字符串\"aaa\"与模式\"a.a\"和\"ab*ac*a\"匹配，但与\"aa.a\"和\"ab*a\"均不匹配。 示例 1:输入: s = \"aa\" p = \"a\" 输出: false 解释: \"a\" 无法匹配 \"aa\" 整个字符串。 示例 2:输入: s = \"aa\" p = \"a*\" 输出: true 解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。 因此，字符串 \"aa\" 可被视为 'a' 重复了一次。 示例 3:输入:s = \"ab\" p = \".*\" 输出: true 解释: \".*\" 表示可匹配零个或多个（'*'）任意字符（'.'）。 示例 4: 输入:s = \"aab\" p = \"c*a*b\" 输出: true 解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 \"aab\"。 示例 5: 输入: s = \"mississippi\" p = \"mis*is*p*.\" 输出: false s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母以及字符 . 和 *，无连续的 '*'。 注意：本题与主站 10 题相同： https://leetcode-cn.com/problems/regular-expression-matching/ 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归(书上方法) O(n) O(n) 02 动态规划 O(n^2) O(n^2) func isMatch(s string, p string) bool { return dfs(s, p, 0, 0) } func dfs(s string, p string, i, j int) bool { if i >= len(s) && j >= len(p) { return true } if i = len(p) { return false } if j+1 1 { if p[i-2] == s[j-1] || p[i-2] == '.' { dp[i][j] = dp[i][j-1] || dp[i-2][j-1] || dp[i-2][j] } else { dp[i][j] = dp[i-2][j] } } } } } return dp[len(p)][len(s)] } 面试题20.表示数值的字符串(1) 题目 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串\"+100\"、\"5e2\"、\"-123\"、\"3.1416\"、\"0123\"都表示数值， 但\"12e\"、\"1a3.14\"、\"1.2.3\"、\"+-5\"、\"-1E-16\"及\"12e+5.4\"都不是。 注意：本题与主站 65 题相同：https://leetcode-cn.com/problems/valid-number/ 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历-找规律(书上方法) O(n) O(1) func isNumber(s string) bool { s = strings.Trim(s, \" \") if s == \"\" || len(s) == 0 || len(s) == 0 { return false } arr := []byte(s) i := 0 numeric := scanInteger(&arr, &i) if i '9' { break } *index++ } return j 面试题21.调整数组顺序使奇数位于偶数前面(4) 题目 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分， 所有偶数位于数组的后半部分。 示例：输入：nums = [1,2,3,4] 输出：[1,3,2,4] 注：[3,1,2,4] 也是正确的答案之一。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n) O(1) 02 双指针(书上方法) O(n) O(1) 03 遍历 O(n) O(n) 04 遍历 O(n) O(1) func exchange(nums []int) []int { i := 0 j := len(nums) - 1 for i 面试题22.链表中倒数第k个节点(5) 题目 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数， 即链表的尾节点是倒数第1个节点。 例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。 这个链表的倒数第3个节点是值为4的节点。 示例：给定一个链表: 1->2->3->4->5, 和 k = 2. 返回链表 4->5. 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组辅助 O(n) O(n) 02 快慢指针(书上方法) O(n) O(1) 03 统计+遍历 O(n) P 04 递归 O(n) O(n) 05 递归 O(n) O(n) func getKthFromEnd(head *ListNode, k int) *ListNode { arr := make([]*ListNode, 0) for head != nil { arr = append(arr, head) head = head.Next } if len(arr) >= k { return arr[len(arr)-k] } return nil } # func getKthFromEnd(head *ListNode, k int) *ListNode { fast := head for k > 0 && head != nil { fast = fast.Next k-- } if k > 0 { return nil } slow := head for fast != nil { fast = fast.Next slow = slow.Next } return slow } # func getKthFromEnd(head *ListNode, k int) *ListNode { temp := head count := 0 for temp != nil { count++ temp = temp.Next } if count 0 { return nil } return res } func dfs(node *ListNode, k int) (*ListNode, int) { if node == nil { return node, k } next, nextValue := dfs(node.Next, k) if nextValue 面试题24.反转链表(4) 题目 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。 示例: 输入: 1->2->3->4->5->NULL 输出: 5->4->3->2->1->NULL 限制：0 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(n) 02 迭代(书上方法) O(n) O(1) 03 数组辅助 O(n) O(n) 04 迭代-新建节点 O(n) O(1) func reverseList(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } result := reverseList(head.Next) head.Next.Next = head head.Next = nil return result } # func reverseList(head *ListNode) *ListNode { var result *ListNode var temp *ListNode for head != nil { temp = head.Next head.Next = result result = head head = temp } return result } # func reverseList(head *ListNode) *ListNode { result := &ListNode{} arr := make([]*ListNode, 0) for head != nil { arr = append(arr, head) head = head.Next } temp := result for i := len(arr) - 1; i >= 0; i-- { arr[i].Next = nil temp.Next = arr[i] temp = temp.Next } return result.Next } # func reverseList(head *ListNode) *ListNode { var res *ListNode for { if head == nil { break } res = &ListNode{head.Val, res} head = head.Next } return res } 面试题25.合并两个排序的链表(3) 题目 输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。 示例1：输入：1->2->4, 1->3->4 输出：1->1->2->3->4->4 限制：0 解题思路 No. 思路 时间复杂度 空间复杂度 01 迭代遍历 O(n) O(1) 02 递归(书上方法) O(n) O(n) 03 迭代 O(n) O(1) func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode { if l1 == nil { return l2 } if l2 == nil { return l1 } var head, node *ListNode if l1.Val 面试题26.树的子结构(2) 题目 输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构) B是A的子结构， 即 A中有出现和B相同的结构和节点值。 例如:给定的树 A: 3 / \\ 4 5 / \\ 1 2 给定的树 B： 4 / 1 返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。 示例 1：输入：A = [1,2,3], B = [3,1]输出：false 示例 2：输入：A = [3,4,5,1,2], B = [4,1]输出：true 限制：0 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归(书上方法) O(n^2) O(log(n)) 02 迭代+递归 O(n^2) O(n) func isSubStructure(A *TreeNode, B *TreeNode) bool { if A == nil || B == nil { return false } return dfs(A, B) || isSubStructure(A.Left, B) || isSubStructure(A.Right, B) } func dfs(A *TreeNode, B *TreeNode) bool { if B == nil { return true } if A == nil { return false } return dfs(A.Left, B.Left) && dfs(A.Right, B.Right) && A.Val == B.Val } # func isSubStructure(A *TreeNode, B *TreeNode) bool { if A == nil || B == nil { return false } res := false list := make([]*TreeNode, 0) list = append(list, A) for len(list) > 0 { node := list[0] list = list[1:] if node.Val == B.Val { res = dfs(node, B) if res == true { return true } } if node.Left != nil { list = append(list, node.Left) } if node.Right != nil { list = append(list, node.Right) } } return res } func dfs(A *TreeNode, B *TreeNode) bool { fmt.Println(A, B) if B == nil { return true } if A == nil { return false } return dfs(A.Left, B.Left) && dfs(A.Right, B.Right) && A.Val == B.Val } 面试题27.二叉树的镜像(2) 题目 请完成一个函数，输入一个二叉树，该函数输出它的镜像。 例如输入： 4 / \\ 2 7 / \\ / \\ 1 3 6 9 镜像输出： 4 / \\ 7 2 / \\ / \\ 9 6 3 1 示例 1：输入：root = [4,2,7,1,3,6,9] 输出：[4,7,2,9,6,3,1] 限制：0 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归(书上方法) O(n) O(n) 02 迭代 O(n) O(n) func mirrorTree(root *TreeNode) *TreeNode { if root == nil || (root.Left == nil && root.Right == nil) { return root } root.Left, root.Right = mirrorTree(root.Right), mirrorTree(root.Left) return root } # func mirrorTree(root *TreeNode) *TreeNode { if root == nil { return root } var queue []*TreeNode queue = append(queue, root) for len(queue) > 0 { node := queue[0] queue = queue[1:] node.Left, node.Right = node.Right, node.Left if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } return root } 面试题28.对称的二叉树(2) 题目 请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 / \\ 2 2 / \\ / \\ 3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 1 / \\ 2 2 \\ \\ 3 3 示例 1：输入：root = [1,2,2,3,4,4,3] 输出：true 示例 2：输入：root = [1,2,2,null,3,null,3] 输出：false 限制：0 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归(书上方法) O(n) O(n) 02 迭代 O(n) O(n) func isSymmetric(root *TreeNode) bool { if root == nil { return true } return recur(root.Left, root.Right) } func recur(left, right *TreeNode) bool { if left == nil && right == nil { return true } if left == nil || right == nil { return false } return left.Val == right.Val && recur(left.Left, right.Right) && recur(left.Right, right.Left) } # func isSymmetric(root *TreeNode) bool { leftQ := make([]*TreeNode, 0) rightQ := make([]*TreeNode, 0) leftQ = append(leftQ, root) rightQ = append(rightQ, root) for len(leftQ) != 0 && len(rightQ) != 0 { leftCur, rightCur := leftQ[0], rightQ[0] leftQ, rightQ = leftQ[1:], rightQ[1:] if leftCur == nil && rightCur == nil { continue } else if leftCur != nil && rightCur != nil && leftCur.Val == rightCur.Val { leftQ = append(leftQ, leftCur.Left, leftCur.Right) rightQ = append(rightQ, rightCur.Right, rightCur.Left) } else { return false } } if len(leftQ) == 0 && len(rightQ) == 0 { return true } else { return false } } 面试题29.顺时针打印矩阵(2) 题目 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。 示例 1：输入：matrix = [[1,2,3],[4,5,6],[7,8,9]] 输出：[1,2,3,6,9,8,7,4,5] 示例 2：输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]] 输出：[1,2,3,4,8,12,11,10,9,5,6,7] 限制：0 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历(书上方法) O(n^2) O(n^2) 02 遍历 O(n^2) O(n^2) var res []int func spiralOrder(matrix [][]int) []int { res = make([]int, 0) rows := len(matrix) if rows == 0 { return res } cols := len(matrix[0]) if cols == 0 { return res } start := 0 for cols > start*2 && rows > start*2 { printCircle(matrix, cols, rows, start) start++ } return res } func printCircle(matrix [][]int, cols, rows, start int) { x := cols - 1 - start y := rows - 1 - start // 左到右 for i := start; i = start; i-- { res = append(res, matrix[y][i]) } } // 下到上 if start = start+1; i-- { res = append(res, matrix[i][start]) } } } # func spiralOrder(matrix [][]int) []int { res := make([]int, 0) rows := len(matrix) if rows == 0 { return res } cols := len(matrix[0]) if cols == 0 { return res } x1, x2, y1, y2 := 0, rows-1, 0, cols-1 direct := 0 for x1 = y1; i-- { res = append(res, matrix[x2][i]) } x2-- } else if direct == 3 { for i := x2; i >= x1; i-- { res = append(res, matrix[i][y1]) } y1++ } direct++ } return res } 面试题30.包含min函数的栈(2) 题目 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中， 调用 min、push 及 pop 的时间复杂度都是 O(1)。 示例: MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.min(); --> 返回 -3. minStack.pop(); minStack.top(); --> 返回 0. minStack.min(); --> 返回 -2. 提示： 各函数的调用总次数不超过 20000 次 注意：本题与主站 155 题相同：https://leetcode-cn.com/problems/min-stack/ 解题思路 No. 思路 时间复杂度 空间复杂度 01 使用数组模拟栈，保存数据的时候同时保存当前的最小值 O(1) O(n) 02 使用双栈(书上方法) O(1) O(n) type item struct { min, x int } type MinStack struct { stack []item } func Constructor() MinStack { return MinStack{} } func (m *MinStack) Push(x int) { min := x if len(m.stack) > 0 && m.Min() 面试题31.栈的压入弹出序列(2) 题目 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。 假设压入栈的所有数字均不相等。 例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列， 但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。 示例 1：输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1] 输出：true 解释：我们可以按以下顺序执行： push(1), push(2), push(3), push(4), pop() -> 4, push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1 示例 2：输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2] 输出：false 解释：1 不能在 2 之前弹出。 提示： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 栈辅助 O(n) O(n) 02 栈辅助(书上方法) O(n) O(n) func validateStackSequences(pushed []int, popped []int) bool { stack := make([]int, 0) j := 0 for i := 0; i 0 && stack[len(stack)-1] == popped[j] { stack = stack[:len(stack)-1] j++ } } if len(stack) == 0 { return true } return false } # func validateStackSequences(pushed []int, popped []int) bool { stack := make([]int, 0) res := false i := 0 j := 0 for j 面试题32-I.从上到下打印二叉树(2) 题目 从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。 例如:给定二叉树: [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 返回：[3,9,20,15,7] 提示：节点总数 解题思路 No. 思路 时间复杂度 空间复杂度 01 层序遍历(书上方法) O(n) O(n) 02 递归 O(n) O(n) func levelOrder(root *TreeNode) []int { res := make([]int, 0) if root == nil { return res } list := make([]*TreeNode, 0) list = append(list, root) for len(list) > 0 { length := len(list) for i := 0; i 面试题32-II.从上到下打印二叉树II(2) 题目 从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。 例如: 给定二叉树: [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 返回其层次遍历结果： [ [3], [9,20], [15,7] ] 提示：节点总数 解题思路 No. 思路 时间复杂度 空间复杂度 01 层序遍历(书上方法) O(n) O(n) 02 递归 O(n) O(n) func levelOrder(root *TreeNode) [][]int { res := make([][]int, 0) if root == nil { return res } list := make([]*TreeNode, 0) list = append(list, root) for len(list) > 0 { length := len(list) temp := make([]int,0) for i := 0; i 面试题32-III.从上到下打印二叉树III(2) 题目 请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印， 第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。 例如:给定二叉树: [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 返回其层次遍历结果： [ [3], [20,9], [15,7] ] 提示：节点总数 解题思路 No. 思路 时间复杂度 空间复杂度 01 层序遍历(书上方法) O(n) O(n) 02 递归 O(n) O(n) func levelOrder(root *TreeNode) [][]int { res := make([][]int, 0) if root == nil { return res } list := make([]*TreeNode, 0) list = append(list, root) level := 0 for len(list) > 0 { length := len(list) temp := make([]int, 0) for i := 0; i = 0; i-- { temp = append(temp, list[i].Val) } } list = list[length:] res = append(res, temp) level++ } return res } # func levelOrder(root *TreeNode) [][]int { if root == nil { return nil } temp := make([][]int, 0) dfs(root, &temp, 0) return temp } func dfs(root *TreeNode, temp *[][]int, level int) { if root == nil { return } if len(*temp)-1 面试题33.二叉搜索树的后序遍历序列(3) 题目 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。 假设输入的数组的任意两个数字都互不相同。 参考以下这颗二叉搜索树： 5 / \\ 2 6 / \\ 1 3 示例 1：输入: [1,6,3,2,5]输出: false 示例 2：输入: [1,3,2,6,5]输出: true 提示： 数组长度 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归(书上方法) O(n^2) O(n) 02 迭代 O(n^2) O(1) 03 栈辅助 O(n) O(n) func verifyPostorder(postorder []int) bool { return dfs(postorder, 0, len(postorder)-1) } func dfs(postorder []int, start, end int) bool { if start >= end { return true } i := 0 for i = start; i postorder[end] { break } } for j := i + 1; j 0 { i := 0 for postorder[i] postorder[last] { i++ } if i != last { return false } last-- } return true } # func verifyPostorder(postorder []int) bool { if len(postorder) = 0; i-- { if postorder[i] > rootValue { // 左子树元素必须要小于递增栈根节点 return false } // 数组元素小于单调栈的元素了，表示往左子树走了，记录上个根节点 for len(stack) > 0 && postorder[i] 面试题34.二叉树中和为某一值的路径(2) 题目 输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。 从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。 示例:给定如下二叉树，以及目标和 sum = 22， 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\ 7 2 5 1 返回: [ [5,4,11,2], [5,8,4,5] ] 提示：节点总数 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归(书上方法) O(n) O(log(n)) 02 迭代 O(n) O(n) var res [][]int func pathSum(root *TreeNode, sum int) [][]int { if root == nil { return nil } res = make([][]int, 0) var arr []int dfs(root, sum, arr) return res } func dfs(root *TreeNode, sum int, arr []int) { if root == nil { return } arr = append(arr, root.Val) if root.Val == sum && root.Left == nil && root.Right == nil { temp := make([]int, len(arr)) copy(temp, arr) res = append(res, temp) } dfs(root.Left, sum-root.Val, arr) dfs(root.Right, sum-root.Val, arr) arr = arr[:len(arr)-1] } # func pathSum(root *TreeNode, sum int) [][]int { res := make([][]int, 0) if root == nil { return res } temp := make([]int, 0) stack := make([]*TreeNode, 0) visited := make(map[*TreeNode]bool) curSum := 0 for root != nil || len(stack) > 0 { for root != nil { temp = append(temp, root.Val) curSum = curSum + root.Val visited[root] = true stack = append(stack, root) root = root.Left } node := stack[len(stack)-1] if node.Right == nil || visited[node.Right] { if node.Left == nil && node.Right == nil && curSum == sum { tmp := make([]int, len(temp)) copy(tmp, temp) res = append(res, tmp) } stack = stack[:len(stack)-1] temp = temp[:len(temp)-1] curSum = curSum - node.Val root = nil } else { root = node.Right } } return res } 面试题35.复杂链表的复制(3) 题目 请实现 copyRandomList 函数，复制一个复杂链表。 在复杂链表中，每个节点除了有一个 next 指针指向下一个节点， 还有一个 random 指针指向链表中的任意节点或者 null。 示例 1： 输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]] 输出：[[7,null],[13,0],[11,4],[10,2],[1,0]] 示例 2：输入：head = [[1,1],[2,1]] 输出：[[1,1],[2,1]] 示例 3：输入：head = [[3,null],[3,0],[3,null]] 输出：[[3,null],[3,0],[3,null]] 示例 4：输入：head = [] 输出：[] 解释：给定的链表为空（空指针），因此返回 null。 提示： -10000 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助-递归 O(n) O(n) 02 哈希辅助 O(n) O(n) 03 复制-删除(书上方法) O(n) O(1) var m map[*Node]*Node func copyRandomList(head *Node) *Node { m = make(map[*Node]*Node) return copyList(head) } func copyList(head *Node) *Node { if head == nil { return head } if node, ok := m[head]; ok { return node } temp := &Node{ Val: head.Val, Next: nil, Random: nil, } m[head] = temp temp.Next = copyList(head.Next) temp.Random = copyList(head.Random) return temp } # func copyRandomList(head *Node) *Node { if head == nil { return nil } res := new(Node) m := make(map[*Node]*Node) temp := head p := res for temp != nil { node := &Node{ Val: temp.Val, Next: nil, Random: nil, } m[temp] = node p.Next = node p = p.Next temp = temp.Next } temp = head p = res.Next for temp != nil { p.Random = m[temp.Random] p = p.Next temp = temp.Next } return res.Next } # func copyRandomList(head *Node) *Node { if head == nil { return nil } res := copyNext(head) res = copyRandom(res) res = cutEven(res) return res } // 原1-复制1-原2-复制2 func copyNext(head *Node) *Node { temp := new(Node) temp.Next = head p := head for p != nil { node := new(Node) node.Val = p.Val node.Next = p.Next p.Next = node p = p.Next.Next } return temp.Next } func copyRandom(head *Node) *Node { temp := new(Node) temp.Next = head p := head for p != nil { if p.Random != nil { p.Next.Random = p.Random.Next } p = p.Next.Next } return temp.Next } func cutEven(head *Node) *Node { temp := new(Node) res := head p := head for p != nil { res.Next = p.Next p.Next = p.Next.Next p = p.Next res = res.Next } return temp.Next } 面试题38.字符串的排列(2) 题目 输入一个字符串，打印出该字符串中字符的所有排列。 你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。 示例:输入：s = \"abc\" 输出：[\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"] 限制：1 解题思路 No. 思路 时间复杂度 空间复杂度 01 回溯算法 O(n!) O(n!) 02 回溯算法-交换(书上方法) O(n!) O(n!) var m map[string]bool func permutation(s string) []string { m = make(map[string]bool) dfs(s, \"\") res := make([]string, 0) for key := range m { res = append(res, key) } return res } func dfs(s string, str string) { if len(s) == 0 { m[str] = true } for i := 0; i 面试题39.数组中出现次数超过一半的数字(5) 题目 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 示例 1:输入: [1, 2, 3, 2, 2, 2, 5, 4, 2] 输出: 2 限制：1 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序取半 O(nlog(n)) O(1) 02 哈希遍历 O(n) O(n) 03 Boyer-Moore投票算法(书上方法) O(n) O(1) 04 位运算 O(n) O(1) 05 分治法 O(nlog(n)) O(log(n)) func majorityElement(nums []int) int { sort.Ints(nums) return nums[len(nums)/2] } # 2 func majorityElement(nums []int) int { m := make(map[int]int) result := 0 for _, v := range nums{ if _,ok := m[v];ok{ m[v]++ }else { m[v]=1 } if m[v] > (len(nums)/2){ result = v } } return result } # 3 func majorityElement(nums []int) int { result, count := 0, 0 for i := 0; i len(nums)/2 { result = result | mask } mask = mask rightCount { return left } return right } 面试题40.最小的k个数(4) 题目 输入整数数组 arr ，找出其中最小的 k 个数。 例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。 示例 1：输入：arr = [3,2,1], k = 2 输出：[1,2] 或者 [2,1] 示例 2：输入：arr = [0,1,2,1], k = 1 输出：[0] 限制： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序 O(nlog(n)) O(1) 02 堆 O(nlog(n)) O(n) 03 计数统计 O(n) O(n) 04 快排切分(书上方法) O(n) O(1) func getLeastNumbers(arr []int, k int) []int { if len(arr) == 0 || k == 0 { return nil } sort.Ints(arr) return arr[:k] } # type IntHeap []int func (i IntHeap) Len() int { return len(i) } func (i IntHeap) Less(x, y int) bool { return i[x] > i[y] } func (i IntHeap) Swap(x, y int) { i[x], i[y] = i[y], i[x] } func (i *IntHeap) Push(v interface{}) { *i = append(*i, v.(int)) } func (i *IntHeap) Pop() interface{} { value := (*i)[len(*i)-1] *i = (*i)[:len(*i)-1] return value } func getLeastNumbers(arr []int, k int) []int { if len(arr) == 0 || k == 0 { return nil } intHeap := make(IntHeap, 0, k) heap.Init(&intHeap) for i := 0; i 0 { for i := 0; i = value && i = j { break } arr[i], arr[j] = arr[j], arr[i] } arr[left] = arr[i] arr[i] = value return i } 面试题41.数据流中的中位数(1) 题目 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。 如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。 例如， [2,3,4] 的中位数是 3 [2,3] 的中位数是 (2 + 3) / 2 = 2.5 设计一个支持以下两种操作的数据结构： void addNum(int num) - 从数据流中添加一个整数到数据结构中。 double findMedian() - 返回目前所有元素的中位数。 示例 1：输入： [\"MedianFinder\",\"addNum\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\"] [[],[1],[2],[],[3],[]] 输出：[null,null,null,1.50000,null,2.00000] 示例 2： 输入： [\"MedianFinder\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\"] [[],[2],[],[3],[]] 输出：[null,null,2.00000,null,2.50000] 限制：最多会对 addNum、findMedia进行 50000 次调用。 注意：本题与主站 295 题相同： https://leetcode-cn.com/problems/find-median-from-data-stream/ 解题思路 No. 思路 时间复杂度 空间复杂度 01 大小根堆-内置heap接口 O(log(n)) O(n) type MinHeap []int func (i MinHeap) Len() int { return len(i) } func (i MinHeap) Less(x, y int) bool { return i[x] i[y] } func (i MaxHeap) Swap(x, y int) { i[x], i[y] = i[y], i[x] } func (i *MaxHeap) Push(v interface{}) { *i = append(*i, v.(int)) } func (i *MaxHeap) Pop() interface{} { value := (*i)[len(*i)-1] *i = (*i)[:len(*i)-1] return value } type MedianFinder struct { minArr *MinHeap maxArr *MaxHeap } func Constructor() MedianFinder { res := new(MedianFinder) res.minArr = new(MinHeap) res.maxArr = new(MaxHeap) heap.Init(res.minArr) heap.Init(res.maxArr) return *res } func (this *MedianFinder) AddNum(num int) { if this.maxArr.Len() == this.minArr.Len() { heap.Push(this.minArr, num) heap.Push(this.maxArr, heap.Pop(this.minArr)) } else { heap.Push(this.maxArr, num) heap.Push(this.minArr, heap.Pop(this.maxArr)) } } func (this *MedianFinder) FindMedian() float64 { if this.minArr.Len() == this.maxArr.Len() { return (float64((*this.maxArr)[0]) + float64((*this.minArr)[0])) / 2 } else { return float64((*this.maxArr)[0]) } } 面试题42.连续子数组的最大和(4) 题目 输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。 要求时间复杂度为O(n)。 示例1:输入: nums = [-2,1,-3,4,-1,2,1,-5,4]输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 贪心法(书上方法) O(n) O(1) 03 动态规划(书上方法) O(n) O(n) 04 动态规划 O(n) O(1) 05 分治 O(nlog(n)) O(log(n)) func maxSubArray(nums []int) int { result := nums[0] sum := 0 for i := 0; i 0 { sum += nums[i] } else { sum = nums[i] } if sum > result { result = sum } } return result } # func maxSubArray(nums []int) int { dp := make([]int, len(nums)) dp[0] = nums[0] result := nums[0] for i := 1; i nums[i] { dp[i] = dp[i-1] + nums[i] } else { dp[i] = nums[i] } if dp[i] > result { result = dp[i] } } return result } # func maxSubArray(nums []int) int { dp := nums[0] result := dp for i := 1; i nums[i] { dp = dp + nums[i] } else { dp = nums[i] } if dp > result { result = dp } } return result } # func maxSubArray(nums []int) int { result := maxSubArr(nums, 0, len(nums)-1) return result } func maxSubArr(nums []int, left, right int) int { if left == right { return nums[left] } mid := (left + right) / 2 leftSum := maxSubArr(nums, left, mid) // 最大子序在左边 rightSum := maxSubArr(nums, mid+1, right) // 最大子序在右边 midSum := findMaxArr(nums, left, mid, right) // 跨中心 result := max(leftSum, rightSum) result = max(result, midSum) return result } func findMaxArr(nums []int, left, mid, right int) int { leftSum := math.MinInt32 sum := 0 // 从右到左 for i := mid; i >= left; i-- { sum += nums[i] leftSum = max(leftSum, sum) } rightSum := math.MinInt32 sum = 0 // 从左到右 for i := mid + 1; i b { return a } return b } 面试题43.1～n整数中1出现的次数(3) 题目 输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。 例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。 示例 1：输入：n = 12 出：5 示例 2：输入：n = 13 出：6 限制： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 找规律-遍历 O(log(n)) O(1) 02 找规律-递归(书上方法) O(log(n)) O(log(n)) 03 找规律 O(log(n)) O(1) func countDigitOne(n int) int { res := 0 digit := 1 high := n / 10 cur := n % 10 low := 0 for high != 0 || cur != 0 { if cur == 0 { res = res + high*digit } else if cur == 1 { res = res + high*digit + low + 1 } else { res = res + (high+1)*digit } low = low + cur*digit cur = high % 10 high = high / 10 digit = digit * 10 } return res } # func dfs(str string) int { if str == \"\" { return 0 } first := int(str[0] - '0') if len(str) == 1 && first == 0 { return 0 } if len(str) == 1 && first >= 1 { return 1 } count := 0 if first > 1 { count = int(math.Pow(float64(10), float64(len(str)-1))) } else if first == 1 { count, _ = strconv.Atoi(str[1:]) count = count + 1 } other := first * (len(str) - 1) * int(math.Pow(float64(10), float64(len(str)-2))) numLeft := dfs(str[1:]) return count + numLeft + other } # func countDigitOne(n int) int { if n 面试题44.数字序列中某一位的数字(2) 题目 数字以0123456789101112131415…的格式序列化到一个字符序列中。 在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。 请写一个函数，求任意第n位对应的数字。 示例 1：输入：n = 3 输出：3 示例 2：输入：n = 11 输出：0 限制： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 找规律(书上方法) O(log(n)) O(1) 02 找规律 O(log(n)) P func findNthDigit(n int) int { if n 0 { n = n - digits*count digits++ count = count * 10 number = number * 10 } number = number + (n-1)/digits index := (n - 1) % digits str := strconv.Itoa(number) return int(str[index] - '0') } 面试题45.把数组排成最小的数(3) 题目 输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。 示例 1:输入: [10,2] 输出: \"102\" 示例 2:输入: [3,30,34,5,9] 输出: \"3033459\" 提示:0 解题思路 No. 思路 时间复杂度 空间复杂度 01 自定义排序 O(nlog(n)) O(n) 02 快排(书上方法) O(nlog(n)) O(n) 03 实现sort接口 O(nlog(n)) O(n) func minNumber(nums []int) string { sort.Slice(nums, func(i, j int) bool { if fmt.Sprintf(\"%d%d\", nums[i], nums[j]) = end { return } temp := arr[start] i := start j := end for i = temp+arr[j] { j-- } for i 面试题46.把数字翻译成字符串(4) 题目 给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……， 11 翻译成 “l”，……，25 翻译成 “z”。 一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。 示例 1:输入: 12258 输出: 5 解释: 12258有5种不同的翻译，分别是\"bccfi\", \"bwfi\", \"bczi\", \"mcfi\"和\"mzi\" 提示： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历(书上方法) O(log(n)) O(log(n)) 02 递归 O(log(n)) O(log(n)) 03 遍历-从后往前 O(log(n)) O(1) 04 动态规划-一维数组 O(log(n)) O(log(n)) func translateNum(num int) int { if num = 0; i-- { count = 0 if i = 10 && value 9 { res = res + translateNum(num/100) res = res + translateNum(num/10) } else { res = res + translateNum(num/10) } return res } # // f(i)=f(i-2)+f(i-1) // f(i)=f(i-1) func translateNum(num int) int { if num 0 { i++ arr = append(arr, 0) arr[i] = arr[i-1] digit1 := num % 10 num = num / 10 if digit1 != 0 && prev >= 0 && digit1*10+prev 面试题47.礼物的最大价值(2) 题目 在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。 你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。 给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？ 示例 1:输入: [ [1,3,1], [1,5,1], [4,2,1] ] 输出: 12 解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物 提示： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划(书上方法) O(n^2) O(n^2) 02 动态规划(书上方法) O(n^2) O(n) func maxValue(grid [][]int) int { if len(grid) == 0 || len(grid[0]) == 0 { return 0 } dp := make([][]int, len(grid)) for i := 0; i 0 { left = dp[i-1][j] } if j > 0 { up = dp[i][j-1] } // dp[i][j]=grid[i-1][j-1]+max(dp[i][j-1],dp[i-1][j]) dp[i][j] = max(left, up) + grid[i][j] } } return dp[len(grid)-1][len(grid[0])-1] } func max(a, b int) int { if a > b { return a } return b } # func maxValue(grid [][]int) int { if len(grid) == 0 || len(grid[0]) == 0 { return 0 } dp := make([]int, len(grid)) for i := 0; i 0 { left = dp[j] } if j > 0 { up = dp[j-1] } // dp[j]=grid[i-1][j-1]+max(dp[j-1],dp[j]) dp[j] = max(left, up) + grid[i][j] } } return dp[len(grid[0])-1] } func max(a, b int) int { if a > b { return a } return b } 面试题48.最长不含重复字符的子字符串(4) 题目 请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。 示例 1:输入: \"abcabcbb\" 输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。 示例 2:输入: \"bbbbb\" 输出: 1 解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。 示例 3:输入: \"pwwkew\" 输出: 3 解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。 提示：s.length 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历+滑动窗口 O(n) O(n) 02 双指针 O(n) O(1) 03 动态规划 O(n) O(n) 04 动态规划(书上方法) O(n) O(1) func lengthOfLongestSubstring(s string) int { if len(s) 0 { for len(arr) > 0 && arr[0] != value { m[arr[0]]-- arr = arr[1:] } m[arr[0]]-- arr = arr[1:] } m[value]++ arr = append(arr, value) if len(arr) > res { res = len(arr) } } return res } # func lengthOfLongestSubstring(s string) int { if len(s) 0 { if right-left > res { res = right - left } left++ break } else { m[s[right]]++ right++ } } if right-left > res { res = right - left } if right >= len(s)-1 { break } } return res } # // dp[n]=dp[n-1]+1 // dp[n]=n-lastIndex func lengthOfLongestSubstring(s string) int { if len(s) dp[i-1] { dp[i] = dp[i-1] + 1 } else { dp[i] = i - index } m[s[i]] = i if dp[i] > res { res = dp[i] } } return res } # func lengthOfLongestSubstring(s string) int { if len(s) curLength { curLength++ } else { if curLength > res { res = curLength } curLength = i - preIndex } arr[s[i]] = i } if curLength > res { res = curLength } return res } 面试题49.丑数(1) 题目 我们把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。 示例:输入: n = 10 输出: 12 解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。 说明: 1 是丑数。n 不超过1690。 注意：本题与主站 264 题相同：https://leetcode-cn.com/problems/ugly-number-ii/ 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划(书上方法) O(n) O(n) func nthUglyNumber(n int) int { dp := make([]int, n) dp[0] = 1 // 丑数*2或3或5之后还是丑数 idx2, idx3, idx5 := 0, 0, 0 for i := 1; i b { return b }go return a } 面试题50.第一个只出现一次的字符(3) 题目 在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。 示例: s = \"abaccdeff\" 返回 \"b\" s = \"\" 返回 \" \" 限制：0 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助(书上方法) O(n) O(1) 02 数组辅助 O(n) O(1) 03 暴力法 O(n^2) O(1) func firstUniqChar(s string) byte { res := byte(' ') m := make(map[byte]int) for i := 0; i 面试题51.数组中的逆序对(1) 题目 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。 输入一个数组，求出这个数组中的逆序对的总数。 示例 1:输入: [7,5,6,4] 输出: 5 限制：0 解题思路 No. 思路 时间复杂度 空间复杂度 01 归并排序(书上方法) O(nlog(n)) O(n) var res int func reversePairs(nums []int) int { res = 0 if len(nums) = right { return } mid := (left + right) / 2 i, j := left, mid+1 merge(nums, left, mid) merge(nums, mid+1, right) temp := make([]int, 0) for i 面试题52.两个链表的第一个公共节点(4) 题目 输入两个链表，找出它们的第一个公共节点。 如下面的两个链表： 在节点 c1 开始相交。 示例 1： 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出：Reference of the node with value = 8 输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。 从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。 在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2： 输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 输出：Reference of the node with value = 2 输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3： 输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2 输出：null 输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。 解释：这两个链表不相交，因此返回 null。 注意： 如果两个链表没有交点，返回 null. 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。 本题与主站 160 题相同：https://leetcode-cn.com/problems/intersection-of-two-linked-lists/ 解题思路 No. 思路 时间复杂度 空间复杂度 01 计算长度后，对齐长度再比较(书上方法) O(n) O(1) 02 交换后相连，再比较 O(n) O(1) 03 暴力法 O(n^2) O(1) 04 哈希法 O(n) O(n) func getIntersectionNode(headA, headB *ListNode) *ListNode { ALength := 0 A := headA for A != nil { ALength++ A = A.Next } BLength := 0 B := headB for B != nil { BLength++ B = B.Next } pA := headA pB := headB if ALength > BLength { n := ALength - BLength for n > 0 { pA = pA.Next n-- } } else { n := BLength - ALength for n > 0 { pB = pB.Next n-- } } for pA != pB { pA = pA.Next pB = pB.Next } return pA } # func getIntersectionNode(headA, headB *ListNode) *ListNode { A, B := headA, headB for A != B { if A != nil { A = A.Next } else { A = headB } if B != nil { B = B.Next } else { B = headA } } return A } # func getIntersectionNode(headA, headB *ListNode) *ListNode { A, B := headA, headB for A != nil { for B != nil { if A == B { return A } B = B.Next } A = A.Next B = headB } return nil } # 4 func getIntersectionNode(headA, headB *ListNode) *ListNode { m := make(map[*ListNode]bool) for headA != nil { m[headA] = true headA = headA.Next } for headB != nil { if _, ok := m[headB]; ok { return headB } headB = headB.Next } return nil } 面试题53-I.在排序数组中查找数字I(5) 题目 统计一个数字在排序数组中出现的次数。 示例 1:输入: nums = [5,7,7,8,8,10], target = 8 输出: 2 示例 2:输入: nums = [5,7,7,8,8,10], target = 6 输出: 0 限制：0 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(1) 02 遍历 O(n) O(1) 03 双指针遍历 O(n) O(1) 04 二分查找 O(log(n)) O(1) 04 二分查找(书上方法) O(log(n)) O(1) func search(nums []int, target int) int { m := make(map[int]int) for i := 0; i = 0 && nums[j] != target { j-- } if i > j { return 0 } return j - i + 1 } # func search(nums []int, target int) int { left := 0 right := len(nums) - 1 count := 0 for left = 0; i--{ if nums[i] == target{ count++ }else { break } } return count } if nums[mid] > target{ right = mid-1 }else { left = mid+1 } } return count } # func search(nums []int, target int) int { count := 0 if len(nums) > 0 { first := getFirstK(nums, target, 0, len(nums)-1) last := getLastK(nums, target, 0, len(nums)-1) if first > -1 && last > -1 { count = last - first + 1 } } return count } func getFirstK(nums []int, target int, start, end int) int { if start > end { return -1 } mid := start + (end-start)/2 if nums[mid] == target { if (mid > 0 && nums[mid-1] != target) || mid == 0 { return mid } else { end = mid - 1 } } else if nums[mid] > target { end = mid - 1 } else { start = mid + 1 } return getFirstK(nums, target, start, end) } func getLastK(nums []int, target int, start, end int) int { if start > end { return -1 } mid := start + (end-start)/2 if nums[mid] == target { if (mid 面试题53-II.0～n-1中缺失的数字(6) 题目 一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。 在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。 示例 1:输入: [0,1,3] 输出: 2 示例 2:输入: [0,1,2,3,4,5,6,7,9] 输出: 8 限制：1 解题思路 No. 思路 时间复杂度 空间复杂度 01 数学计算 O(n) O(1) 02 遍历 O(n) O(1) 03 异或-位运算 O(n) O(1) 04 哈希辅助 O(n) O(n) 05 二分查找(书上方法) O(log(n)) O(1) 06 内置函数 O(n) O(1) func missingNumber(nums []int) int { n := len(nums) sum := n * (n + 1) / 2 for i := 0; i 面试题54.二叉搜索树的第k大节点(3) 题目 给定一棵二叉搜索树，请找出其中第k大的节点。 示例 1: 输入: root = [3,1,4,null,2], k = 1 3 / \\ 1 4 \\ 2 输出: 4 示例 2:输入: root = [5,3,6,2,4,null,null,1], k = 3 5 / \\ 3 6 / \\ 2 4 / 1 输出: 4 限制：1 ≤ k ≤ 二叉搜索树元素个数 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归(书上方法) O(n) O(log(n)) 02 递归+数组 O(n) O(n) 03 迭代 O(n) O(n) var count int var res int func kthLargest(root *TreeNode, k int) int { count = k res = 0 dfs(root) return res } func dfs(root *TreeNode) { if root == nil { return } dfs(root.Right) count-- if count == 0 { res = root.Val return } dfs(root.Left) } # var arr []int func kthLargest(root *TreeNode, k int) int { arr = make([]int, 0) dfs(root) return arr[k-1] } func dfs(root *TreeNode) { if root == nil { return } dfs(root.Right) arr = append(arr, root.Val) dfs(root.Left) } # func kthLargest(root *TreeNode, k int) int { if root == nil { return 0 } arr := make([]int, 0) stack := make([]*TreeNode, 0) cur := root for len(stack) > 0 || cur != nil { for cur != nil { stack = append(stack, cur) cur = cur.Left } node := stack[len(stack)-1] arr = append(arr, node.Val) stack = stack[:len(stack)-1] cur = node.Right } return arr[len(arr)-k] } 面试题55-I.二叉树的深度(2) 题目 输入一棵二叉树的根节点，求该树的深度。 从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。 例如： 给定二叉树 [3,9,20,null,null,15,7]， 3 / \\ 9 20 / \\ 15 7 返回它的最大深度 3 。 提示：节点总数 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归(书上方法) O(n) O(log(n)) 02 迭代 O(n) O(n) func maxDepth(root *TreeNode) int { if root == nil { return 0 } left := maxDepth(root.Left) right := maxDepth(root.Right) return max(left, right) + 1 } func max(a, b int) int { if a > b { return a } return b } # func maxDepth(root *TreeNode) int { if root == nil { return 0 } queue := make([]*TreeNode, 0) queue = append(queue, root) depth := 0 for len(queue) > 0 { length := len(queue) for i := 0; i 面试题55-II.平衡二叉树(2) 题目 输入一棵二叉树的根节点，判断该树是不是平衡二叉树。 如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。 示例 1:给定二叉树 [3,9,20,null,null,15,7] 3 / \\ 9 20 / \\ 15 7 返回 true 。 示例 2:给定二叉树 [1,2,2,3,3,null,null,4,4] 1 / \\ 2 2 / \\ 3 3 / \\ 4 4 返回 false 。 限制：1 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 递归(书上方法) O(n) O(log(n)) func isBalanced(root *TreeNode) bool { _, isBalanced := recur(root) return isBalanced } func recur(root *TreeNode) (int, bool) { if root == nil { return 0, true } leftDepth, leftIsBalanced := recur(root.Left) if leftIsBalanced == false { return 0, false } rightDepth, rightIsBalanced := recur(root.Right) if rightIsBalanced == false { return 0, false } if -1 b { return a } return b } # func isBalanced(root *TreeNode) bool { return dfs(root) != -1 } func dfs(root *TreeNode) int { if root == nil { return 0 } left := dfs(root.Left) right := dfs(root.Right) if left != -1 && right != -1 && abs(left, right) b { return a } return b } func abs(a, b int) int { if a > b { return a - b } return b - a } 面试题56-I.数组中数字出现的次数(5) 题目 一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。 请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。 示例 1： 输入：nums = [4,1,4,6]输出：[1,6] 或 [6,1] 示例 2：输入：nums = [1,2,10,4,1,4,3,3] 输出：[2,10] 或 [10,2] 限制： 2 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(n) 02 排序 O(nlog(n)) O(1) 03 位运算 O(n) O(1) 04 位运算 O(n) O(1) 05 位运算(书上方法) O(n) O(1) func singleNumbers(nums []int) []int { m := make(map[int]int) for i := 0; i > 1 } return res } func isBit(num int, index int) bool { num = num >> index return num&1 == 1 } 面试题56-II.数组中数字出现的次数II(5) 题目 在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。 示例 1：输入：nums = [3,4,3,3] 输出：4 示例 2：输入：nums = [9,1,7,9,7,9,7] 输出：1 限制： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(n) 02 统计1的位求余(书上方法) O(n) O(1) 03 排序遍历 O(nlog(n)) O(1) 04 求和遍历 O(n) O(n) 05 位运算(有限状态自动机) O(n) O(1) func singleNumber(nums []int) int { m := make(map[int]int) for i := 0; i = 0; j-- { arr[j] = arr[j] + value&1 value = value / 2 } } res := 0 for i := 0; i 面试题57.和为s的两个数字(2) 题目 输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。 如果有多对数字的和等于s，则输出任意一对即可。 示例 1：输入：nums = [2,7,11,15], target = 9 输出：[2,7] 或者 [7,2] 示例 2：输入：nums = [10,26,30,31,47,60], target = 40 输出：[10,30] 或者 [30,10] 限制： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针(书上方法) O(n) O(1) 02 哈希辅助 O(n) O(n) func twoSum(nums []int, target int) []int { i := 0 j := len(nums) - 1 for i target { j-- } else { i++ } } return nil } # func twoSum(nums []int, target int) []int { m := make(map[int]int, len(nums)) for i, b := range nums { if j, ok := m[target-b]; ok { return []int{nums[j], nums[i]} } m[b] = i } return nil } 面试题57-II.和为s的连续正数序列(4) 题目 输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。 序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。 示例 1：输入：target = 9 输出：[[2,3,4],[4,5]] 示例 2：输入：target = 15 输出：[[1,2,3,4,5],[4,5,6],[7,8]] 限制：1 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n) O(1) 02 双指针(书上方法) O(n) O(1) 03 前缀和-暴力法 O(n^2) O(n) 04 数学法 O(n) O(1) func findContinuousSequence(target int) [][]int { res := make([][]int, 0) i := 1 j := 2 for i target && i = 2; i-- { nA1 := target - i*(i-1)/2 if nA1 面试题58-I.翻转单词顺序(3) 题目 输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。 为简单起见，标点符号和普通字母一样处理。 例如输入字符串\"I am a student. \"，则输出\"student. a am I\"。 示例 1：输入: \"the sky is blue\" 输出: \"blue is sky the\" 示例 2：输入: \" hello world! \" 输出: \"world! hello\" 解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 示例 3：输入: \"a good example\" 输出: \"example good a\" 解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 说明： 无空格字符构成一个单词。 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 注意：本题与主站 151 题相同：https://leetcode-cn.com/problems/reverse-words-in-a-string/ 注意：此题对比原题有改动 解题思路 No. 思路 时间复杂度 空间复杂度 01 内置函数 O(n) O(n) 02 遍历-2次反转(书上方法) O(n) O(n) 03 遍历 O(n) O(n) func reverseWords(s string) string { s = strings.Trim(s, \" \") arr := strings.Fields(s) for i := 0; i 0 { return res[1:] } return res } func reverse(arr []byte) []byte { start := 0 end := len(arr) - 1 for start = 0 { if arr[i] == ' ' { if flag == true { res = res + \" \" + string(arr[i+1:j]) flag = false } j = i i-- } else { if i == 0 { res = res + \" \" + string(arr[i:j]) } i-- flag = true } } if len(res) > 0 { return res[1:] } return res } 面试题58-II.左旋转字符串(2) 题目 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。 比如，输入字符串\"abcdefg\"和数字2，该函数将返回左旋转两位得到的结果\"cdefgab\"。 示例 1：输入: s = \"abcdefg\", k = 2 输出: \"cdefgab\" 示例 2：输入: s = \"lrloseumgh\", k = 6 输出: \"umghlrlose\" 限制： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 切片 O(n) O(n) 02 三次反转(书上方法) O(n) O(n) func reverseLeftWords(s string, n int) string { n = n % len(s) return s[n:] + s[:n] } # func reverseLeftWords(s string, n int) string { n = n % len(s) arr := []byte(s) reverse(arr, 0, n-1) reverse(arr, n, len(arr)-1) reverse(arr, 0, len(arr)-1) return string(arr) } func reverse(arr []byte, start, end int) []byte { for start 面试题59-I.滑动窗口的最大值(4) 题目 给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。 示例:输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3 输出: [3,3,5,5,6,7] 解释: 滑动窗口的位置 最大值 --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 提示：你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。 注意：本题与主站 239 题相同：https://leetcode-cn.com/problems/sliding-window-maximum/ 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法 O(n^2) O(n) 02 暴力法-有条件更新最大值 O(n^2) O(n) 03 双端队列(书上方法) O(n) O(n) 04 堆排序 O(nlog(n)) O(n) func maxSlidingWindow(nums []int, k int) []int { res := make([]int, 0) if len(nums) == 0 { return res } for i := 0; i max { max = nums[j] } } res = append(res, max) } return res } # func maxSlidingWindow(nums []int, k int) []int { res := make([]int, 0) if len(nums) == 0 { return res } max := math.MaxInt32 for i := 0; i max { max = nums[j] } } } else { if nums[i+k-1] > max { max = nums[i+k-1] } } res = append(res, max) } return res } # func maxSlidingWindow(nums []int, k int) []int { res := make([]int, 0) if len(nums) == 0 { return res } deque := make([]int, 0) for i := 0; i 0 && nums[i] >= nums[deque[len(deque)-1]] { deque = deque[:len(deque)-1] } deque = append(deque, i) } for i := k; i 0 && nums[i] >= nums[deque[len(deque)-1]] { deque = deque[:len(deque)-1] } if len(deque) > 0 && deque[0] i[y] } func (i IntHeap) Swap(x, y int) { i[x], i[y] = i[y], i[x] } func (i *IntHeap) Push(v interface{}) { *i = append(*i, v.(int)) } func (i *IntHeap) Pop() interface{} { value := (*i)[len(*i)-1] *i = (*i)[:len(*i)-1] return value } func (i *IntHeap) Remove(x interface{}) { for j := 0; j 面试题59-II.队列的最大值(2) 题目 请定义一个队列并实现函数 max_value 得到队列里的最大值， 要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。 若队列为空，pop_front 和 max_value 需要返回 -1 示例 1：输入: [\"MaxQueue\",\"push_back\",\"push_back\",\"max_value\",\"pop_front\",\"max_value\"] [[],[1],[2],[],[],[]] 输出: [null,null,null,2,1,2] 示例 2：输入: [\"MaxQueue\",\"pop_front\",\"max_value\"] [[],[],[]] 输出: [null,-1,-1] 限制： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 双队列(书上方法) O(1) O(n) 02 内置list O(1) O(n) type MaxQueue struct { data []int max []int } func Constructor() MaxQueue { return MaxQueue{ data: make([]int, 0), max: make([]int, 0), } } func (this *MaxQueue) Max_value() int { if len(this.max) == 0 { return -1 } return this.max[0] } func (this *MaxQueue) Push_back(value int) { this.data = append(this.data, value) for len(this.max) > 0 && value > this.max[len(this.max)-1] { this.max = this.max[:len(this.max)-1] } this.max = append(this.max, value) } func (this *MaxQueue) Pop_front() int { res := -1 if len(this.data) > 0 { res = this.data[0] this.data = this.data[1:] if res == this.max[0] { this.max = this.max[1:] } } return res } # type MaxQueue struct { data *list.List max []int } func Constructor() MaxQueue { return MaxQueue{ data:list.New(), max: make([]int, 0), } } func (this *MaxQueue) Max_value() int { if len(this.max) == 0 { return -1 } return this.max[0] } func (this *MaxQueue) Push_back(value int) { this.data.PushBack(value) for len(this.max) > 0 && value > this.max[len(this.max)-1] { this.max = this.max[:len(this.max)-1] } this.max = append(this.max, value) } func (this *MaxQueue) Pop_front() int { res := -1 if this.data.Len() > 0 { res = this.data.Front().Value.(int) this.data.Remove(this.data.Front()) if res == this.max[0] { this.max = this.max[1:] } } return res } 面试题60.n个骰子的点数(2) 题目 把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。 你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。 示例 1:输入: 1 输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667] 示例 2:输入: 2 输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111, 0.08333,0.05556,0.02778] 限制： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 递推-数组辅助(书上方法) O(n) O(n) 02 递推-动态规划 O(n) O(n) 03 递归-超时(书上方法) O(6^n) O(n) func twoSum(n int) []float64 { res := make([]float64, 0) if n = i; j-- { arr[j] = 0 for k := 1; k = i-1 { arr[j] = arr[j] + arr[j-k] } } } } total := math.Pow(float64(6), float64(n)) for i := n; i 面试题61.扑克牌中的顺子(3) 题目 从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。 2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。 示例 1:输入: [1,2,3,4,5] 输出: True 示例 2:输入: [0,0,1,2,5] 输出: True 限制：数组长度为 5 数组的数取值为 [0, 13] . 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序遍历 O(1) O(1) 02 哈希辅助 O(1) O(1) 03 排序遍历(书上方法) O(1) O(1) func isStraight(nums []int) bool { sort.Ints(nums) sum := 0 for i := 0; i max { max = nums[i] } if nums[i] zero { return false } return true } 面试题62.圆圈中最后剩下的数字(2) 约瑟夫环理解参考： https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/huan-ge-jiao-du-ju-li-jie-jue-yue-se-fu-huan-by-as/ 题目 0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。 求出这个圆圈里剩下的最后一个数字。 例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字， 则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。 示例 1：输入: n = 5, m = 3 输出: 3 示例 2：输入: n = 10, m = 17 输出: 2 限制： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(n) 02 递推(书上方法) O(n) O(1) 03 模拟-超时 O(n^2) O(n) func lastRemaining(n int, m int) int { if n == 1 { return 0 } return (lastRemaining(n-1, m) + m) % n } # func lastRemaining(n int, m int) int { res := 0 for i := 2; i 1 { index := (last + m - 1) % len(arr) arr = remove(arr, index) last = index } return arr[0] } func remove(arr []int, index int) []int { if index == 0 { return arr[1:] } if index == len(arr)-1 { return arr[:len(arr)-1] } return append(arr[:index], arr[index+1:]...) } 面试题63.股票的最大利润(3) 题目 假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？ 示例 1:输入: [7,1,5,3,6,4] 输出: 5 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出， 最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2:输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 限制： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法 O(n^2) O(1) 02 动态规划(从前到后) 最大利润=max{前一天最大利润, 今天的价格 - 之前最低价格}(书上方法) O(n) O(1) 03 动态规划(从后到前) O(n) O(1) func maxProfit(prices []int) int { max := 0 length := len(prices) for i := 0; i max { max = prices[j] - prices[i] } } } return max } # func maxProfit(prices []int) int { if len(prices) = 0; i-- { if max 面试题64.求1+2+…+n(2) 题目 求 1+2+...+n ，要求不能使用乘除法、 for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 示例 1：输入: n = 3 输出: 6 示例 2：输入: n = 9 输出: 45 限制：1 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(n) 02 内置函数 O(1) O(1) var res int func sumNums(n int) int { res = 0 dfs(n) return res } func dfs(n int) bool { res = res + n return n > 0 && dfs(n-1) } # func sumNums(n int) int { return (int(math.Pow(float64(n), float64(2))) + n) >> 1 } 面试题65.不用加减乘除做加法(2) 题目 写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。 示例:输入: a = 1, b = 1 输出: 2 提示： a, b 均可能是负数或 0 结果不会溢出 32 位整数 解题思路 No. 思路 时间复杂度 空间复杂度 01 迭代(书上方法) O(1) O(1) 02 递归 O(1) O(1) // 非进位和：异或运算 // 进位：与运算+左移一位 func add(a int, b int) int { for b != 0 { a, b = a^b, (a&b) 面试题66.构建乘积数组(2) 题目 给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]， 其中 B 中的元素 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。 示例:输入: [1,2,3,4,5] 输出: [120,60,40,30,24] 提示：所有元素乘积之和不会溢出 32 位整数 a.length 解题思路 No. 思路 时间复杂度 空间复杂度 01 二次遍历(书上方法) O(n) O(1) 02 数组辅助 O(n) O(n) func constructArr(a []int) []int { res := make([]int, len(a)) if len(a) == 0 { return res } res[0] = 1 for i := 1; i = 0; i-- { res[i] = res[i] * a[i+1] * temp temp = temp * a[i+1] } return res } # func constructArr(a []int) []int { res := make([]int, len(a)) if len(a) == 0 { return res } left := make([]int, len(a)) left[0] = 1 right := make([]int, len(a)) right[len(a)-1] = 1 for i := 1; i = 0; i-- { right[i] = right[i+1] * a[i+1] } for i := 0; i 面试题67.把字符串转换成整数(2) 题目 写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来， 作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、 字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0。 说明： 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 示例 1:输入: \"42\"输出: 42 示例 2:输入: \" -42\"输出: -42 解释: 第一个非空白字符为 '-', 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 示例 3:输入: \"4193 with words\"输出: 4193 解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。 示例 4:输入: \"words and 987\" 输出: 0 解释: 第一个非空字符是 'w', 但它不是数字或正、负号。 因此无法执行有效的转换。 示例 5:输入: \"-91283472332\" 输出: -2147483648 因此返回 INT_MIN (−231) 。 注意：本题与主站 8 题相同：https://leetcode-cn.com/problems/string-to-integer-atoi/ 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(n) 02 正则 O(n) O(n) func strToInt(str string) int { i := 0 for i = '0' && str[j] 0 { break } if str[j] != ' ' && str[j] != '+' && str[j] != '-' { return 0 } if isFlag != ' ' { return 0 } isFlag = str[j] } } res := 0 for i := 0; i math.MaxInt32 { return math.MaxInt32 } } } if isFlag == '-' { return -1 * res } return res } # func strToInt(str string) int { re := regexp.MustCompile(`^[+-]?\\d+`) arrS := re.FindAllString(strings.Trim(str, \" \"), -1) if len(arrS) == 0{ return 0 } arr := arrS[0] res := 0 isFlag := byte(' ') if !(arr[0] >= '0' && arr[0] 214748364 || (res==214748364 && value >= 8) { return math.MinInt32 } } else if isFlag == ' ' || isFlag == '+' { if res > 214748364 || (res==214748364 && value >= 7) { return math.MaxInt32 } } res = res*10 + value } if isFlag == '-' { return -1 * res } return res } Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-07-14 17:48:59 "},"docs/source/classification/easy.html":{"url":"docs/source/classification/easy.html","title":"初级算法-完成","keywords":"","body":"初级算法(49) 初级算法 - 帮助入门 本系列共49题 原文分类链接 https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/ 1.数组(11) Title Tag 难度 完成情况 26.删除排序数组中的重复项 数组、双指针 Easy 完成 122.买卖股票的最佳时机 II 贪心算法、数组 Easy 完成 189.旋转数组 数组 Easy 完成 217.存在重复元素 数组、哈希表 Easy 完成 136.只出现一次的数字 位运算、哈希表 Easy 完成 350.两个数组的交集 II 排序、哈希表、双指针、二分查找 Easy 完成 66.加一 数组 Easy 完成 283.移动零 数组、双指针 Easy 完成 1.两数之和 数组、哈希表 Easy 完成 36.有效的数独 哈希表 Medium 完成 48.旋转图像 数组 Medium 完成 2.字符串(9) Title Tag 难度 完成情况 344.反转字符串 双指针、字符串 Easy 完成 7.整数反转 数学 Easy 完成 387.字符串中的第一个唯一字符 哈希表、字符串 Easy 完成 242.有效的字母异位词 排序、哈希 Easy 完成 验证回文字符串125.验证回文串 双指针、字符串 Easy 完成 8.字符串转换整数 (atoi) 数字、字符串 Medium 完成 28.实现strStr() 双指针、字符串 Easy 完成 外观数列 38.报数 字符串 Easy 完成 14.最长公共前缀 字符串 Easy 完成 3.链表(6) Title Tag 难度 完成情况 237.删除链表中的节点 链表 Easy 完成 19.删除链表的倒数第N个节点 链表、双指针 Medium 完成 206.反转链表 链表 Easy 完成 21.合并两个有序链表 链表 Easy 完成 234.回文链表 链表、双指针 Easy 完成 141.环形链表 链表、双指针 Easy 完成 4.树(5) Title Tag 难度 完成情况 104.二叉树的最大深度 树、深度优先搜索 Easy 完成 98.验证二叉搜索树 树、深度优先搜索 Medium 完成 101.对称二叉树 树、深度优先搜索、广度优先搜索 Easy 完成 102.二叉树的层序遍历 树、广度优先搜索 Medium 完成 108.将有序数组转换为二叉搜索树 树、深度优先搜索 Easy 完成 5.排序和搜索(2) Title Tag 难度 完成情况 88.合并两个有序数组 数组、双指针 Easy 完成 278.第一个错误的版本 二分查找 Easy 完成 6.动态规划(4) Title Tag 难度 完成情况 70.爬楼梯 动态规划 Easy 完成 121.买卖股票的最佳时机 数组、动态规划 Easy 完成 53.最大子序和 数组、分治算法、动态规划 Easy 完成 198.打家劫舍 动态规划 Easy 完成 7.设计问题(2) Title Tag 难度 完成情况 Shuffle an Array 384.打乱数组 Medium 完成 155.最小栈 栈、设计 Easy 完成 8.数学(4) Title Tag 难度 完成情况 412.Fizz Buzz Easy 完成 204.计数质数 哈希表、数学 Easy 完成 326.3的幂 数学 Easy 完成 13.罗马数字转整数 数学、字符串 Easy 完成 9.其他(6) Title Tag 难度 完成情况 191.位1的个数 位运算 Easy 完成 461.汉明距离 位运算 Easy 完成 190.颠倒二进制位 位运算 Easy 完成 帕斯卡三角形 118.杨辉三角 数组 Easy 完成 20.有效的括号 栈、字符串 Easy 完成 268.缺失数字 位运算、数组、数学 Easy 完成 Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-07-21 16:07:34 "},"docs/source/classification/medium.html":{"url":"docs/source/classification/medium.html","title":"中级算法","keywords":"","body":"中级算法(45) 中级算法 - 巩固训练 本系列共45题 原文分类链接 https://leetcode-cn.com/explore/interview/card/top-interview-questions-medium/ 1.数组和字符串(6) Title Tag 难度 完成情况 15.三数之和 数组、双指针 Medium 完成 73.矩阵置零 数组 Medium 完成 49.字母异位词分组 哈希表、字符串 Medium 完成 3.无重复字符的最长子串 哈希表、双指针、字符串Sliding Window Medium 完成 5.最长回文子串 字符串、动态规划 Medium 完成 递增的三元子序列 2.链表(3) Title Tag 难度 完成情况 2.两数相加 链表、数学 Medium 完成 奇偶链表 相交链表 3.树和图(6) Title Tag 难度 完成情况 中序遍历二叉树 94.二叉树的中序遍历 栈、树、哈希表 Medium 完成 103.二叉树的锯齿形层次遍历 栈、树、广度优先搜索 Medium 完成 105.从前序与中序遍历序列构造二叉树 树、深度优先搜索、数组 Medium 完成 填充每个节点的下一个右侧节点指针 二叉搜索树中第K小的元素 岛屿数量 4.回溯算法(5) Title Tag 难度 完成情况 17.电话号码的字母组合 字符串、回溯算法 Medium 完成 22.括号生成 字符串、回溯算法 Medium 完成 46.全排列 回溯算法 Medium 完成 78.子集 位运算、数组、回溯算法 Medium 完成 79.单词搜索 数组、回溯算法 Medium 完成 5.排序和搜索(8) Title Tag 难度 完成情况 75.颜色分类 排序、数组、双指针 Medium 完成 前 K 个高频元素 数组中的第K个最大元素 162.寻找峰值 数组、二分查找 Medium 完成 34.在排序数组中查找元素的第一个和最后一个位置 数组、二分查找 Medium 完成 56.合并区间 排序、数组 Medium 完成 33.搜索旋转排序数组 数组、二分查找 Medium 完成 搜索二维矩阵 II 6.动态规划(4) Title Tag 难度 完成情况 55.跳跃游戏 贪心算法、数组 Medium 完成 62.不同路径 数组、动态规划 Medium 完成 零钱兑换 Longest Increasing Subsequence 7.设计问题(2) Title Tag 难度 完成情况 二叉树的序列化与反序列化 Insert Delete GetRandom O(1) 8.数学(7) Title Tag 难度 完成情况 202.快乐数 哈希表、数学 Easy 完成 172.阶乘后的零 数学 Easy 完成 171.Excel表列序号 数学 Easy 完成 50.Pow(x,n) 数学、二分查找 Medium 完成 69.x 的平方根 数学，二分查找 Easy 完成 29.两数相除 数学、二分查找 Medium 完成 分数到小数 9.其他(4) Title Tag 难度 完成情况 371.两整数之和 位运算 Easy 完成 150.逆波兰表达式求值 栈 Medium 完成 169.多数元素 位运算、数组、分治算法 Easy 完成 任务调度器 Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-07-25 08:12:47 "},"docs/source/classification/hard.html":{"url":"docs/source/classification/hard.html","title":"高级算法","keywords":"","body":"高级算法(47) 高级算法 - 提升进阶 本系列共47题 原文分类链接 https://leetcode-cn.com/explore/interview/card/top-interview-questions-hard/ 1.数组和字符串(11) Title Tag 难度 完成情况 除自身以外数组的乘积 54.螺旋矩阵 数组 Medium 完成 四数相加 II 11.盛最多水的容器 数组、双指针 Medium 完成 生命游戏 缺失的第一个正数 最长连续序列 寻找重复数 基本计算器 II 滑动窗口最大值 最小覆盖子串 2.链表(3) Title Tag 难度 完成情况 合并K个元素的有序链表 链表排序 复制带随机指针的链表 3.树和图(9) Title Tag 难度 完成情况 单词接龙 被围绕的区域 二叉树的最近公共祖先 二叉树中的最大路径和 Friend Circles 课程表 课程表 II 矩阵中的最长递增路径 计算右侧小于当前元素的个数 4.回溯算法(5) Title Tag 难度 完成情况 131.分割回文串 回溯算法 Medium 完成 单词搜索 II Remove Invalid Parentheses 通配符匹配 正则表达式匹配 5.排序和搜索 Title Tag 难度 完成情况 摆动排序 II 有序矩阵中第K小的元素 寻找两个正序数组的中位数 6.动态规划 Title Tag 难度 完成情况 152.乘积最大子数组 数组、动态规划 Medium 完成 7.设计问题(4) 8.数学 Title Tag 难度 完成情况 179.最大数 排序 Medium 完成 Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-07-26 01:35:30 "},"docs/source/classification/offer.html":{"url":"docs/source/classification/offer.html","title":"书籍-剑指offer-完成","keywords":"","body":"剑指offer 参考资料 本系列共68题，leetcode上共75题，其中编号36、37、74、75提交没有Go语言 leetcode专栏链接 https://leetcode-cn.com/problemset/lcof/ http://zhedahht.blog.163.com/ 《剑指Offer》第二版源代码 C++ https://github.com/zhedahht/CodingInterviewChinese2 No. Title Tag 难度 完成情况 第二章：面试需要的基础知识 2.2 编程语言 面试题1 赋值运算符函数 - - - 面试题2 实现Singleton模式 - - - 2.3 数据结构 0001 面试题3 面试题03.数组中重复的数字 数组、哈希表 Easy 完成 0002 面试题4 面试题04.二维数组中的查找 数组、双指针 Easy 完成 0003 面试题5 面试题05.替换空格 Easy 完成 0004 面试题6 面试题06.从尾到头打印链表 Easy 完成 0005 面试题7 面试题07.重建二叉树 树、递归 Medium 完成 面试题8 二叉树的下一个节点 - - - 0006 面试题9 面试题09.用两个栈实现队列 栈、设计 Easy 完成 2.4 算法和数据操作 0007 面试题10 面试题10- I.斐波那契数列 递归 Easy 完成 0008 面试题10- II.青蛙跳台阶问题 递归 Easy 完成 0009 面试题11 面试题11.旋转数组的最小数字 二分查找 Easy 完成 0010 面试题12 面试题12.矩阵中的路径 动态规划 Medium 完成 0011 面试题13 面试题13.机器人的运动范围 Medium 完成 0012 面试题14 面试题14- I.剪绳子 数学、动态规划 Medium 完成 0013 面试题14-II.剪绳子 II 数学、动态规划 Medium 完成 0014 面试题15 面试题15.二进制中1的个数 位运算 Easy 完成 第三章：高质量的代码 3.3 代码的完整性 0015 面试题16 面试题16.数值的整数次方 递归 Medium 完成 0016 面试题17 面试题17.打印从1到最大的n位数 数学 Easy 完成 0017 面试题18 面试题18.删除链表的节点 链表 Easy 完成 0018 面试题19 面试题19.正则表达式匹配 动态规划 Hard 完成 0019 面试题20 面试题20.表示数值的字符串 数学 Medium 完成 0020 面试题21 面试题21.调整数组顺序使奇数位于偶数前面 Easy 完成 3.4 代码的鲁棒性 0021 面试题22 面试题22.链表中倒数第k个节点 链表、双指针 Easy 完成 面试题23 链表中环的入口节点 - - - 0022 面试题24 面试题24.反转链表 链表 Easy 完成 0023 面试题25 面试题25.合并两个排序的链表 分治算法 Easy 完成 0024 面试题26 面试题26.树的子结构 树 Medium 完成 第四章：解决面试题的思路 4.2 画图让抽象问题形象化 0025 面试题27 面试题27.二叉树的镜像 树 Easy 完成 0026 面试题28 面试题28.对称的二叉树 树 Easy 完成 0027 面试题29 面试题29.顺时针打印矩阵 数组 Easy 完成 4.3 举例让抽象问题具体化 0028 面试题30 面试题30.包含min函数的栈 栈、设计 Easy 完成 0029 面试题31 面试题31. 栈的压入弹出序列 Medium 完成 0030 面试题32 面试题32-I.从上到下打印二叉树 树、广度优先搜索 Medium 完成 0031 面试题32-II.从上到下打印二叉树II 树、广度优先搜索 Easy 完成 0032 面试题32-III.从上到下打印二叉树III 树、广度优先搜索 Medium 完成 0033 面试题33 面试题33.二叉搜索树的后序遍历序列 Medium 完成 0034 面试题34 面试题34.二叉树中和为某一值的路径 树、深度优先搜索 Medium 完成 4.4 分解让复杂问题简单化 0035 面试题35 面试题35.复杂链表的复制 链表 Medium 完成 0036 面试题36 面试题36.二叉搜索树与双向链表 分治算法 Medium [提交没有Go语言] 0037 面试题37 面试题37.序列化二叉树 树、设计 Hard [提交没有Go语言] 0038 面试题38 面试题38.字符串的排列 回溯算法 Medium 完成 第五章：优化时间和空间效率 5.2 时间效率 0039 面试题39 面试题39.数组中出现次数超过一半的数字 位运算、分治算法 Easy 完成 0040 面试题40 面试题40.最小的k个数 堆、分治算法 Easy 完成 0041 面试题41 面试题41.数据流中的中位数 堆、设计 Hard 完成 0042 面试题42 面试题42.连续子数组的最大和 分治算法、动态规划 Easy 完成 0043 面试题43 面试题43.1～n整数中1出现的次数 数学 Medium 完成 0044 面试题44 面试题44.数字序列中某一位的数字 数学 Medium 完成 0045 面试题45 面试题45.把数组排成最小的数 排序 Medium 完成 0046 面试题46 面试题46.把数字翻译成字符串 Medium 完成 0047 面试题47 面试题47.礼物的最大价值 动态规划 Medium 完成 0048 面试题48 面试题48.最长不含重复字符的子字符串 哈希表、双指针、Sliding Window Medium 完成 5.3 时间效率与空间效率的平衡 0049 面试题49 面试题49.丑数 数学 Medium 完成 0050 面试题50 面试题50.第一个只出现一次的字符 哈希表 Easy 完成 0051 面试题51 面试题51.数组中的逆序对 Hard 完成 0052 面试题52 面试题52.两个链表的第一个公共节点 链表 Easy 完成 第六章：面试中的各项能力 6.3 知识迁移能力 0053 面试题53 面试题53-I.在排序数组中查找数字I 数组、二分查找 Easy 完成 0054 面试题53-II.0～n-1中缺失的数字 数组、二分查找 Easy 完成 0055 面试题54 面试题54.二叉搜索树的第k大节点 树 Easy 完成 0056 面试题55 面试题55-I.二叉树的深度 树、深度优先搜索 Easy 完成 0057 面试题55-II.平衡二叉树 树、深度优先搜索 Easy 完成 0058 面试题56 面试题56-I.数组中数字出现的次数 Medium 完成 0059 面试题56-II.数组中数字出现的次数II Medium 完成 0060 面试题57 面试题57.和为s的两个数字 Easy 完成 0061 面试题57-II.和为s的连续正数序列 Easy 完成 0062 面试题58 面试题58-I.翻转单词顺序 字符串 Easy 完成 0063 面试题58-II.左旋转字符串 字符串 Easy 完成 0064 面试题59 面试题59-I.滑动窗口的最大值 栈、Sliding Window Easy 完成 0065 面试题59-II.队列的最大值 栈、Sliding Window Medium 完成 6.4 抽象建模能力 0066 面试题60 面试题60.n个骰子的点数 Easy 完成 0067 面试题61 面试题61.扑克牌中的顺子 Easy 完成 0068 面试题62 面试题62.圆圈中最后剩下的数字 Easy 完成 0069 面试题63 面试题63.股票的最大利润 动态规划 Medium 完成 6.5 发散思维能力 0070 面试题64 面试题64.求1+2+…+n Medium 完成 0071 面试题65 面试题65.不用加减乘除做加法 Easy 完成 0072 面试题66 面试题66.构建乘积数组 Easy 完成 第七章：两个面试案例 0073 面试题67 面试题67.把字符串转换成整数 数学、字符串 Medium 完成 0074 面试题68 面试题68-I.二叉搜索树的最近公共祖先 树 Easy [提交没有Go语言] 0075 面试题68-II.二叉树的最近公共祖先 树 Easy [提交没有Go语言] Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-07-23 18:36:56 "},"docs/source/classification/lcci.html":{"url":"docs/source/classification/lcci.html","title":"书籍-程序员面试金典","keywords":"","body":"程序员面试金典 参考资料 本系统共xx题， leetcode专栏链接 https://leetcode-cn.com/problemset/lcci/ https://github.com/careercup/ctci No. Title Tag 难度 完成情况 0001 面试题01.01.判定字符是否唯一 数组 Easy 完成 0002 面试题01.02.判定是否互为字符重排 数组、字符串 Easy Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-07-26 03:13:35 "},"docs/source/classification/lcp.html":{"url":"docs/source/classification/lcp.html","title":"lcp","keywords":"","body":"LCP No. Title Tag 难度 完成情况 0001 LCP01.猜数字 Easy 完成 0002 LCP02.分式化简 Easy 完成 0003 LCP03.机器人大冒险 Medium 完成 0004 0005 0006 LCP06.拿硬币 Easy 完成 0007 LCP07.传递信息 Easy 完成 0008 LCP08.剧情触发时间 Medium 完成 0009 0010 0011 LCP11.期望个数统计 Easy 完成 0012 LCP12.小张刷题计划 Medium 完成 Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-07-18 05:45:21 "},"docs/source/classification/leetcode_contest.html":{"url":"docs/source/classification/leetcode_contest.html","title":"leetcode-竞赛","keywords":"","body":"周赛 No. 第1题 第2题 第3题 第4题 第196场周赛 1502.判断能否形成等差数列 Easy 第195场周赛 第194场周赛 Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-07-10 01:08:27 "},"docs/source/question/same.html":{"url":"docs/source/question/same.html","title":"重复题目","keywords":"","body":"leetcode重复/类似的题目 No. 01 530.二叉搜索树的最小绝对差 Easy 783.二叉搜索树节点最小距离 Easy 02 509.斐波那契数 Easy 面试题10- I.斐波那契数列 Easy 03 70.爬楼梯 Easy 面试题10- II.青蛙跳台阶问题 Easy 04 154 面试题11.旋转数组的最小数字 Easy 05 105.从前序与中序遍历序列构造二叉树 Medium 面试题07.重建二叉树 Medium 06 79.单词搜索 Medium 面试题12.矩阵中的路径 Medium 07 343 面试题14- I.剪绳子 Medium面试题14-II.剪绳子 II Medium 08 24074.搜索二维矩阵 Medium 面试题04.二维数组中的查找 Easy 09 191.位1的个数 Easy 面试题15.二进制中1的个数 Easy 10 50.Pow(x,n) Medium 面试题16.数值的整数次方 Medium 11(相似) 203.移除链表元素 Easy237.删除链表中的节点 Easy 面试题18.删除链表的节点 Easy 12 905.按奇偶排序数组 Easy 面试题21.调整数组顺序使奇数位于偶数前面 Easy 13 206.反转链表 Easy 面试题24.反转链表 Easy 14 21.合并两个有序链表 Easy 面试题25.合并两个排序的链表 Easy 15 226.翻转二叉树 Easy 面试题27.二叉树的镜像 Easy 16 101.对称二叉树 Easy 面试题28.对称的二叉树 Easy 17 54.螺旋矩阵 Medium 面试题29.顺时针打印矩阵 Easy 18 155.最小栈 Easy 面试题30.包含min函数的栈 Easy 19 946 面试题31. 栈的压入弹出序列 Medium 20 102.二叉树的层序遍历 Medium 面试题32-II.从上到下打印二叉树II Easy 21 169.多数元素 Easy 面试题39.数组中出现次数超过一半的数字 Easy 22 53.最大子序和 Easy 面试题42.连续子数组的最大和 Easy 23 233 面试题43.1～n整数中1出现的次数 Medium 24(相似) 387.字符串中的第一个唯一字符 Easy 面试题50.第一个只出现一次的字符 Easy 25 160.相交链表 Easy 面试题52.两个链表的第一个公共节点 Easy 26 264 面试题49.丑数 Medium 27(相似) 34.在排序数组中查找元素的第一个和最后一个位置 Medium 面试题53-I.在排序数组中查找数字I Easy 28(相似) 268.缺失数字 Easy 面试题53-II.0～n-1中缺失的数字 Easy 29 104.二叉树的最大深度 Easy 面试题55-I.二叉树的深度 Easy 30 110.平衡二叉树 Easy 面试题55-II.平衡二叉树 Easy 31 158 面试题58-I.翻转单词顺序 Easy 32 239 面试题59-I.滑动窗口的最大值 Easy 33 121.买卖股票的最佳时机 Easy 面试题63.股票的最大利润 Medium 34 371.两整数之和 Easy 面试题65.不用加减乘除做加法 Easy 35 8.字符串转换整数 (atoi) Medium 面试题67.把字符串转换成整数 Medium 36 235.二叉搜索树的最近公共祖先 Easy 面试题68-I.二叉搜索树的最近公共祖先 [Easy] 37 236 面试题68-II.二叉树的最近公共祖先 [Easy] 38 3.无重复字符的最长子串 Medium 面试题48.最长不含重复字符的子字符串 Medium 39 400 面试题44.数字序列中某一位的数字 Medium 40 297 面试题37.序列化二叉树 [Hard] 41 426 面试题36.二叉搜索树与双向链表 [Medium] 42 138 面试题35.复杂链表的复制 Medium 43 113.路径总和II Medium 面试题34.二叉树中和为某一值的路径 Medium 44 65 面试题20.表示数值的字符串 Medium 45 10 面试题19.正则表达式匹配 Hard 46 295 面试题41.数据流中的中位数 Hard 47 476.数字的补数 Easy 1009.十进制整数的反码 Easy 48(相似) 1037.有效的回旋镖 Easy 1232.缀点成线 Easy 49 103.二叉树的锯齿形层次遍历 Medium 面试题32-III.从上到下打印二叉树III Medium 50(相似) 179.最大数 Medium 面试题45.把数组排成最小的数 Medium Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-07-25 16:01:13 "},"docs/source/classification/hot-100.html":{"url":"docs/source/classification/hot-100.html","title":"热题100","keywords":"","body":"热题Hot100 本系列共100题 原文分类链接 https://leetcode-cn.com/problemset/hot-100/ No. Title Tag 难度 完成情况 第1期 0001 1.两数之和 数组、哈希表 Easy 完成 0002 2.两数相加 链表、数学 Medium 完成 0003 3.无重复字符的最长子串 哈希表、双指针、字符串Sliding Window Medium 完成 0004 4 0005 5.最长回文子串 字符串、动态规划 Medium 完成 0006 10 0007 11.盛最多水的容器 数组、双指针 Medium 完成 0008 15.三数之和 数组、双指针 Medium 完成 0009 17.电话号码的字母组合 字符串、回溯算法 Medium 完成 0010 19.删除链表的倒数第N个节点 链表、双指针 Medium 完成 第2期 0011 20.有效的括号 栈、字符串 Easy 完成 0012 21.合并两个有序链表 链表 Easy 完成 0013 22.括号生成 字符串、回溯算法 Medium 完成 0014 23 0015 31.下一个排列 数组 Medium 完成 0016 32 0017 33.搜索旋转排序数组 数组、二分查找 Medium 完成 0018 34.在排序数组中查找元素的第一个和最后一个位置 数组、二分查找 Medium 完成 0019 39.组合总和 数组、回溯算法 Medium 完成 0020 42 第3期 0021 46.全排列 回溯算法 Medium 完成 0022 48.旋转图像 数组 Medium 完成 0023 49.字母异位词分组 哈希表、字符串 Medium 完成 0024 53.最大子序和 数组、分治算法、动态规划 Easy 完成 0025 55.跳跃游戏 贪心算法、数组 Medium 完成 0026 56.合并区间 排序、数组 Medium 完成 0027 62.不同路径 数组、动态规划 Medium 完成 0028 70.爬楼梯 动态规划 Easy 完成 0029 72 0030 75.颜色分类 排序、数组、双指针 Medium 完成 第4期 0031 76 0032 78.子集 位运算、数组、回溯算法 Medium 完成 0033 79.单词搜索 数组、回溯算法 Medium 完成 0034 84 0035 85 0036 94.二叉树的中序遍历 栈、树、哈希表 Medium 完成 0037 96 0038 98.验证二叉搜索树 树、深度优先搜索 Medium 完成 0039 101.对称二叉树 树、深度优先搜索、广度优先搜索 Easy 完成 0040 102.二叉树的层序遍历 树、广度优先搜索 Medium 完成 第5期 0041 104.二叉树的最大深度 树、深度优先搜索 Easy 完成 0042 105.从前序与中序遍历序列构造二叉树 树、深度优先搜索、数组 Medium 完成 0043 114.二叉树展开为链表 树、深度优先搜索 Medium 完成 0044 121.买卖股票的最佳时机 数组、动态规划 Easy 完成 0045 124 0046 128 0047 136.只出现一次的数字 位运算、哈希表 Easy 完成 0048 139.单词拆分 动态规划 Medium 完成 0049 141.环形链表 链表、双指针 Easy 完成 0050 142 第6期 0051 146 0052 148 0053 152.乘积最大子数组 数组、动态规划 Medium 完成 0054 155.最小栈 栈、设计 Easy 完成 0055 160.相交链表 链表 Easy 完成 0056 169.多数元素 位运算、数组、分治算法 Easy 完成 0057 198.打家劫舍 动态规划 Easy 完成 0058 200 0059 206.反转链表 链表 Easy 完成 0060 207 第7期 Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-07-26 01:20:06 "},"docs/source/classification/array_and_string.html":{"url":"docs/source/classification/array_and_string.html","title":"数组与字符串-完成","keywords":"","body":"数组和字符串 数组和字符串系列 本系列共22题 原文分类链接 https://leetcode-cn.com/explore/learn/card/array-and-string/ 1-数组简介(3) Title Tag 难度 完成情况 724.寻找数组的中心索引 数组 Easy 完成 35.搜索插入位置 数组、二分查找 Easy 完成 56.合并区间 排序、数组 Medium 完成 2-二维数组简介(3) Title Tag 难度 完成情况 旋转矩阵 48.旋转图像 数组 Medium 完成 零矩阵 73.矩阵置零 数组 Medium 完成 对角线遍历 3-字符串简介(4) Title Tag 难度 完成情况 14.最长公共前缀 字符串 Easy 完成 5.最长回文子串 字符串、动态规划 Medium 完成 151.翻转字符串里的单词 字符串 Medium 完成 28.实现strStr() 双指针、字符串 Easy 完成 4-双指针技巧(6) Title Tag 难度 完成情况 344.反转字符串 双指针、字符串 Easy 完成 561.数组拆分 I 数组 Easy 完成 167.两数之和 II - 输入有序数组 数组、双指针、二分查找 Easy 完成 27.移除元素 数组、双指针 Easy 完成 485.最大连续1的个数 数组 Easy 完成 209 5-小结(6) Title Tag 难度 完成情况 118.杨辉三角 数组 Easy 完成 119.杨辉三角 II 数组 Easy 完成 557.反转字符串中的单词 III 字符串 Easy 完成 153.寻找旋转排序数组中的最小值 数组、二分查找 Medium 完成 26.删除排序数组中的重复项 数组、双指针 Easy 完成 283.移动零 数组、双指针 Easy 完成 Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-07-26 00:52:39 "},"docs/source/classification/queue-stack.html":{"url":"docs/source/classification/queue-stack.html","title":"队列与栈","keywords":"","body":"队列&栈 https://leetcode-cn.com/explore/learn/card/queue-stack/ Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-06-29 11:33:05 "},"docs/source/classification/recursion.html":{"url":"docs/source/classification/recursion.html","title":"递归","keywords":"","body":"递归1 本系列共xx题 原文分类链接 https://leetcode-cn.com/explore/featured/card/recursion-i/ 1.递归原理 Title Tag 难度 完成情况 344.反转字符串 双指针、字符串 Easy 完成 2.递推关系(3) Title Tag 难度 完成情况 118.杨辉三角 数组 Easy 完成 119.杨辉三角 II 数组 Easy 完成 206.反转链表 链表 Easy 完成 3.Memorization(记忆化)计数(2) Title Tag 难度 完成情况 509.斐波那契数 数组 Easy 完成 70.爬楼梯 动态规划 Easy 完成 4.复杂度分析(2) Title Tag 难度 完成情况 104.二叉树的最大深度 树、深度优先搜索 Easy 完成 50.Pow(x,n) 数学、二分查找 Medium 完成 5.总结 Title Tag 难度 完成情况 21.合并两个有序链表 链表 Easy 完成 x Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-07-14 18:36:39 "},"docs/source/classification/nowcoder_hw.html":{"url":"docs/source/classification/nowcoder_hw.html","title":"牛客-华为","keywords":"","body":"牛客-华为机试 本系统共108题目 https://www.nowcoder.com/ta/huawei No. Title Tag(知识点) 难度 完成情况 第1期 0001 字符串最后一个单词的长度 字符串 较难 完成 0002 计算字符个数 字符串、哈希 较难 完成 0003 明明的随机数 数组 较难 完成 0004 字符串分隔 字符串 较难 完成 0005 进制转换 字符串 中等 完成 0006 质数因子 排序 中等 完成 0007 取近似值 数学、语法题 入门 完成 0008 合并表记录 栈 中等 完成 0009 提取不重复的整数 数组、哈希、位运算 中等 完成 0010 字符个数统计 字符串、哈希 中等 完成 第2期 0011 数字颠倒 字符串 简单 完成 0012 字符串反转 字符串 简单 完成 0013 句子逆序 数组 较难 完成 0014 字串的连接最长路径查找 字符串 中等 完成 0015 求int型正整数在内存中存储时1的个数 位运算 入门 完成 0016 购物单 动态规划 中等 0017 坐标移动 字符串 较难 完成 0018 识别有效的IP地址和掩码并进行分类统计 字符串、查找 困难 Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-06-29 17:14:44 "},"docs/source/classification/patB.html":{"url":"docs/source/classification/patB.html","title":"PAT-乙级","keywords":"","body":"PAT乙 参考 https://blog.csdn.net/weixin_38380313 No. Title 分值 完成情况 第1期 1001 害死人不偿命的(3n+1)猜想 15 完成 1002 写出这个数 20 完成 1003 我要通过! 20 完成 1004 成绩排名 20 完成 1005 继续(3n+1)猜想 25 完成 1006 换个格式输出整数 15 完成 1007 素数对猜想 20 完成 1008 数组元素循环右移问题 20 完成 1009 说反话 20 完成 1010 一元多项式求导 25 完成 第2期 1011 A+B 和 C 15 完成 1012 数字分类 20 完成 1013 数素数 20 完成 1014 福尔摩斯的约会 20 完成 1015 德才论 25 完成 1016 部分A+B 15 1017 Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-07-01 00:44:56 "},"docs/source/algorithm/1-search.html":{"url":"docs/source/algorithm/1-search.html","title":"查找","keywords":"","body":"查找算法 总结 1. Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-05-20 01:24:48 "},"docs/source/algorithm/2-sort.html":{"url":"docs/source/algorithm/2-sort.html","title":"排序","keywords":"","body":"排序算法 参考 https://www.cnblogs.com/onepixel/articles/7674659.html总结 1.冒泡排序 func bubbleSort(arr []int) { for i := 0; i arr[j+1] { arr[j], arr[j+1] = arr[j+1], arr[j] } } } } 2.选择排序 Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-06-14 11:07:44 "},"docs/source/nowcoder/hw.html":{"url":"docs/source/nowcoder/hw.html","title":"华为机试","keywords":"","body":"牛客-华为机试 https://www.nowcoder.com/ta/huawei 1.字符串最后一个单词的长度(5) 题目 题目描述:计算字符串最后一个单词的长度，单词以空格隔开。 输入描述:一行字符串，非空，长度小于5000。 输出描述:整数N，最后一个单词的长度。 示例1:输入:hello world 输出:5 解题思路 No. 思路 时间复杂度 空间复杂度 01 内置函数 O(n) O(n) 02 内置函数 O(n) O(n) 03 内置函数 O(n) O(n) 04 内置函数 O(n) O(n) 05 顺序读取 O(n) O(n) package main import ( \"bufio\" \"fmt\" \"os\" \"strings\" ) func main() { reader := bufio.NewReader(os.Stdin) data, _, _ := reader.ReadLine() str := string(data) arr := strings.Fields(str) if len(arr) == 0 { fmt.Println(0) return } fmt.Println(len(arr[len(arr)-1])) return } # 2 package main import ( \"bufio\" \"fmt\" \"os\" \"strings\" ) func main() { scan := bufio.NewScanner(os.Stdin) scan.Scan() str := scan.Text() arr := strings.Fields(str) if len(arr) == 0 { fmt.Println(0) return } fmt.Println(len(arr[len(arr)-1])) return } # 3 package main import ( \"bufio\" \"fmt\" \"os\" \"strings\" ) func main() { reader := bufio.NewReader(os.Stdin) //data, _ := reader.ReadBytes('\\n') data, _ := reader.ReadString('\\n') str := string(data) arr := strings.Fields(str) if len(arr) == 0 { fmt.Println(0) return } fmt.Println(len(arr[len(arr)-1])) return } # 4 package main import ( \"bufio\" \"fmt\" \"os\" \"strings\" ) func main() { scan := bufio.NewScanner(os.Stdin) for scan.Scan() { str := scan.Text() arr := strings.Fields(str) if len(arr) == 0 { fmt.Println(0) } else { fmt.Println(len(arr[len(arr)-1])) } } return } # 5 package main import \"fmt\" func main() { var str string for { flag, _ := fmt.Scan(&str) if flag == 0 { break } } fmt.Println(len(str)) } 2.计算字符个数(4) 题目 题目描述 写出一个程序，接受一个由字母和数字组成的字符串，和一个字符，然后输出输入字符串中含有该字符的个数。 不区分大小写。 输入描述:第一行输入一个有字母和数字以及空格组成的字符串，第二行输入一个字符。 输出描述:输出输入字符串中含有该字符的个数。 示例1 输入 ABCDEF A 输出 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 遍历 O(n) O(1) 03 遍历 O(n) O(1) 04 内置函数 O(n) O(1) package main import ( \"bufio\" \"fmt\" \"os\" \"strings\" ) func main() { reader := bufio.NewReader(os.Stdin) data, _ := reader.ReadString('\\n') str := strings.ToLower(data) // data, _ = reader.ReadString('\\n') // c := strings.ToLower(data)[0] c, _, _ := reader.ReadRune() res := 0 for i := 0; i 3.明明的随机数(2) 题目 明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性， 他先用计算机生成了N个1到1000之间的随机整数（N≤1000），对于其中重复的数字，只保留一个，把其余相同的数去掉， 不同的数对应着不同的学生的学号。 然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。 请你协助明明完成“去重”与“排序”的工作(同一个测试用例里可能会有多组数据，希望大家能正确处理)。 Input Param n 输入随机数的个数 inputArray n个随机整数组成的数组 Return Value OutputArray 输出处理后的随机整数 注：测试用例保证输入参数的正确性，答题者无需验证。测试用例不止一组。 样例输入解释： 样例有两组测试 第一组是3个数字，分别是：2，2，1。 第二组是11个数字，分别是：10，20，40，32，67，40，20，89，300，400，15。 输入描述:输入多行，先输入随机整数的个数，再输入相应个数的整数 输出描述:返回多行，处理后的结果 示例1 输入 3 2 2 1 11 10 20 40 32 67 40 20 89 300 400 15 输出 1 2 10 15 20 32 40 67 89 300 400 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历-数组辅助 O(n) O(1) 02 遍历-数组辅助 O(n) O(1) package main import ( \"bufio\" \"fmt\" \"os\" \"strconv\" ) func main() { reader := bufio.NewReader(os.Stdin) for { n, _, _ := reader.ReadLine() if len(n) 4.字符串分隔(2) 题目 题目描述 •连续输入字符串，请按长度为8拆分每个字符串后输出到新的字符串数组； •长度不是8整数倍的字符串请在后面补数字0，空字符串不处理。 输入描述:连续输入字符串(输入2次,每个字符串长度小于100) 输出描述:输出到长度为8的新字符串数组 示例1 输入 abc 123456789 输出 abc00000 12345678 90000000 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(n) 02 遍历 O(n) O(n) package main import ( \"bufio\" \"fmt\" \"os\" ) func main() { scan := bufio.NewScanner(os.Stdin) for i := 0; i 5.进制转换(3) 题目 题目描述 写出一个程序，接受一个十六进制的数，输出该数值的十进制表示。（多组同时输入 ） 输入描述:输入一个十六进制的数值字符串。 输出描述:输出该数值的十进制字符串。 示例1 输入 0xA 输出 10 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(1) O(1) 02 遍历 O(1) O(1) 03 字符串转整数 O(1) O(1) package main import \"fmt\" func main() { var num int for { n, _ := fmt.Scanf(\"0x%x\", &num) if n == 0 { break } fmt.Println(num) } } # package main import \"fmt\" func main() { var num int for { n, _ := fmt.Scanf(\"%v\", &num) if n == 0 { break } fmt.Println(num) } } # package main import ( \"bufio\" \"fmt\" \"os\" \"strconv\" ) func main() { reader := bufio.NewReader(os.Stdin) var num string for { data, _, _ := reader.ReadLine() if len(data) == 0 { break } num = string(data[2:]) value, _ := strconv.ParseInt(num, 16, 32) fmt.Println(value) } } 6.质数因子(2) 题目 题目描述 功能:输入一个正整数，按照从小到大的顺序输出它的所有质因子（重复的也要列举） （如180的质因子为2 2 3 3 5 ） 最后一个数后面也要有空格 输入描述:输入一个long型整数 输出描述:按照从小到大的顺序输出它的所有质数的因子，以空格隔开。最后一个数后面也要有空格。 示例1 输入 180 输出 2 2 3 3 5 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(log(n)) O(1) 02 遍历 O(log(n)) O(1) package main import \"fmt\" func main() { var num int64 for { n, _ := fmt.Scanf(\"%d\", &num) if n == 0 { break } i := int64(2) for num > 1 { if num%i == 0 { fmt.Printf(\"%d \", i) num = num / i } else { i++ } } fmt.Println() } } # package main import \"fmt\" func main() { var num int64 for { n, _ := fmt.Scanf(\"%d\", &num) if n == 0 { break } for i := int64(2); i 7.取近似值(2) 题目 题目描述 写出一个程序，接受一个正浮点数值，输出该数值的近似整数值。如果小数点后数值大于等于5,向上取整； 小于5，则向下取整。 输入描述:输入一个正浮点数值 输出描述:输出该数值的近似整数值 示例1 输入 5.5 输出 6 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(1) O(1) 02 遍历 O(1) O(1) package main import \"fmt\" func main() { var num float32 fmt.Scanf(\"%f\", &num) fmt.Println(int(num + 0.5)) } # package main import ( \"fmt\" \"math\" ) func main() { var num float64 for { n, _ := fmt.Scanf(\"%f\", &num) if n == 0 { break } fmt.Println(int(math.Floor(num + 0.5))) } } 8.合并表记录(2) 题目 题目描述 数据表记录包含表索引和数值（int范围的整数），请对表索引相同的记录进行合并，即将相同索引的数值进行求和运算， 输出按照key值升序进行输出。 输入描述:先输入键值对的个数 然后输入成对的index和value值，以空格隔开 输出描述:输出合并后的键值对（多行） 示例1 输入 4 0 1 0 2 1 2 3 4 输出 0 3 1 2 3 4 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组辅助 O(n) O(1) 02 哈希辅助 O(nlog(n)) O(n) package main import \"fmt\" func main() { var num int for { n, _ := fmt.Scanf(\"%d\", &num) if n == 0 { break } var key, vale int arr := make([]int, 1024) for i := 0; i 9.提取不重复的整数(2) 题目 题目描述:输入一个int型整数，按照从右向左的阅读顺序，返回一个不含重复数字的新的整数。 输入描述:输入一个int型整数 输出描述:按照从右向左的阅读顺序，返回一个不含重复数字的新的整数 示例1 输入 9876673 输出 37689 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组辅助 O(log(n)) O(1) 02 数组辅助 O(log(n)) O(1) package main import ( \"fmt\" ) func main() { var num int for { n, _ := fmt.Scanf(\"%d\", &num) if n == 0 { break } m := make(map[int]int) res := 0 for num > 0 { value := num % 10 num = num / 10 if m[value] == 0 { res = res*10 + value m[value] = 1 } } fmt.Println(res) } } # package main import ( \"fmt\" ) func main() { var num string for { n, _ := fmt.Scanf(\"%s\", &num) if n == 0 { break } m := make(map[byte]int) for i := len(num) - 1; i >= 0; i-- { if m[num[i]] == 0 { fmt.Printf(\"%c\", num[i]) m[num[i]] = 1 } } fmt.Println() } } 10.字符个数统计(2) 题目 题目描述 编写一个函数，计算字符串中含有的不同字符的个数。字符在ACSII码范围内(0~127)，换行表示结束符，不算在字符里。 不在范围内的不作统计。多个相同的字符只计算一次 输入 abaca 输出 3 输入描述:输入N个字符，字符在ACSII码范围内。 输出描述:输出范围在(0~127)字符的个数。 示例1 输入 abc 输出 3 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(1) 02 数组辅助 O(n) O(1) package main import ( \"fmt\" ) func main() { var num string for { n, _ := fmt.Scanf(\"%s\", &num) if n == 0 { break } m := make(map[byte]int) for i := 0; i 11.数字颠倒(2) 题目 题目描述 描述：输入一个整数，将这个整数以字符串的形式逆序输出 程序不考虑负数的情况，若数字含有0，则逆序形式也含有0，如输入为100，则输出为001 输入描述:输入一个int整数 输出描述:将这个整数以字符串的形式逆序输出 示例1 输入 1516000 输出 0006151 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(log(n)) O(1) 02 遍历 O(log(n)) O(1) package main import ( \"fmt\" ) func main() { var num string for { n, _ := fmt.Scanf(\"%s\", &num) if n == 0 { break } for i := len(num) - 1; i >= 0; i-- { // fmt.Print(num[i] - '0') fmt.Print(string(num[i])) } fmt.Println() } } # package main import ( \"fmt\" ) func main() { var num int for { n, _ := fmt.Scanf(\"%d\", &num) if n == 0 { break } for num > 0{ fmt.Print(num%10) num = num/10 } fmt.Println() } } 12.字符串反转(2) 题目 题目描述:写出一个程序，接受一个字符串，然后输出该字符串反转后的字符串。（字符串长度不超过1000） 输入描述:输入N个字符 输出描述:输出该字符串反转后的字符串 示例1 输入 abcd 输出 dcba 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 01 遍历 O(n) O(1) package main import ( \"fmt\" ) func main() { var str string for { n, _ := fmt.Scanf(\"%s\", &str) if n == 0 { break } for i := len(str) - 1; i >= 0; i-- { fmt.Print(string(str[i])) } fmt.Println() } } # package main import ( \"bufio\" \"fmt\" \"os\" ) func main() { reader := bufio.NewReader(os.Stdin) for { n, _, _ := reader.ReadLine() if len(n) == 0 { break } str := n for i := len(str) - 1; i >= 0; i-- { fmt.Print(string(str[i])) } fmt.Println() } } 13.句子逆序(2) 题目 题目描述 将一个英文语句以单词为单位逆序排放。例如“I am a boy”，逆序排放后为“boy a am I” 所有单词之间用一个空格隔开，语句中除了英文字母外，不再包含其他字符 接口说明 /** * 反转句子 * * @param sentence 原句子 * @return 反转后的句子 */ public String reverse(String sentence); 输入描述:将一个英文语句以单词为单位逆序排放。 输出描述:得到逆序的句子 示例1 输入 I am a boy 输出 boy a am I 解题思路 No. 思路 时间复杂度 空间复杂度 01 内置函数 O(n) O(n) 02 内置函数 O(n) O(n) package main import ( \"bufio\" \"fmt\" \"os\" \"strings\" ) func main() { reader := bufio.NewReader(os.Stdin) for { n, _, _ := reader.ReadLine() if len(n) == 0 { break } str := string(n) arr := strings.Split(str, \" \") for i := 0; i 14.字串的连接最长路径查找(2) 题目 题目描述 给定n个字符串，请对n个字符串按照字典序排列。 输入描述:输入第一行为一个正整数n(1≤n≤1000),下面n行为n个字符串(字符串长度≤100),字符串中只含有大小写字母。 输出描述:数据输出n行，输出结果为按照字典序排列的字符串。 示例1 输入 9 cap to cat card two too up boat boot 输出 boat boot cap card cat to too two up 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序 O(nlog(n)) O(n) 02 排序 O(nlog(n)) O(n) package main import ( \"fmt\" \"sort\" ) func main() { var num int for { n, _ := fmt.Scanf(\"%d\", &num) if n == 0 { break } arr := make([]string, 0) var str string for i := 0; i 15.求int型正整数在内存中存储时1的个数(2) 题目 题目描述:输入一个int型的正整数，计算出该int型数据在内存中存储时1的个数。 输入描述:输入一个整数（int类型） 输出描述:这个数转换成2进制后，输出1的个数 示例1 输入 5 输出 2 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(log(n)) O(1) 02 位运算 O(log(n)) O(1) package main import \"fmt\" func main() { var num int for { n, _ := fmt.Scanf(\"%d\", &num) if n == 0{ break } res := 0 for num > 0{ if num%2 == 1{ res++ } num = num/2 } fmt.Println(res) } } # package main import \"fmt\" func main() { var num int for { n, _ := fmt.Scanf(\"%d\", &num) if n == 0 { break } res := 0 for num > 0 { num = num & (num - 1) res++ } fmt.Println(res) } } 16.购物单 题目 题目描述 王强今天很开心，公司发给N元的年终奖。王强决定把年终奖用于购物，他把想买的物品分为两类： 主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子： 主件 附件 电脑 打印机，扫描仪 书柜 图书 书桌 台灯，文具 工作椅 无 如果要买归类为附件的物品，必须先买该附件所属的主件。 每个主件可以有 0 个、 1 个或 2 个附件。附件不再有从属于自己的附件。 王强想买的东西很多，为了不超出预算，他把每件物品规定了一个重要度，分为 5 等： 用整数 1 ~ 5 表示，第 5 等最重要。他还从因特网上查到了每件物品的价格（都是 10 元的整数倍）。 他希望在不超过 N 元（可以等于 N 元）的前提下，使每件物品的价格与重要度的乘积的总和最大。 设第 j 件物品的价格为 v[j] ，重要度为 w[j] ，共选中了 k 件物品， 编号依次为 j 1 ， j 2 ，……， j k ，则所求的总和为： v[j 1 ]*w[j 1 ]+v[j 2 ]*w[j 2 ]+ … +v[j k ]*w[j k ] 。（其中 * 为乘号） 请你帮助王强设计一个满足要求的购物单。 输入描述: 输入的第 1 行，为两个正整数，用一个空格隔开：N m （其中 N （ 0 ，表示该物品为附件， q 是所属主件的编号） 输出描述:输出文件只有一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值（ 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(log(n)) O(1) 17.坐标移动(1) 题目 题目描述 开发一个坐标计算工具， A表示向左移动，D表示向右移动，W表示向上移动，S表示向下移动。 从（0,0）点开始移动，从输入字符串里面读取一些坐标，并将最终输入结果输出到输出文件里面。 输入：合法坐标为A(或者D或者W或者S) + 数字（两位以内）坐标之间以;分隔。 非法坐标点需要进行丢弃。如AA10; A1A; $%$; YAD; 等。 下面是一个简单的例子 如： A10;S20;W10;D30;X;A1A;B10A11;;A10; 处理过程：起点（0,0） + A10 = （-10,0） + S20 = (-10,-20) + W10 = (-10,-10) + D30 = (20,-10) + x = 无效 + A1A = 无效 + B10A11 = 无效 + 一个空 不影响 + A10 = (10,-10) 结果 （10， -10） 注意请处理多组输入输出 输入描述:一行字符串 输出描述:最终坐标，以,分隔 示例1 输入 A10;S20;W10;D30;X;A1A;B10A11;;A10; 输出 10,-10 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) package main import ( \"fmt\" \"strconv\" \"strings\" ) func main() { var str string for { n, _ := fmt.Scanf(\"%s\", &str) if n == 0 { break } arr := strings.Split(str, \";\") x := 0 y := 0 for i := 0; i 3 { continue } value, _ := strconv.Atoi(arr[i][1:]) switch arr[i][0] { case 'A': x = x - value case 'D': x = x + value case 'W': y = y + value case 'S': y = y - value } } fmt.Printf(\"%d,%d\\n\", x, y) } } # 18.识别有效的IP地址和掩码并进行分类统计 题目 题目描述 请解析IP地址和对应的掩码，进行分类识别。要求按照A/B/C/D/E类地址归类，不合法的地址和掩码单独归类。 所有的IP地址划分为 A,B,C,D,E五类 A类地址1.0.0.0~126.255.255.255; B类地址128.0.0.0~191.255.255.255; C类地址192.0.0.0~223.255.255.255; D类地址224.0.0.0~239.255.255.255； E类地址240.0.0.0~255.255.255.255 私网IP范围是： 10.0.0.0～10.255.255.255 172.16.0.0～172.31.255.255 192.168.0.0～192.168.255.255 子网掩码为二进制下前面是连续的1，然后全是0。（例如：255.255.255.32就是一个非法的掩码） 注意二进制下全是1或者全是0均为非法 注意： 1. 类似于【0.*.*.*】和【127.*.*.*】的IP地址不属于上述输入的任意一类，也不属于不合法ip地址， 计数时可以忽略 2. 私有IP地址和A,B,C,D,E类地址是不冲突的 输入描述: 多行字符串。每行一个IP地址和掩码，用~隔开。 输出描述:统计A、B、C、D、E、错误IP地址或错误掩码、私有IP的个数，之间以空格隔开。 示例1 输入 10.70.44.68~255.254.255.0 1.0.0.1~255.0.0.0 192.168.0.2~255.255.255.0 19..0.~255.255.255.0 输出 1 0 1 0 0 2 1 解题思路 Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-06-29 17:44:31 "},"docs/source/question/patB.html":{"url":"docs/source/question/patB.html","title":"PAT-乙级","keywords":"","body":"PAT (Basic Level) Practice 乙级 1001.害死人不偿命的(3n+1)猜想(1) 题目 卡拉兹(Callatz)猜想： 对任何一个正整数 n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把 (3n+1) 砍掉一半。 这样一直反复砍下去，最后一定在某一步得到 n=1。卡拉兹在 1950 年的世界数学家大会上公布了这个猜想， 传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业， 一心只证 (3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展…… 我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过 1000 的正整数 n， 简单地数一下，需要多少步（砍几下）才能得到 n=1？ 输入格式：每个测试输入包含 1 个测试用例，即给出正整数 n 的值。 输出格式：输出从 n 计算到 1 需要的步数。 输入样例：3 输出样例：5 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历模拟 O(log(n)) O(1) package main import \"fmt\" func main() { var n int fmt.Scanf(\"%d \", &n) var res = 0 for n != 1 { if n%2 == 0 { n = n / 2 res++ } else { n = (3*n + 1) / 2 res++ } } fmt.Println(res) } 1002.写出这个数(1) 题目 读入一个正整数 n，计算其各位数字之和，用汉语拼音写出和的每一位数字。 输入格式： 每个测试输入包含 1 个测试用例，即给出自然数 n 的值。这里保证 n 小于 10^100。 输出格式： 在一行内输出 n 的各位数字之和的每一位，拼音数字间有 1 空格，但一行中最后一个拼音数字后没有空格。 输入样例：1234567890987654321123456789 输出样例：yi san wu 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(log(n)) O(1) package main import ( \"fmt\" \"strconv\" ) func main() { var str string m := map[uint8]string{ '0': \"ling\", '1': \"yi\", '2': \"er\", '3': \"san\", '4': \"si\", '5': \"wu\", '6': \"liu\", '7': \"qi\", '8': \"ba\", '9': \"jiu\", } fmt.Scanf(\"%s\", &str) sum := 0 for k := range str { sum = sum + int(str[k]-'0') } toString := strconv.Itoa(sum) for k := range toString { if k != 0 { fmt.Print(\" \") } fmt.Print(m[toString[k]]) } } 1003.我要通过!(1) 题目 “答案正确”是自动判题系统给出的最令人欢喜的回复。 本题属于 PAT 的“答案正确”大派送 —— 只要读入的字符串满足下列条件， 系统就输出“答案正确”，否则输出“答案错误”。 得到“答案正确”的条件是： 字符串中必须仅有 P、 A、 T这三种字符，不可以包含其它字符； 任意形如 xPATx 的字符串都可以获得“答案正确”，其中 x 或者是空字符串，或者是仅由字母 A 组成的字符串； 如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a、 b、 c 均或者是空字符串， 或者是仅由字母 A 组成的字符串。 现在就请你为 PAT 写一个自动裁判程序，判定哪些字符串是可以获得“答案正确”的。 输入格式： 每个测试输入包含 1 个测试用例。第 1 行给出一个正整数 n ( 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(n) package main import \"fmt\" func main() { var n int fmt.Scanf(\"%d\", &n) for i := 0; i 就是P和T中间每增加一个A，需要将P之前的内容复制到字符串末尾，得到的新字符串就也是正确的。 if charMap['P'] == 1 && charMap['T'] == 1 && charMap['A'] != 0 && len(charMap) == 3 && right-length != 1 && l*m == r { return \"YES\" } return \"NO\" } 1004.成绩排名(1) 题目 读入 n（>0）名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。 输入格式：每个测试输入包含 1 个测试用例，格式为 第 1 行：正整数 n 第 2 行：第 1 个学生的姓名 学号 成绩 第 3 行：第 2 个学生的姓名 学号 成绩 ... ... ... 第 n+1 行：第 n 个学生的姓名 学号 成绩 其中姓名和学号均为不超过 10 个字符的字符串，成绩为 0 到 100 之间的一个整数， 这里保证在一组测试用例中没有两个学生的成绩是相同的。 输出格式： 对每个测试用例输出 2 行， 第 1 行是成绩最高学生的姓名和学号，第 2 行是成绩最低学生的姓名和学号，字符串间有 1 空格。 输入样例： 3 Joe Math990112 89 Mike CS991301 100 Mary EE990830 95 输出样例： Mike CS991301 Joe Math990112 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(n) package main import \"fmt\" type Student struct { Name string Num string Grade int } func main() { var n int fmt.Scanf(\"%d\", &n) m := make(map[string]Student) var max, low int var maxName, lowName string for i := 0; i max { max = s.Grade maxName = s.Name } if s.Grade 1005.继续(3n+1)猜想(1) 题目 卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。 当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。 例如对 n=3 进行验证的时候，我们需要计算 3、5、8、4、2、1，则当我们对 n=5、8、4、2 进行验证的时候， 就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这 4 个数已经在验证3的时候遇到过了， 我们称 5、8、4、2 是被 3“覆盖”的数。我们称一个数列中的某个数 n 为“关键数”， 如果 n 不能被数列中的其他数字所覆盖。 现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。 你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。 输入格式： 每个测试输入包含 1 个测试用例，第 1 行给出一个正整数 K ( 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序遍历 O(nlog(n)) O(n) package main import ( \"fmt\" \"sort\" ) func main() { var n int fmt.Scanf(\"%d\", &n) arr := make([]int, 10001) maps := make(map[int]int, n) for i := 0; i = 0; i-- { if arr[tempArr[i]] == 0 { if flag == true { fmt.Print(\" \") } fmt.Print(tempArr[i]) flag = true } } } 1006.换个格式输出整数(1) 题目 让我们用字母 B 来表示“百”、字母 S 表示“十”，用 12...n 来表示不为零的个位数字 n（ 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(log(n)) O(1) package main import \"fmt\" func main() { var n int fmt.Scanf(\"%d\", &n) arr := make([]int, 3) i := 0 for { if n == 0 { break } arr[i] = n % 10 n = n / 10 i++ } for k := 0; k 1007.素数对猜想(1) 题目 让我们定义dn为：dn=pn+1−pn，其中pi是第i个素数。 显然有d1=1，且对于n>1有dn是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。 现给定任意正整数N( 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n^3/2) O(1) package main import \"fmt\" func main() { var n int fmt.Scanf(\"%d\", &n) count := 0 // 2 3 5 7 for i := 5; i 1008.数组元素循环右移问题(1) 题目 一个数组A中存有N（>0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（≥0）个位置， 即将A中的数据由（A0A1⋯AN−1）变换为（AN−M⋯AN−1A0A1⋯AN−M−1） （最后M个数循环移至最前面的M个位置）。 如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？ 输入格式: 每个输入包含一个测试用例，第1行输入N（1≤N≤100）和M（≥0）；第2行输入N个整数，之间用空格分隔。 输出格式:在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。 输入样例: 6 2 1 2 3 4 5 6 输出样例:5 6 1 2 3 4 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历交换 O(n) O(n) package main import ( \"fmt\" ) func main() { var N, M int fmt.Scanf(\"%d %d\", &N, &M) M = M % N arr := make([]int, 0) for i := 0; i 1009.说反话(1) 题目 给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。 输入格式： 测试输入包含一个测试用例，在一行内给出总长度不超过 80 的字符串。字符串由若干单词和若干空格组成， 其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用 1 个空格分开，输入保证句子末尾没有多余的空格。 输出格式：每个测试用例的输出占一行，输出倒序后的句子。 输入样例：Hello World Here I Come 输出样例：Come I Here World Hello 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(n) package main import ( \"bufio\" \"fmt\" \"os\" \"strings\" ) func main() { var str string reader := bufio.NewReader(os.Stdin) data, _, _ := reader.ReadLine() str = string(data) arr := strings.Split(str, \" \") for k := len(arr) - 1; k >= 0; k-- { fmt.Print(arr[k]) if k != 0 { fmt.Print(\" \") } } } 1010.一元多项式求导(1) 题目 设计函数求一元多项式的导数。（注：xn（n为整数）的一阶导数为nxn−1。） 输入格式: 以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过 1000 的整数）。数字间以空格分隔。 输出格式: 以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。 注意“零多项式”的指数和系数都是 0，但是表示为 0 0。 输入样例:3 4 -5 2 6 1 -2 0 输出样例:12 3 -10 1 6 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) package main import ( \"bufio\" \"fmt\" \"os\" \"strconv\" \"strings\" ) func main() { var str string reader := bufio.NewReader(os.Stdin) data, _, _ := reader.ReadLine() str = string(data) var flag = false arr := strings.Fields(str) for k := 0; k 1011.A+B 和 C(1) 题目 给定区间 [−2^31,2^31] 内的 3 个整数 A、B 和 C，请判断 A+B 是否大于 C。 输入格式： 输入第 1 行给出正整数 T (≤10)，是测试用例的个数。随后给出 T 组测试用例，每组占一行， 顺序给出 A、B 和 C。整数间以空格分隔。 输出格式： 对每组测试用例，在一行中输出 Case #X: true 如果 A+B>C， 否则输出 Case #X: false，其中 X 是测试用例的编号（从 1 开始）。 输入样例： 4 1 2 3 2 3 4 2147483647 0 2147483646 0 -2147483648 -2147483647 输出样例： Case #1: false Case #2: true Case #3: true Case #4: false 解题思路 No. 思路 时间复杂度 空间复杂度 01 计算 O(1) O(1) package main import \"fmt\" func main() { var n int _, _ = fmt.Scanf(\"%d\", &n) for i := 0; i b { result = a - c + b } else { result = b - c + a } if result > 0 { fmt.Print(\"Case #\", i+1, \": \", true, \"\\n\") } else { fmt.Print(\"Case #\", i+1, \": \", false, \"\\n\") } } } 1012.数字分类(1) 题目 给定一系列正整数，请按要求对数字进行分类，并输出以下 5 个数字： A1 = 能被 5 整除的数字中所有偶数的和； A2 = 将被 5 除后余 1 的数字按给出顺序进行交错求和，即计算 n1−n2+n3−n4⋯； A3 = 被 5 除后余 2 的数字的个数； A4 = 被 5 除后余 3 的数字的平均数，精确到小数点后 1 位； A5 = 被 5 除后余 4 的数字中最大数字。 输入格式： 每个输入包含 1 个测试用例。每个测试用例先给出一个不超过 1000 的正整数 N， 随后给出 N 个不超过 1000 的待分类的正整数。数字间以空格分隔。 输出格式： 对给定的 N 个正整数，按题目要求计算 A1~A5 并在一行中顺序输出。 数字间以空格分隔，但行末不得有多余空格。 若其中某一类数字不存在，则在相应位置输出 N。 输入样例 1：13 1 2 3 4 5 6 7 8 9 10 20 16 18 输出样例 1：30 11 2 9.7 9 输入样例 2：8 1 2 4 5 6 7 9 16 输出样例 2：N 11 2 N 9 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) package main import ( \"fmt\" ) func main() { var n int fmt.Scanf(\"%d\", &n) var A1, A2, A5 = 0, 0, 0 var A4 = 0 mapArr := make(map[int][]int) for i := 0; i A5 { A5 = mapArr[i][j] } } } for i := 0; i 1013.数素数(1) 题目 令 Pi 表示第 i 个素数。现任给两个正整数 M≤N≤10^4，请输出 PM 到 PN 的所有素数。 输入格式：输入在一行中给出 M 和 N，其间以空格分隔。 输出格式：输出从 PM 到 PN 的所有素数，每 10 个数字占 1 行，其间以空格分隔，但行末不得有多余空格。 输入样例：5 27 输出样例： 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n^3/2) O(n) package main import \"fmt\" func main() { var N, M int var num = 2 var count int fmt.Scanf(\"%d %d\", &M, &N) result := make([]int, 0) for { if count = M { result = append(result, num) } } num++ } else { break } } for i := 0; i 1014.福尔摩斯的约会(1) 题目 大侦探福尔摩斯接到一张奇怪的字条：我们约会吧！ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&hgsfdk d&Hyscvnm。 大侦探很快就明白了，字条上奇怪的乱码实际上就是约会的时间星期四 14:04， 因为前面两字符串中第 1 对相同的大写英文字母（大小写有区分）是第 4 个字母 D，代表星期四； 第 2 对相同的字符是 E ，那是第 5 个英文字母， 代表一天里的第 14 个钟头（于是一天的 0 点到 23 点由数字 0 到 9、以及大写字母 A 到 N 表示）； 后面两字符串第 1 对相同的英文字母 s 出现在第 4 个位置（从 0 开始计数）上，代表第 4 分钟。 现给定两对字符串，请帮助福尔摩斯解码得到约会的时间。 输入格式：输入在 4 行中分别给出 4 个非空、不包含空格、且长度不超过 60 的字符串。 输出格式： 在一行中输出约会的时间，格式为 DAY HH:MM，其中 DAY 是某星期的 3 字符缩写，即 MON 表示星期一， TUE 表示星期二，WED 表示星期三，THU 表示星期四，FRI 表示星期五，SAT 表示星期六，SUN 表示星期日。 题目输入保证每个测试存在唯一解。 输入样例： 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&hgsfdk d&Hyscvnm 输出样例：THU 14:04 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) package main import ( \"bufio\" \"fmt\" \"os\" ) var week = []string{ \"MON\", \"TUE\", \"WED\", \"THU\", \"FRI\", \"SAT\", \"SUN\", } func main() { var a, b, c, d string reader := bufio.NewReader(os.Stdin) data, _, _ := reader.ReadLine() a = string(data) data, _, _ = reader.ReadLine() b = string(data) data, _, _ = reader.ReadLine() c = string(data) data, _, _ = reader.ReadLine() d = string(data) len0 := len(a) len2 := len(c) if len(b) > len0 { len0 = len(b) } if len(d) > len2 { len2 = len(d) } flag := true for i := 0; i = 'A' && a[i] = 'A' && a[i] = '0' && a[i] = 'A' && c[i] = 'a' && c[i] 1015.德才论(1) 题目 宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”： “是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人， 君子而与之，与其得小人，不若得愚人。” 现给出一批考生的德才分数，请根据司马光的理论给出录取排名。 输入格式： 输入第一行给出 3 个正整数，分别为： N（≤10^5），即考生总数；L（≥60），为录取最低分数线，即德分和才分均不低于 L 的考生才有资格被考虑录取； H（ 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序 O(nlog(n)) O(n) package main import ( \"bufio\" \"fmt\" \"os\" \"sort\" \"strconv\" \"strings\" ) type Student struct { id int d, c, t int sortNum int } type Students []Student func (s Students) Len() int { return len(s) } func (s Students) Swap(i, j int) { s[i], s[j] = s[j], s[i] } func (s Students) Less(i, j int) bool { if s[i].sortNum == s[j].sortNum { if s[i].t == s[j].t { if s[i].d == s[j].d { return s[i].id s[j].d } return s[i].t > s[j].t } return s[i].sortNum > s[j].sortNum } func main() { reader := bufio.NewReader(os.Stdin) var N, L, H int _, _ = fmt.Scanf(\"%d %d %d\", &N, &L, &H) arr := make(Students, N) count := 0 for i := 0; i = H && d >= H { sortNum = 4 } else if d >= H && c = c { sortNum = 2 } else { sortNum = 1 } arr[i].sortNum = sortNum count++ } fmt.Println(count) sort.Sort(arr) for i := 0; i Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-07-01 00:22:50 "}}