{"./":{"url":"./","title":"Introduction","keywords":"","body":"go-Leetcode readthedoc gitbook gitbook0.参考 https://leetcode-cn.com/ 2.6k https://github.com/kylesliu/awesome-golang-leetcode 2.5k https://github.com/aQuaYi/LeetCode-in-Go 5.2k https://github.com/greyireland/algorithm-pattern 2.6k https://github.com/halfrost/LeetCode-Go 55.7k https://github.com/labuladong/fucking-algorithm1.完成的题目 Easy系列 No. Title Tag 难度 完成情况 第1期 0001 1.两数之和 数组、哈希表 Easy 完成 0002 7.整数反转 数学 Easy 完成 0003 9.回文数 数学 Easy 完成 0004 13.罗马数字转整数 数学、字符串 Easy 完成 0005 14.最长公共前缀 字符串 Easy 完成 0006 20.有效的括号 栈、字符串 Easy 完成 0007 21.合并两个有序链表 链表 Easy 完成 0008 26.删除排序数组中的重复项 数组、双指针 Easy 完成 0009 27.移除元素 数组、双指针 Easy 完成 0010 28.实现strStr() 双指针、字符串 Easy 完成 第2期 0011 35.搜索插入位置 数组、二分查找 Easy 完成 0012 38.报数 字符串 Easy 完成 0013 53.最大子序和 数组、分治算法、动态规划 Easy 完成 0014 58.最后一个单词的长度 字符串 Easy 完成 0015 66.加一 数组 Easy 完成 0016 67.二进制求和 数字、字符串 Easy 完成 0017 69.x的平方根 数学，二分查找 Easy 完成 0018 70.爬楼梯 动态规划 Easy 完成 0019 83.删除排序链表中的重复元素 链表 Easy 完成 0020 88.合并两个有序数组 数组、双指针 Easy 完成 第3期 0021 100.相同的树 树、深度优先搜索 Easy 完成 0022 101.对称二叉树 树、深度优先搜索、广度优先搜索 Easy 完成 0023 104.二叉树的最大深度 树、深度优先搜索 Easy 完成 0024 107.二叉树的层次遍历II 树、广度优先搜索 Easy 完成 0025 108.将有序数组转换为二叉搜索树 树、深度优先搜索 Easy 完成 0026 110.平衡二叉树 树、深度优先搜索 Easy 完成 0027 111.二叉树的最小深度 树、深度优先搜索、广度优先搜索 Easy 完成 0028 112.路径总和 树、深度优先搜索 Easy 完成 0029 118.杨辉三角 数组 Easy 完成 0030 119.杨辉三角II 数组 Easy 完成 第4期 0031 121.买卖股票的最佳时机 数组、动态规划 Easy 完成 0032 122.买卖股票的最佳时机II 贪心算法、数组 Easy 完成 0033 125.验证回文串 双指针、字符串 Easy 完成 0034 136.只出现一次的数字 位运算、哈希表 Easy 完成 0035 141.环形链表 链表、双指针 Easy 完成 0036 155.最小栈 栈、设计 Easy 完成 0037 160.相交链表 链表 Easy 完成 0038 167.两数之和II-输入有序数组 数组、双指针、二分查找 Easy 完成 0039 168.Excel表列名称 数学 Easy 完成 0040 169.多数元素 位运算、数组、分治算法 Easy 完成 第5期 0041 171.Excel表列序号 数学 Easy 完成 0042 172.阶乘后的零 数学 Easy 完成 0043 175.组合两个表 Mysql Easy 完成 0044 176.第二高的薪水 Mysql Easy 完成 0045 181.超过经理收入的员工 Mysql Easy 完成 0046 182.查找重复的电子邮箱 Mysql Easy 完成 0047 183.从不订购的客户 Mysql Easy 完成 0048 189.旋转数组 数组 Easy 完成 0049 190.颠倒二进制位 位运算 Easy 完成 0050 191.位1的个数 位运算 Easy 完成 第6期 0051 193.有效电话号码 Bash Easy 完成 0052 195.第十行 Bash Easy 完成 0053 196.删除重复的电子邮箱 Mysql Easy 完成 0054 197.上升的温度 Mysql Easy 完成 0055 198.打家劫舍 动态规划 Easy 完成 0056 202.快乐数 哈希表、数学 Easy 完成 0057 203.移除链表元素 链表 Easy 完成 0058 204.计数质数 哈希表、数学 Easy 完成 0059 205.同构字符串 哈希表 Easy 完成 0060 206.反转链表 链表 Easy 完成 第7期 0061 217.存在重复元素 数组、哈希表 Easy 完成 0062 219.存在重复元素II 数组、哈希表 Easy 完成 0063 225.用队列实现栈 栈、设计 Easy 完成 0064 226.翻转二叉树 树 Easy 完成 0065 231.2的幂 位运算、数学 Easy 完成 0066 232.用栈实现队列 栈、设计 Easy 完成 0067 234.回文链表 链表、双指针 Easy 完成 0068 235.二叉搜索树的最近公共祖先 树 Easy 完成 0069 237.删除链表中的节点 链表 Easy 完成 0070 242.有效的字母异位词 排序、哈希 Easy 完成 第8期 0071 257.二叉树的所有路径 树、深度优先搜索 Easy 完成 0072 258.各位相加 数学 Easy 完成 0073 263.丑数 数学 Easy 完成 0074 268.缺失数字 位运算、数组、数学 Easy 完成 0075 278.第一个错误的版本 二分查找 Easy 完成 0076 283.移动零 数组、双指针 Easy 完成 0077 290.单词规律 哈希表 Easy 完成 0078 292.Nim游戏 脑筋急转弯、极小化极大 Easy 完成 0079 299.猜数字游戏 哈希表 Easy 完成 0080 303.区域和检索-数组不可变 动态规划 Easy 完成 第9期 0081 326.3的幂 数学 Easy 完成 0082 342.4的幂 位运算 Easy 完成 0083 344.反转字符串 双指针、字符串 Easy 完成 0084 345.反转字符串中的元音字母 双指针、字符串 Easy 完成 0085 349.两个数组的交集 排序、哈希表、双指针、二分查找 Easy 完成 0086 350.两个数组的交集II 排序、哈希表、双指针、二分查找 Easy 完成 0087 367.有效的完全平方数 数学、二分查找 Easy 完成 0088 371.两整数之和 位运算 Easy 完成 0089 374.猜数字大小 二分查找 Easy 完成 0090 383.赎金信 字符串 Easy 完成 第10期 0091 387.字符串中的第一个唯一字符 哈希表、字符串 Easy 完成 0092 389.找不同 位运算、哈希表 Easy 完成 0093 392.判断子序列 贪心算法、二分查找、动态规划 Easy 完成 0094 401.二进制手表 位运算、回溯算法 Easy 完成 0095 404.左叶子之和 树 Easy 完成 0096 405.数字转换为十六进制数 位运算 Easy 完成 0097 409.最长回文串 哈希表 Easy 完成 0098 412.Fizz Buzz Easy 完成 0099 414.第三大的数 数组 Easy 完成 0100 415.字符串相加 字符串 Easy 完成 第11期 0101 434.字符串中的单词数 字符串 Easy 完成 0102 437.路径总和III 树 Easy 完成 0103 441.排列硬币 数学、二分查找 Easy 完成 0104 443.压缩字符串 字符串 Easy 完成 0105 447.回旋镖的数量 哈希表 Easy 完成 0106 448.找到所有数组中消失的数字 数组 Easy 完成 0107 453.最小移动次数使数组元素相等 数学 Easy 完成 0108 455.分发饼干 贪心算法 Easy 完成 0109 459.重复的子字符串 字符串 Easy 完成 0110 461.汉明距离 位运算 Easy 完成 第12期 0111 463.岛屿的周长 哈希表 Easy 完成 0112 475.供暖器 二分查找 Easy 完成 0113 476.数字的补数 位运算 Easy 完成 0114 482.密钥格式化 Easy 完成 0115 485.最大连续1的个数 数组 Easy 完成 0116 492.构造矩形 Easy 完成 0117 496.下一个更大元素I 栈 Easy 完成 0118 500.键盘行 哈希表 Easy 完成 0119 501.二叉搜索树中的众数 树 Easy 完成 0120 504.七进制数 Easy 完成 第13期 0121 506.相对名次 Easy 完成 0122 507.完美数 数学 Easy 完成 0123 509.斐波那契数 数组 Easy 完成 0124 520.检测大写字母 字符串 Easy 完成 0125 521.最长特殊序列Ⅰ 字符串 Easy 完成 0126 530.二叉搜索树的最小绝对差 树 Easy 完成 0127 532.数组中的K-diff数对 数组、双指针 Easy 完成 0128 538.把二叉搜索树转换为累加树 树 Easy 完成 0129 541.反转字符串II 字符串 Easy 完成 0130 543.二叉树的直径 树 Easy 完成 第14期 0131 551.学生出勤记录I 字符串 Easy 完成 0132 557.反转字符串中的单词III 字符串 Easy 完成 0133 559.N叉树的最大深度 树、深度优先搜索、广度优先搜索 Easy 完成 0134 561.数组拆分I 数组 Easy 完成 0135 563.二叉树的坡度 树 Easy 完成 0136 566.重塑矩阵 数组 Easy 完成 0137 572.另一个树的子树 树 Easy 完成 0138 575.分糖果 哈希表 Easy 完成 0139 581.最短无序连续子数组 数组 Easy 完成 0140 589.N叉树的前序遍历 树 Easy 完成 第15期 0141 590.N叉树的后序遍历 树 Easy 完成 0142 594.最长和谐子序列 哈希表 Easy 完成 0143 595.大的国家 Mysql Easy 完成 0144 596.超过5名学生的课 Mysql Easy 完成 0145 598.范围求和II 数学 Easy 完成 0146 599.两个列表的最小索引总和 哈希表 Easy 完成 0147 605.种花问题 数组 Easy 完成 0148 606.根据二叉树创建字符串 树、字符串 Easy 完成 0149 617.合并二叉树 树 Easy 完成 0150 620.有趣的电影 Mysql Easy 完成 第16期 0151 627.交换工资 Mysql Easy 完成 0152 628.三个数的最大乘积 数组、数学 Easy 完成 0153 633.平方数之和 数学 Easy 完成 0154 637.二叉树的层平均值 树 Easy 完成 0155 643.子数组最大平均数I 数组 Easy 完成 0156 645.错误的集合 哈希表、数学 Easy 完成 0157 653.两数之和IV-输入BST 树 Easy 完成 0158 657.机器人能否返回原点 字符串 Easy 完成 0159 661.图片平滑器 数组 Easy 完成 0160 665.非递减数列 数组 Easy 完成 第17期 0161 669.修剪二叉搜索树 树 Easy 完成 0162 671.二叉树中第二小的节点 树 Easy 完成 0163 674.最长连续递增序列 数组 Easy 完成 0164 680.验证回文字符串Ⅱ 字符串 Easy 完成 0165 682.棒球比赛 栈 Easy 完成 0166 686.重复叠加字符串匹配 字符串 Easy 完成 0167 687.最长同值路径 树 Easy 完成 0168 690.员工的重要性 深度优先搜索、广度优先搜索、哈希表 Easy 完成 0169 693.交替位二进制数 位运算 Easy 完成 0170 696.计数二进制子串 字符串 Easy 完成 第18期 0171 697.数组的度 数组 Easy 完成 0172 700.二叉搜索树中的搜索 树 Easy 完成 0173 703.数据流中的第K大元素 堆 Easy 完成 0174 704.二分查找 二分查找 Easy 完成 0175 705.设计哈希集合 设计、哈希表 Easy 完成 0176 706.设计哈希映射 设计、哈希表 Easy 完成 0177 709.转换成小写字母 字符串 Easy 完成 0178 717.1比特与2比特字符 数组 Easy 完成 0179 720.词典中最长的单词 字典树、哈希表 Easy 完成 0180 724.寻找数组的中心索引 数组 Easy 完成 第19期 0181 728.自除数 数学 Easy 完成 0182 733.图像渲染 深度优先搜索 Easy 完成 0183 744.寻找比目标字母大的最小字母 二分查找 Easy 完成 0184 746.使用最小花费爬楼梯 数组、动态规划 Easy 完成 0185 747.至少是其他数字两倍的最大数 数组 Easy 完成 0186 748.最短完整词 哈希表 Easy 完成 0187 762.二进制表示中质数个计算置位 位运算 Easy 完成 0188 766.托普利茨矩阵 数组 Easy 完成 0189 771.宝石与石头 哈希表 Easy 完成 0190 783.二叉搜索树节点最小距离 树、递归 Easy 完成 第20期 0191 784.字母大小写全排列 位运算、回溯算法 Easy 完成 0192 788.旋转数字 字符串 Easy 完成 0193 796.旋转字符串 Easy 完成 0194 804.唯一摩尔斯密码词 字符串 Easy 完成 0195 806.写字符串需要的行数 Easy 完成 0196 811.子域名访问计数 哈希表 Easy 完成 0197 812.最大三角形面积 数学 Easy 完成 0198 819.最常见的单词 字符串 Easy 完成 0199 821.字符的最短距离 Easy 完成 0200 824.山羊拉丁文 字符串 Easy 完成 第21期 0201 830.较大分组的位置 数组 Easy 完成 0202 832.翻转图像 数组 Easy 完成 0203 836.矩形重叠 数学 Easy 完成 0204 840.矩阵中的幻方 数组 Easy 完成 0205 844.比较含退格的字符串 栈、双指针 Easy 完成 0206 849.到最近的人的最大距离 数组 Easy 完成 0207 852.山脉数组的峰顶索引 二分查找 Easy 完成 0208 859.亲密字符串 字符串 Easy 完成 0209 860.柠檬水找零 贪心算法 Easy 完成 0210 867.转置矩阵 数组 Easy 完成 第22期 0211 868.二进制间距 数学 Easy 完成 0212 872.叶子相似的树 树、深度优先搜索 Easy 完成 0213 874.模拟行走机器人 贪心算法 Easy 完成 0214 876.链表的中间结点 链表 Easy 完成 0215 883.三维形体投影面积 数学 Easy 完成 0216 884.两句话中的不常见单词 哈希表 Easy 完成 0217 888.公平的糖果交换 数组 Easy 完成 0218 892.三维形体的表面积 几何、数学 Easy 完成 0219 893.特殊等价字符串组 字符串 Easy 完成 0220 896.单调数列 数组 Easy 完成 第23期 0221 897.递增顺序查找树 树、深度优先搜索 Easy 完成 0222 905.按奇偶排序数组 数组 Easy 完成 0223 908.最小差值I 数学 Easy 完成 0224 914.卡牌分组 数组、数学 Easy 完成 0225 917.仅仅反转字母 字符串 Easy 完成 0226 922.按奇偶排序数组II 排序、数组 Easy 完成 0227 925.长按键入 双指针、字符串 Easy 完成 0228 929.独特的电子邮件地址 字符串 Easy 完成 0229 933.最近的请求次数 队列 Easy 完成 0230 937.重新排列日志文件 字符串 Easy 完成 第24期 0231 938.二叉搜索树的范围和 树、递归 Easy 完成 0232 941.有效的山脉数组 数组 Easy 完成 0233 942.增减字符串匹配 数学 Easy 完成 0234 944.删列造序 贪心算法 Easy 完成 0235 949.给定数字能组成的最大时间 数学 Easy 完成 0236 953.验证外星语词典 哈希表 Easy 完成 0237 961.重复N次的元素 哈希表 Easy 完成 0238 965.单值二叉树 树 Easy 完成 0239 970.强整数 哈希表、数学 Easy 完成 0240 976.三角形的最大周长 排序、数学 Easy 完成 第25期 0241 977.有序数组的平方 数组、双指针 Easy 完成 0242 985.查询后的偶数和 数组 Easy 完成 0243 989.数组形式的整数加法 数组 Easy 完成 0244 993.二叉树的堂兄弟节点 树、广度优先搜索 Easy 完成 0245 997.找到小镇的法官 图 Easy 完成 0246 999.可以被一步捕获的棋子数 数组 Easy 完成 0247 1002.查找常用字符 数组、哈希表 Easy 完成 0248 1005.K次取反后最大化的数组和 贪心算法 Easy 完成 0249 1009.十进制整数的反码 数学 Easy 完成 0250 1010.总持续时间可被60整除的歌曲 数组 Easy 完成 第26期 0251 1013.将数组分成和相等的三个部分 数组 Easy 完成 0252 1018.可被5整除的二进制前缀 数组 Easy 完成 0253 1021.删除最外层的括号 栈 Easy 完成 0254 1022.从根到叶的二进制数之和 树 Easy 完成 0255 1025.除数博弈 数学、动态规划 Easy 完成 0256 1029.两地调度 贪心算法 Easy 完成 0257 1030.距离顺序排列矩阵单元格 排序 Easy 完成 0258 1033.移动石子直到连续 脑筋急转弯 Easy 完成 0259 1037.有效的回旋镖 数学 Easy 完成 0260 1042.不邻接植花 图 Easy 完成 第27期 0261 1046.最后一块石头的重量 堆、贪心算法 Easy 完成 0262 1047.删除字符串中的所有相邻重复项 栈 Easy 完成 0263 1051.高度检查器 数组 Easy 完成 0264 1071.字符串的最大公因子 字符串 Easy 完成 0265 1078.Bigram分词 哈希表 Easy 完成 0266 1089.复写零 数组 Easy 完成 0267 1103.分糖果II 数学 Easy 完成 0268 1108.IP地址无效化 字符串 Easy 完成 0269 1114.按序打印 Easy [提交没有Go语言] 0270 1122.数组的相对排序 排序、数组 Easy 完成 第28期 0271 1128.等价多米诺骨牌对的数量 数组 Easy 完成 0272 1137.第N个泰波那契数 递归 Easy 完成 0273 1154.一年中的第几天 数学 Easy 完成 0274 1160.拼写单词 数组、哈希表 Easy 完成 0275 1170.比较字符串最小字母出现频次 数组、字符串 Easy 完成 0276 1175.质数排列 数学 Easy 完成 0277 1179.重新格式化部门表 Mysql Easy 完成 0278 1184.公交站间的距离 数组 Easy 完成 0279 1185.一周中的第几天 数组 Easy 完成 0280 1189.“气球”的最大数量 哈希表、字符串 Easy 完成 第29期 0281 1200.最小绝对差 数组 Easy 完成 0282 1207.独一无二的出现次数 哈希表 Easy 完成 0283 1217.玩筹码 贪心算法、数组、数学 Easy 完成 0284 1221.分割平衡字符串 贪心算法、字符串 Easy 完成 0285 1232.缀点成线 几何、数组、数学 Easy 完成 0286 1237.找出给定方程的正整数解 数学、二分查找 Easy 完成 0287 1252.奇数值单元格的数目 数组 Easy 完成 0288 1260.二维网格迁移 数组 Easy 完成 0289 1266.访问所有点的最小时间 几何、数组 Easy 完成 0290 1275.找出井字棋的获胜者 数组 Easy 完成 第30期 0291 1281.整数的各位积和之差 数学 Easy 完成 0292 1287.有序数组中出现次数超过25%的元素 数字 Easy 完成 0293 1290.二进制链表转整数 位运算、链表 Easy 完成 0294 1295.统计位数为偶数的数字 数组 Easy 完成 0295 1299.将每个元素替换为右侧最大元素 数组 Easy 完成 0296 1304.和为零的N个唯一整数 数组 Easy 完成 0297 1309.解码字母到整数映射 字符串 Easy 完成 0298 1313.解压缩编码列表 数组 Easy 完成 0299 1317.将整数转换为两个无零整数的和 数学 Easy 完成 0300 1323.6和9组成的最大数字 数学 Easy 完成 第31期 0301 1331.数组序号转换 数组 Easy 完成 0302 1332.删除回文子序列 字符串 Easy 完成 0303 1337.方阵中战斗力最弱的K行 数组、二分查找 Easy 完成 0304 1342.将数字变成0的操作次数 位运算 Easy 完成 0305 1346.检查整数及其两倍数是否存在 数组 Easy 完成 0306 1351.统计有序矩阵中的负数 数组、二分查找 Easy 完成 0307 1356.根据数字二进制下1的数目排序 排序、位运算 Easy 完成 0308 1360.日期之间隔几天 Easy 完成 0309 1365.有多少小于当前数字的数字 数组、哈希表 Easy 完成 0310 1370.上升下降字符串 排序、字符串 Easy 完成 第32期 0311 1374.生成每种字符都是奇数个的字符串 字符串 Easy 完成 0312 1380.矩阵中的幸运数 数组 Easy 完成 0313 1385.两个数组间的距离值 数组 Easy 完成 0314 1389.按既定顺序创建目标数组 数组 Easy 完成 0315 1394.找出数组中的幸运数 数组 Easy 完成 0316 1399.统计最大组的数目 数组 Easy 完成 0317 1403.非递增顺序的最小子序列 贪心算法、排序 Easy 完成 0318 1408.数组中的字符串匹配 字符串 Easy 完成 0319 1413.逐步求和得到正数的最小值 数组 Easy 完成 0320 1417.重新格式化字符串 字符串 Easy 完成 第33期 0321 1422.分割字符串的最大得分 字符串 Easy 完成 0322 1431.拥有最多糖果的孩子 数组 Easy 完成 0323 1436.旅行终点站 字符串 Easy 完成 0324 1441.用栈操作构建数组 栈 Easy 完成 0325 1446.连续字符 字符串 Easy 完成 0326 1450.在既定时间做作业的学生人数 数组 Easy 完成 0327 1455.检查单词是否为句中其他单词的前缀 字符串 Easy 完成 0328 1460.通过翻转子数组使两个数组相等 数组 Easy 完成 0329 1464.数组中两元素的最大乘积 数组 Easy 完成 0330 1470.重新排列数组 数组 Easy 完成 第34期 0331 1475.商品折扣后的最终价格 数组 Easy 完成 0332 1480.一维数组的动态和 数组 Easy 完成 0333 1486.数组异或操作 位运算、数组 Easy 完成 0334 1491.去掉最低工资和最高工资后的工资平均值 排序、数组 Easy 完成 0335 1496.判断路径是否相交 字符串 Easy 完成 0336 1502.判断能否形成等差数列 排序、数组 Easy 完成 0337 1507.转变日期格式 字符串 Easy 完成 0338 1512.好数对的数目 数组、哈希表、数学 Easy 完成 0339 1518.换酒问题 贪心算法 Easy 完成 0340 1523.在区间范围内统计奇数数目 数学 Easy 完成 第35期 0341 1528.重新排列字符串 排序 Easy 完成 0342 1534.统计好三元组 数组 Easy 完成 0343 1539.第k个缺失的正整数 数组、哈希表 Easy 完成 0344 1544.整理字符串 栈、字符串 Easy 完成 0345 1550.存在连续三个奇数的数组 数组 Easy 完成 0346 1556.千位分隔数 字符串 Easy 完成 0347 1560.圆形赛道上经过次数最多的扇区 数组 Easy 完成 0348 1566.重复至少K次且长度为M的模式 数组 Easy 完成 0349 1572.矩阵对角线元素的和 数组 Easy 完成 0350 1576.替换所有的问号 字符串 Easy 完成 第36期 Medium系列 No. Title Tag 难度 完成情况 第1期 0001 2.两数相加 链表、数学 Medium 完成 0002 3.无重复字符的最长子串 哈希表、双指针、字符串Sliding Window Medium 完成 0003 5.最长回文子串 字符串、动态规划 Medium 完成 0004 6.Z字形变换 字符串 Medium 完成 0005 8.字符串转换整数(atoi) 数字、字符串 Medium 完成 0006 11.盛最多水的容器 数组、双指针 Medium 完成 0007 12.整数转罗马数字 数学、字符串 Medium 完成 0008 15.三数之和 数组、双指针 Medium 完成 0009 16.最接近的三数之和 数组、双指针 Medium 完成 0010 17.电话号码的字母组合 字符串、回溯算法 Medium 完成 第2期 0011 18.四数之和 数组、哈希表、双指针 Medium 完成 0012 19.删除链表的倒数第N个节点 链表、双指针 Medium 完成 0013 22.括号生成 字符串、回溯算法 Medium 完成 0014 24.两两交换链表中的节点 链表 Medium 完成 0015 29.两数相除 数学、二分查找 Medium 完成 0016 31.下一个排列 数组 Medium 完成 0017 33.搜索旋转排序数组 数组、二分查找 Medium 完成 0018 34.在排序数组中查找元素的第一个和最后一个位置 数组、二分查找 Medium 完成 0019 36.有效的数独 哈希表 Medium 完成 0020 39.组合总和 数组、回溯算法 Medium 完成 第3期 0021 40.组合总和II 数组、回溯算法 Medium 完成 0022 43.字符串相乘 数学、字符串 Medium 完成 0023 46.全排列 回溯算法 Medium 完成 0024 47.全排列II 回溯算法 Medium 完成 0025 48.旋转图像 数组 Medium 完成 0026 49.字母异位词分组 哈希表、字符串 Medium 完成 0027 50.Pow(x,n) 数学、二分查找 Medium 完成 0028 54.螺旋矩阵 数组 Medium 完成 0029 55.跳跃游戏 贪心算法、数组 Medium 完成 0030 56.合并区间 排序、数组 Medium 完成 第4期 0031 59.螺旋矩阵II 数组 Medium 完成 0032 60.第k个排列 数学、回溯算法 Medium 完成 0033 61.旋转链表 链表、双指针 Medium 完成 0034 62.不同路径 数组、动态规划 Medium 完成 0035 63.不同路径II 数组、动态规划 Medium 完成 0036 64.最小路径和 数组、动态规划 Medium 完成 0037 71.简化路径 栈、字符串 Medium 完成 0038 73.矩阵置零 数组 Medium 完成 0039 74.搜索二维矩阵 数组、二分查找 Medium 完成 0040 75.颜色分类 排序、数组、双指针 Medium 完成 第5期 0041 77.组合 回溯算法 Medium 完成 0042 78.子集 位运算、数组、回溯算法 Medium 完成 0043 79.单词搜索 数组、回溯算法 Medium 完成 0044 80.删除排序数组中的重复项II 数组、双指针 Medium 完成 0045 81.搜索旋转排序数组II 数组、二分查找 Medium 完成 0046 82.删除排序链表中的重复元素II 链表 Medium 完成 0047 86.分隔链表 链表、双指针 Medium 完成 0048 89.格雷编码 回溯算法 Medium 完成 0049 90.子集II 数组、回溯算法 Medium 完成 0050 91.解码方法 字符串、动态规划 Medium 完成 第6期 0051 92.反转链表II 链表 Medium 完成 0052 93.复原IP地址 字符串、回溯算法 Medium 完成 0053 94.二叉树的中序遍历 栈、树、哈希表 Medium 完成 0054 95.不同的二叉搜索树II 树、动态规划 Medium 完成 0055 96.不同的二叉搜索树 树、动态规划 Medium 完成 0056 98.验证二叉搜索树 树、深度优先搜索 Medium 完成 0057 102.二叉树的层序遍历 树、广度优先搜索 Medium 完成 0058 103.二叉树的锯齿形层次遍历 栈、树、广度优先搜索 Medium 完成 0059 105.从前序与中序遍历序列构造二叉树 树、深度优先搜索、数组 Medium 完成 0060 106.从中序与后序遍历序列构造二叉树 树、深度优先搜索、数组 Medium 完成 第7期 0061 109.有序链表转换二叉搜索树 深度优先搜索、链表 Medium 完成 0062 113.路径总和II 树、深度优先搜索 Medium 完成 0063 114.二叉树展开为链表 树、深度优先搜索 Medium 完成 0064 116.填充每个节点的下一个右侧节点指针 树、深度优先搜索 Medium 完成 0065 117.填充每个节点的下一个右侧节点指针II 树、深度优先搜索 Medium 完成 0066 120.三角形最小路径和 数组、动态规划 Medium 完成 0067 127.单词接龙 广度优先搜索 Medium 0068 129.求根到叶子节点数字之和 树、深度优先搜索 Medium 完成 0069 130.被围绕的区域 深度优先搜索、广度优先搜索、并查集 Medium 完成 0070 131.分割回文串 回溯算法 Medium 完成 第8期 0071 133.克隆图 深度优先搜索、广度优先搜索、图 Medium 完成 0072 134.加油站 贪心算法 Medium 完成 0073 137.只出现一次的数字II 位运算 Medium 完成 0074 138.复制带随机指针的链表 哈希表、链表 Medium 完成 0075 139.单词拆分 动态规划 Medium 完成 0076 142.环形链表II 链表、双指针 Medium 完成 0077 143.重排链表 链表 Medium 完成 0078 144.二叉树的前序遍历 栈、树 Medium 完成 0079 146.LRU缓存机制 设计 Medium 完成 0080 147.对链表进行插入排序 排序、链表 Medium 第9期 0081 148.排序链表 排序、链表 Medium 完成 0082 150.逆波兰表达式求值 栈 Medium 完成 0083 151.翻转字符串里的单词 字符串 Medium 完成 0084 152.乘积最大子数组 数组、动态规划 Medium 完成 0085 153.寻找旋转排序数组中的最小值 数组、二分查找 Medium 完成 0086 162.寻找峰值 数组、二分查找 Medium 完成 0087 165.比较版本号 字符串 Medium 完成 0088 166.分数到小数 哈希表、数学 Medium 完成 0089 173.二叉搜索树迭代器 栈、树、设计 Medium 0090 177.第N高的薪水 Mysql Medium 第10期 0091 178.分数排名 Mysql Medium 0092 179.最大数 排序 Medium 完成 0093 180.连续出现的数字 Mysql Medium 0094 184.部门工资最高的员工 Mysql Medium 0095 187.重复的DNA序列 位运算、哈希表 Medium 完成 0096 192.统计词频 Bash Medium 0097 194.转置文件 Bash Medium 0098 199.二叉树的右视图 树、深度优先搜索、广度优先搜索 Medium 完成 0099 200.岛屿数量 深度优先搜索、广度优先搜索、并查集 Medium 完成 0100 201.数字范围按位与 位运算 Medium 完成 第11期 0101 207.课程表 深度优先搜索、广度优先搜索、图、拓扑排序 Medium 完成 0102 208.实现 Trie (前缀树) 设计、字典树 Medium 完成 0103 209.长度最小的子数组 数组、双指针、二分查找 Medium 完成 0104 210.课程表II 深度优先搜索、广度优先搜索、图、拓扑排序 Medium 完成 0105 211.添加与搜索单词-数据结构设计 设计、字典树、回溯算法 Medium 完成 0106 213.打家劫舍II 动态规划 Medium 完成 0107 215.数组中的第K个最大元素 堆、分治算法 Medium 完成 0108 216.组合总和III 数组、回溯算法 Medium 完成 0109 220.存在重复元素III 排序、Ordered Map Medium 完成 0110 221.最大正方形 动态规划 Medium 完成 第12期 0111 222.完全二叉树的节点个数 树、二分查找 Medium 完成 0112 223.矩形面积 数学 Medium 完成 0113 227.基本计算器II 字符串 Medium 0114 228.汇总区间 数组 Medium 完成 0115 229.求众数II 数组 Medium 完成 0116 230.二叉搜索树中第K小的元素 树、二分查找 Medium 完成 0117 236.二叉树的最近公共祖先 树 Medium 完成 0118 238.除自身以外数组的乘积 数组 Medium 完成 0119 240.搜索二维矩阵II 二分查找、分治算法 Medium 完成 0120 241.为运算表达式设计优先级 分治算法 Medium 第13期 0121 260.只出现一次的数字III 位运算 Medium 完成 0122 264.丑数II 堆、数学、动态规划 Medium 完成 0123 274.H指数 排序、哈希表 Medium 完成 0124 275.H指数II 二分查找 Medium 完成 0125 279.完全平方数 广度优先搜索、数学、动态规划 Medium 完成 0126 284.顶端迭代器 设计 Medium 0127 287.寻找重复数 数组、双指针、二分查找 Medium 完成 0128 289.生命游戏 数组 Medium 完成 0129 300.最长上升子序列 二分查找、动态规划 Medium 完成 0130 304.二维区域和检索-矩阵不可变 动态规划 Medium 完成 第14期 0131 306.累加数 回溯算法 Medium 0132 307 0133 309.最佳买卖股票时机含冷冻期 动态规划 Medium 完成 0134 310 0135 313.超级丑数 堆、数学 Medium 0136 318 0137 319.灯泡开关 脑筋急转弯、数学 Medium 完成 0138 322.零钱兑换 动态规划 Medium 完成 0139 324 0140 328.奇偶链表 链表 Medium 完成 第15期 0141 331 0142 332 0143 334.递增的三元子序列 Medium 完成 0144 337.打家劫舍III 树、深度优先搜索 Medium 完成 0145 338.比特位计数 位运算、动态规划 Medium 完成 0146 341 0147 343.整数拆分 数学、动态规划 Medium 完成 0148 347.前K个高频元素 堆、哈希表 Medium 完成 0149 355 0150 357 第16期 0151 365.水壶问题 数学 Medium 完成 368 第x期 378.有序矩阵中第K小的元素 堆、二分查找 Medium 完成 380.常数时间插入、删除和获取随机元素 设计、数组、哈希表 Medium 完成 384.打乱数组 Medium 完成 394.字符串解码 栈、深度优先搜索 Medium 完成 399.除法求值 并查集、图 Medium 400.第N个数字 数学 Medium 完成 406.根据身高重建队列 贪心算法 Medium 完成 416.分割等和子集 动态规划 Medium 完成 438.找到字符串中所有字母异位词 哈希表 Medium 完成 442.数组中重复的数据 数组 Medium 完成 445.两数相加II 链表 Medium 完成 486.预测赢家 极小化极大、动态规划 Medium 完成 491.递增子序列 深度优先搜索 Medium 完成 494.目标和 深度优先搜索、动态规划 Medium 完成 498.对角线遍历 Medium 完成 516.最长回文子序列 动态规划 Medium 完成 518.零钱兑换II Medium 完成 523.连续的子数组和 数学、动态规划 Medium 完成 542.01矩阵 深度优先搜索、广度优先搜索 Medium 完成 560.和为K的子数组 数组、哈希表 Medium 完成 567.字符串的排列 双指针、Sliding Window Medium 完成 621.任务调度器 贪心算法、队列、数组 Medium 完成 622.设计循环队列 设计、队列 Medium 完成 647.回文子串 字符串、动态规划 Medium 完成 695.岛屿的最大面积 深度优先搜索、数组 Medium 完成 714.买卖股票的最佳时机含手续费 贪心算法、数组、动态规划 Medium 完成 718.最长重复子数组 数组、哈希表、二分查找、动态规划 Medium 完成 739.每日温度 栈、哈希表 Medium 完成 752.打开转盘锁 广度优先搜索 Medium 完成 779.第K个语法符号 递归 Medium 完成 820.单词的压缩编码 Medium 完成 841.钥匙和房间 深度优先搜索、图 Medium 完成 877.石子游戏 极小化极大、数学、动态规划 Medium 完成 901.股票价格跨度 栈 Medium 完成 912.排序数组 Medium 完成 921.使括号有效的最少添加 栈、贪心算法 Medium 完成 945.使数组唯一的最小增量 数组 Medium 完成 946.验证栈序列 栈 Medium 完成 974.和可被K整除的子数组 数组、哈希表 Medium 完成 983.最低票价 动态规划 Medium 完成 994.腐烂的橘子 广度优先搜索 Medium 完成 1014.最佳观光组合 数组 Medium 完成 1035.不相交的线 数组 Medium 完成 1081.不同字符的最小子序列 字符串 Medium 完成 1111.有效括号的嵌套深度 贪心算法、二分查找 Medium 完成 1143.最长公共子序列 动态规划 Medium 完成 1162.地图分析 广度优先搜索、图 Medium 完成 1191.K次串联后最大子数组之和 动态规划 Medium 1248.统计「优美子数组」 双指针 Medium 完成 1306.跳跃游戏III 广度优先搜索、图 Medium 完成 1375.灯泡开关III 数组 Medium 完成 1376.通知所有员工所需的时间 深度优先搜索 Medium 完成 1418.点菜展示表 哈希表 Medium 完成 1442.形成两个异或相等数组的三元组数目 位运算、数组、数学 Medium 完成 1487.保证文件名唯一 哈希表、字符串 Medium 完成 1492.n的第k个因子 数学 Medium 完成 1493.删掉一个元素以后全为1的最长子数组 数组 Medium 完成 1503.所有蚂蚁掉下来前的最后一刻 脑筋急转弯、数组 Medium 完成 1508.子数组和排序后的区间和 排序、数组 Medium 完成 1509.三次操作后最大值与最小值的最小差 排序、数组 Medium 完成 1513.仅含1的子串数 数学、字符串 Medium 完成 1514.概率最大的路径 图 Medium 1525.字符串的好分割数目 位运算、字符串 Medium 完成 1529.灯泡开关IV 字符串 Medium 完成 1541.平衡括号字符串的最少插入次数 栈、字符串 Medium 完成 1545.找出第N个二进制字符串中的第K位 字符串 Medium 完成 1546.和为目标值的最大数目不重叠非空子数组数目 动态规划 Medium 完成 1551.使数组中所有元素相等的最小操作数 数学 Medium 完成 1552.两球之间的磁力 数组、二分查找 Medium 完成 1557.可以到达所有点的最少点数目 图 Medium 完成 1558.得到目标数组的最少函数调用次数 贪心算法 Medium 完成 1561.你可以获得的最大硬币数目 排序 Medium 完成 1562.查找大小为M的最新分组 二分查找 Medium 完成 1567.乘积为正数的最长子数组长度 贪心算法 Medium 完成 1568.使陆地分离的最少天数 贪心算法 Medium 完成 1573.分割字符串的方案数 字符串 Medium 完成 1574.删除最短的子数组使剩余数组有序 数组、二分查找 Medium 完成 Hard系列 No. Title Tag 难度 完成情况 第1期 0001 4.寻找两个正序数组的中位数 数组、二分查找、分治算法 Hard 完成 0002 10.正则表达式匹配 字符串、动态规划、回溯算法 Hard 完成 0003 23.合并K个排序链表 堆、链表、分治算法 Hard 完成 0004 25.K个一组翻转链表 链表 Hard 完成 0005 30.串联所有单词的子串 哈希表、双指针、字符串 Hard 完成 0006 32.最长有效括号 字符串、动态规划 Hard 完成 0007 37.解数独 哈希表、回溯算法 Hard 完成 0008 41.缺失的第一个正数 数组 Hard 完成 0009 42.接雨水 栈、数组、双指针 Hard 完成 0010 44.通配符匹配 贪心算法、字符串、动态规划、回溯算法 Hard 完成 第2期 0011 45.跳跃游戏II 贪心算法、数组 Hard 完成 0012 51.N皇后 回溯算法 Hard 完成 0013 52.N皇后II 回溯算法 Hard 完成 0014 57.插入区间 排序、数组 Hard 完成 0015 65.有效数字 数学、字符串 Hard 完成 0016 68.文本左右对齐 字符串 Hard 完成 0017 72.编辑距离 字符串、动态规划 Hard 完成 0018 76.最小覆盖子串 哈希表、双指针、字符串、Sliding Window Hard 完成 0019 84.柱状图中最大的矩形 栈、数组 Hard 完成 0020 85.最大矩形 栈、数组、哈希表、动态规划 Hard 完成 第3期 0021 87.扰乱字符串 字符串、动态规划 Hard 完成 0022 97.交错字符串 字符串、动态规划 Hard 完成 0023 99.恢复二叉搜索树 树、深度优先搜索 Hard 完成 0024 115.不同的子序列 字符串、动态规划 Hard 完成 0025 123.买卖股票的最佳时机III 数组、动态规划 Hard 完成 0026 124.二叉树中的最大路径和 树、深度优先搜索 Hard 完成 0027 126 0028 128.最长连续序列 并查集、数组 Hard 完成 0029 132 0030 135.分发糖果 贪心算法 Hard 完成 第4期 0031 140 0032 145.二叉树的后序遍历 栈、树 Hard 完成 0033 149.直线上最多的点数 哈希表、数学 Hard 0034 154.寻找旋转排序数组中的最小值II 数组、二分查找 Hard 完成 0035 164.最大间距 排序 Hard 完成 0036 174 0037 185 0038 188.买卖股票的最佳时机IV 动态规划 Hard 完成 0039 212 0040 214.最短回文串 字符串 Hard 完成 第5期 0041 218 0042 224 0043 233.数字1的个数 数学 Hard 完成 0044 239.滑动窗口最大值 堆、Sliding Window Hard 完成 0045 262 0046 273 0047 282 0048 295.数据流的中位数 堆、设计 Hard 完成 0049 297.二叉树的序列化与反序列化 树、设计 Hard 完成 0050 301.删除无效的括号 深度优先搜索、广度优先搜索 Hard 完成 第6期 0051 312.戳气球 分治算法、动态规划 Hard 完成 0052 315.计算右侧小于当前元素的个数 排序、树状数组、线段树、二分查找、分治算法 Hard 0053 316.去除重复字母 栈、贪心算法 Hard 完成 0054 321 0055 327 0056 329 第x期 354.俄罗斯套娃信封问题 二分查找、动态规划 Hard 完成 410.分割数组的最大值 二分查找、动态规划 Hard 完成 460.LFU缓存 设计 Hard 502.IPO 堆、贪心算法 Hard 887.鸡蛋掉落 数学、二分查找、动态规划 Hard x 956.最高的广告牌 动态规划 Hard 完成 1510.石子游戏IV 动态规划 Hard 完成 1526.形成目标数组的子数组最少增加次数 线段树 Hard 完成 1553.吃掉N个橘子的最少天数 动态规划 Hard 完成 1559.二维网格图中探测环 深度优先搜索 Hard 完成 1563.石子游戏V 动态规划 Hard 完成 Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 09:46:01 "},"docs/source/question/readme.html":{"url":"docs/source/question/readme.html","title":"题目","keywords":"","body":"Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 09:46:03 "},"docs/source/question/0001-0100.html":{"url":"docs/source/question/0001-0100.html","title":"0001-0100","keywords":"","body":"0001-0100-Easy 0001-0100-Easy 1.两数之和(3) 7.整数反转(2) 9.回文数(3) 13.罗马数字转整数(2) 14.最长公共前缀(6) 20.有效的括号(3) 21.合并两个有序链表(3) 26.删除排序数组中的重复项(2) 27.移除元素(3) 28.实现strStr()(4) 35.搜索插入位置(3) 38.报数(2) 53.最大子序和(5) 58.最后一个单词的长度(2) 66.加一(2) 67.二进制求和(2) 69.x的平方根 (5) 70.爬楼梯(3) 83.删除排序链表中的重复元素(3) 88.合并两个有序数组(3) 100.相同的树(2) 0001-0100-Medium 2.两数相加(2) 3.无重复字符的最长子串(4) 5.最长回文子串(5) 6.Z字形变换(2) 8.字符串转换整数 (atoi)(3) 11.盛最多水的容器(2) 12.整数转罗马数字(2) 15.三数之和(2) 16.最接近的三数之和(2) 17.电话号码的字母组合(2) 18.四数之和(3) 19.删除链表的倒数第N个节点(3) 22.括号生成(3) 24.两两交换链表中的节点(2) 29.两数相除(2) 31.下一个排列(1) 33.搜索旋转排序数组(2) 34.在排序数组中查找元素的第一个和最后一个位置(4) 36.有效的数独(1) 39.组合总和(2) 40.组合总和II(2) 43.字符串相乘(1) 46.全排列(3) 47.全排列II(3) 48.旋转图像(3) 49.字母异位词分组(2) 50.Pow(x,n)(4) 54.螺旋矩阵(2) 55.跳跃游戏(4) 56.合并区间(2) 59.螺旋矩阵II(2) 60.第k个排列(1) 61.旋转链表(2) 62.不同路径(4) 63.不同路径II(3) 64.最小路径和(4) 71.简化路径(2) 73.矩阵置零(4) 74.搜索二维矩阵(6) 75.颜色分类(3) 77.组合(4) 78.子集(3) 79.单词搜索(2) 80.删除排序数组中的重复项II(2) 81.搜索旋转排序数组II(2) 82.删除排序链表中的重复元素II(3) 86.分隔链表(2) 89.格雷编码(2) 90.子集II(2) 91.解码方法(3) 92.反转链表II(2) 93.复原IP地址(2) 94.二叉树的中序遍历(3) 95.不同的二叉搜索树II(2) 96.不同的二叉搜索树(3) 98.验证二叉搜索树(5) 0001-1000-Hard 4.寻找两个正序数组的中位数(4) 10.正则表达式匹配(3) 23.合并K个排序链表(4) 25.K个一组翻转链表(4) 30.串联所有单词的子串(2) 32.最长有效括号(4) 37.解数独(2) 41.缺失的第一个正数(5) 42.接雨水(4) 44.通配符匹配(3) 45.跳跃游戏II(4) 51.N皇后(3) 52.N皇后II(3) 57.插入区间(3) 65.有效数字(1) 68.文本左右对齐(1) 72.编辑距离(2) 76.最小覆盖子串(2) 84.柱状图中最大的矩形(5) 85.最大矩形(2) 87.扰乱字符串(2) 97.交错字符串(3) 99.恢复二叉搜索树(4) 1.两数之和(3) 题目 给定一个整数数组 nums 和一个目标值 target， 请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例:给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 解答思路 No. 思路 时间复杂度 空间复杂度 01 暴力法: 2层循环遍历 O(n^2) O(1) 02 两遍哈希遍历 O(n) O(n) 03(最优) 一遍哈希遍历 O(n) O(n) # 暴力法: 2层循环遍历 func twoSum(nums []int, target int) []int { for i := 0; i 7.整数反转(2) 题目 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1:输入: 123 输出: 321 示例 2:输入: -123 输出: -321 示例 3:输入: 120 输出: 21 注意:假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31, 2^31 − 1]。 请根据这个假设，如果反转后整数溢出那么就返回 0。 解答思路 No. 思路 时间复杂度 空间复杂度 01 使用符号标记，转成正数，循环得到%10的余数，再加上符号 O(log(x)) O(1) 02(最优) 对x进行逐个%10取个位，一旦溢出，直接跳出循环 O(log(x)) O(1) // 使用符号标记，转成正数，循环得到%10的余数，再加上符号 func reverse(x int) int { flag := 1 if x 0 { temp := x % 10 x = x / 10 result = result*10 + temp } result = flag * result if result > math.MaxInt32 || result math.MaxInt32 || result 9.回文数(3) 题目 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1: 输入: 121 输出: true 示例 2:输入: -121 输出: false 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3:输入: 10 输出: false 解释: 从右向左读, 为 01 。因此它不是一个回文数。 进阶: 你能不将整数转为字符串来解决这个问题吗？ 解答思路 No. 思路 时间复杂度 空间复杂度 01(最优) 数学解法，取出后半段数字进行翻转，然后判断是否相等 O(log(x)) O(1) 02 转成字符串，依次判断 O(log(x)) O(log(x)) 03 转成byte数组，依次判断，同2 O(log(x)) O(log(x)) // 数学解法，取出后半段数字进行翻转，然后判断是否相等 func isPalindrome(x int) bool { if x revertedNumber { temp := x % 10 revertedNumber = revertedNumber*10 + temp x = x / 10 } // for example: // x = 1221 => x = 12 revertedNumber = 12 // x = 12321 => x = 12 revertedNumber = 123 return x == revertedNumber || x == revertedNumber/10 } // 转成字符串，依次判断 func isPalindrome(x int) bool { if x 13.罗马数字转整数(2) 题目 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。 但也存在特例，例如 4 不写做 IIII，而是 IV。 数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。 同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1:输入: \"III\" 输出: 3 示例 2: 输入: \"IV\" 输出: 4 示例 3: 输入: \"IX\" 输出: 9 示例 4: 输入: \"LVIII\" 输出: 58 解释: L = 50, V= 5, III = 3. 示例 5: 输入: \"MCMXCIV\" 输出: 1994 解释: M = 1000, CM = 900, XC = 90, IV = 4. 解答思路 No. 思路 时间复杂度 空间复杂度 01 本质上其实就是全部累加，然后遇到特殊的就做判断。使用一个字段记录递增 O(n) O(1) 02(最优) 从右到左遍历字符串，如果当前字符代表的值不小于其右边，就加上该值；否则就减去该值。 O(n) O(1) // 带标记位 func romanToInt(s string) int { m := map[byte]int{ 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000, } result := 0 last := 0 for i := len(s) - 1; i >= 0; i-- { current := m[s[i]] flag := 1 if current = 0; i-- { current := m[s[i]] if current 14.最长公共前缀(6) 题目 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 \"\"。 示例 1:输入: [\"flower\",\"flow\",\"flight\"] 输出: \"fl\" 示例 2:输入: [\"dog\",\"racecar\",\"car\"] 输出: \"\" 解释: 输入不存在公共前缀。 说明: 所有输入只包含小写字母 a-z 。 解答思路 No. 思路 时间复杂度 空间复杂度 01 先找最短的一个字符串，依次比较最短字符串子串是否是其他字符串子串 O(n^2)/O(n*m) O(1) 02 纵向扫描(暴力法):直接取第一个字符串作为最长公共前缀，将其每个字符遍历过一次 O(n^2)/O(n*m) O(1) 03(最优) 排序后，然后计算第一个，和最后一个字符串的最长前缀 O(nlog(n)) O(1) 04 trie树 O(n^2) O(n^2) 05 水平扫描法:比较前2个字符串得到最长前缀，然后跟第3个比较得到一个新的最长前缀，继续比较，直到最后 O(n^2)/O(n*m) O(1) 06 分治法 O(n^2) O(1) // 先找最短的一个字符串，依次比较最短字符串子串是否是其他字符串子串 func longestCommonPrefix(strs []string) string { if len(strs) == 0{ return \"\" } if len(strs) == 1{ return strs[0] } short := strs[0] for _, s := range strs{ if len(short) > len(s){ short = s } } for i := range short{ shortest := short[:i+1] for _,str := range strs{ if strings.Index(str,shortest) != 0{ return short[:i] } } } return short } // 暴力法:直接依次遍历 func longestCommonPrefix(strs []string) string { if len(strs) == 0 { return \"\" } if len(strs) == 1 { return strs[0] } length := 0 for i := 0; i = len(strs[j]) || char != strs[j][i] { return strs[0][:length] } } length++ } return strs[0][:length] } // 排序后，遍历比较第一个，和最后一个字符串 func longestCommonPrefix(strs []string) string { if len(strs) == 0{ return \"\" } if len(strs) == 1{ return strs[0] } sort.Strings(strs) first := strs[0] last := strs[len(strs)-1] i := 0 length := len(first) if len(last) retValue { minValue = retValue } } return strs[0][:minValue] } func insert(str string) int { p := 0 count := 0 for i := 0; i = len(str2) || char != str2[i] { return str1[:length] } length++ } return str1[:length] } // 分治法 func longestCommonPrefix(strs []string) string { if len(strs) == 0 { return \"\" } if len(strs) == 1 { return strs[0] } return commonPrefix(strs, 0, len(strs)-1) } func commonPrefix(strs []string, left, right int) string { if left == right { return strs[left] } middle := (left + right) / 2 leftStr := commonPrefix(strs, left, middle) rightStr := commonPrefix(strs, middle+1, right) return commonPrefixWord(leftStr, rightStr) } func commonPrefixWord(leftStr, rightStr string) string { if len(leftStr) > len(rightStr) { leftStr = leftStr[:len(rightStr)] } if len(leftStr) 20.有效的括号(3) 题目 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例 1: 输入: \"()\" 输出: true 示例 2: 输入: \"()[]{}\" 输出: true 示例 3: 输入: \"(]\" 输出: false 示例 4: 输入: \"([)]\" 输出: false 示例 5: 输入: \"{[]}\" 输出: true 解题思路 No. 思路 时间复杂度 空间复杂度 01 使用栈结构实现栈 O(n) O(n) 02 借助数组实现栈 O(n) O(n) 03 借助数组实现栈，使用数字表示来匹配 O(n) O(n) // 使用栈结构实现 func isValid(s string) bool { st := new(stack) for _, char := range s { switch char { case '(', '[', '{': st.push(char) case ')', ']', '}': ret, ok := st.pop() if !ok || ret != match[char] { return false } } } if len(*st) > 0 { return false } return true } var match = map[rune]rune{ ')': '(', ']': '[', '}': '{', } type stack []rune func (s *stack) push(b rune) { *s = append(*s, b) } func (s *stack) pop() (rune, bool) { if len(*s) > 0 { res := (*s)[len(*s)-1] *s = (*s)[:len(*s)-1] return res, true } return 0, false } // 借助数组实现栈 func isValid(s string) bool { if s == \"\" { return true } stack := make([]rune, len(s)) length := 0 var match = map[rune]rune{ ')': '(', ']': '[', '}': '{', } for _, char := range s { switch char { case '(', '[', '{': stack[length] = char length++ case ')', ']', '}': if length == 0 { return false } if stack[length-1] != match[char]{ return false } else { length-- } } } return length == 0 } // 借助数组实现栈，使用数字表示来匹配 func isValid(s string) bool { if s == \"\" { return true } stack := make([]int, len(s)) length := 0 var match = map[rune]int{ ')': 1, '(': -1, ']': 2, '[': -2, '}': 3, '{': -3, } for _, char := range s { switch char { case '(', '[', '{': stack[length] = match[char] length++ case ')', ']', '}': if length == 0 { return false } if stack[length-1]+match[char] != 0 { return false } else { length-- } } } return length == 0 } 21.合并两个有序链表(3) 题目 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例：输入：1->2->4, 1->3->4 输出：1->1->2->3->4->4 解题思路 No. 思路 时间复杂度 空间复杂度 01(最优) 迭代遍历 O(n) O(1) 02 递归实现 O(n) O(n) 03 迭代 O(n) O(1) // 迭代遍历 func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode { if l1 == nil { return l2 } if l2 == nil { return l1 } var head, node *ListNode if l1.Val 26.删除排序数组中的重复项(2) 题目 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。 你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。 for (int i = 0; i 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针法 O(n) O(1) 02(最优) 计数法 O(n) O(1) // 双指针法 func removeDuplicates(nums []int) int { i , j , length := 0, 1, len(nums) for ; j 27.移除元素(3) 题目 给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。 注意这五个元素可为任意顺序。 你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝 int len = removeElement(nums, val); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。 for (int i = 0; i 解题思路 No. 思路 时间复杂度 空间复杂度 01(最优) 双指针，数字前移 O(n) O(1) 02 双指针，出现重复最后数字前移 O(n) O(1) 03 首位指针法 O(n) O(1) // 双指针，数字前移 func removeElement(nums []int, val int) int { i := 0 for j := 0; j = 0 && nums[j] == val { j-- } if i >= j { break } // fmt.Println(i,j) nums[i], nums[j] = nums[j], nums[i] } return i } 28.实现strStr()(4) 题目 实现 strStr() 函数。 给定一个 haystack 字符串和一个 needle 字符串， 在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。 如果不存在，则返回-1。 示例 1:输入: haystack = \"hello\", needle = \"ll\" 输出: 2 示例 2: 输入: haystack = \"aaaaa\", needle = \"bba\" 输出: -1 说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。 这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。 解题思路 No. 思路 时间复杂度 空间复杂度 01(最优) Sunday算法 O(n) O(1) 02 直接匹配 O(n) O(1) 03 系统函数 O(n) O(1) 04 kmp算法 O(n) O(n) // Sunday算法 func strStr(haystack string, needle string) int { if needle == \"\"{ return 0 } if len(needle) > len(haystack){ return -1 } // 计算模式串needle的偏移量 m := make(map[int32]int) for k,v := range needle{ m[v] = len(needle)-k } index := 0 for index+len(needle) = len(haystack){ return -1 } // 后一位字符串 next := haystack[index+len(needle)] if nextStep,ok := m[int32(next)];ok{ index = index+nextStep }else { index = index+len(needle)+1 } } } if index + len(needle) >= len(haystack){ return -1 }else { return index } } // func strStr(haystack string, needle string) int { hlen, nlen := len(haystack), len(needle) for i := 0; i 35.搜索插入位置(3) 题目 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。 如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例 1: 输入: [1,3,5,6], 5 输出: 2 示例 2: 输入: [1,3,5,6], 2 输出: 1 示例 3: 输入: [1,3,5,6], 7 输出: 4 示例 4: 输入: [1,3,5,6], 0 输出: 0 解题思路 No. 思路 时间复杂度 空间复杂度 01(最优) 二分查找 O(log(n)) O(1) 02 顺序查找 O(n) O(1) 03 顺序查找 O(n) O(1) // 二分查找 func searchInsert(nums []int, target int) int { low, high := 0, len(nums)-1 for low target: high = mid - 1 default: return mid } } return low } // 顺序查找 func searchInsert(nums []int, target int) int { i := 0 for i = target { return i } } return len(nums) } 38.报数(2) 题目 报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下： 1. 1 2. 11 3. 21 4. 1211 5. 111221 1 被读作 \"one 1\" (\"一个一\") , 即 11。 11 被读作 \"two 1s\" (\"两个一\"）, 即 21。 21 被读作 \"one 2\", \"one 1\" （\"一个二\" , \"一个一\") , 即 1211。 给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。 注意：整数顺序将表示为一个字符串。 示例 1:输入: 1 输出: \"1\" 示例 2: 输入: 4 输出: \"1211\" 解题思路 No. 思路 时间复杂度 空间复杂度 01 (最优) 递推+双指针计数 O(n^2) O(1) 02 递归+双指针计数 O(n^2) O(n) // 递推+双指针计数 func countAndSay(n int) string { strs := []byte{'1'} for i := 1; i 53.最大子序和(5) 题目 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 解题思路 No. 思路 时间复杂度 空间复杂度 01(最优) 贪心法 O(n) O(1) 02 暴力法 O(n^2) O(1) 03 动态规划 O(n) O(n) 04 动态规划 O(n) O(1) 05 分治 O(nlog(n)) O(log(n)) // 贪心法 func maxSubArray(nums []int) int { result := nums[0] sum := 0 for i := 0; i 0 { sum += nums[i] } else { sum = nums[i] } if sum > result { result = sum } } return result } // 暴力法 func maxSubArray(nums []int) int { result := math.MinInt32 for i := 0; i result { result = sum } } } return result } // func maxSubArray(nums []int) int { dp := make([]int, len(nums)) dp[0] = nums[0] result := nums[0] for i := 1; i nums[i] { dp[i] = dp[i-1] + nums[i] } else { dp[i] = nums[i] } if dp[i] > result { result = dp[i] } } return result } // 动态规划 func maxSubArray(nums []int) int { dp := nums[0] result := dp for i := 1; i nums[i] { dp = dp + nums[i] } else { dp = nums[i] } if dp > result { result = dp } } return result } // 分治法 func maxSubArray(nums []int) int { result := maxSubArr(nums, 0, len(nums)-1) return result } func maxSubArr(nums []int, left, right int) int { if left == right { return nums[left] } mid := (left + right) / 2 leftSum := maxSubArr(nums, left, mid) // 最大子序在左边 rightSum := maxSubArr(nums, mid+1, right) // 最大子序在右边 midSum := findMaxArr(nums, left, mid, right) // 跨中心 result := max(leftSum, rightSum) result = max(result, midSum) return result } func findMaxArr(nums []int, left, mid, right int) int { leftSum := math.MinInt32 sum := 0 // 从右到左 for i := mid; i >= left; i-- { sum += nums[i] leftSum = max(leftSum, sum) } rightSum := math.MinInt32 sum = 0 // 从左到右 for i := mid + 1; i b { return a } return b } 58.最后一个单词的长度(2) 题目 给定一个仅包含大小写字母和空格 ' ' 的字符串，返回其最后一个单词的长度。 如果不存在最后一个单词，请返回 0 。 说明：一个单词是指由字母组成，但不包含任何空格的字符串。 示例: 输入: \"Hello World\" 输出: 5 解题思路 No. 思路 时间复杂度 空间复杂度 01(最优) 调用系统函数，切割为数组取最后一个值 O(n) O(1) 02 遍历统计 O(n) O(1) // 调用系统函数，切割为数组取最后一个值 func lengthOfLastWord(s string) int { arr := strings.Split(strings.Trim(s, \" \"), \" \") return len(arr[len(arr)-1]) } // 遍历统计 func lengthOfLastWord(s string) int { length := len(s) if length == 0 { return 0 } result := 0 for i := length - 1; i >= 0; i-- { if s[i] == ' ' { if result > 0 { return result } continue } result++ } return result } 66.加一(2) 题目 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1: 输入: [1,2,3] 输出: [1,2,4] 解释: 输入数组表示数字 123。 示例 2: 输入: [4,3,2,1] 输出: [4,3,2,2] 解释: 输入数组表示数字 4321。 解题思路 No. 思路 时间复杂度 空间复杂度 01 直接模拟 O(n) O(1) 02(最优) 直接模拟 O(n) O(1) // 模拟进位 func plusOne(digits []int) []int { length := len(digits) if length == 0 { return []int{1} } digits[length-1]++ for i := length - 1; i > 0; i-- { if digits[i] 9 { digits[0] = digits[0] - 10 digits = append([]int{1}, digits...) } return digits } // 模拟进位 func plusOne(digits []int) []int { for i := len(digits) - 1; i >= 0; i-- { if digits[i] 67.二进制求和(2) 题目 给定两个二进制字符串，返回他们的和（用二进制表示）。 输入为非空字符串且只包含数字 1 和 0。 示例 1: 输入: a = \"11\", b = \"1\" 输出: \"100\" 示例 2:输入: a = \"1010\", b = \"1011\" 输出: \"10101\" 解题思路 No. 思路 时间复杂度 空间复杂度 01 转换成数组模拟 O(n) O(n) 02(最优) 直接模拟 O(n) O(1) // 转换成数组模拟 func addBinary(a string, b string) string { if len(a) = 1; i-- { temp := result[i] + a[i-1] + b[i-1] result[i] = temp % 2 result[i-1] = temp / 2 } i := 0 for i = 0 || j >= 0 { intA, intB := 0, 0 if i >= 0 { intA = int(a[i] - '0') } if j >= 0 { intB = int(b[j] - '0') } current = intA + intB + flag flag = 0 if current >= 2 { flag = 1 current = current - 2 } cur := strconv.Itoa(current) result = cur + result i-- j-- } if flag == 1 { result = \"1\" + result } return result } 69.x的平方根 (5) 题目 实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 示例 1:输入: 4 输出: 2 示例 2:输入: 8 输出: 2 说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 解题思路 No. 思路 时间复杂度 空间复杂度 01 系统函数 O(log(n)) O(1) 02 系统函数 O(log(n)) O(1) 03(最优) 牛顿迭代法 O(log(n)) O(1) 04 二分查找法 O(log(n)) O(1) 05 暴力法:遍历 O(n) O(1) // 系统函数 func mySqrt(x int) int { result := int(math.Sqrt(float64(x))) return result } // 系统函数 func mySqrt(x int) int { result := math.Floor(math.Sqrt(float64(x))) return int(result) } // 牛顿迭代法 func mySqrt(x int) int { result := x for result*result > x { result = (result + x/result) / 2 } return result } // 二分查找法 func mySqrt(x int) int { left := 1 right := x for left 70.爬楼梯(3) 题目 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。 1. 1 阶 + 1 阶 2. 2 阶 示例 2： 输入： 3 输出： 3 解释： 有三种方法可以爬到楼顶。 1. 1 阶 + 1 阶 + 1 阶 2. 1 阶 + 2 阶 3. 2 阶 + 1 阶 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(n) 02 动态规划 O(n) O(n) 03(最优) 斐波那契 O(n) O(1) // 递归 var arr []int func climbStairs(n int) int { arr = make([]int, n+1) return climbStart(0, n) } func climbStart(i, n int) int { if i > n { return 0 } if i == n { return 1 } if arr[i] > 0 { return arr[i] } arr[i] = climbStart(i+1, n) + climbStart(i+2, n) return arr[i] } // 动态规划 func climbStairs(n int) int { if n == 1 { return 1 } if n == 2 { return 2 } dp := make([]int, n+1) dp[1] = 1 dp[2] = 2 for i := 3; i 83.删除排序链表中的重复元素(3) 题目 给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 示例 1:输入: 1->1->2 输出: 1->2 示例 2:输入: 1->1->2->3->3 输出: 1->2->3 解题思路 No. 思路 时间复杂度 空间复杂度 01( 最优) 直接法 O(n) O(1) 02 递归法 O(n) O(1) 03 双指针法 O(n) O(1) // 直接法 func deleteDuplicates(head *ListNode) *ListNode { if head == nil { return nil } temp := head for temp.Next != nil { if temp.Val == temp.Next.Val { temp.Next = temp.Next.Next } else { temp = temp.Next } } return head } // 递归法 func deleteDuplicates(head *ListNode) *ListNode { if head == nil || head.Next == nil{ return head } head.Next = deleteDuplicates(head.Next) if head.Val == head.Next.Val{ head = head.Next } return head } // 双指针法 func deleteDuplicates(head *ListNode) *ListNode { if head == nil || head.Next == nil{ return head } p := head q := head.Next for p.Next != nil{ if p.Val == q.Val{ if q.Next == nil{ p.Next = nil }else { p.Next = q.Next q = q.Next } }else { p = p.Next q = q.Next } } return head } 88.合并两个有序数组(3) 题目 给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 示例:输入: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3 输出: [1,2,2,3,5,6] 解题思路 No. 思路 时间复杂度 空间复杂度 01 合并后排序 O(nlog(n)) O(1) 02(最优) 双指针法 O(n) O(1) 03 拷贝后插入 O(n) O(n) // 合并后排序 func merge(nums1 []int, m int, nums2 []int, n int) { nums1 = nums1[:m] nums1 = append(nums1, nums2[:n]...) sort.Ints(nums1) } // 双指针法 func merge(nums1 []int, m int, nums2 []int, n int) { for m > 0 && n > 0 { if nums1[m-1] 0 { for n > 0 { nums1[n-1] = nums2[n-1] n-- } } } // 拷贝后插入 func merge(nums1 []int, m int, nums2 []int, n int) { temp := make([]int, m) copy(temp, nums1) if n == 0 { return } first, second := 0, 0 for i := 0; i = n { nums1[i] = temp[first] first++ continue } if first >= m { nums1[i] = nums2[second] second++ continue } if temp[first] 100.相同的树(2) 题目 给定两个二叉树，编写一个函数来检验它们是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 示例 1: 输入: 1 1 / \\ / \\ 2 3 2 3 [1,2,3], [1,2,3] 输出: true 示例 2: 输入: 1 1 / \\ 2 2 [1,2], [1,null,2] 输出: false 示例 3: 输入: 1 1 / \\ / \\ 2 1 1 2 [1,2,1], [1,1,2] 输出: false 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归(深度优先) O(n) O(log(n)) 02 层序遍历(宽度优先) O(n) O(log(n)) // 递归(深度优先) func isSameTree(p *TreeNode, q *TreeNode) bool { if p == nil && q == nil { return true } if p == nil || q == nil { return false } return p.Val == q.Val && isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right) } // 层序遍历(宽度优先) func isSameTree(p *TreeNode, q *TreeNode) bool { if p == nil && q == nil { return true } if p == nil || q == nil { return false } var queueP, queueQ []*TreeNode if p != nil { queueP = append(queueP, p) queueQ = append(queueQ, q) } for len(queueP) > 0 && len(queueQ) > 0 { tempP := queueP[0] queueP = queueP[1:] tempQ := queueQ[0] queueQ = queueQ[1:] if tempP.Val != tempQ.Val { return false } if (tempP.Left != nil && tempQ.Left == nil) || (tempP.Left == nil && tempQ.Left != nil) { return false } if tempP.Left != nil { queueP = append(queueP, tempP.Left) queueQ = append(queueQ, tempQ.Left) } if (tempP.Right != nil && tempQ.Right == nil) || (tempP.Right == nil && tempQ.Right != nil) { return false } if tempP.Right != nil { queueP = append(queueP, tempP.Right) queueQ = append(queueQ, tempQ.Right) } } return true } 0001-0100-Medium 2.两数相加(2) 题目 给出两个 非空 的链表用来表示两个非负的整数。 其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例：输入：(2 -> 4 -> 3) + (5 -> 6 -> 4) 输出：7 -> 0 -> 8 原因：342 + 465 = 807 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(n) 02 递归 O(n) O(n) func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { res := &ListNode{} cur := res carry := 0 for l1 != nil || l2 != nil || carry > 0 { sum := carry if l1 != nil { sum += l1.Val l1 = l1.Next } if l2 != nil { sum += l2.Val l2 = l2.Next } carry = sum / 10 // 进位 cur.Next = &ListNode{Val: sum % 10} cur = cur.Next } return res.Next } # func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { if l1 == nil && l2 == nil { return nil } if l1 == nil { return l2 } if l2 == nil { return l1 } sum := l1.Val + l2.Val res := &ListNode{Val: sum % 10} if sum >= 10 { l1.Next = addTwoNumbers(l1.Next, &ListNode{Val: 1}) } res.Next = addTwoNumbers(l1.Next, l2.Next) return res } 3.无重复字符的最长子串(4) 题目 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1:输入: \"abcabcbb\"输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。 示例 2:输入: \"bbbbb\" 输出: 1 解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。 示例 3:输入: \"pwwkew\" 输出: 3 解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。 同剑指offer面试题48.最长不含重复字符的子字符串 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组辅助-双指针 O(n) O(1) 02 双指针-内置函数 O(n^2) O(1) 03 哈希辅助-双指针 O(n) O(1) 04 动态规划 O(n) O(n) func lengthOfLongestSubstring(s string) int { arr := [256]int{} for i := range arr { arr[i] = -1 } max, j := 0, 0 for i := 0; i = j { j = arr[s[i]] + 1 } else if i+1-j > max { max = i + 1 - j } arr[s[i]] = i } return max } # func lengthOfLongestSubstring(s string) int { max, j := 0, 0 for i := 0; i max { max = i - j } j = j + index + 1 } if len(s)-j > max { max = len(s) - j } return max } # func lengthOfLongestSubstring(s string) int { m := make(map[uint8]int) max, j := 0, 0 for i := 0; i = j { j = v + 1 } else if i+1-j > max { max = i + 1 - j } m[s[i]] = i } return max } # func lengthOfLongestSubstring(s string) int { if len(s) dp[i-1] { dp[i] = dp[i-1] + 1 } else { dp[i] = i - index } m[s[i]] = i if dp[i] > res { res = dp[i] } } return res } 5.最长回文子串(5) 题目 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1：输入: \"babad\"输出: \"bab\" 注意: \"aba\" 也是一个有效答案。 示例 2：输入: \"cbbd\" 输出: \"bb\" 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n^2) O(n^2) 02 中心扩展 O(n^2) O(1) 03 暴力法 O(n^3) O(1) 04 Manacher算法 O(n^2) O(n) 05 Manacher算法 O(n) O(n) // dp(l,r)=dp(l+1,r−1)&&(s[l]==s[r]) // dp[l,r]：字符串s从索引l到r的子串是否是回文串 func longestPalindrome(s string) string { if len(s) max { max = r - l + 1 start = l } } } } return s[start : start+max] } # 2 func longestPalindrome(s string) string { if len(s) end-start { start, end = left1, right1 } if right2-left2 > end-start { start, end = left2, right2 } } return s[start : end+1] } func find(s string, left, right int) (int, int) { for ; 0 max { max = curLength begin = (i - max) / 2 } } return s[begin : begin+max] } func search(s string, center int) int { i := center - 1 j := center + 1 step := 0 for ; i >= 0 && j = 0 && right maxRight { maxRight = i + temp[i] center = i } if temp[i] > max { max = temp[i] begin = (i - max) / 2 } } return s[begin : begin+max] } func add(s string) string { var res []rune for _, v := range s { res = append(res, '#') res = append(res, v) } res = append(res, '#') return string(res) } func min(a, b int) int { if a > b { return b } return a } 6.Z字形变换(2) 题目 将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 \"LEETCODEISHIRING\" 行数为 3 时，排列如下： L C I R E T O E S I I G E D H N 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：\"LCIRETOESIIGEDHN\"。 请你实现这个将字符串进行指定行数变换的函数： string convert(string s, int numRows); 示例 1:输入: s = \"LEETCODEISHIRING\", numRows = 3 输出: \"LCIRETOESIIGEDHN\" 示例 2:输入: s = \"LEETCODEISHIRING\", numRows = 4 输出: \"LDREOEIIECIHNTSG\" 解释: L D R E O E I I E C I H N T S G 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(n) 02 遍历 O(n) O(n) func convert(s string, numRows int) string { if numRows == 1 { return s } arr := []rune(s) total := numRows*2 - 2 res := make([]string, numRows) for i := 0; i 8.字符串转换整数 (atoi)(3) 题目 请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下： 如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。 假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。 该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时， 则你的函数不需要进行转换，即无法进行有效转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0 。 提示： 本题中的空白字符只包括空格字符 ' ' 。 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。 如果数值超过这个范围，请返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 示例 1:输入: \"42\" 输出: 42 示例 2:输入: \" -42\" 输出: -42 解释: 第一个非空白字符为 '-', 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 示例 3:输入: \"4193 with words\" 输出: 4193 解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。 示例 4:输入: \"words and 987\" 输出: 0 解释: 第一个非空字符是 'w', 但它不是数字或正、负号。 因此无法执行有效的转换。 示例 5:输入: \"-91283472332\" 输出: -2147483648 解释: 数字 \"-91283472332\" 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(n) 02 正则 O(n) O(n) 03 遍历 O(n) O(n) func myAtoi(str string) int { i := 0 for i = '0' && str[j] 0 { break } if str[j] != ' ' && str[j] != '+' && str[j] != '-' { return 0 } if isFlag != ' ' { return 0 } isFlag = str[j] } } res := 0 for i := 0; i math.MaxInt32 { return math.MaxInt32 } } } if isFlag == '-' { return -1 * res } return res } # func myAtoi(str string) int { re := regexp.MustCompile(`^[+-]?\\d+`) arrS := re.FindAllString(strings.Trim(str, \" \"), -1) if len(arrS) == 0{ return 0 } arr := arrS[0] res := 0 isFlag := byte(' ') if !(arr[0] >= '0' && arr[0] 214748364 || (res==214748364 && value >= 8) { return math.MinInt32 } } else if isFlag == ' ' || isFlag == '+' { if res > 214748364 || (res==214748364 && value >= 7) { return math.MaxInt32 } } res = res*10 + value } if isFlag == '-' { return -1 * res } return res } # func myAtoi(str string) int { str = strings.TrimSpace(str) result := 0 flag := 1 for i, v := range str { if v >= '0' && v math.MaxInt32 { if flag == -1 { return math.MinInt32 } return math.MaxInt32 } } return flag * result } 11.盛最多水的容器(2) 题目 给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。 在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例：输入：[1,8,6,2,5,4,8,3,7] 输出：49 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历-双指针 O(n) O(1) 02 遍历-暴力法 O(n^2) O(1) func maxArea(height []int) int { i := 0 j := len(height) - 1 res := 0 for i res { res = area } // 移动较小的指针，尝试获取更大的面积 if height[i] > height[j] { j-- } else { i++ } } return res } func min(a, b int) int { if a > b { return b } return a } # func maxArea(height []int) int { res := 0 for i := 0; i res { res = area } } } return res } func min(a, b int) int { if a > b { return b } return a } 12.整数转罗马数字(2) 题目 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。 数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。 同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。 示例 1:输入: 3输出: \"III\" 示例 2:输入: 4 输出: \"IV\" 示例 3:输入: 9 输出: \"IX\" 示例 4:输入: 58 输出: \"LVIII\" 解释: L = 50, V = 5, III = 3. 示例 5:输入: 1994 输出: \"MCMXCIV\" 解释: M = 1000, CM = 900, XC = 90, IV = 4. 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(log(n)) O(1) 02 枚举 O(1) O(1) func intToRoman(num int) string { m := map[int]string{ 1: \"I\", 4: \"IV\", 5: \"V\", 9: \"IX\", 10: \"X\", 40: \"XL\", 50: \"L\", 90: \"XC\", 100: \"C\", 400: \"CD\", 500: \"D\", 900: \"CM\", 1000: \"M\", } arr := []int{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1} result := \"\" for i := 0; i 15.三数之和(2) 题目 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？ 请你找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例： 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ] 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n^2) O(n^2) 02 哈希辅助 O(n^2) O(n^2) func threeSum(nums []int) [][]int { res := make([][]int, 0) sort.Ints(nums) for i := 0; i 0 || nums[i]+nums[left] > 0 { break } if i > 0 && nums[i] == nums[i-1] { continue } for left i+1 && nums[left] == nums[left-1] { left++ continue } if right target { right-- } else if nums[left]+nums[right] 0 { break } if value, ok := p[-sum]; ok && value > j { if _, ok2 := m[[2]int{nums[i], nums[j]}]; !ok2 { res = append(res, []int{nums[i], nums[j], 0 - nums[i] - nums[j]}) m[[2]int{nums[i], nums[j]}] = 1 } } } } return res } 16.最接近的三数之和(2) 题目 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。 找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 示例：输入：nums = [-1,2,1,-4], target = 1 输出：2 解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。 提示： 3 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n^2) O(1) 02 暴力法 O(n^3) O(1) func threeSumClosest(nums []int, target int) int { sort.Ints(nums) res := nums[0] + nums[1] + nums[2] for i := 0; i target { right-- } else if sum b { return a - b } return b - a } # func threeSumClosest(nums []int, target int) int { res := nums[0] + nums[1] + nums[2] for i := 0; i b { return a - b } return b - a } 17.电话号码的字母组合(2) 题目 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例:输入：\"23\"输出：[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]. 说明:尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(4^n) O(4^n) 02 递归-回溯 O(4^n) O(4^n) func letterCombinations(digits string) []string { if len(digits) == 0 { return nil } arr := []string{\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"} res := []string{\"\"} for i := 0; i 18.四数之和(3) 题目 给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ， 使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 注意：答案中不可以包含重复的四元组。 示例：给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ] 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n^3) O(n^3) 02 哈希辅助 O(n^3) O(n^3) 03 全排列+递归 O(n^3) O(n^3) func fourSum(nums []int, target int) [][]int { sort.Ints(nums) res := make([][]int, 0) for i := 0; i 0 && nums[i] == nums[i-1] { continue } for j := i + 1; j i+1 && nums[j] == nums[j-1] { continue } temp := target - nums[i] - nums[j] left := j + 1 right := len(nums) - 1 for left j+1 && nums[left] == nums[left-1] { left++ continue } if right temp { right-- } else if nums[left]+nums[right] k { if _, ok2 := m[[3]int{nums[i], nums[j], nums[k]}]; !ok2 { res = append(res, []int{nums[i], nums[j], nums[k], target - nums[i] - nums[j] - nums[k]}) m[[3]int{nums[i], nums[j], nums[k]}] = 1 } } } } } return res } # var res [][]int func fourSum(nums []int, target int) [][]int { sort.Ints(nums) res = make([][]int, 0) dfs(nums, target, []int{}, 0) return res } func dfs(nums []int, target int, arr []int, level int) { if len(arr) == 4 { sum := 0 for i := 0; i 19.删除链表的倒数第N个节点(3) 题目 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例：给定一个链表: 1->2->3->4->5, 和 n = 2. 当删除了倒数第二个节点后，链表变为 1->2->3->5. 说明：给定的 n 保证是有效的。 进阶：你能尝试使用一趟扫描实现吗？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 快慢指针 O(n) O(1) 03 递归 O(n) O(n) func removeNthFromEnd(head *ListNode, n int) *ListNode { temp := &ListNode{Next: head} cur := temp total := 0 for cur.Next != nil { cur = cur.Next total++ } cur = temp count := 0 for cur.Next != nil { if total-n == count { cur.Next = cur.Next.Next break } cur = cur.Next count++ } return temp.Next } # func removeNthFromEnd(head *ListNode, n int) *ListNode { temp := &ListNode{Next: head} fast, slow := temp, temp for i := 0; i 22.括号生成(3) 题目 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 示例：输入：n = 3 输出：[ \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\" ] 解题思路 No. 思路 时间复杂度 空间复杂度 01 全排列-递归 O(4^n/n^(1/2)) O(4^n/n^(1/2)) 02 动态规划 O(4^n/n^(1/2)) O(4^n/n^(1/2)) 03 广度优先搜索 O(4^n/n^(1/2)) O(4^n/n^(1/2)) var res []string func generateParenthesis(n int) []string { res = make([]string, 0) dfs(0, 0, n, \"\") return res } func dfs(left, right, max int, str string) { if left == right && left == max { res = append(res, str) return } if left 0 { node := queue[0] queue = queue[1:] if node.left == 0 && node.right == 0 { res = append(res, node.str) } if node.left > 0 { queue = append(queue, &Node{ str: node.str + \"(\", left: node.left - 1, right: node.right, }) } if node.right > 0 && node.left 24.两两交换链表中的节点(2) 题目 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例:给定 1->2->3->4, 你应该返回 2->1->4->3. 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 递归 O(n) O(n) func swapPairs(head *ListNode) *ListNode { temp := &ListNode{Next: head} prev := temp for head != nil && head.Next != nil { first, second := head, head.Next prev.Next = second first.Next, second.Next = second.Next, first prev, head = first, first.Next } return temp.Next } # func swapPairs(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } first, second := head, head.Next first.Next, second.Next = swapPairs(second.Next), first return second } 29.两数相除(2) 题目 给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。 返回被除数 dividend 除以除数 divisor 得到的商。 整数除法的结果应当截去（truncate）其小数部分， 例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2 示例 1:输入: dividend = 10, divisor = 3输出: 3 解释: 10/3 = truncate(3.33333..) = truncate(3) = 3 示例 2:输入: dividend = 7, divisor = -3 输出: -2 解释: 7/-3 = truncate(-2.33333..) = -2 提示： 被除数和除数均为 32 位有符号整数。 除数不为 0。 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31, 2^31 − 1]。 本题中，如果除法结果溢出，则返回 2^31 − 1。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(log(n)) O(1) 02 计算 O(1) O(1) func divide(dividend int, divisor int) int { if divisor == 0 || dividend == 0 { return 0 } if divisor == 1 { return dividend } flag, count := 1, 1 if dividend = 0 { for a-b >= 0 { a = a - b c = c + count b = b + b count = count + count } b = temp count = 1 } if c > math.MaxInt32 { return math.MaxInt32 } if flag math.MaxInt32 { return math.MaxInt32 } return res } 31.下一个排列(1) 题目 实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。 必须原地修改，只允许使用额外常数空间。 以下是一些例子，输入位于左侧列，其相应输出位于右侧列。 1,2,3 → 1,3,2 3,2,1 → 1,2,3 1,1,5 → 1,5,1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) func nextPermutation(nums []int) { left := len(nums) - 2 for left >= 0 && nums[left] >= nums[left+1] { left-- } if left == -1 { sort.Ints(nums) return } right := len(nums) - 1 for right >= 0 && nums[right] 33.搜索旋转排序数组(2) 题目 假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 你可以假设数组中不存在重复的元素。 你的算法时间复杂度必须是 O(log n) 级别。 示例 1:输入: nums = [4,5,6,7,0,1,2], target = 0 输出: 4 示例 2:输入: nums = [4,5,6,7,0,1,2], target = 3 输出: -1 解题思路 No. 思路 时间复杂度 空间复杂度 01 二分查找 O(log(n)) O(1) 02 遍历 O(n) O(1) func search(nums []int, target int) int { left, right := 0, len(nums)-1 for left 34.在排序数组中查找元素的第一个和最后一个位置(4) 题目 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 你的算法时间复杂度必须是 O(log n) 级别。 如果数组中不存在目标值，返回 [-1, -1]。 示例 1:输入: nums = [5,7,7,8,8,10], target = 8 输出: [3,4] 示例 2:输入: nums = [5,7,7,8,8,10], target = 6 输出: [-1,-1] 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n) O(1) 02 遍历 O(n) O(1) 03 二分查找 O(log(n)) O(1) 04 二分查找 O(log(n)) O(1) func searchRange(nums []int, target int) []int { left := 0 right := len(nums) - 1 for left nums[left] { left++ } } if nums[right] != target { if target = 0 && nums[left] == nums[right] && nums[left] == target { break } } if right target { break } } for i := len(nums) - 1; i >= 0; i-- { if nums[i] == target { left = i } else if nums[i] target || nums[len(nums)-1] nums[mid] { left = mid + 1 } else { right = mid - 1 } } if left = 0 && nums[right] == target { return right } return -1 } # func searchRange(nums []int, target int) []int { left := -1 right := -1 for i, j := 0, len(nums)-1; i target { j = mid - 1 } else { for temp := mid; temp >= 0; temp-- { if target == nums[temp] { left = temp } else { break } } for temp := mid; temp 36.有效的数独(1) 题目 判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 上图是一个部分填充的有效的数独。 数独部分空格内已填入了数字，空白格用 '.' 表示。 示例 1:输入: [ [\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"], [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"], [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"], [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"], [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"], [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"], [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"], [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"], [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"] ] 输出: true 示例 2:输入: [ [\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"], [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"], [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"], [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"], [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"], [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"], [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"], [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"], [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"] ] 输出: false 解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。 说明: 一个有效的数独（部分已被填充）不一定是可解的。 只需要根据以上规则，验证已经填入的数字是否有效即可。 给定数独序列只包含数字 1-9 和字符 '.' 。 给定数独永远是 9x9 形式的。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(1) O(1) func isValidSudoku(board [][]byte) bool { var row, col, arr [9][9]int for i := 0; i 39.组合总和(2) 题目 给定一个无重复元素的数组 candidates 和一个目标数 target ， 找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。 解集不能包含重复的组合。 示例 1:输入: candidates = [2,3,6,7], target = 7, 所求解集为: [ [7], [2,2,3] ] 示例 2:输入: candidates = [2,3,5], target = 8, 所求解集为: [ [2,2,2,2], [2,3,3], [3,5] ] 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(2^n) O(2^n) 02 递归 O(2^n) O(2^n) var res [][]int func combinationSum(candidates []int, target int) [][]int { res = make([][]int, 0) sort.Ints(candidates) dfs(candidates, target, []int{}, 0) return res } func dfs(candidates []int, target int, arr []int, index int) { if target == 0 { temp := make([]int, len(arr)) copy(temp, arr) res = append(res, temp) return } if target 40.组合总和II(2) 题目 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。 说明： 所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。 示例 1:输入: candidates = [10,1,2,7,6,1,5], target = 8, 所求解集为: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ] 示例 2:输入: candidates = [2,5,2,1,2], target = 5, 所求解集为: [ [1,2,2], [5] ] 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n!) O(n!) 02 递归 O(n!) O(n!) var res [][]int func combinationSum2(candidates []int, target int) [][]int { res = make([][]int, 0) sort.Ints(candidates) dfs(candidates, target, []int{}, 0) return res } func dfs(candidates []int, target int, arr []int, index int) { if target == 0 { temp := make([]int, len(arr)) copy(temp, arr) res = append(res, temp) return } if target 43.字符串相乘(1) 题目 给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积， 它们的乘积也表示为字符串形式。 示例 1:输入: num1 = \"2\", num2 = \"3\"输出: \"6\" 示例 2:输入: num1 = \"123\", num2 = \"456\"输出: \"56088\" 说明： num1 和 num2 的长度小于110。 num1 和 num2 只包含数字 0-9。 num1 和 num2 均不以零开头，除非是数字 0 本身。 不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。 解题思路 No. 思路 时间复杂度 空间复杂度 01 模拟 O(n^2) O(n) 02 内置函数 O(n^2) O(n) func multiply(num1 string, num2 string) string { if num1 == \"0\" || num2 == \"0\" { return \"0\" } arr := make([]int, len(num1)+len(num2)) for i := len(num1) - 1; i >= 0; i-- { a := int(num1[i] - '0') for j := len(num2) - 1; j >= 0; j-- { b := int(num2[j] - '0') value := a*b + arr[i+j+1] arr[i+j+1] = value % 10 arr[i+j] = value/10 + arr[i+j] } } res := \"\" for i := 0; i 46.全排列(3) 题目 给定一个 没有重复 数字的序列，返回其所有可能的全排列。 示例:输入: [1,2,3]输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] 解题思路 No. 思路 时间复杂度 空间复杂度 01 回溯 O(n^n) O(n*n!) 02 递归 O(n!) O(n*n!) 03 回溯 O(n!) O(n*n!) var res [][]int func permute(nums []int) [][]int { res = make([][]int, 0) arr := make([]int, 0) visited := make(map[int]bool) dfs(nums, 0, arr, visited) return res } func dfs(nums []int, index int, arr []int, visited map[int]bool) { if index == len(nums) { temp := make([]int, len(arr)) copy(temp, arr) res = append(res, temp) return } for i := 0; i 47.全排列II(3) 题目 给定一个可包含重复数字的序列，返回所有不重复的全排列。 示例:输入: [1,1,2] 输出: [ [1,1,2], [1,2,1], [2,1,1] ] 解题思路 No. 思路 时间复杂度 空间复杂度 01 回溯 O(n!) O(n!) 02 回溯 O(n!) O(n!) 03 回溯 O(n!) O(n!) var res [][]int func permuteUnique(nums []int) [][]int { res = make([][]int, 0) sort.Ints(nums) dfs(nums, 0, make([]int, len(nums)), make([]int, 0)) return res } func dfs(nums []int, index int, visited []int, arr []int) { if len(nums) == index { temp := make([]int, len(arr)) copy(temp, arr) res = append(res, temp) return } for i := 0; i 0 && nums[i] == nums[i-1] && visited[i-1] == 0{ continue } arr = append(arr, nums[i]) visited[i] = 1 dfs(nums, index+1, visited, arr) visited[i] = 0 arr = arr[:len(arr)-1] } } # 2 var res [][]int func permuteUnique(nums []int) [][]int { res = make([][]int, 0) sort.Ints(nums) dfs(nums, 0) return res } func dfs(nums []int, index int) { if index == len(nums) { temp := make([]int, len(nums)) copy(temp, nums) res = append(res, temp) return } m := make(map[int]int) for i := index; i 48.旋转图像(3) 题目 给定一个 n × n 的二维矩阵表示一个图像。 将图像顺时针旋转 90 度。 说明：你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。 示例 1:给定 matrix = [ [1,2,3], [4,5,6], [7,8,9] ], 原地旋转输入矩阵，使其变为: [ [7,4,1], [8,5,2], [9,6,3] ] 示例 2:给定 matrix = [ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16] ], 原地旋转输入矩阵，使其变为: [ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11] ] 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n^2) O(1) 02 遍历 O(n^2) O(1) 03 数组辅助 O(n^2) O(n^2) func rotate(matrix [][]int) { n := len(matrix) // 同行逆置 // [[1 2 3] [4 5 6] [7 8 9]] // [[3 2 1] [6 5 4] [9 8 7]] for i := 0; i 49.字母异位词分组(2) 题目 给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。 示例:输入: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"] 输出: [ [\"ate\",\"eat\",\"tea\"], [\"nat\",\"tan\"], [\"bat\"] ] 说明： 所有输入均为小写字母。 不考虑答案输出的顺序。 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n^2log(n)) O(n^2) 02 哈希辅助 O(n^2) O(n^2) func groupAnagrams(strs []string) [][]string { m := make(map[string]int) res := make([][]string, 0) for i := 0; i 50.Pow(x,n)(4) 题目 实现 pow(x, n) ，即计算 x 的 n 次幂函数。 示例 1:输入: 2.00000, 10 输出: 1024.00000 示例 2:输入: 2.10000, 3 输出: 9.26100 示例 3:输入: 2.00000, -2 输出: 0.25000 解释: 2-2 = 1/22 = 1/4 = 0.25 说明: -100.0 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(log(n)) O(1) 02 迭代 O(log(n)) O(1) 03 计算 O(log(n)) O(1) 04 递归 O(log(n)) O(log(n)) func myPow(x float64, n int) float64 { if n == 0 { return 1 } if n 0 { if n%2 == 1 { res = res * x } x = x * x n = n / 2 } return res } # func myPow(x float64, n int) float64 { return math.Pow(x, float64(n)) } # func myPow(x float64, n int) float64 { if n == 0 { return 1 } if n == 1 { return x } res := 1.0 if n > 0 { res = myPow(x, n/2) return res * res * myPow(x, n%2) } else { res = myPow(x, -n/2) res = res * res * myPow(x, -n%2) return 1 / res } } 54.螺旋矩阵(2) 题目 给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。 示例 1:输入: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] 输出: [1,2,3,6,9,8,7,4,5] 示例 2:输入: [ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12] ] 输出: [1,2,3,4,8,12,11,10,9,5,6,7] 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n^2) O(n^2) 02 遍历 O(n^2) O(n^2) var res []int func spiralOrder(matrix [][]int) []int { res = make([]int, 0) rows := len(matrix) if rows == 0 { return res } cols := len(matrix[0]) if cols == 0 { return res } start := 0 for cols > start*2 && rows > start*2 { printCircle(matrix, cols, rows, start) start++ } return res } func printCircle(matrix [][]int, cols, rows, start int) { x := cols - 1 - start y := rows - 1 - start // 左到右 for i := start; i = start; i-- { res = append(res, matrix[y][i]) } } // 下到上 if start = start+1; i-- { res = append(res, matrix[i][start]) } } } # func spiralOrder(matrix [][]int) []int { res := make([]int, 0) rows := len(matrix) if rows == 0 { return res } cols := len(matrix[0]) if cols == 0 { return res } x1, x2, y1, y2 := 0, rows-1, 0, cols-1 direct := 0 for x1 = y1; i-- { res = append(res, matrix[x2][i]) } x2-- } else if direct == 3 { for i := x2; i >= x1; i-- { res = append(res, matrix[i][y1]) } y1++ } direct++ } return res } 55.跳跃游戏(4) 题目 给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个位置。 示例 1:输入: [2,3,1,1,4] 输出: true 解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。 示例 2:输入: [3,2,1,0,4] 输出: false 解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历-贪心 O(n) O(1) 02 动态规划 O(n^2) O(n) 03 遍历-贪心 O(n) O(1) 04 遍历 O(n) O(1) func canJump(nums []int) bool { j := len(nums) - 1 for i := len(nums) - 2; i >= 0; i-- { if nums[i]+i >= j { j = i } } return j = i { flag = true break } } dp[i] = flag } return dp[len(nums)-1] } # func canJump(nums []int) bool { max := 0 for i := 0; i max { max = i + nums[i] } if max >= len(nums)-1 { return true } } } return false } # func canJump(nums []int) bool { zero := -1 for i := len(nums) - 2; i >= 0; i-- { if zero > 0 { if i+nums[i] > zero { zero = -1 } continue } if nums[i] == 0 { zero = i continue } } return zero 56.合并区间(2) 题目 给出一个区间的集合，请合并所有重叠的区间。 示例 1:输入: [[1,3],[2,6],[8,10],[15,18]] 输出: [[1,6],[8,10],[15,18]] 解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2:输入: [[1,4],[4,5]] 输出: [[1,5]] 解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序遍历 O(nlog(n)) O(n) 02 排序-双指针 O(nlog(n)) O(n) func merge(intervals [][]int) [][]int { res := make([][]int, 0) if len(intervals) == 0 { return nil } sort.Slice(intervals, func(i, j int) bool { return intervals[i][0] arr[1] { res = append(res, intervals[i]) } else if intervals[i][1] > arr[1] { res[len(res)-1][1] = intervals[i][1] } } return res } # func merge(intervals [][]int) [][]int { res := make([][]int, 0) if len(intervals) == 0 { return nil } sort.Slice(intervals, func(i, j int) bool { return intervals[i][0] end { end = intervals[j][1] } j++ } res = append(res, []int{intervals[i][0], end}) i = j } return res } 59.螺旋矩阵II(2) 题目 给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。 示例:输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ] 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n^2) O(n^2) 02 遍历模拟 O(n^2) O(n^2) func generateMatrix(n int) [][]int { res := make([][]int, n) for i := 0; i = left && left = top+1 && top = left; i-- { res[bottom][i] = count count++ } bottom-- for i := bottom; i >= top; i-- { res[i][left] = count count++ } left++ } return res } 60.第k个排列(1) 题目 给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。 按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下： \"123\" \"132\" \"213\" \"231\" \"312\" \"321\" 给定 n 和 k，返回第 k 个排列。 说明： 给定 n 的范围是 [1, 9]。 给定 k 的范围是[1, n!]。 示例 1:输入: n = 3, k = 3 输出: \"213\" 示例 2:输入: n = 4, k = 9 输出: \"2314\" 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历计算 O(n) O(n) func getPermutation(n int, k int) string { res := \"\" arr := []string{\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"} times := make([]int, 0) times = append(times, 1) value := 1 for i := 1; i 0 { i := k / times[n-1] k = k % times[n-1] n-- res = res + arr[i] arr = append(arr[:i], arr[i+1:]...) } return res } 61.旋转链表(2) 题目 给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。 示例 1: 输入: 1->2->3->4->5->NULL, k = 2 输出: 4->5->1->2->3->NULL 解释: 向右旋转 1 步: 5->1->2->3->4->NULL 向右旋转 2 步: 4->5->1->2->3->NULL 示例 2: 输入: 0->1->2->NULL, k = 4 输出: 2->0->1->NULL 解释: 向右旋转 1 步: 2->0->1->NULL 向右旋转 2 步: 1->2->0->NULL 向右旋转 3 步: 0->1->2->NULL 向右旋转 4 步: 2->0->1->NULL 解题思路 No. 思路 时间复杂度 空间复杂度 01 统计遍历 O(n) O(1) 02 数组辅助 O(n) O(n) func rotateRight(head *ListNode, k int) *ListNode { if head == nil || k == 0 { return head } temp := head count := 1 for temp.Next != nil { temp = temp.Next count++ } temp.Next = head k = k % count for i := 0; i 62.不同路径(4) 题目 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ 例如，上图是一个7 x 3 的网格。有多少可能的路径？ 示例 1:输入: m = 3, n = 2 输出: 3 解释: 从左上角开始，总共有 3 条路径可以到达右下角。 1. 向右 -> 向右 -> 向下 2. 向右 -> 向下 -> 向右 3. 向下 -> 向右 -> 向右 示例 2:输入: m = 7, n = 3 输出: 28 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n^2) O(n^2) 02 动态规划 O(n^2) O(n) 03 数学 O(n) O(1) 04 递归 O(n^2) O(n^2) // dp[i][j] = dp[i-1][j] + dp[i][j-1] func uniquePaths(m int, n int) int { if m n { m, n = n, m } a := 1 for i := 1; i 0 { return arr[n][m] } arr[n][m] = dfs(m, n-1) + dfs(m-1, n) return arr[n][m] } 63.不同路径II(3) 题目 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 网格中的障碍物和空位置分别用 1 和 0 来表示。 说明：m 和 n 的值均不超过 100。 示例 1: 输入: [ [0,0,0], [0,1,0], [0,0,0] ] 输出: 2 解释: 3x3 网格的正中间有一个障碍物。 从左上角到右下角一共有 2 条不同的路径： 1. 向右 -> 向右 -> 向下 -> 向下 2. 向下 -> 向下 -> 向右 -> 向右 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n^2) O(n^2) 02 动态规划 O(n^2) O(n) 03 动态规划 O(n^2) O(1) func uniquePathsWithObstacles(obstacleGrid [][]int) int { n := len(obstacleGrid) if n = 1 && obstacleGrid[i][j-1] == 0 { dp[j] = dp[j] + dp[j-1] } } } return dp[m-1] } # 3 func uniquePathsWithObstacles(obstacleGrid [][]int) int { n := len(obstacleGrid) if n 64.最小路径和(4) 题目 给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例: 输入: [ [1,3,1], [1,5,1], [4,2,1] ] 输出: 7解释: 因为路径 1→3→1→1→1 的总和最小。 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n^2) O(n^2) 02 动态规划 O(n^2) O(1) 03 动态规划 O(n^2) O(n) 04 递归 O(n^2) O(n^2) func minPathSum(grid [][]int) int { n := len(grid) if n == 0 { return 0 } m := len(grid[0]) dp := make([][]int, n) for i := 0; i b { return b } return a } # func minPathSum(grid [][]int) int { n := len(grid) if n == 0 { return 0 } m := len(grid[0]) for i := 0; i b { return b } return a } # 3 func minPathSum(grid [][]int) int { n := len(grid) if n == 0 { return 0 } m := len(grid[0]) dp := make([]int, m) dp[0] = grid[0][0] for i := 1; i b { return b } return a } # 4 var arr [][]int func minPathSum(grid [][]int) int { n := len(grid) if n == 0 { return 0 } m := len(grid[0]) arr = make([][]int, n) for i := 0; i 0 { return arr[n][m] } arr[n][m] = min(dfs(grid, n-1, m), dfs(grid, n, m-1)) + grid[n][m] return arr[n][m] } func min(a, b int) int { if a > b { return b } return a } 71.简化路径(2) 题目 以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。 在 Unix 风格的文件系统中，一个点（.）表示当前目录本身； 此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。 更多信息请参阅：Linux / Unix中的绝对路径 vs 相对路径 请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。 最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。 示例 1：输入：\"/home/\" 输出：\"/home\" 解释：注意，最后一个目录名后面没有斜杠。 示例 2：输入：\"/../\" 输出：\"/\" 解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。 示例 3：输入：\"/home//foo/\" 输出：\"/home/foo\" 解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。 示例 4：输入：\"/a/./b/../../c/\" 输出：\"/c\" 示例 5：输入：\"/a/../../b/../c//.//\" 输出：\"/c\" 示例 6：输入：\"/a//b////c/d//././/..\" 输出：\"/a/b/c\" 解题思路 No. 思路 时间复杂度 空间复杂度 01 栈辅助 O(n) O(n) 02 内置函数 O(n) O(n) func simplifyPath(path string) string { stack := make([]string, 0) arr := strings.Split(path, \"/\") for i := 0; i 0 { stack = stack[:len(stack)-1] } } else { stack = append(stack, arr[i]) } } return \"/\" + strings.Join(stack, \"/\") } # func simplifyPath(path string) string { return filepath.Clean(path) } 73.矩阵置零(4) 题目 给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。 示例 1: 输入: [ [1,1,1], [1,0,1], [1,1,1] ] 输出: [ [1,0,1], [0,0,0], [1,0,1] ] 示例 2: 输入: [ [0,1,2,0], [3,4,5,2], [1,3,1,5] ] 输出: [ [0,0,0,0], [0,4,5,0], [0,3,1,0] ] 进阶: 一个直接的解决方案是使用 O(mn) 的额外空间，但这并不是一个好的解决方案。 一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。 你能想出一个常数空间的解决方案吗？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n^2) O(n) 02 暴力法 O(n^4) O(1) 03 遍历 O(n^2) O(1) 04 遍历 O(n^2) O(1) func setZeroes(matrix [][]int) { x := make(map[int]int) y := make(map[int]int) for i := 0; i = 0; i-- { for j := len(matrix[i]) - 1; j >= 1; j-- { if matrix[i][0] == 0 || matrix[0][j] == 0 { matrix[i][j] = 0 } } } // 第一列处理 if flag == true { for i := 0; i 74.搜索二维矩阵(6) 题目 编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性： 每行中的整数从左到右按升序排列。 每行的第一个整数大于前一行的最后一个整数。 示例 1:输入: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 3 输出: true 示例 2:输入: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 13 输出: false 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法 O(n^2) O(1) 02 暴力法-优化 O(n^2) O(1) 03 二分查找 O(nlog(n)) O(1) 04 左下角查找 O(n) O(1) 05 右上角查找 O(n) O(1) 06 内置函数 O(n^2) O(1) func searchMatrix(matrix [][]int, target int) bool { if len(matrix) == 0 { return false } if len(matrix[0]) == 0 { return false } for i := 0; i = target { for j := 0; j = target { res := binarySearch(matrix[i], target) if res == true { return true } } } return false } func binarySearch(arr []int, target int) bool { left := 0 right := len(arr) - 1 for left target { right = mid - 1 } else { left = mid + 1 } } return false } # 4 func searchMatrix(matrix [][]int, target int) bool { if len(matrix) == 0 { return false } if len(matrix[0]) == 0 { return false } i := len(matrix) - 1 j := 0 for i >= 0 && j target { i-- } else { j++ } } return false } # 5 func searchMatrix(matrix [][]int, target int) bool { if len(matrix) == 0 { return false } if len(matrix[0]) == 0 { return false } i := 0 j := len(matrix[0]) - 1 for j >= 0 && i target { j-- } else { i++ } } return false } # 6 func searchMatrix(matrix [][]int, target int) bool { if len(matrix) == 0 { return false } if len(matrix[0]) == 0 { return false } for i := 0; i 75.颜色分类(3) 题目 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序， 使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 注意: 不能使用代码库中的排序函数来解决这道题。 示例:输入: [2,0,2,1,1,0] 输出: [0,0,1,1,2,2] 进阶： 一个直观的解决方案是使用计数排序的两趟扫描算法。 首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。 你能想出一个仅使用常数空间的一趟扫描算法吗？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序 O(nlog(n)) O(1) 02 双指针 O(n) O(1) 03 数组辅助 O(n) O(1) func sortColors(nums []int) { sort.Ints(nums) } # 2 func sortColors(nums []int) { left := 0 right := len(nums) - 1 for i := 0; i 77.组合(4) 题目 给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。 示例:输入: n = 4, k = 2 输出: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ] 解题思路 No. 思路 时间复杂度 空间复杂度 01 回溯-递归 O(kC(n,k)) O(C(n,k)) 02 回溯 O(kC(n,k)) O(C(n,k)) 03 回溯 O(kC(n,k)) O(C(n,k)) 04 迭代 O(kC(n,k)) O(C(n,k)) var res [][]int func combine(n int, k int) [][]int { res = make([][]int, 0) nums := make([]int, 0) for i := 1; i nums[index-1] { nums[i], nums[index] = nums[index], nums[i] dfs(nums, index+1, k) nums[i], nums[index] = nums[index], nums[i] } } } # 2 var res [][]int func combine(n int, k int) [][]int { res = make([][]int, 0) dfs(n, k, 1, make([]int, 0)) return res } func dfs(n, k, index int, arr []int) { if len(arr) == k { temp := make([]int, k) copy(temp, arr) res = append(res, temp) return } for i := index; i = 0 { arr[i]++ if arr[i] > n { i-- } else if i == k-1 { temp := make([]int, k) copy(temp, arr) res = append(res, temp) } else { i++ arr[i] = arr[i-1] } } return res } 78.子集(3) 题目 给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例:输入: nums = [1,2,3] 输出: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ] 解题思路 No. 思路 时间复杂度 空间复杂度 01 回溯 O(n*2^n) O(n*2^n) 02 迭代 O(n*2^n) O(n*2^n) 03 位运算 O(n*2^n) O(n*2^n) var res [][]int func subsets(nums []int) [][]int { res = make([][]int, 0) dfs(nums, make([]int, 0), 0) return res } func dfs(nums []int, arr []int, level int) { temp := make([]int, len(arr)) copy(temp, arr) res = append(res, temp) for i := level; i 79.单词搜索(2) 题目 给定一个二维网格和一个单词，找出该单词是否存在于网格中。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。 同一个单元格内的字母不允许被重复使用。 示例:board = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] 给定 word = \"ABCCED\", 返回 true 给定 word = \"SEE\", 返回 true 给定 word = \"ABCB\", 返回 false 提示： board 和 word 中只包含大写和小写英文字母。 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 深度优先搜索+回溯 O(n^2) O(n) 02 深度优先搜索+回溯+数组辅助 O(n^2) O(n^2) func exist(board [][]byte, word string) bool { for i := 0; i = len(board) || j = len(board[0]) || board[i][j] != word[level] { return false } if level == len(word)-1 { return true } temp := board[i][j] board[i][j] = ' ' res := dfs(board, i+1, j, word, level+1) || dfs(board, i-1, j, word, level+1) || dfs(board, i, j+1, word, level+1) || dfs(board, i, j-1, word, level+1) board[i][j] = temp return res } # func exist(board [][]byte, word string) bool { visited := make([][]bool, len(board)) for i := 0; i = 0 && i = 0 && j 80.删除排序数组中的重复项II(2) 题目 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1:给定 nums = [1,1,1,2,2,3], 函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 你不需要考虑数组中超出新长度后面的元素。 示例 2:给定 nums = [0,0,1,1,1,1,2,3,3], 函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。 你不需要考虑数组中超出新长度后面的元素。 说明:为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。 for (int i = 0; i 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n) O(1) 02 双指针 O(n) O(1) func removeDuplicates(nums []int) int { if len(nums) == 0 { return 0 } if len(nums) == 1 { return 1 } n := 2 i := n for j := n; j 81.搜索旋转排序数组II(2) 题目 假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。 编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。 示例 1:输入: nums = [2,5,6,0,0,1,2], target = 0 输出: true 示例 2:输入: nums = [2,5,6,0,0,1,2], target = 3 输出: false 进阶: 这是 搜索旋转排序数组 的延伸题目，本题中的 nums 可能包含重复元素。 这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 二分查找 O(log(n)) O(1) func search(nums []int, target int) bool { for i := 0; i 82.删除排序链表中的重复元素II(3) 题目 给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。 示例 1:输入: 1->2->3->3->4->4->5 输出: 1->2->5 示例 2:输入: 1->1->1->2->3 输出: 2->3 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 递归 O(n) O(n) 03 双指针 O(n) O(1) func deleteDuplicates(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } temp := &ListNode{Next: head} cur := temp value := 0 for cur.Next != nil && cur.Next.Next != nil { if cur.Next.Val == cur.Next.Next.Val { value = cur.Next.Val for cur.Next != nil && cur.Next.Val == value { cur.Next = cur.Next.Next } } else { cur = cur.Next } } return temp.Next } # func deleteDuplicates(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } flag := false for head.Next != nil && head.Val == head.Next.Val{ head = head.Next flag = true } head.Next = deleteDuplicates(head.Next) if flag{ return head.Next } return head } # func deleteDuplicates(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } flag := false for head.Next != nil && head.Val == head.Next.Val{ head = head.Next flag = true } head.Next = deleteDuplicates(head.Next) if flag{ return head.Next } return head } 86.分隔链表(2) 题目 给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。 你应当保留两个分区中每个节点的初始相对位置。 示例: 输入: head = 1->4->3->2->5->2, x = 3 输出: 1->2->2->4->3->5 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n) O(1) 02 数组辅助 O(n) O(n) func partition(head *ListNode, x int) *ListNode { first := &ListNode{} second := &ListNode{} a := first b := second for head != nil { if head.Val 89.格雷编码(2) 题目 格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。 给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。即使有多个不同答案，你也只需要返回其中一种。 格雷编码序列必须以 0 开头。 示例 1:输入: 2 输出: [0,1,3,2] 解释: 00 - 0 01 - 1 11 - 3 10 - 2 对于给定的 n，其格雷编码序列并不唯一。例如，[0,2,3,1] 也是一个有效的格雷编码序列。 00 - 0 10 - 2 11 - 3 01 - 1 示例 2:输入: 0 输出: [0] 解释: 我们定义格雷编码序列必须以 0 开头。 给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n = 0 时，长度为 20 = 1。 因此，当 n = 0 时，其格雷编码序列为 [0]。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历-推导 O(2^n) O(2^n) 02 公式 O(2^n) O(2^n) func grayCode(n int) []int { if n == 0 { return []int{0} } res := []int{0, 1} for i := 1; i = 0; j-- { // 10 1 11 // 10 0 10 // 100 10 110 // 100 11 111 // 100 1 101 // 100 0 100 // fmt.Printf(\"%b %b %b\\n\", value, res[j], res[j]^value) // temp = append(temp, res[j]|value) // temp = append(temp, res[j]^value) temp = append(temp, res[j]+value) } res = append(res, temp...) } return res } # 2 func grayCode(n int) []int { total := 1 >1)) } return res } 90.子集II(2) 题目 给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例:输入: [1,2,2] 输出: [ [2], [1], [1,2,2], [2,2], [1,2], [] ] 解题思路 No. 思路 时间复杂度 空间复杂度 01 回溯 O(n*2^n) O(n*2^n) 02 回溯 O(n*2^n) O(n*2^n) var res [][]int func subsetsWithDup(nums []int) [][]int { sort.Ints(nums) res = make([][]int, 0) dfs(nums, make([]int, 0), 0) return res } func dfs(nums []int, arr []int, level int) { temp := make([]int, len(arr)) copy(temp, arr) res = append(res, temp) for i := level; i level && nums[i] == nums[i-1] { continue } arr = append(arr, nums[i]) dfs(nums, arr, i+1) arr = arr[:len(arr)-1] } } # 2 var res [][]int func subsetsWithDup(nums []int) [][]int { sort.Ints(nums) res = make([][]int, 0) dfs(nums, make([]int, 0)) return res } func dfs(nums []int, arr []int) { temp := make([]int, len(arr)) copy(temp, arr) res = append(res, temp) for i := 0; i 0 && nums[i] == nums[i-1] { continue } arr = append(arr, nums[i]) dfs(nums[i+1:], arr) arr = arr[:len(arr)-1] } } 91.解码方法(3) 题目 一条包含字母 A-Z 的消息通过以下方式进行了编码： 'A' -> 1 'B' -> 2 ... 'Z' -> 26 给定一个只包含数字的非空字符串，请计算解码方法的总数。 示例 1:输入: \"12\" 输出: 2 解释: 它可以解码为 \"AB\"（1 2）或者 \"L\"（12）。 示例 2:输入: \"226\" 输出: 3 解释: 它可以解码为 \"BZ\" (2 26), \"VF\" (22 6), 或者 \"BBF\" (2 2 6) 。 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n) O(1) 02 动态规划 O(n) O(n) 03 递归 O(n) O(n) func numDecodings(s string) int { if s[0] == '0' { return 0 } pre := 1 cur := 1 for i := 1; i = '1' && s[i] 0 && (s[i-1] == '2' && s[i] >= '1' && s[i] 0 { return m[s] } if len(s) == 0 { return 1 } if s[0] == '0' { return 0 } if len(s) == 1 { return 1 } if (s[0]-'0')*10+s[1]-'0' > 26 { return dfs(s[1:]) } m[s] = dfs(s[1:]) + dfs(s[2:]) return m[s] } 92.反转链表II(2) 题目 反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。 说明: 1 ≤ m ≤ n ≤ 链表长度。 示例:输入: 1->2->3->4->5->NULL, m = 2, n = 4 输出: 1->4->3->2->5->NULL 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 递归 O(n) O(n) func reverseBetween(head *ListNode, m int, n int) *ListNode { if m == n || head == nil { return head } temp := &ListNode{Next: head} prev := temp for i := 1; i 93.复原IP地址(2) 题目 给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。 有效的 IP 地址正好由四个整数（每个整数位于 0 到 255 之间组成），整数之间用 '.' 分隔。 示例:输入: \"25525511135\" 输出: [\"255.255.11.135\", \"255.255.111.35\"] 解题思路 No. 思路 时间复杂度 空间复杂度 01 回溯 O(1) O(1) 02 暴力法 O(1) O(1) func dfs(s string, arr []string, level int) { if level == 4 { if len(s) == 0 { str := strings.Join(arr, \".\") res = append(res, str) } return } for i := 1; i 12 { return nil } for i := 1; i 1 && s[0] == '0' { return false } value, _ := strconv.Atoi(s) if value > 255 { return false } return true } 94.二叉树的中序遍历(3) 题目 给定一个二叉树，返回它的中序 遍历。 示例:输入: [1,null,2,3] 1 \\ 2 / 3 输出: [1,3,2] 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(n) 02 迭代 O(n) O(n) 03 递归 O(n) O(n) func inorderTraversal(root *TreeNode) []int { if root == nil { return nil } left := inorderTraversal(root.Left) right := inorderTraversal(root.Right) res := left res = append(res, root.Val) res = append(res, right...) return res } # 2 func inorderTraversal(root *TreeNode) []int { if root == nil { return nil } stack := make([]*TreeNode, 0) res := make([]int, 0) for len(stack) > 0 || root != nil { for root != nil { stack = append(stack, root) root = root.Left } last := len(stack) - 1 res = append(res, stack[last].Val) root = stack[last].Right stack = stack[:last] } return res } # 3 var res []int func inorderTraversal(root *TreeNode) []int { res = make([]int, 0) dfs(root) return res } func dfs(root *TreeNode) { if root != nil { dfs(root.Left) res = append(res, root.Val) dfs(root.Right) } } 95.不同的二叉搜索树II(2) 题目 给定一个整数 n，生成所有由 1 ... n 为节点所组成的 二叉搜索树 。 示例：输入：3 输出： [ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3] ] 解释：以上的输出对应以下 5 种不同结构的二叉搜索树： 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 提示： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(C(2n,n)/(n+1)) O(n) 02 动态规划 O(C(2n,n)/(n+1)) O(n^2) func generateTrees(n int) []*TreeNode { if n == 0 { return nil } return dfs(1, n) } func dfs(left, right int) []*TreeNode { if left > right { return []*TreeNode{nil} } if left == right { return []*TreeNode{ &TreeNode{Val: left}, } } arr := make([]*TreeNode, 0) for i := left; i 96.不同的二叉搜索树(3) 题目 给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？ 示例:输入: 3 输出: 5 解释: 给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n^2) O(n) 02 公式 ) O(1) 03 公式 O(n) O(1) func numTrees(n int) int { dp := make([]int, n+1) dp[0] =1 dp[1] =1 for i := 2; i 98.验证二叉搜索树(5) 题目 给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1:输入: 2 / \\ 1 3 输出: true 示例 2:输入: 5 / \\ 1 4 / \\ 3 6 输出: false 解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 递归 O(n) O(n) 03 迭代 O(n) O(n) 04 迭代 O(n) O(n) 05 递归 O(n) O(log(n)) func isValidBST(root *TreeNode) bool { return dfs(root, math.MinInt64, math.MaxInt64) } func dfs(root *TreeNode, left, right int) bool { if root == nil { return true } if left >= root.Val || right = res[i+1] { return false } } return true } func dfs(root *TreeNode) { if root != nil { dfs(root.Left) res = append(res, root.Val) dfs(root.Right) } } # 3 func isValidBST(root *TreeNode) bool { if root == nil { return true } stack := make([]*TreeNode, 0) res := make([]int, 0) for len(stack) > 0 || root != nil { for root != nil { stack = append(stack, root) root = root.Left } last := len(stack) - 1 res = append(res, stack[last].Val) root = stack[last].Right stack = stack[:last] } for i := 0; i = res[i+1] { return false } } return true } # 4 func isValidBST(root *TreeNode) bool { if root == nil { return true } stack := make([]*TreeNode, 0) pre := math.MinInt64 for len(stack) > 0 || root != nil { for root != nil { stack = append(stack, root) root = root.Left } last := len(stack) - 1 if stack[last].Val 0001-1000-Hard 4.寻找两个正序数组的中位数(4) 题目 给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。 请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 示例 1:nums1 = [1, 3] nums2 = [2] 则中位数是 2.0 示例 2:nums1 = [1, 2] nums2 = [3, 4] 则中位数是 (2 + 3)/2 = 2.5 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序 O(nlog(n)) O(n) 02 二分查找 O(log(n)) O(1) 03 遍历 O(n) O(1) 04 二分查找 O(log(n)) O(1) func findMedianSortedArrays(nums1 []int, nums2 []int) float64 { nums1 = append(nums1, nums2...) sort.Ints(nums1) if len(nums1)%2 == 1 { return float64(nums1[len(nums1)/2]) } return float64(nums1[len(nums1)/2]+nums1[len(nums1)/2-1]) / 2 } # 2 func findMedianSortedArrays(nums1 []int, nums2 []int) float64 { total := len(nums1) + len(nums2) if total%2 == 1 { mid := total / 2 return float64(getKth(nums1, nums2, mid+1)) } mid1, mid2 := total/2-1, total/2 return float64(getKth(nums1, nums2, mid1+1)+getKth(nums1, nums2, mid2+1)) / 2.0 } func getKth(nums1 []int, nums2 []int, k int) int { a, b := 0, 0 for { if a == len(nums1) { return nums2[b+k-1] } if b == len(nums2) { return nums1[a+k-1] } if k == 1 { return min(nums1[a], nums2[b]) } mid := k / 2 newA := min(a+mid, len(nums1)) - 1 newB := min(b+mid, len(nums2)) - 1 valueA, valueB := nums1[newA], nums2[newB] if valueA b { return b } return a } # 3 func findMedianSortedArrays(nums1 []int, nums2 []int) float64 { total := len(nums1) + len(nums2) a, b := total/2, (total-1)/2 count := 0 res := 0 for i, j := 0, 0; i m { return findMedianSortedArrays(nums2, nums1) } left, right := 0, n a, b := 0, 0 for left max(A[i-1],B[j-1])) b=>min(A[i],B[j])) // 奇数求a=>max(A[i-1],B[j-1])) if j != 0 && i != n && nums1[i] nums2[j] { right = i - 1 } else { if i == 0 { a = nums2[j-1] } else if j == 0 { a = nums1[i-1] } else { a = max(nums1[i-1], nums2[j-1]) } if (n+m)%2 == 1 { return float64(a) } if i == n { b = nums2[j] } else if j == m { b = nums1[i] } else { b = min(nums1[i], nums2[j]) } return float64(a+b) / 2.0 } } return 0.0 } func max(a, b int) int { if a > b { return a } return b } func min(a, b int) int { if a > b { return b } return a } 10.正则表达式匹配(3) 题目 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。 '.' 匹配任意单个字符 '*' 匹配零个或多个前面的那一个元素 所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。 说明: s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。 示例 1:输入:s = \"aa\" p = \"a\" 输出: false 解释: \"a\" 无法匹配 \"aa\" 整个字符串。 示例 2:输入: s = \"aa\" p = \"a*\" 输出: true 解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。 因此，字符串 \"aa\" 可被视为 'a' 重复了一次。 示例 3:输入: s = \"ab\" p = \".*\" 输出: true 解释: \".*\" 表示可匹配零个或多个（'*'）任意字符（'.'）。 示例 4:输入:s = \"aab\"p = \"c*a*b\" 输出: true 解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 \"aab\"。 示例 5:输入:s = \"mississippi\"p = \"mis*is*p*.\" 输出: false 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(n) 02 动态规划 O(n^2) O(n^2) 03 递归 O(n) O(n) func isMatch(s string, p string) bool { return dfs(s, p, 0, 0) } func dfs(s string, p string, i, j int) bool { if i >= len(s) && j >= len(p) { return true } if i = len(p) { return false } if j+1 1 { if p[i-2] == s[j-1] || p[i-2] == '.' { dp[i][j] = dp[i][j-1] || dp[i-2][j-1] || dp[i-2][j] } else { dp[i][j] = dp[i-2][j] } } } } } return dp[len(p)][len(s)] } # 3 func isMatch(s string, p string) bool { if len(s) == 0 && len(p) == 0 { return true } else if len(p) == 0 { return false } match := false // 正常匹配条件=>相等，或者 p[0]等于.就不用管s[0] if len(s) > 0 && (s[0] == p[0] || p[0] == '.') { match = true } // 匹配多个 就把 s 往后移1位，注意p不移动 // 匹配0个 就把 p 往后移2位，相当于p的*当前作废 if len(p) > 1 && p[1] == '*' { return (match && isMatch(s[1:], p)) || isMatch(s, p[2:]) } // 匹配当前成功，同时往后移 return match && isMatch(s[1:], p[1:]) } 23.合并K个排序链表(4) 题目 合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。 示例:输入: [ 1->4->5, 1->3->4, 2->6 ] 输出: 1->1->2->3->4->4->5->6 解题思路 No. 思路 时间复杂度 空间复杂度 01 顺序合并 O(n^2) O(1) 02 归并(分治)合并 O(nlog(n)) O(log(n)) 03 堆辅助 O(nlog(n)) O(log(n)) 04 自定义排序 O(nlog(n)) O(n) func mergeKLists(lists []*ListNode) *ListNode { if len(lists) == 0 { return nil } temp := &ListNode{} for i := 0; i 0 { minItem := heap.Pop(&h).(*ListNode) temp.Next = minItem temp = temp.Next if minItem.Next != nil { heap.Push(&h, minItem.Next) } } return res.Next } type IntHeap []*ListNode func (h IntHeap) Len() int { return len(h) } func (h IntHeap) Less(i, j int) bool { return h[i].Val 25.K个一组翻转链表(4) 题目 给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。 如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。 示例： 给你这个链表：1->2->3->4->5 当 k = 2 时，应当返回: 2->1->4->3->5 当 k = 3 时，应当返回: 3->2->1->4->5 说明： 你的算法只能使用常数的额外空间。 你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(n) 02 递归 O(n) O(n) 03 遍历 O(n) O(1) 04 遍历 O(n) O(1) func reverseKGroup(head *ListNode, k int) *ListNode { length := getLength(head) if length 30.串联所有单词的子串(2) 题目 给定一个字符串 s 和一些长度相同的单词 words。 找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。 注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。 示例 1：输入：s = \"barfoothefoobarman\",words = [\"foo\",\"bar\"] 输出：[0,9] 解释：从索引 0 和 9 开始的子串分别是 \"barfoo\" 和 \"foobar\" 。 输出的顺序不重要, [9,0] 也是有效答案。 示例 2：输入：s = \"wordgoodgoodgoodbestword\",words = [\"word\",\"good\",\"best\",\"word\"]输出：[] 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n^2) O(n) 02 滑动窗口 O(n^2) O(n) func findSubstring(s string, words []string) []int { res := make([]int, 0) length,n := len(s),len(words) if length == 0 || n == 0 || len(words[0]) == 0 { return res } single := len(words[0]) m := make(map[string]int) for i := 0; i m[str] { break } if compare(m, temp) == true { res = append(res, i) break } } } return res } func compare(m1, m2 map[string]int) bool { if len(m1) != len(m2) { return false } for k, v := range m1 { if m2[k] != v { return false } } return true } # 2 func findSubstring(s string, words []string) []int { res := make([]int, 0) length := len(s) n := len(words) if length == 0 || n == 0 || len(words[0]) == 0 { return res } single := len(words[0]) m := make(map[string]int) for i := 0; i 0 { temp[str]++ if temp[str] == m[str] { count++ } } if right-left == n*single { if count == len(m) { res = append(res, left) } leftStr := s[left : left+single] left = left + single if m[leftStr] > 0 { if temp[leftStr] == m[leftStr] { count-- } temp[leftStr]-- } } } } return res } 32.最长有效括号(4) 题目 给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。 示例 1:输入: \"(()\"输出: 2 解释: 最长有效括号子串为 \"()\" 示例 2:输入: \")()())\" 输出: 4 解释: 最长有效括号子串为 \"()()\" 解题思路 No. 思路 时间复杂度 空间复杂度 01 栈辅助 O(n) O(n) 02 动态规划 O(n) O(n) 03 遍历 O(n) O(1) 04 暴力法 O(n^2) O(1) func longestValidParentheses(s string) int { res := 0 stack := make([]int, 0) stack = append(stack, -1) for i := 0; i b { return a } return b } # 2 func longestValidParentheses(s string) int { res := 0 dp := make([]int, len(s)) for i := 1; i 0 && s[i-dp[i-1]-1] == '(' { if i-dp[i-1] b { return a } return b } # 3 func longestValidParentheses(s string) int { res := 0 left, right := 0, 0 for i := 0; i left { left, right = 0, 0 } } left, right = 0, 0 for i := len(s) - 1; i >= 0; i-- { if s[i] == '(' { left++ } else { right++ } if left == right { res = max(res, 2*left) } else if left > right { left, right = 0, 0 } } return res } func max(a, b int) int { if a > b { return a } return b } # 4 func longestValidParentheses(s string) int { res := 0 for i := 0; i b { return a } return b } 37.解数独(2) 题目 编写一个程序，通过已填充的空格来解决数独问题。 一个数独的解法需遵循如下规则： 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 空白格用 '.' 表示。 一个数独。 答案被标成红色。 Note:给定的数独序列只包含数字 1-9 和字符 '.' 。 你可以假设给定的数独只有唯一解。 给定数独永远是 9x9 形式的。 解题思路 No. 思路 时间复杂度 空间复杂度 01 回溯 O((9!)^9) O(1) 02 回溯 O((9!)^9) O(1) var rows, cols, arrs [9][9]int func solveSudoku(board [][]byte) { rows = [9][9]int{} cols = [9][9]int{} arrs = [9][9]int{} for i := 0; i 41.缺失的第一个正数(5) 题目 给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。 示例 1:输入: [1,2,0] 输出: 3 示例 2:输入: [3,4,-1,1]输出: 2 示例 3:输入: [7,8,9,11,12]输出: 1 提示：你的算法的时间复杂度应为O(n)，并且只能使用常数级别的额外空间。 解题思路 No. 思路 时间复杂度 空间复杂度 01 标负 O(n) O(1) 02 置换 O(n) O(1) 03 哈希辅助 O(n) O(n) 04 暴力法 O(n^2) O(1) 05 桶 O(n) O(n) func firstMissingPositive(nums []int) int { n := len(nums) for i := 0; i 0 { return i + 1 } } return n + 1 } func abs(a int) int { if a >= 0 { return a } return -a } # 2 func firstMissingPositive(nums []int) int { n := len(nums) for i := 0; i 0 && nums[i] 42.接雨水(4) 题目 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图， 在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。 示例:输入: [0,1,0,2,1,0,1,3,2,1,2,1]输出: 6 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法 O(n^2) O(1) 02 数组辅助 O(n) O(n) 03 栈辅助 O(n) O(n) 04 双指针 O(n) O(1) func trap(height []int) int { res := 0 for i := 0; i = 0; j-- { left = max(left, height[j]) } for j := i; j b { return a } return b } func min(a, b int) int { if a > b { return b } return a } # 2 func trap(height []int) int { res := 0 if len(height) == 0{ return 0 } left := make([]int, len(height)) right := make([]int, len(height)) left[0] = height[0] right[len(right)-1] = height[len(height)-1] for i := 1; i = 0; i-- { right[i] = max(height[i], right[i+1]) } for i := 0; i b { return a } return b } func min(a, b int) int { if a > b { return b } return a } # 3 func trap(height []int) int { res := 0 stack := make([]int, 0) for i := 0; i 0 && height[i] > height[stack[len(stack)-1]] { bottom := height[stack[len(stack)-1]] stack = stack[:len(stack)-1] if len(stack) > 0 { prev := stack[len(stack)-1] // 横着的面积=长(min(height[i], height[prev])-bottom)*宽(i-prev-1) h := min(height[i], height[prev]) - bottom w := i - prev - 1 area := h * w res = res + area } } stack = append(stack, i) } return res } func min(a, b int) int { if a > b { return b } return a } # 4 func trap(height []int) int { res := 0 if len(height) == 0 { return 0 } left := 0 right := len(height) - 1 leftMax := 0 // 左边的最大值 rightMax := 0 // 右边的最大值 for left = leftMax { // 递增无法蓄水 leftMax = height[left] } else { res = res + leftMax - height[left] } left++ } else { // 也可以写成这样 // rightMax = max(rightMax, height[right]) // res = res + rightMax - height[right] if height[right] >= rightMax { // 递减无法蓄水 rightMax = height[right] } else { res = res + rightMax - height[right] } right-- } } return res } 44.通配符匹配(3) 题目 给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配。 '?' 可以匹配任何单个字符。 '*' 可以匹配任意字符串（包括空字符串）。 两个字符串完全匹配才算匹配成功。 说明:s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。 示例 1: 输入:s = \"aa\" p = \"a\" 输出: false 解释: \"a\" 无法匹配 \"aa\" 整个字符串。 示例 2: 输入: s = \"aa\" p = \"*\" 输出: true 解释: '*' 可以匹配任意字符串。 示例 3:输入: s = \"cb\" p = \"?a\" 输出: false 解释: '?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。 示例 4:输入:s = \"adceb\" p = \"*a*b\" 输出: true 解释: 第一个 '*' 可以匹配空字符串, 第二个 '*' 可以匹配字符串 \"dce\". 示例 5:输入:s = \"acdcb\" p = \"a*c?b\" 输出: false 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n^2) O(n^2) 02 递归 O(n^2) O(n^2) 03 贪心 O(n^2) O(1) func isMatch(s string, p string) bool { n, m := len(s), len(p) dp := make([][]bool, n+1) for i := 0; i 不使用这个*，dp[i-1][j]=>使用这个* dp[i][j] = dp[i][j-1] || dp[i-1][j] } else if p[j-1] == '?' || s[i-1] == p[j-1] { dp[i][j] = dp[i-1][j-1] } } } return dp[n][m] } # 2 var dp [][]int func isMatch(s string, p string) bool { n, m := len(s), len(p) dp = make([][]int, n+1) for i := 0; i 0 { if dp[i][j] == 1 { return false } else { return true } } if i >= len(s) { return p[j] == '*' && dfs(s, p, i, j+1) } if j >= len(p) { return false } res := false if p[j] == '*' { res = dfs(s, p, i+1, j) || dfs(s, p, i, j+1) } else { res = (s[i] == p[j] || p[j] == '?') && dfs(s, p, i+1, j+1) } if res == true { dp[i][j] = 2 } else { dp[i][j] = 1 } return res } # 3 func isMatch(s string, p string) bool { i, j := 0, 0 start, last := 0, 0 for i = 0; i 45.跳跃游戏II(4) 题目 给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 你的目标是使用最少的跳跃次数到达数组的最后一个位置。 示例:输入: [2,3,1,1,4] 输出: 2 解释: 跳到最后一个位置的最小跳跃数是 2。 从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。 说明:假设你总是可以到达数组的最后一个位置。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n^2) O(1) 02 遍历 O(n) O(1) 03 动态规划 O(n^2) O(n) 04 迭代 O(n^2) O(n) func jump(nums []int) int { last := len(nums) - 1 res := 0 for last > 0 { // 从前往后，找到第一个一步能走到终点的，更新终点的位置 for i := 0; i = last { last = i res++ break } } } return res } # 2 func jump(nums []int) int { res := 0 end := 0 maxValue := 0 for i := 0; i b { return a } return b } # 3 func jump(nums []int) int { dp := make([]int, len(nums)) dp[0] = 0 for i := 1; i = i { dp[i] = min(dp[i], dp[j]+1) } } } return dp[len(nums)-1] } func min(a, b int) int { if a > b { return b } return a } # 4 func jump(nums []int) int { if len(nums) = len(nums)-1 { return dp[i] + 1 } for j := i + 1; j b { return b } return a } # 4 func jump(nums []int) int { if len(nums) = len(nums)-1 { return arr[i] + 1 } for j := i + 1; j b { return b } return a } 51.N皇后(3) 题目 n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 上图为 8 皇后问题的一种解法。 给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。 每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。 示例: 输入: 4 输出: [ [\".Q..\", // 解法 1 \"...Q\", \"Q...\", \"..Q.\"], [\"..Q.\", // 解法 2 \"Q...\", \"...Q\", \".Q..\"] ] 解释: 4皇后问题存在两个不同的解法。 提示： 皇后，是国际象棋中的棋子，意味着国王的妻子。皇后只做一件事，那就是“吃子”。 当她遇见可以吃的棋子时，就迅速冲上去吃掉棋子。当然，她横、竖、斜都可走一到七步，可进可退。 解题思路 No. 思路 时间复杂度 空间复杂度 01 回溯 O(n^n) O(n^2) 02 回溯 O(n^n) O(n^2) 03 回溯 O(n^n) O(n^2) var res [][]string func solveNQueens(n int) [][]string { res = make([][]string, 0) // 初始化棋盘 arr := make([][]string, n) for i := 0; i = 0 && col >= 0; row, col = row-1, col-1 { if arr[row][col] == \"Q\" { return false } } // 右上角 for row, col := row-1, col+1; row >= 0 && col >a)&1) != 0 || ((left>>b)&1) != 0 || ((right>>c)&1) != 0 { continue } arr[row][col] = \"Q\" dfs(arr, row+1, rows^(1 52.N皇后II(3) 题目 n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 上图为 8 皇后问题的一种解法。 给定一个整数 n，返回 n 皇后不同的解决方案的数量。 示例:输入: 4 输出: 2 解释: 4 皇后问题存在如下两个不同的解法。 [ [\".Q..\", // 解法 1 \"...Q\", \"Q...\", \"..Q.\"], [\"..Q.\", // 解法 2 \"Q...\", \"...Q\", \".Q..\"] ] 提示：皇后，是国际象棋中的棋子，意味着国王的妻子。皇后只做一件事，那就是“吃子”。 当她遇见可以吃的棋子时，就迅速冲上去吃掉棋子。当然，她横、竖、斜都可走一或 N-1 步，可进可退。 解题思路 No. 思路 时间复杂度 空间复杂度 01 回溯 O(n^n) O(n^2) 02 回溯 O(n^n) O(n^2) 03 回溯-位运算 O(n^n) O(n) var res int var rows, left, right []bool func totalNQueens(n int) int { res = 0 rows, left, right = make([]bool, n), make([]bool, 2*n-1), make([]bool, 2*n-1) // 初始化棋盘 arr := make([][]string, n) for i := 0; i = 0 && col >= 0; row, col = row-1, col-1 { if arr[row][col] == \"Q\" { return false } } // 右上角 for row, col := row-1, col+1; row >= 0 && col >a)&1) != 0 || ((left>>b)&1) != 0 || ((right>>c)&1) != 0 { continue } dfs(row+1, n, rows^(1 57.插入区间(3) 题目 给出一个无重叠的 ，按照区间起始端点排序的区间列表。 在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。 示例 1： 输入：intervals = [[1,3],[6,9]], newInterval = [2,5] 输出：[[1,5],[6,9]] 示例 2： 输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] 输出：[[1,2],[3,10],[12,16]] 解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。 注意：输入类型已在 2019 年 4 月 15 日更改。请重置为默认代码定义以获取新的方法签名。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(n) 02 遍历 O(n) O(n) 03 排序遍历 O(nlog(n)) O(n) func insert(intervals [][]int, newInterval []int) [][]int { res := make([][]int, 0) if len(intervals) == 0 { res = append(res, newInterval) return res } i := 0 for ; i b { return b } return a } func max(a, b int) int { if a > b { return a } return b } # 2 func insert(intervals [][]int, newInterval []int) [][]int { if len(intervals) == 0 { return [][]int{newInterval} } i := 0 for ; i = 0 && intervals[i][0] > newInterval[1]; i-- { } right := i if left > right { return append(intervals[:left], append([][]int{newInterval}, intervals[left:]...)...) } newInterval[0] = min(newInterval[0], intervals[left][0]) newInterval[1] = max(newInterval[1], intervals[right][1]) return append(intervals[:left], append([][]int{newInterval}, intervals[right+1:]...)...) } func min(a, b int) int { if a > b { return b } return a } func max(a, b int) int { if a > b { return a } return b } # 3 func insert(intervals [][]int, newInterval []int) [][]int { res := make([][]int, 0) intervals = append(intervals, newInterval) sort.Slice(intervals, func(i, j int) bool { return intervals[i][0] arr[1] { res = append(res, intervals[i]) } else if intervals[i][1] > arr[1] { res[len(res)-1][1] = intervals[i][1] } } return res } 65.有效数字(1) 题目 验证给定的字符串是否可以解释为十进制数字。 例如: \"0\" => true \" 0.1 \" => true \"abc\" => false \"1 a\" => false \"2e10\" => true \" -90e3 \" => true \" 1e\" => false \"e3\" => false \" 6e-1\" => true \" 99e2.5 \" => false \"53.5e93\" => true \" --6 \" => false \"-+3\" => false \"95a54e53\" => false 说明: 我们有意将问题陈述地比较模糊。在实现代码之前，你应当事先思考所有可能的情况。 这里给出一份可能存在于有效十进制数字中的字符列表： 数字 0-9 指数 - \"e\" 正/负号 - \"+\"/\"-\" 小数点 - \".\" 当然，在输入中，这些字符的上下文也很重要。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(n) func isNumber(s string) bool { s = strings.Trim(s, \" \") if s == \"\" || len(s) == 0 || len(s) == 0 { return false } arr := []byte(s) i := 0 numeric := scanInteger(&arr, &i) if i '9' { break } *index++ } return j 68.文本左右对齐(1) 题目 给定一个单词数组和一个长度 maxWidth，重新排版单词，使其成为每行恰好有 maxWidth 个字符， 且左右两端对齐的文本。 你应该使用“贪心算法”来放置给定的单词；也就是说，尽可能多地往每行中放置单词。 必要时可用空格 ' ' 填充，使得每行恰好有 maxWidth 个字符。 要求尽可能均匀分配单词间的空格数量。 如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。 文本的最后一行应为左对齐，且单词之间不插入额外的空格。 说明:单词是指由非空格字符组成的字符序列。 每个单词的长度大于 0，小于等于 maxWidth。 输入单词数组 words 至少包含一个单词。 示例:输入: words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"] maxWidth = 16 输出: [ \"This is an\", \"example of text\", \"justification. \" ] 示例 2:输入: words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"] maxWidth = 16 输出: [ \"What must be\", \"acknowledgment \", \"shall be \" ] 解释: 注意最后一行的格式应为 \"shall be \" 而不是 \"shall be\", 因为最后一行应为左对齐，而不是左右两端对齐。 第二行同样为左对齐，这是因为这行只包含一个单词。 示例 3: 输入:words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\", \"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"] maxWidth = 20 输出: [ \"Science is what we\", \"understand well\", \"enough to explain to\", \"a computer. Art is\", \"everything else we\", \"do \" ] 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历模拟 O(n) O(n) func fullJustify(words []string, maxWidth int) []string { res := make([]string, 0) count := 0 start := 0 for i := 0; i maxWidth { temp := justify(words, start, i-1, maxWidth) res = append(res, temp) start = i if i == len(words)-1 { count = 0 i-- } else { count = len(words[i]) + 1 } } else if i == len(words)-1 { temp := justify(words, start, i, maxWidth) res = append(res, temp) } else { count++ } } return res } func justify(words []string, start, end int, maxWidth int) string { arr := make([]byte, maxWidth) for i := 0; i 0 { index++ mod-- } } } return string(arr) } 72.编辑距离(2) 题目 给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 插入一个字符 删除一个字符 替换一个字符 示例 1：输入：word1 = \"horse\", word2 = \"ros\" 输出：3 解释：horse -> rorse (将 'h' 替换为 'r') rorse -> rose (删除 'r') rose -> ros (删除 'e') 示例 2：输入：word1 = \"intention\", word2 = \"execution\" 输出：5 解释： intention -> inention (删除 't') inention -> enention (将 'i' 替换为 'e') enention -> exention (将 'n' 替换为 'x') exention -> exection (将 'n' 替换为 'c') exection -> execution (插入 'u') 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n^2) O(n^2) 02 递归 O(n^2) O(n^2) func minDistance(word1 string, word2 string) int { n1 := len(word1) n2 := len(word2) // dp[i][j]代表 word1的i位置转换成word2的j位置需要最少步数 dp := make([][]int, n1+1) for i := 0; i b { return b } return a } # 2 var dp [][]int func minDistance(word1 string, word2 string) int { dp = make([][]int, len(word1)+1) for i := 0; i 0 { return dp[i][j] } if i == len(word1) || j == len(word2) { return len(word1) - i + len(word2) - j } if word1[i] == word2[j] { return helper(word1, word2, i+1, j+1) } inserted := helper(word1, word2, i, j+1) deleted := helper(word1, word2, i+1, j) replaced := helper(word1, word2, i+1, j+1) dp[i][j] = min(inserted, min(deleted, replaced)) + 1 return dp[i][j] } func min(a, b int) int { if a > b { return b } return a } 76.最小覆盖子串(2) 题目 给你一个字符串 S、一个字符串 T 。 请你设计一种算法，可以在 O(n) 的时间复杂度内，从字符串 S 里面找出：包含 T 所有字符的最小子串。 示例：输入：S = \"ADOBECODEBANC\", T = \"ABC\" 输出：\"BANC\" 提示：如果 S 中不存这样的子串，则返回空字符串 \"\"。 如果 S 中存在这样的子串，我们保证它是唯一的答案。 解题思路 No. 思路 时间复杂度 空间复杂度 01 滑动窗口 O(n^2) O(n) 02 滑动窗口 O(n) O(n) func minWindow(s string, t string) string { if len(s) 0 { window[s[r]]++ } // 找到，然后left往右移 for check(need, window) == true && l = 0 { count++ } // left往右边移动 for count == len(t) { if minLength > r-l+1 { minLength = r - l + 1 res = s[l : r+1] } arr[s[l]]++ if arr[s[l]] > 0 { count-- } l++ } } return res } 84.柱状图中最大的矩形(5) 题目 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。 求在该柱状图中，能够勾勒出来的矩形的最大面积。 以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。 图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。 示例:输入: [2,1,5,6,2,3]输出: 10 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法 O(n^2) O(1) 02 暴力法 O(n^2) O(1) 03 单调栈 O(n) O(n) 04 单调栈 O(n) O(n) 05 单调栈 O(n) O(n) func largestRectangleArea(heights []int) int { n := len(heights) res := 0 for i := 0; i b { return a } return b } func min(a, b int) int { if a > b { return b } return a } # 2 func largestRectangleArea(heights []int) int { n := len(heights) res := 0 for i := 0; i 0 && heights[left-1] >= height { left-- } for right = height { right++ } width := right - left + 1 res = max(res, width*height) } return res } func max(a, b int) int { if a > b { return a } return b } # 3 func largestRectangleArea(heights []int) int { n := len(heights) res := 0 left := make([]int, n) right := make([]int, n) stack := make([]int, 0) for i := 0; i 0 && heights[stack[len(stack)-1]] >= heights[i] { stack = stack[:len(stack)-1] } if len(stack) == 0 { left[i] = -1 } else { left[i] = stack[len(stack)-1] } stack = append(stack, i) } stack = make([]int, 0) for i := n - 1; i >= 0; i-- { for len(stack) > 0 && heights[stack[len(stack)-1]] >= heights[i] { stack = stack[:len(stack)-1] } if len(stack) == 0 { right[i] = n } else { right[i] = stack[len(stack)-1] } stack = append(stack, i) } for i := 0; i b { return a } return b } # 4 func largestRectangleArea(heights []int) int { n := len(heights) res := 0 left := make([]int, n) right := make([]int, n) stack := make([]int, 0) for i := 0; i 0 && heights[stack[len(stack)-1]] >= heights[i] { right[stack[len(stack)-1]] = i stack = stack[:len(stack)-1] } if len(stack) == 0 { left[i] = -1 } else { left[i] = stack[len(stack)-1] } stack = append(stack, i) } for i := 0; i b { return a } return b } # 5 func largestRectangleArea(heights []int) int { heights = append([]int{0}, heights...) heights = append(heights, 0) n := len(heights) res := 0 stack := make([]int, 0) for i := 0; i 0 && heights[stack[len(stack)-1]] > heights[i] { height := heights[stack[len(stack)-1]] stack = stack[:len(stack)-1] width := i - stack[len(stack)-1] - 1 res = max(res, height*width) } stack = append(stack, i) } return res } func max(a, b int) int { if a > b { return a } return b } 85.最大矩形(2) 题目 给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。 示例:输入: [ [\"1\",\"0\",\"1\",\"0\",\"0\"], [\"1\",\"0\",\"1\",\"1\",\"1\"], [\"1\",\"1\",\"1\",\"1\",\"1\"], [\"1\",\"0\",\"0\",\"1\",\"0\"] ] 输出: 6 解题思路 No. 思路 时间复杂度 空间复杂度 01 单调栈 O(n^2) O(n) 02 动态规划 O(n^2) O(n) func maximalRectangle(matrix [][]byte) int { if len(matrix) == 0 || len(matrix[0]) == 0 { return 0 } res := 0 n, m := len(matrix), len(matrix[0]) height := make([]int, m) // 高度 for i := 0; i 0 && heights[stack[len(stack)-1]] > heights[i] { height := heights[stack[len(stack)-1]] stack = stack[:len(stack)-1] width := i - stack[len(stack)-1] - 1 res = max(res, height*width) } stack = append(stack, i) } return res } func max(a, b int) int { if a > b { return a } return b } # 2 func maximalRectangle(matrix [][]byte) int { if len(matrix) == 0 || len(matrix[0]) == 0 { return 0 } res := 0 n, m := len(matrix), len(matrix[0]) left, right, height := make([]int, m), make([]int, m), make([]int, m) for i := 0; i = 0; j-- { if matrix[i][j] == '1' { right[j] = min(right[j], curRight) } else { right[j] = m curRight = j } } for j := 0; j b { return a } return b } func min(a, b int) int { if a > b { return b } return a } 87.扰乱字符串(2) 题目 给定一个字符串 s1，我们可以把它递归地分割成两个非空子字符串，从而将其表示为二叉树。 下图是字符串 s1 = \"great\" 的一种可能的表示形式。 great / \\ gr eat / \\ / \\ g r e at / \\ a t 在扰乱这个字符串的过程中，我们可以挑选任何一个非叶节点，然后交换它的两个子节点。 例如，如果我们挑选非叶节点 \"gr\" ，交换它的两个子节点，将会产生扰乱字符串 \"rgeat\" 。 rgeat / \\ rg eat / \\ / \\ r g e at / \\ a t 我们将 \"rgeat” 称作 \"great\" 的一个扰乱字符串。 同样地，如果我们继续交换节点 \"eat\" 和 \"at\" 的子节点，将会产生另一个新的扰乱字符串 \"rgtae\" 。 rgtae / \\ rg tae / \\ / \\ r g ta e / \\ t a 我们将 \"rgtae” 称作 \"great\" 的一个扰乱字符串。 给出两个长度相等的字符串 s1 和 s2，判断 s2 是否是 s1 的扰乱字符串。 示例 1:输入: s1 = \"great\", s2 = \"rgeat\" 输出: true 示例 2:输入: s1 = \"abcde\", s2 = \"caebd\" 输出: false 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n^4) O(n^3) 02 递归 O(5^n) O(n) func isScramble(s1 string, s2 string) bool { n, m := len(s1), len(s2) if n != m { return false } // dp[i][j][l]:表示s1从i开始，s2从j开始长度为l的两个子字符串是扰乱 dp := make([][][]bool, n+1) for i := 0; i T1, S2->T2 // 划分交换： S1->T2, S2->T1 if (dp[i][j][w] == true && dp[i+w][j+w][k-w] == true) || (dp[i][j+k-w][w] == true && dp[i+w][j][k-w] == true) { dp[i][j][k] = true } } } } } return dp[0][0][n] } # 2 func isScramble(s1 string, s2 string) bool { return dfs([]byte(s1), []byte(s2)) } func dfs(arr1, arr2 []byte) bool { if compare(arr1, arr2) == false { return false } if len(arr1) 97.交错字符串(3) 题目 给定三个字符串 s1, s2, s3, 验证 s3 是否是由 s1 和 s2 交错组成的。 示例 1：输入：s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\" 输出：true 示例 2：输入：s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbbaccc\" 输出：false 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n^2) O(n^2) 02 动态规划-一维 O(n^2) O(n) 03 递归 O(n) O(n) func isInterleave(s1 string, s2 string, s3 string) bool { n, m, t := len(s1), len(s2), len(s3) if n+m != t { return false } // dp[i][j]表示s1的前i个元素和s2的前j个元素是否能交错组成s3的前i+j个元素 dp := make([][]bool, n+1) for i := 0; i 0 && dp[i-1][j] == true && s1[i-1] == s3[total] { dp[i][j] = true } if j > 0 && dp[i][j-1] == true && s2[j-1] == s3[total] { dp[i][j] = true } } } return dp[n][m] } # 2 func isInterleave(s1 string, s2 string, s3 string) bool { n, m, t := len(s1), len(s2), len(s3) if n+m != t { return false } // dp[j]表示s1的前i个元素和s2的前j个元素是否能交错组成s3的前i+j个元素 dp := make([]bool, m+1) dp[0] = true for i := 0; i 0 { if dp[j] == true && s1[i-1] == s3[total] { dp[j] = true } else { dp[j] = false } } if j > 0 { if dp[j] == true || (dp[j-1] == true && s2[j-1] == s3[total]) { dp[j] = true } else { dp[j] = false } } } } return dp[m] } # 3 func isInterleave(s1 string, s2 string, s3 string) bool { if len(s1)+len(s2) != len(s3) { return false } return dfs(s1, s2, s3, 0, 0, 0) } func dfs(s1, s2, s3 string, i, j, k int) bool { if k == len(s3) && i == len(s1) && j == len(s2) { return true } if k >= len(s3) { return false } if i 99.恢复二叉搜索树(4) 题目 二叉搜索树中的两个节点被错误地交换。 请在不改变其结构的情况下，恢复这棵树。 示例 1:输入: [1,3,null,null,2] 1 / 3 \\ 2 输出: [3,1,null,null,2] 3 / 1 \\ 2 示例 2:输入: [3,1,4,null,null,2] 3 / \\ 1 4 / 2 输出: [2,1,4,null,null,3] 2 / \\ 1 4 / 3 进阶:使用 O(n) 空间复杂度的解法很容易实现。你能想出一个只使用常数空间的解决方案吗？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(n) 02 递归 O(n) O(log(n)) 03 迭代 O(n) O(n) 04 迭代 O(n) O(1) var arr []*TreeNode func recoverTree(root *TreeNode) { arr = make([]*TreeNode, 0) dfs(root) a, b := -1, -1 for i := 0; i arr[i+1].Val { b = i + 1 if a == -1 { a = i } } } arr[a].Val, arr[b].Val = arr[b].Val, arr[a].Val } func dfs(root *TreeNode) { if root == nil { return } dfs(root.Left) arr = append(arr, root) dfs(root.Right) } # 2 var prev, first, second *TreeNode func recoverTree(root *TreeNode) { prev, first, second = nil, nil, nil dfs(root) first.Val, second.Val = second.Val, first.Val } func dfs(root *TreeNode) { if root == nil { return } dfs(root.Left) if prev != nil && prev.Val > root.Val { second = root if first == nil { first = prev } else { return } } prev = root dfs(root.Right) } # 3 func recoverTree(root *TreeNode) { var prev, first, second *TreeNode stack := make([]*TreeNode, 0) for len(stack) > 0 || root != nil { for root != nil { stack = append(stack, root) root = root.Left } root = stack[len(stack)-1] stack = stack[:len(stack)-1] if prev != nil && root.Val root.Val { second = root if first == nil { first = prev } } prev = root root = root.Right } first.Val, second.Val = second.Val, first.Val } Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 09:56:05 "},"docs/source/question/0101-0200.html":{"url":"docs/source/question/0101-0200.html","title":"0100-0200","keywords":"","body":"0101-0200-Easy 0101-0200-Easy 101. 对称二叉树(2) 104.二叉树的最大深度(2) 107.二叉树的层次遍历II(2) 108.将有序数组转换为二叉搜索树(2) 110.平衡二叉树(3) 111.二叉树的最小深度(2) 112.路径总和(2) 118.杨辉三角(2) 119.杨辉三角II(3) 121.买卖股票的最佳时机(3) 122.买卖股票的最佳时机II(2) 125.验证回文串(2) 136.只出现一次的数字(4) 141.环形链表(3) 155.最小栈(2) 160.相交链表(4) 167.两数之和 II - 输入有序数组(4) 168.Excel表列名称(2) 169.多数元素(5) 171.Excel表列序号(1) 172.阶乘后的零(1) 189.旋转数组(4) 190.颠倒二进制位(3) 191.位1的个数(4) 198.打家劫舍(4) 0101-0200-Medium 102.二叉树的层序遍历(2) 103.二叉树的锯齿形层次遍历(2) 105.从前序与中序遍历序列构造二叉树(3) 106.从中序与后序遍历序列构造二叉树(3) 109.有序链表转换二叉搜索树(2) 113.路径总和II(2) 114.二叉树展开为链表(3) 116.填充每个节点的下一个右侧节点指针(3) 117.填充每个节点的下一个右侧节点指针II(4) 120.三角形最小路径和(5) 127.单词接龙 题目 解题思路 129.求根到叶子节点数字之和(2) 130.被围绕的区域(1) 131.分割回文串(2) 133.克隆图(2) 134.加油站(2) 137.只出现一次的数字II(5) 138.复制带随机指针的链表(3) 139.单词拆分(1) 142.环形链表II(3) 143.重排链表(4) 144.二叉树的前序遍历(3) 146.LRU缓存机制(1) 147.对链表进行插入排序 题目 解题思路 148.排序链表(3) 150.逆波兰表达式求值(1) 151.翻转字符串里的单词(2) 152.乘积最大子数组(2) 153.寻找旋转排序数组中的最小值(2) 162.寻找峰值(3) 165.比较版本号(2) 166.分数到小数(1) 173.二叉搜索树迭代器 题目 解题思路 179.最大数(2) 187.重复的DNA序列(1) 199.二叉树的右视图(2) 200.岛屿数量(1) 0101-0200-Hard 115.不同的子序列(2) 123.买卖股票的最佳时机III(2) 124.二叉树中的最大路径和(2) 128.最长连续序列(3) 135.分发糖果(2) 145.二叉树的后序遍历(4) 149.直线上最多的点数 题目 解题思路 154.寻找旋转排序数组中的最小值II(4) 164.最大间距(2) 188.买卖股票的最佳时机IV(3) 101. 对称二叉树(2) 题目 给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 / \\ 2 2 / \\ / \\ 3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 1 / \\ 2 2 \\ \\ 3 3 说明:如果你可以运用递归和迭代两种方法解决这个问题，会很加分。 解答思路 No. 思路 时间复杂度 空间复杂度 01(最优) 递归 O(n) O(n) 02 迭代 O(n) O(n) // 递归 func isSymmetric(root *TreeNode) bool { if root == nil { return true } return recur(root.Left, root.Right) } func recur(left, right *TreeNode) bool { if left == nil && right == nil { return true } if left == nil || right == nil { return false } return left.Val == right.Val && recur(left.Left, right.Right) && recur(left.Right, right.Left) } // 迭代 func isSymmetric(root *TreeNode) bool { leftQ := make([]*TreeNode, 0) rightQ := make([]*TreeNode, 0) leftQ = append(leftQ, root) rightQ = append(rightQ, root) for len(leftQ) != 0 && len(rightQ) != 0 { leftCur, rightCur := leftQ[0], rightQ[0] leftQ, rightQ = leftQ[1:], rightQ[1:] if leftCur == nil && rightCur == nil { continue } else if leftCur != nil && rightCur != nil && leftCur.Val == rightCur.Val { leftQ = append(leftQ, leftCur.Left, leftCur.Right) rightQ = append(rightQ, rightCur.Right, rightCur.Left) } else { return false } } if len(leftQ) == 0 && len(rightQ) == 0 { return true } else { return false } } 104.二叉树的最大深度(2) 题目 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例：给定二叉树 [3,9,20,null,null,15,7]， 3 / \\ 9 20 / \\ 15 7 返回它的最大深度 3 。 解答思路 No. 思路 时间复杂度 空间复杂度 01(最优) 递归 O(n) O(log(n)) 02 迭代 O(n) O(n) // 递归 func maxDepth(root *TreeNode) int { if root == nil { return 0 } left := maxDepth(root.Left) right := maxDepth(root.Right) return max(left, right) + 1 } func max(a, b int) int { if a > b { return a } return b } // 迭代 func maxDepth(root *TreeNode) int { if root == nil { return 0 } queue := make([]*TreeNode,0) queue = append(queue,root) depth := 0 for len(queue) > 0{ length := len(queue) for i := 0; i 107.二叉树的层次遍历II(2) 题目 给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） 例如：给定二叉树 [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 返回其自底向上的层次遍历为： [ [15,7], [9,20], [3] ] 解题思路 No. 思路 时间复杂度 空间复杂度 01(最优) 递归 O(n) O(n) 02 迭代 O(n) O(n) // 迭代 func levelOrderBottom(root *TreeNode) [][]int { if root == nil { return nil } queue := make([]*TreeNode,0) out := make([][]int,0) queue = append(queue, root) for len(queue) != 0 { l := len(queue) arr := make([]int,0) for i := 0; i level { (*result)[level] = append((*result)[level], root.Val) } else { *result = append(*result, []int{root.Val}) } orderBottom(root.Left, result, level+1) orderBottom(root.Right, result, level+1) } 108.将有序数组转换为二叉搜索树(2) 题目 将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 示例:给定有序数组: [-10,-3,0,5,9], 一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树： 0 / \\ -3 9 / / -10 5 解题思路 No. 思路 时间复杂度 空间复杂度 01(最优) 递归 O(n) O(log(n)) 02 迭代 O(n) O(n) // 递归 func sortedArrayToBST(nums []int) *TreeNode { if len(nums) == 0 { return nil } mid := len(nums) / 2 return &TreeNode{ Val: nums[mid], Left: sortedArrayToBST(nums[:mid]), Right: sortedArrayToBST(nums[mid+1:]), } } // 迭代 type MyTreeNode struct { root *TreeNode start int end int } func sortedArrayToBST(nums []int) *TreeNode { if len(nums) == 0 { return nil } queue := make([]MyTreeNode, 0) root := &TreeNode{Val: 0} queue = append(queue, MyTreeNode{root, 0, len(nums)}) for len(queue) > 0 { myRoot := queue[0] queue = queue[1:] start := myRoot.start end := myRoot.end mid := (start + end) / 2 curRoot := myRoot.root curRoot.Val = nums[mid] if start 110.平衡二叉树(3) 题目 给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。 示例 1:给定二叉树 [3,9,20,null,null,15,7] 3 / \\ 9 20 / \\ 15 7 返回 true 。 示例 2:给定二叉树 [1,2,2,3,3,null,null,4,4] 1 / \\ 2 2 / \\ 3 3 / \\ 4 4 返回 false 。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 递归 O(n) O(log(n)) 03 递归 O(n) O(log(n)) func isBalanced(root *TreeNode) bool { _, isBalanced := recur(root) return isBalanced } func recur(root *TreeNode) (int, bool) { if root == nil { return 0, true } leftDepth, leftIsBalanced := recur(root.Left) if leftIsBalanced == false{ return 0,false } rightDepth, rightIsBalanced := recur(root.Right) if rightIsBalanced == false{ return 0,false } if -1 b { return a } return b } # func isBalanced(root *TreeNode) bool { return dfs(root) != -1 } func dfs(root *TreeNode) int { if root == nil { return 0 } left := dfs(root.Left) right := dfs(root.Right) if left != -1 && right != -1 && abs(left, right) b { return a } return b } func abs(a, b int) int { if a > b { return a - b } return b - a } # 3 func isBalanced(root *TreeNode) bool { if root == nil { return true } if math.Abs(dfs(root.Left)-dfs(root.Right)) 111.二叉树的最小深度(2) 题目 给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明: 叶子节点是指没有子节点的节点。 示例:给定二叉树 [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 返回它的最小深度 2. 解题思路 No. 思路 时间复杂度 空间复杂度 01(最优) 递归 O(n) O(log(n)) 02 广度优先 O(n) O(n) // 递归 func minDepth(root *TreeNode) int { if root == nil { return 0 } else if root.Left == nil { return 1 + minDepth(root.Right) } else if root.Right == nil { return 1 + minDepth(root.Left) } else { return 1 + min(minDepth(root.Left), minDepth(root.Right)) } } func min(a, b int) int { if a 0{ length := len(list) for i := 0; i 112.路径总和(2) 题目 给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的节点。 示例: 给定如下二叉树，以及目标和 sum = 22， 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\ 7 2 1 返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。 解题思路 No. 思路 时间复杂度 空间复杂度 01(最优) 递归 O(n) O(log(n)) 02 迭代 O(n) O(n) // 递归 func hasPathSum(root *TreeNode, sum int) bool { if root == nil { return false } sum = sum - root.Val if root.Left == nil && root.Right == nil { return sum == 0 } return hasPathSum(root.Left, sum) || hasPathSum(root.Right, sum) } // 迭代 func hasPathSum(root *TreeNode, sum int) bool { if root == nil { return false } list1 := list.New() list2 := list.New() list1.PushFront(root) list2.PushFront(sum - root.Val) for list1.Len() > 0 { length := list1.Len() for i := 0; i 118.杨辉三角(2) 题目 给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例:输入: 5 输出: [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1] ] 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n^2) O(n^2) 02(最优) 递推 O(n^2) O(n^2) // 动态规划 func generate(numRows int) [][]int { var result [][]int for i := 0; i 119.杨辉三角II(3) 题目 给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例:输入: 3 输出: [1,3,3,1] 进阶：你可以优化你的算法到 O(k) 空间复杂度吗？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n^2) O(n^2) 02 递推 O(n^2) O(n) 03(最优) 二项式定理 O(n) O(n) // 动态规划 func getRow(rowIndex int) []int { var result [][]int for i := 0; i 0; j--{ res[j] = res[j] + res[j-1] } } return res } // 二项式定理 func getRow(rowIndex int) []int { res := make([]int,rowIndex+1) res[0] = 1 if rowIndex == 0{ return res } // 公式 // C(n,k）= n! /(k! * (n-k)!) // C(n,k) = (n-k+1)/k * C(n,k-1) for i := 1; i 121.买卖股票的最佳时机(3) 题目 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 1:输入: [7,1,5,3,6,4] 输出: 5 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2:输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法 O(n^2) O(1) 02(最优) 动态规划(从前到后) 最大利润=max{前一天最大利润, 今天的价格 - 之前最低价格} O(n) O(1) 03 动态规划(从后到前) O(n) O(1) // 暴力法 func maxProfit(prices []int) int { max := 0 length := len(prices) for i := 0; i max{ max = prices[j] - prices[i] } } } return max } // 动态规划(从前到后) func maxProfit(prices []int) int { if len(prices) = 0; i-- { if max 122.买卖股票的最佳时机II(2) 题目 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1:输入: [7,1,5,3,6,4] 输出: 7 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 输入: [1,2,3,4,5]输出: 4 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3:输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 解题思路 No. 思路 时间复杂度 空间复杂度 01(最优) 贪心法 O(n) O(1) 02 峰谷峰顶法 O(n) O(1) func maxProfit(prices []int) int { max := 0 for i := 1; i prices[i-1] { max = max + prices[i] - prices[i-1] } } return max } func maxProfit(prices []int) int { if len(prices) == 0 { return 0 } i := 0 valley := prices[0] peak := prices[0] profit := 0 for i = prices[i+1] { i++ } valley = prices[i] for i 125.验证回文串(2) 题目 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。 示例 1:输入: \"A man, a plan, a canal: Panama\" 输出: true 示例 2:输入: \"race a car\" 输出: false 解题思路 No. 思路 时间复杂度 空间复杂度 01( 最优) 双指针法 O(n) O(1) 02 双指针法 O(n) O(n) func isPalindrome(s string) bool { s = strings.ToLower(s) i, j := 0, len(s)-1 for i = '0' && value = 'a' && value 136.只出现一次的数字(4) 题目 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1:输入: [2,2,1] 输出: 1 示例 2:输入: [4,1,2,1,2] 输出: 4 解题思路 No. 思路 时间复杂度 空间复杂度 01(最优) 异或 O(n) O(1) 02 哈希 O(n) O(n) 03 暴力法 O(n^2) O(1) 04 排序遍历 O(nlog(n)) O(1) // 异或 func singleNumber(nums []int) int { res := 0 for _, n := range nums { res = res ^ n } return res } // 哈希 func singleNumber(nums []int) int { m := make(map[int]int) for _,v := range nums{ m[v]++ } for k,v := range m{ if v == 1{ return k } } return -1 } // 暴力法 func singleNumber(nums []int) int { for i := 0; i 141.环形链表(3) 题目 给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 示例 1：输入：head = [3,2,0,-4], pos = 1 输出：true 解释：链表中有一个环，其尾部连接到第二个节点。 示例 2：输入：head = [1,2], pos = 0 输出：true 解释：链表中有一个环，其尾部连接到第一个节点。 示例 3：输入：head = [1], pos = -1输出：false 解释：链表中没有环。 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希法 O(n) O(n) 02(最优) 双指针(快慢指针) O(n) O(1) 03 遍历标记 O(n) O(1) func hasCycle(head *ListNode) bool { m := make(map[*ListNode]bool) for head != nil { if m[head] { return true } m[head] = true head = head.Next } return false } // 双指针(快慢指针) func hasCycle(head *ListNode) bool { if head == nil { return false } fast := head.Next for fast != nil && head != nil && fast.Next != nil { if fast == head { return true } fast = fast.Next.Next head = head.Next } return false } # 3 func hasCycle(head *ListNode) bool { for head != nil { if head.Val == math.MaxInt32 { return true } head.Val = math.MaxInt32 head = head.Next } return false } 155.最小栈(2) 题目 设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) -- 将元素 x 推入栈中。 pop() -- 删除栈顶的元素。 top() -- 获取栈顶元素。 getMin() -- 检索栈中的最小元素。 示例: MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); --> 返回 -3. minStack.pop(); minStack.top(); --> 返回 0. minStack.getMin(); --> 返回 -2. 解题思路 No. 思路 时间复杂度 空间复杂度 01(最优) 使用数组模拟栈，保存数据的时候同时保存当前的最小值 O(n) O(n) 02 使用双栈 O(n) O(n) type item struct { min, x int } type MinStack struct { stack []item } func Constructor() MinStack { return MinStack{} } func (this *MinStack) Push(x int) { min := x if len(this.stack) > 0 && this.GetMin() 160.相交链表(4) 题目 编写一个程序，找到两个单链表相交的起始节点。 如下面的两个链表： 在节点 c1 开始相交。 示例 1： 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出：Reference of the node with value = 8 输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。 从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。 在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2： 输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 输出：Reference of the node with value = 2 输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。 从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。 在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3： 输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2 输出：null 输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。 由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。 解释：这两个链表不相交，因此返回 null。 注意： 如果两个链表没有交点，返回 null. 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。 解题思路 No. 思路 时间复杂度 空间复杂度 01 计算长度后，对齐长度再比较 O(n) O(1) 02(最优) 交换后相连，再比较 O(n) O(1) 03 暴力法 O(n^2) O(1) 04 哈希法 O(n) O(n) func getIntersectionNode(headA, headB *ListNode) *ListNode { ALength := 0 A := headA for A != nil { ALength++ A = A.Next } BLength := 0 B := headB for B != nil { BLength++ B = B.Next } pA := headA pB := headB if ALength > BLength { n := ALength - BLength for n > 0 { pA = pA.Next n-- } } else { n := BLength - ALength for n > 0 { pB = pB.Next n-- } } for pA != pB { pA = pA.Next pB = pB.Next } return pA } // func getIntersectionNode(headA, headB *ListNode) *ListNode { A, B := headA, headB for A != B { if A != nil { A = A.Next } else { A = headB } if B != nil { B = B.Next } else { B = headA } } return A } // 暴力法 func getIntersectionNode(headA, headB *ListNode) *ListNode { A, B := headA, headB for A != nil { for B != nil { if A == B { return A } B = B.Next } A = A.Next B = headB } return nil } // 哈希表法 func getIntersectionNode(headA, headB *ListNode) *ListNode { m := make(map[*ListNode]bool) for headA != nil { m[headA] = true headA = headA.Next } for headB != nil { if _, ok := m[headB]; ok { return headB } headB = headB.Next } return nil } 167.两数之和 II - 输入有序数组(4) 题目 给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明: 返回的下标值（index1 和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例:输入: numbers = [2, 7, 11, 15], target = 9 输出: [1,2] 解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法: 2层循环遍历 O(n^2) O(1) 02 两遍哈希遍历 O(n) O(n) 03 一遍哈希遍历 O(n) O(n) 04(最优) 一遍哈希遍历 O(n) O(1) // 暴力法: 2层循环遍历 func twoSum(nums []int, target int) []int { for i := 0; i target { last-- } else { first++ } } } 168.Excel表列名称(2) 题目 给定一个正整数，返回它在 Excel 表中相对应的列名称。 例如， 1 -> A 2 -> B 3 -> C ... 26 -> Z 27 -> AA 28 -> AB ... 示例 1:输入: 1 输出: \"A\" 示例 2:输入: 28 输出: \"AB\" 示例 3:输入: 701 输出: \"ZY\" 解题思路 No. 思路 时间复杂度 空间复杂度 01(最优) 求余模拟进制 O(log(n)) O(1) 02 递归计算 O(log(n)) O(log(n)) // 求余模拟进制 func convertToTitle(n int) string { str := \"\" for n > 0 { n-- str = string(byte(n%26)+'A') + str n /= 26 } return str } // 递归计算 func convertToTitle(n int) string { if n AZ return convertToTitle((n-y-1)/26)+convertToTitle(26) } return convertToTitle((n-y)/26)+convertToTitle(y) } 169.多数元素(5) 题目 给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 示例 1:输入: [3,2,3]输出: 3 示例 2:输入: [2,2,1,1,1,2,2]输出: 2 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序取半 O(nlog(n)) O(1) 02 哈希法 O(n) O(n) 03(最优) Boyer-Moore投票算法 O(n) O(1) 04 位运算 O(n) O(1) 05 分治法 O(nlog(n)) O(log(n)) // 排序取半 func majorityElement(nums []int) int { sort.Ints(nums) return nums[len(nums)/2] } // 哈希法 func majorityElement(nums []int) int { m := make(map[int]int) result := 0 for _, v := range nums{ if _,ok := m[v];ok{ m[v]++ }else { m[v]=1 } if m[v] > (len(nums)/2){ result = v } } return result } // Boyer-Moore投票算法 func majorityElement(nums []int) int { result, count := 0, 0 for i := 0; i len(nums)/2 { result = result | mask } mask = mask rightCount { return left } return right } 171.Excel表列序号(1) 题目 给定一个Excel表格中的列名称，返回其相应的列序号。 例如， A -> 1 B -> 2 C -> 3 ... Z -> 26 AA -> 27 AB -> 28 ... 示例 1:输入: \"A\" 输出: 1 示例 2:输入: \"AB\" 输出: 28 示例 3:输入: \"ZY\" 输出: 701 解题思路 No. 思路 时间复杂度 空间复杂度 01 26进制计算 O(log(n)) O(1) func titleToNumber(s string) int { result := 0 for i := 0; i 172.阶乘后的零(1) 题目 给定一个整数 n，返回 n! 结果尾数中零的数量。 示例 1:输入: 3 输出: 0 解释: 3! = 6, 尾数中没有零。 示例 2:输入: 5输出: 1 解释: 5! = 120, 尾数中有 1 个零. 说明: 你算法的时间复杂度应为 O(log n) 。 解题思路 No. 思路 时间复杂度 空间复杂度 01 数学，找规律 O(log(n)) O(1) func trailingZeroes(n int) int { result := 0 for n >= 5 { n = n / 5 result = result + n } return result } 189.旋转数组(4) 题目 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 示例 1: 输入: [1,2,3,4,5,6,7] 和 k = 3 输出: [5,6,7,1,2,3,4] 解释: 向右旋转 1 步: [7,1,2,3,4,5,6] 向右旋转 2 步: [6,7,1,2,3,4,5] 向右旋转 3 步: [5,6,7,1,2,3,4] 示例 2: 输入: [-1,-100,3,99] 和 k = 2 输出: [3,99,-1,-100] 解释: 向右旋转 1 步: [99,-1,-100,3] 向右旋转 2 步: [3,99,-1,-100] 说明: 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。 要求使用空间复杂度为 O(1) 的 原地 算法。 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法 O(n^2) O(1) 02 三次反转法 O(n) O(1) 03 使用额外的数组 O(n) O(n) 04(最优) 环形替换 O(n) O(1) // 暴力法 func rotate(nums []int, k int) { n := len(nums) if k > n { k = k % n } if k == 0 || k == n { return } for i := 0; i n { k = k % n } if k == 0 || k == n { return } reverse(nums, 0, n-1) reverse(nums, 0, k-1) reverse(nums, k, n-1) } func reverse(nums []int, i, j int) { for i n { k = k % n } if k == 0 || k == n { return } arr := make([]int, len(nums)) for i := 0; i n { k = k % n } if k == 0 || k == n { return } count := 0 for i := 0; count 190.颠倒二进制位(3) 题目 颠倒给定的 32 位无符号整数的二进制位。 示例 1：输入: 00000010100101000001111010011100 输出: 00111001011110000010100101000000 解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596， 因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。 示例 2：输入：11111111111111111111111111111101 输出：10111111111111111111111111111111 解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293， 因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。 提示： 请注意，在某些语言（如 Java）中，没有无符号整数类型。 在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现， 因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在 Java 中，编译器使用二进制补码记法来表示有符号整数。 因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。 进阶: 如果多次调用这个函数，你将如何优化你的算法？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 位操作 O(1) O(1) 02 转字符串 O(n) O(1) 03 二进制交换 O(1) O(1) func reverseBits(num uint32) uint32 { result := uint32(0) for i := 0; i > 1 } return result } // func reverseBits(num uint32) uint32 { str := strconv.FormatUint(uint64(num), 2) rev := \"\" for i := len(str) - 1; i >= 0; i-- { rev = rev + str[i:i+1] } if len(rev) > 16) | ((num & 0x0000ffff) > 8) | ((num & 0x00ff00ff) > 4) | ((num & 0x0f0f0f0f) > 2) | ((num & 0x33333333) > 1) | ((num & 0x55555555) 191.位1的个数(4) 题目 编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数 （也被称为汉明重量）。 示例 1：输入：00000000000000000000000000001011 输出：3 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。 示例 2：输入：00000000000000000000000010000000 输出：1 解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。 示例 3：输入：11111111111111111111111111111101 输出：31 解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。 提示： 请注意，在某些语言（如 Java）中，没有无符号整数类型。 在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现， 因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在 Java 中，编译器使用二进制补码记法来表示有符号整数。 因此，在上面的 示例 3 中，输入表示有符号整数 -3。 进阶:如果多次调用这个函数，你将如何优化你的算法？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 循环位计算 O(1) O(1) 02(最优) 位计算n&(n-1)，会把该整数的最右边的1变成0 O(1) O(1) 03 内置函数 O(1) O(1) 04 遍历 O(1) O(1) // 循环位计算 func hammingWeight(num uint32) int { count := 0 for num != 0 { if num&1 == 1 { count++ } num = num >> 1 } return count } // func hammingWeight(num uint32) int { count := 0 for num != 0 { num = num & (num - 1) count++ } return count } # func hammingWeight(num uint32) int { return strings.Count(strconv.FormatInt(int64(num),2),\"1\") // return strings.Count(fmt.Sprintf(\"%b\",num),\"1\") } # func hammingWeight(num uint32) int { count := 0 flag := uint32(1) for flag != 0 { if num&flag == flag { count++ } flag = flag 198.打家劫舍(4) 题目 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金， 影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统， 如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1:输入: [1,2,3,1] 输出: 4 解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2: 输入: [2,7,9,3,1] 输出: 12 解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 解题思路 No. 思路 时间复杂度 空间复杂度 01(最优) 动态规划 O(n) O(1) 02 动态规划+一维数组 O(n) O(n) 03 动态规划+二维数组 O(n) O(n) 04 奇偶法 O(n) O(1) func rob(nums []int) int { if len(nums) == 0 { return 0 } if len(nums) == 1 { return nums[0] } a := nums[0] b := max(a, nums[1]) for i := 2; i b { return a } return b } # func rob(nums []int) int { n := len(nums) if n == 0 { return 0 } if n == 1 { return nums[0] } dp := make([]int, n) dp[0] = nums[0] if nums[0] > nums[1] { dp[1] = nums[0] } else { dp[1] = nums[1] } for i := 2; i b { return a } return b } # func rob(nums []int) int { if len(nums) == 0 { return 0 } if len(nums) == 1 { return nums[0] } n := len(nums) dp := make([][]int, n) for n := range dp { dp[n] = make([]int, 2) } dp[0][0], dp[0][1] = 0, nums[0] for i := 1; i b { return a } return b } # func rob(nums []int) int { var a, b int for i, v := range nums { if i%2 == 0 { a = max(a+v, b) } else { b = max(a, b+v) } } return max(a, b) } func max(a, b int) int { if a > b { return a } return b } 0101-0200-Medium 102.二叉树的层序遍历(2) 题目 给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。 示例：二叉树：[3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 返回其层次遍历结果： [ [3], [9,20], [15,7] ] 解题思路 No. 思路 时间复杂度 空间复杂度 01 层序遍历 O(n) O(n) 02 递归 O(n) O(n) func levelOrder(root *TreeNode) [][]int { res := make([][]int, 0) if root == nil { return res } list := make([]*TreeNode, 0) list = append(list, root) for len(list) > 0 { length := len(list) temp := make([]int, 0) for i := 0; i 103.二叉树的锯齿形层次遍历(2) 题目 给定一个二叉树，返回其节点值的锯齿形层次遍历。 （即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 例如：给定二叉树 [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 返回锯齿形层次遍历如下： [ [3], [20,9], [15,7] ] 解题思路 No. 思路 时间复杂度 空间复杂度 01 层序遍历 O(n) O(n) 02 递归 O(n) O(n) func zigzagLevelOrder(root *TreeNode) [][]int { res := make([][]int, 0) if root == nil { return res } list := make([]*TreeNode, 0) list = append(list, root) for len(list) > 0 { length := len(list) temp := make([]int, 0) for i := 0; i 105.从前序与中序遍历序列构造二叉树(3) 题目 根据一棵树的前序遍历与中序遍历构造二叉树。 注意:你可以假设树中没有重复的元素。 例如，给出 前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树： 3 / \\ 9 20 / \\ 15 7 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(n) 02 迭代 O(n) O(n) 03 递归 O(n) O(n) func buildTree(preorder []int, inorder []int) *TreeNode { for k := range inorder { if inorder[k] == preorder[0] { return &TreeNode{ Val: preorder[0], Left: buildTree(preorder[1:k+1], inorder[0:k]), Right: buildTree(preorder[k+1:], inorder[k+1:]), } } } return nil } # 2 func buildTree(preorder []int, inorder []int) *TreeNode { if preorder == nil || len(preorder) == 0 { return nil } root := &TreeNode{ Val: preorder[0], } length := len(preorder) stack := make([]*TreeNode, 0) stack = append(stack, root) index := 0 for i := 1; i 0 && stack[len(stack)-1].Val == inorder[index] { node = stack[len(stack)-1] stack = stack[:len(stack)-1] index++ } node.Right = &TreeNode{Val: value} stack = append(stack, node.Right) } } return root } # func buildTree(preorder []int, inorder []int) *TreeNode { if len(preorder) == 0 { return nil } return helper(preorder, inorder) } func helper(preorder []int, inorder []int) *TreeNode { var root *TreeNode for k := range inorder { if inorder[k] == preorder[0] { root = &TreeNode{Val: preorder[0]} root.Left = helper(preorder[1:k+1], inorder[0:k]) root.Right = helper(preorder[k+1:], inorder[k+1:]) } } return root } 106.从中序与后序遍历序列构造二叉树(3) 题目 根据一棵树的中序遍历与后序遍历构造二叉树。 注意:你可以假设树中没有重复的元素。 例如，给出 中序遍历 inorder = [9,3,15,20,7] 后序遍历 postorder = [9,15,7,20,3] 返回如下的二叉树： 3 / \\ 9 20 / \\ 15 7 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(n) 02 递归 O(n) O(n) 03 迭代 O(n) O(n) func buildTree(inorder []int, postorder []int) *TreeNode { last := len(postorder) - 1 for k := range inorder { if inorder[k] == postorder[last] { return &TreeNode{ Val: postorder[last], Left: buildTree(inorder[0:k], postorder[0:k]), Right: buildTree(inorder[k+1:], postorder[k:last]), } } } return nil } # func buildTree(inorder []int, postorder []int) *TreeNode { if len(postorder) == 0 { return nil } return helper(inorder, postorder) } func helper(inorder []int, postorder []int) *TreeNode { var root *TreeNode last := len(postorder) - 1 for k := range inorder { if inorder[k] == postorder[last] { root = &TreeNode{Val: postorder[last]} root.Left = helper(inorder[0:k], postorder[0:k]) root.Right = helper(inorder[k+1:], postorder[k:last]) } } return root } # func buildTree(inorder []int, postorder []int) *TreeNode { if postorder == nil || len(postorder) == 0 { return nil } last := len(postorder) - 1 root := &TreeNode{ Val: postorder[last], } length := len(postorder) stack := make([]*TreeNode, 0) stack = append(stack, root) index := last for i := length - 2; i >= 0; i-- { value := postorder[i] node := stack[len(stack)-1] if node.Val != inorder[index] { node.Right = &TreeNode{Val: value} stack = append(stack, node.Right) } else { for len(stack) > 0 && stack[len(stack)-1].Val == inorder[index] { node = stack[len(stack)-1] stack = stack[:len(stack)-1] index-- } node.Left = &TreeNode{Val: value} stack = append(stack, node.Left) } } return root } 109.有序链表转换二叉搜索树(2) 题目 给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 示例:给定的有序链表： [-10, -3, 0, 5, 9], 一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树： 0 / \\ -3 9 / / -10 5 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(nlog(n)) O(log(n)) 02 数组辅助 O(n) O(n) func sortedListToBST(head *ListNode) *TreeNode { if head == nil { return nil } mid := find(head) if mid == head { return &TreeNode{Val: mid.Val} } return &TreeNode{ Val: mid.Val, Left: sortedListToBST(head), Right: sortedListToBST(mid.Next), } } func find(head *ListNode) *ListNode { if head == nil { return nil } slow, fast := head, head var prev *ListNode for fast != nil && fast.Next != nil { prev = slow slow = slow.Next fast = fast.Next.Next } if prev != nil { prev.Next = nil } return slow } # func sortedListToBST(head *ListNode) *TreeNode { if head == nil { return nil } arr := make([]int, 0) for head != nil { arr = append(arr, head.Val) head = head.Next } return sortArr(arr) } func sortArr(arr []int) *TreeNode { if len(arr) == 0 { return nil } return &TreeNode{ Val: arr[len(arr)/2], Left: sortArr(arr[:len(arr)/2]), Right: sortArr(arr[len(arr)/2+1:]), } } 113.路径总和II(2) 题目 给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。 说明: 叶子节点是指没有子节点的节点。 示例:给定如下二叉树，以及目标和 sum = 22， 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\ 7 2 5 1 返回: [ [5,4,11,2], [5,8,4,5] ] 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 迭代 O(n) O(n) var res [][]int func pathSum(root *TreeNode, sum int) [][]int { if root == nil { return nil } res = make([][]int, 0) var arr []int dfs(root, sum, arr) return res } func dfs(root *TreeNode, sum int, arr []int) { if root == nil { return } arr = append(arr, root.Val) if root.Val == sum && root.Left == nil && root.Right == nil { temp := make([]int, len(arr)) copy(temp, arr) res = append(res, temp) } dfs(root.Left, sum-root.Val, arr) dfs(root.Right, sum-root.Val, arr) arr = arr[:len(arr)-1] } # func pathSum(root *TreeNode, sum int) [][]int { res := make([][]int, 0) if root == nil { return res } temp := make([]int, 0) stack := make([]*TreeNode, 0) visited := make(map[*TreeNode]bool) curSum := 0 for root != nil || len(stack) > 0 { for root != nil { temp = append(temp, root.Val) curSum = curSum + root.Val visited[root] = true stack = append(stack, root) root = root.Left } node := stack[len(stack)-1] if node.Right == nil || visited[node.Right] { if node.Left == nil && node.Right == nil && curSum == sum { tmp := make([]int, len(temp)) copy(tmp, temp) res = append(res, tmp) } stack = stack[:len(stack)-1] temp = temp[:len(temp)-1] curSum = curSum - node.Val root = nil } else { root = node.Right } } return res } 114.二叉树展开为链表(3) 题目 给定一个二叉树，原地将它展开为一个单链表。 例如，给定二叉树 1 / \\ 2 5 / \\ \\ 3 4 6 将其展开为： 1 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 递归 O(n) O(log(n)) 03 迭代 O(n) O(n) // 将原左子树变为节点的右子树 // 再将原右子树变为当前右子树最右节点的右子树。 func flatten(root *TreeNode) { if root == nil { return } flatten(root.Left) flatten(root.Right) right := root.Right root.Right, root.Left = root.Left, nil for root.Right != nil { root = root.Right } root.Right = right } # func flatten(root *TreeNode) { dfs(root, nil) } func dfs(root *TreeNode, pre *TreeNode) *TreeNode { if root == nil { return pre } pre = dfs(root.Right, pre) pre = dfs(root.Left, pre) root.Right, root.Left = pre, nil pre = root return pre } # func flatten(root *TreeNode) { if root == nil { return } res := make([]*TreeNode, 0) stack := make([]*TreeNode, 0) stack = append(stack, root) for len(stack) > 0 { node := stack[len(stack)-1] res = append(res, node) stack = stack[:len(stack)-1] if node.Right != nil { stack = append(stack, node.Right) } if node.Left != nil { stack = append(stack, node.Left) } } for i := 1; i 116.填充每个节点的下一个右侧节点指针(3) 题目 给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下： struct Node { int val; Node *left; Node *right; Node *next; } 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。 如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 初始状态下，所有 next 指针都被设置为 NULL。 示例：输入：{\"$id\":\"1\",\"left\":{\"$id\":\"2\",\"left\":{\"$id\":\"3\",\"left\":null,\"next\":null,\"right\":null,\"val\":4},\"next\":null,\"right\": {\"$id\":\"4\",\"left\":null,\"next\":null,\"right\":null,\"val\":5},\"val\":2},\"next\":null,\"right\": {\"$id\":\"5\",\"left\": {\"$id\":\"6\",\"left\":null,\"next\":null,\"right\":null,\"val\":6},\"next\":null,\"right\": {\"$id\":\"7\",\"left\":null,\"next\":null,\"right\":null,\"val\":7},\"val\":3},\"val\":1} 输出：{\"$id\":\"1\",\"left\":{\"$id\":\"2\",\"left\":{\"$id\":\"3\",\"left\":null,\"next\": {\"$id\":\"4\",\"left\":null,\"next\":{\"$id\":\"5\",\"left\":null,\"next\": {\"$id\":\"6\",\"left\":null,\"next\":null,\"right\":null,\"val\":7},\"right\":null,\"val\":6}, \"right\":null,\"val\":5},\"right\":null,\"val\":4},\"next\":{\"$id\":\"7\",\"left\": {\"$ref\":\"5\"},\"next\":null,\"right\":{\"$ref\":\"6\"},\"val\":3},\"right\": {\"$ref\":\"4\"},\"val\":2},\"next\":null,\"right\":{\"$ref\":\"7\"},\"val\":1} 解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。 提示：你只能使用常量级额外空间。 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 迭代 O(n) O(1) 03 迭代 O(n) O(n) func connect(root *Node) *Node { if root == nil { return nil } left := root.Left right := root.Right // 从上往下，连接最中间的 for left != nil { left.Next = right left = left.Right right = right.Left } connect(root.Left) connect(root.Right) return root } # 2 func connect(root *Node) *Node { if root == nil { return nil } cur := root for cur.Left != nil { parent := cur for parent != nil { parent.Left.Next = parent.Right // 左节点连接右节点 if parent.Next != nil { // 图中的5->6 ，左子树的右节点->右子树的左节点 parent.Right.Next = parent.Next.Left } parent = parent.Next } cur = cur.Left // 移到下一层最左边 } return root } # 3 func connect(root *Node) *Node { if root == nil { return nil } queue := make([]*Node, 0) if root.Left != nil { queue = append(queue, root.Left) } if root.Right != nil { queue = append(queue, root.Right) } for len(queue) > 0 { length := len(queue) i := 0 for i = 0; i 117.填充每个节点的下一个右侧节点指针II(4) 题目 给定一个二叉树 struct Node { int val; Node *left; Node *right; Node *next; } 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。 如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 初始状态下，所有 next 指针都被设置为 NULL。 进阶：你只能使用常量级额外空间。 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。 示例：输入：root = [1,2,3,4,5,null,7] 输出：[1,#,2,3,#,4,5,7,#] 解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。 提示： 树中的节点数小于 6000 -100 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 迭代 O(n) O(n) 03 迭代 O(n) O(1) 04 迭代 O(n) O(1) func connect(root *Node) *Node { if root == nil || (root.Left == nil && root.Right == nil) { return root } if root.Left != nil { root.Left.Next = root.Right } prev := root.Right if prev == nil { prev = root.Left } nextRoot := root.Next for nextRoot != nil && (nextRoot.Left == nil && nextRoot.Right == nil) { nextRoot = nextRoot.Next } if nextRoot != nil { if nextRoot.Left != nil { prev.Next = nextRoot.Left } else { prev.Next = nextRoot.Right } } connect(root.Right) connect(root.Left) return root } # 2 func connect(root *Node) *Node { if root == nil { return nil } queue := make([]*Node, 0) if root.Left != nil { queue = append(queue, root.Left) } if root.Right != nil { queue = append(queue, root.Right) } for len(queue) > 0 { length := len(queue) i := 0 for i = 0; i 120.三角形最小路径和(5) 题目 给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。 相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。 例如，给定三角形： [ [2], [3,4], [6,5,7], [4,1,8,3] ] 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 说明：如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n^2) O(n^2) 02 动态规划 O(n^2) O(n) 03 动态规划 O(n^2) O(n) 04 遍历 O(n^2) O(1) 05 递归 O(n^2) O(n^2) func minimumTotal(triangle [][]int) int { n := len(triangle) dp := make([][]int, n) for i := 0; i b { return b } return a } # 2 func minimumTotal(triangle [][]int) int { n := len(triangle) dp := [2][]int{} for i := 0; i b { return b } return a } # 3 func minimumTotal(triangle [][]int) int { n := len(triangle) dp := make([]int, n) dp[0] = triangle[0][0] for i := 1; i 0; j-- { dp[j] = min(dp[j-1], dp[j]) + triangle[i][j] } dp[0] = dp[0] + triangle[i][0] } res := dp[0] for i := 1; i b { return b } return a } # 4 func minimumTotal(triangle [][]int) int { n := len(triangle) for i := n - 2; i >= 0; i-- { for j := 0; j b { return b } return a } # 5 var dp [][]int func minimumTotal(triangle [][]int) int { dp = make([][]int, len(triangle)) for i := 0; i b { return b } return a } 127.单词接龙 题目 给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。 转换需遵循如下规则： 每次转换只能改变一个字母。 转换过程中的中间单词必须是字典中的单词。 说明: 如果不存在这样的转换序列，返回 0。 所有单词具有相同的长度。 所有单词只由小写字母组成。 字典中不存在重复的单词。 你可以假设 beginWord 和 endWord 是非空的，且二者不相同。 示例 1:输入: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"] 输出: 5 解释: 一个最短转换序列是 \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\", 返回它的长度 5。 示例 2:输入: beginWord = \"hit\" endWord = \"cog\" wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"] 输出: 0 解释: endWord \"cog\" 不在字典中，所以无法进行转换。 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n^2) O(n^2) 129.求根到叶子节点数字之和(2) 题目 给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。 例如，从根到叶子节点路径 1->2->3 代表数字 123。 计算从根到叶子节点生成的所有数字之和。 说明: 叶子节点是指没有子节点的节点。 示例 1:输入: [1,2,3] 1 / \\ 2 3 输出: 25 解释: 从根到叶子节点路径 1->2 代表数字 12. 从根到叶子节点路径 1->3 代表数字 13. 因此，数字总和 = 12 + 13 = 25. 示例 2:输入: [4,9,0,5,1] 4 / \\ 9 0 / \\ 5 1 输出: 1026 解释: 从根到叶子节点路径 4->9->5 代表数字 495. 从根到叶子节点路径 4->9->1 代表数字 491. 从根到叶子节点路径 4->0 代表数字 40. 因此，数字总和 = 495 + 491 + 40 = 1026。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 迭代 O(n) O(n) var res int func sumNumbers(root *TreeNode) int { res = 0 dfs(root, 0) return res } func dfs(root *TreeNode, sum int) { if root == nil { return } sum = sum*10 + root.Val if root.Left == nil && root.Right == nil { res = res + sum } dfs(root.Left, sum) dfs(root.Right, sum) } # func sumNumbers(root *TreeNode) int { res := 0 if root == nil { return res } list := make([]*TreeNode, 0) list = append(list, root) for len(list) > 0 { length := len(list) for i := 0; i 130.被围绕的区域(1) 题目 给定一个二维的矩阵，包含 'X' 和 'O'（字母 O）。 找到所有被 'X' 围绕的区域，并将这些区域里所有的 'O' 用 'X' 填充。 示例: X X X X X O O X X X O X X O X X 运行你的函数后，矩阵变为： X X X X X X X X X X X X X O X X 解释: 被围绕的区间不会存在于边界上，换句话说，任何边界上的 'O' 都不会被填充为 'X'。 任何不在边界上，或不与边界上的 'O' 相连的 'O' 最终都会被填充为 'X'。 如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。 解题思路 No. 思路 时间复杂度 空间复杂度 01 深度优先搜索 O(n^2) O(1) func solve(board [][]byte) { if board == nil || len(board) == 0 { return } for i := 0; i = len(board) || j >= len(board[0]) || board[i][j] == '#' || board[i][j] == 'X' { return } board[i][j] = '#' dfs(board, i+1, j) dfs(board, i-1, j) dfs(board, i, j+1) dfs(board, i, j-1) } 131.分割回文串(2) 题目 给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。 返回 s 所有可能的分割方案。 示例:输入: \"aab\" 输出: [ [\"aa\",\"b\"], [\"a\",\"a\",\"b\"] ] 解题思路 No. 思路 时间复杂度 空间复杂度 01 回溯 O(n*2^n) O(n*2^n) 02 动态规划+回溯 O(n*2^n) O(n*2^n) var res [][]string func partition(s string) [][]string { res = make([][]string, 0) arr := make([]string, 0) dfs(s, 0, arr) return res } func dfs(s string, level int, arr []string) { if level == len(s) { temp := make([]string, len(arr)) copy(temp, arr) res = append(res, temp) return } for i := level; i 133.克隆图(2) 题目 给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。 图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。 class Node { public int val; public List neighbors; } 测试用例格式：简单起见，每个节点的值都和它的索引相同。 例如，第一个节点值为 1（val = 1），第二个节点值为 2（val = 2），以此类推。 该图在测试用例中使用邻接列表表示。 邻接列表 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。 给定节点将始终是图中的第一个节点（值为 1）。你必须将 给定节点的拷贝 作为对克隆图的引用返回。 示例 1：输入：adjList = [[2,4],[1,3],[2,4],[1,3]] 输出：[[2,4],[1,3],[2,4],[1,3]] 解释：图中有 4 个节点。 节点 1 的值是 1，它有两个邻居：节点 2 和 4 。 节点 2 的值是 2，它有两个邻居：节点 1 和 3 。 节点 3 的值是 3，它有两个邻居：节点 2 和 4 。 节点 4 的值是 4，它有两个邻居：节点 1 和 3 。 示例 2：输入：adjList = [[]] 输出：[[]] 解释：输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。 示例 3：输入：adjList = [] 输出：[] 解释：这个图是空的，它不含任何节点。 示例 4：输入：adjList = [[2],[1]] 输出：[[2],[1]] 提示： 节点数不超过 100 。 每个节点值 Node.val 都是唯一的，1 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(n) 02 迭代 O(n) O(n) var visited map[*Node]*Node func cloneGraph(node *Node) *Node { visited = make(map[*Node]*Node) return clone(node) } func clone(node *Node) *Node { if node == nil { return node } if v, ok := visited[node]; ok { return v } newNode := &Node{ Val: node.Val, Neighbors: make([]*Node, len(node.Neighbors)), } visited[node] = newNode for i := 0; i 0 { temp := queue[0] queue = queue[1:] for i, v := range temp.Neighbors { if _, ok := visited[v]; !ok { queue = append(queue, v) visited[v] = &Node{ Val: v.Val, Neighbors: make([]*Node, len(v.Neighbors)), } } visited[temp].Neighbors[i] = visited[v] } } return visited[node] } 134.加油站(2) 题目 在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。 你从其中的一个加油站出发，开始时油箱为空。 如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。 说明: 如果题目有解，该答案即为唯一答案。 输入数组均为非空数组，且长度相同。 输入数组中的元素均为非负数。 示例 1:输入: gas = [1,2,3,4,5] cost = [3,4,5,1,2] 输出: 3 解释:从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。 因此，3 可为起始索引。 示例 2:输入: gas = [2,3,4] cost = [3,4,3]输出: -1 解释:你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。 我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油 开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油 开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油 你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。 因此，无论怎样，你都不可能绕环路行驶一周。。 解题思路 No. 思路 时间复杂度 空间复杂度 01 贪心 O(n) O(1) 02 暴力法 O(n^2) O(1) func canCompleteCircuit(gas []int, cost []int) int { total, sum, start := 0, 0, 0 for i := 0; i 1, 2, 3, 4, -11, 12 // 1->-11 -11 -11 -11 =0)， // 那么i和j之间的所有点都到不了b(= cost[j] { return i } total = total - cost[j] } } gas = append(gas[1:], gas[0]) cost = append(cost[1:], cost[0]) } return -1 } 137.只出现一次的数字II(5) 题目 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1:输入: [2,2,3,2] 输出: 3 示例 2:输入: [0,1,0,1,0,1,99] 输出: 99 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(n) 02 排序遍历 O(nlog(n)) O(1) 03 位运算 O(n) O(1) 04 位运算 O(n) O(1) 05 数学计算 O(n) O(n) func singleNumber(nums []int) int { m := make(map[int]int) for _, v := range nums { m[v]++ } for k, v := range m { if v == 1 { return k } } return 0 } # 2 func singleNumber(nums []int) int { sort.Ints(nums) for i := 0; i >i) & 1 ==1{ count++ } } res |= count%3 138.复制带随机指针的链表(3) 题目 给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。 要求返回这个链表的 深拷贝。 我们用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示： val：一个表示 Node.val 的整数。 random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为 null 。 示例 1：输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]] 输出：[[7,null],[13,0],[11,4],[10,2],[1,0]] 示例 2：输入：head = [[1,1],[2,1]] 输出：[[1,1],[2,1]] 示例 3：输入：head = [[3,null],[3,0],[3,null]] 输出：[[3,null],[3,0],[3,null]] 示例 4：输入：head = [] 输出：[] 解释：给定的链表为空（空指针），因此返回 null。 提示： -10000 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助-递归 O(n) O(n) 02 哈希辅助 O(n) O(n) 03 复制-删除 O(n) O(1) var m map[*Node]*Node func copyRandomList(head *Node) *Node { m = make(map[*Node]*Node) return copyList(head) } func copyList(head *Node) *Node { if head == nil { return head } if node, ok := m[head]; ok { return node } temp := &Node{ Val: head.Val, Next: nil, Random: nil, } m[head] = temp temp.Next = copyList(head.Next) temp.Random = copyList(head.Random) return temp } # 2 func copyRandomList(head *Node) *Node { if head == nil { return nil } res := new(Node) m := make(map[*Node]*Node) temp := head p := res for temp != nil { node := &Node{ Val: temp.Val, Next: nil, Random: nil, } m[temp] = node p.Next = node p = p.Next temp = temp.Next } temp = head p = res.Next for temp != nil { p.Random = m[temp.Random] p = p.Next temp = temp.Next } return res.Next } # 3 func copyRandomList(head *Node) *Node { if head == nil { return nil } res := copyNext(head) res = copyRandom(res) res = cutEven(res) return res } // 原1-复制1-原2-复制2 func copyNext(head *Node) *Node { p := head for p != nil { node := new(Node) node.Val = p.Val node.Next = p.Next p.Next = node p = node.Next } return head } func copyRandom(head *Node) *Node { p := head for p != nil { if p.Random != nil { p.Next.Random = p.Random.Next } p = p.Next.Next } return head } func cutEven(head *Node) *Node { oldNode := head newNode := head.Next cur := newNode for oldNode != nil { oldNode.Next = oldNode.Next.Next if newNode.Next != nil{ newNode.Next = newNode.Next.Next } oldNode = oldNode.Next newNode = newNode.Next } return cur } 139.单词拆分(1) 题目 给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict， 判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 说明： 拆分时可以重复使用字典中的单词。 你可以假设字典中没有重复的单词。 示例 1：输入: s = \"leetcode\", wordDict = [\"leet\", \"code\"] 输出: true 解释: 返回 true 因为 \"leetcode\" 可以被拆分成 \"leet code\"。 示例 2：输入: s = \"applepenapple\", wordDict = [\"apple\", \"pen\"] 输出: true 解释: 返回 true 因为 \"applepenapple\" 可以被拆分成 \"apple pen apple\"。 注意你可以重复使用字典中的单词。 示例 3：输入: s = \"catsandog\", wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"] 输出: false 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n^2) O(n) func wordBreak(s string, wordDict []string) bool { m := make(map[string]bool) for i := 0; i 142.环形链表II(3) 题目 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 说明：不允许修改给定的链表。 示例 1：输入：head = [3,2,0,-4], pos = 1 输出：tail connects to node index 1 解释：链表中有一个环，其尾部连接到第二个节点。 示例 2：输入：head = [1,2], pos = 0 输出：tail connects to node index 0 解释：链表中有一个环，其尾部连接到第一个节点。 示例 3：输入：head = [1], pos = -1 输出：no cycle 解释：链表中没有环。 进阶：你是否可以不用额外空间解决此题？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(n) 02 快慢指针 O(n) O(1) 03 遍历标记 O(n) O(1) func detectCycle(head *ListNode) *ListNode { m := make(map[*ListNode]bool) for head != nil { if m[head] { return head } m[head] = true head = head.Next } return nil } # 2 func detectCycle(head *ListNode) *ListNode { if head == nil { return nil } fast, slow := head, head for fast != nil && fast.Next != nil { fast = fast.Next.Next slow = slow.Next if fast == slow { break } } if fast == nil || fast.Next == nil { return nil } slow = head for fast != slow { fast = fast.Next slow = slow.Next } return slow } # 3 func detectCycle(head *ListNode) *ListNode { for head != nil { if head.Val == math.MaxInt32 { return head } head.Val = math.MaxInt32 head = head.Next } return head } 143.重排链表(4) 题目 给定一个单链表 L：L0→L1→…→Ln-1→Ln ， 将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→… 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例 1:给定链表 1->2->3->4, 重新排列为 1->4->2->3. 示例 2:给定链表 1->2->3->4->5, 重新排列为 1->5->2->4->3. 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组辅助 O(n) O(n) 02 三指针 O(n^2) O(1) 03 反转链表 O(n) O(1) 04 递归 O(n) O(n) func reorderList(head *ListNode) { if head == nil || head.Next == nil { return } cur := head arr := make([]*ListNode, 0) for cur != nil { arr = append(arr, cur) cur = cur.Next } res := make([]*ListNode, 0) for i := 0; i 144.二叉树的前序遍历(3) 题目 给定一个二叉树，返回它的 前序 遍历。 示例:输入: [1,null,2,3] 1 \\ 2 / 3 输出: [1,2,3] 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(n) 02 迭代 O(n) O(n) 03 迭代 O(n) O(n) var res []int func preorderTraversal(root *TreeNode) []int { res = make([]int, 0) dfs(root) return res } func dfs(root *TreeNode) { if root != nil { res = append(res, root.Val) dfs(root.Left) dfs(root.Right) } } # 2 func preorderTraversal(root *TreeNode) []int { res := make([]int, 0) stack := make([]*TreeNode, 0) for len(stack) > 0 || root != nil { for root != nil { res = append(res, root.Val) stack = append(stack, root.Right) root = root.Left } last := len(stack) - 1 root = stack[last] stack = stack[:last] } return res } # 3 func preorderTraversal(root *TreeNode) []int { res := make([]int, 0) if root == nil { return res } stack := make([]*TreeNode, 0) stack = append(stack, root) for len(stack) > 0 { node := stack[len(stack)-1] stack = stack[:len(stack)-1] res = append(res, node.Val) if node.Right != nil { stack = append(stack, node.Right) } if node.Left != nil { stack = append(stack, node.Left) } } return res } 146.LRU缓存机制(1) 题目 运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。 它应该支持以下操作： 获取数据 get 和 写入数据 put 。 获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。 写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值； 如果关键字不存在，则插入该组「关键字/值」。 当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。 进阶:你是否可以在 O(1) 时间复杂度内完成这两种操作？ 示例:LRUCache cache = new LRUCache( 2 /* 缓存容量 */ ); cache.put(1, 1); cache.put(2, 2); cache.get(1); // 返回 1 cache.put(3, 3); // 该操作会使得关键字 2 作废 cache.get(2); // 返回 -1 (未找到) cache.put(4, 4); // 该操作会使得关键字 1 作废 cache.get(1); // 返回 -1 (未找到) cache.get(3); // 返回 3 cache.get(4); // 返回 4 解题思路 No. 思路 时间复杂度 空间复杂度 01 双向链表 O(1) O(n) type Node struct { key int value int prev *Node next *Node } type LRUCache struct { cap int header *Node tail *Node m map[int]*Node } func Constructor(capacity int) LRUCache { cache := LRUCache{ cap: capacity, header: &Node{}, tail: &Node{}, m: make(map[int]*Node, capacity), } cache.header.next = cache.tail cache.tail.prev = cache.header return cache } func (this *LRUCache) Get(key int) int { if node, ok := this.m[key]; ok { this.remove(node) this.putHead(node) return node.value } return -1 } func (this *LRUCache) Put(key int, value int) { if node, ok := this.m[key]; ok { node.value = value this.remove(node) this.putHead(node) return } if this.cap 147.对链表进行插入排序 题目 对链表进行插入排序。 插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。 每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。 插入排序算法： 插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。 每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。 重复直到所有输入数据插入完为止。 示例 1：输入: 4->2->1->3 输出: 1->2->3->4 示例 2：输入: -1->5->3->4->0 输出: -1->0->3->4->5 解题思路 No. 思路 时间复杂度 空间复杂度 01 快排 O(nlog(n)) O(log(n)) 148.排序链表(3) 题目 在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。 示例 1:输入: 4->2->1->3 输出: 1->2->3->4 示例 2:输入: -1->5->3->4->0 输出: -1->0->3->4->5 解题思路 No. 思路 时间复杂度 空间复杂度 01 快排 O(nlog(n)) O(log(n)) 02 归并 O(nlog(n)) O(log(n)) 03 归并 O(nlog(n)) O(1) func sortList(head *ListNode) *ListNode { quickSort(head, nil) return head } func quickSort(head, end *ListNode) { if head == end || head.Next == end { return } temp := head.Val fast, slow := head.Next, head for fast != end { if fast.Val 0 && cur != nil { length-- cur = cur.Next } if cur == nil { return nil } right = cur.Next cur.Next = nil return right } func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode { res := &ListNode{} temp := res for l1 != nil && l2 != nil { if l1.Val 150.逆波兰表达式求值(1) 题目 根据 逆波兰表示法，求表达式的值。 有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 说明： 整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。 示例 1：输入: [\"2\", \"1\", \"+\", \"3\", \"*\"] 输出: 9 解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9 示例 2：输入: [\"4\", \"13\", \"5\", \"/\", \"+\"] 输出: 6 解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6 示例 3： 输入: [\"10\", \"6\", \"9\", \"3\", \"+\", \"-11\", \"*\", \"/\", \"*\", \"17\", \"+\", \"5\", \"+\"] 输出: 22 解释: 该算式转化为常见的中缀算术表达式为： ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22 逆波兰表达式： 逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。 平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。 该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。 逆波兰表达式主要有以下两个优点： 去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。 解题思路 No. 思路 时间复杂度 空间复杂度 01 栈辅助 O(n) O(n) func evalRPN(tokens []string) int { stack := make([]int, 0) for _, v := range tokens { length := len(stack) if v == \"+\" || v == \"-\" || v == \"*\" || v == \"/\" { a := stack[length-2] b := stack[length-1] stack = stack[:length-2] var value int if v == \"+\" { value = a + b } else if v == \"-\" { value = a - b } else if v == \"*\" { value = a * b } else { value = a / b } stack = append(stack, value) } else { value, _ := strconv.Atoi(v) stack = append(stack, value) } } return stack[0] } 151.翻转字符串里的单词(2) 题目 给定一个字符串，逐个翻转字符串中的每个单词。 示例 1：输入: \"the sky is blue\" 输出: \"blue is sky the\" 示例 2：输入: \" hello world! \" 输出: \"world! hello\" 解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 示例 3：输入: \"a good example\" 输出: \"example good a\" 解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 说明： 无空格字符构成一个单词。 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 进阶：请选用 C 语言的用户尝试使用 O(1) 额外空间复杂度的原地解法。 解题思路 No. 思路 时间复杂度 空间复杂度 01 内置函数 O(n) O(n) 02 遍历 O(n) O(n) func reverseWords(s string) string { arr := strings.Fields(s) for i := 0; i 152.乘积最大子数组(2) 题目 给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字）， 并返回该子数组所对应的乘积。 示例 1:输入: [2,3,-2,4] 输出: 6 解释: 子数组 [2,3] 有最大乘积 6。 示例 2:输入: [-2,0,-1] 输出: 0 解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。 -解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n) O(1) 02 暴力法 O(n^2) O(1) func maxProduct(nums []int) int { minValue, maxValue, res := nums[0], nums[0], nums[0] for i := 1; i b { return a } return b } func min(a, b int) int { if a > b { return b } return a } # func maxProduct(nums []int) int { res := math.MinInt64 for i := 0; i res { res = temp } } } return res } 153.寻找旋转排序数组中的最小值(2) 题目 假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 请找出其中最小的元素。 你可以假设数组中不存在重复元素。 示例 1:输入: [3,4,5,1,2]输出: 1 示例 2:输入: [4,5,6,7,0,1,2]输出: 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 二分查找 O(log(n)) O(1) func findMin(nums []int) int { res := nums[0] for i := 1; i nums[right] { left = mid + 1 } else { right = mid } } return nums[left] } 162.寻找峰值(3) 题目 峰值元素是指其值大于左右相邻值的元素。 给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。 数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。 你可以假设 nums[-1] = nums[n] = -∞。 示例 1:输入: nums = [1,2,3,1] 输出: 2 解释: 3 是峰值元素，你的函数应该返回其索引 2。 示例 2:输入: nums = [1,2,1,3,5,6,4] 输出: 1 或 5 解释: 你的函数可以返回索引 1，其峰值元素为 2； 或者返回索引 5， 其峰值元素为 6。 说明:你的解法应该是 O(logN) 时间复杂度的。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 二分查找 O(log(n)) O(1) 03 遍历 O(n) O(1) func findPeakElement(nums []int) int { n := len(nums) if n == 1 { return 0 } for i := 0; i nums[i+1] { return i } if i == n-1 && i-1 >= 0 && nums[i] > nums[i-1] { return i } if i-1 >= 0 && i+1 nums[i+1] && nums[i] > nums[i-1] { return i } } return -1 } # 2 func findPeakElement(nums []int) int { n := len(nums) if n == 1 { return 0 } left := 0 right := n - 1 for left nums[mid+1] { right = mid } else { left = mid + 1 } } return left } # 3 func findPeakElement(nums []int) int { n := len(nums) if n == 1 { return 0 } for i := 0; i nums[i+1] { return i } } return n - 1 } 165.比较版本号(2) 题目 比较两个版本号 version1 和 version2。 如果 version1 > version2 返回 1，如果 version1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(n) 02 遍历 O(n) O(n) func compareVersion(version1 string, version2 string) int { arr1 := strings.Split(version1, \".\") arr2 := strings.Split(version2, \".\") for len(arr1) b { return 1 } else if a 01 b[j] { return 1 } } } return 0 } 166.分数到小数(1) 题目 给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以字符串形式返回小数。 如果小数部分为循环小数，则将循环的部分括在括号内。 示例 1:输入: numerator = 1, denominator = 2 输出: \"0.5\" 示例 2:输入: numerator = 2, denominator = 1 输出: \"2\" 示例 3:输入: numerator = 2, denominator = 3 输出: \"0.(6)\" 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(log(n)) O(log(n)) func fractionToDecimal(numerator int, denominator int) string { res := make([]string, 0) if numerator == 0 { return \"0\" } // 预处理 flag := false if numerator 0 { b = b * 10 if v, ok := m[b]; ok { last = v break } else { m[b] = index } index++ a, b = b/denominator, b%denominator res = append(res, strconv.Itoa(a)) } if last != -1 { res = append(res[:last], append([]string{\"(\"}, res[last:]...)...) res = append(res, \")\") } return strings.Join(res, \"\") } 173.二叉搜索树迭代器 题目 解题思路 179.最大数(2) 题目 给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。 示例 1:输入: [10,2] 输出: 210 示例 2:输入: [3,30,34,5,9] 输出: 9534330 说明: 输出结果可能非常大，所以你需要返回一个字符串而不是整数。 解题思路 No. 思路 时间复杂度 空间复杂度 01 自定义排序 O(nlog(n)) O(n) 02 自定义排序 O(nlog(n)) O(n) func largestNumber(nums []int) string { arr := make([]string, 0) for i := 0; i = arr[j]+arr[i] }) res := strings.Join(arr, \"\") if res[0] == '0' { return \"0\" } return res } # func largestNumber(nums []int) string { sort.Slice(nums, func(i, j int) bool { return fmt.Sprintf(\"%d%d\", nums[i], nums[j]) >= fmt.Sprintf(\"%d%d\", nums[j], nums[i]) }) res := \"\" for i := 0; i 187.重复的DNA序列(1) 题目 所有 DNA 都由一系列缩写为 A，C，G 和 T 的核苷酸组成，例如：“ACGAATTCCG”。 在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。 编写一个函数来查找目标子串，目标子串的长度为 10，且在 DNA 字符串 s 中出现次数超过一次。 示例：输入：s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\" 输出：[\"AAAAACCCCC\", \"CCCCCAAAAA\"] 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(n) func findRepeatedDnaSequences(s string) []string { res := make([]string, 0) m := make(map[string]int) // 可以采用其他的形式作为key for i := 0; i 1 { res = append(res, k) } } return res } 199.二叉树的右视图(2) 题目 给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 示例:输入: [1,2,3,null,5,null,4] 输出: [1, 3, 4] 解释: 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 迭代 O(n) O(n) 02 递归 O(n) O(log(n)) func rightSideView(root *TreeNode) []int { res := make([]int, 0) if root == nil{ return res } list := make([]*TreeNode, 0) list = append(list, root) for len(list) > 0 { length := len(list) res = append(res, list[0].Val) for i := 0; i len(res) { res = append(res, root.Val) } dfs(root.Right, level+1) dfs(root.Left, level+1) } 200.岛屿数量(1) 题目 给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 示例 1:输入: [ ['1','1','1','1','0'], ['1','1','0','1','0'], ['1','1','0','0','0'], ['0','0','0','0','0'] ] 输出: 1 示例 2:输入: [ ['1','1','0','0','0'], ['1','1','0','0','0'], ['0','0','1','0','0'], ['0','0','0','1','1'] ] 输出: 3 解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。 解题思路 No. 思路 时间复杂度 空间复杂度 01 深度优先遍历 O(n^2) O(1) func numIslands(grid [][]byte) int { res := 0 for i := 0; i = len(grid) || j >= len(grid[0]) || grid[i][j] == '0' { return } grid[i][j] = '0' dfs(grid, i+1, j) dfs(grid, i-1, j) dfs(grid, i, j+1) dfs(grid, i, j-1) } 0101-0200-Hard 115.不同的子序列(2) 题目 给定一个字符串 S 和一个字符串 T，计算在 S 的子序列中 T 出现的个数。 一个字符串的一个子序列是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。 （例如，\"ACE\" 是 \"ABCDE\" 的一个子序列，而 \"AEC\" 不是） 题目数据保证答案符合 32 位带符号整数范围。 示例 1：输入：S = \"rabbbit\", T = \"rabbit\" 输出：3 解释：如下图所示, 有 3 种可以从 S 中得到 \"rabbit\" 的方案。 (上箭头符号 ^ 表示选取的字母) rabbbit ^^^^ ^^ rabbbit ^^ ^^^^ rabbbit ^^^ ^^^ 示例 2：输入：S = \"babgbag\", T = \"bag\" 输出：5 解释：如下图所示, 有 5 种可以从 S 中得到 \"bag\" 的方案。 (上箭头符号 ^ 表示选取的字母) babgbag ^^ ^ babgbag ^^ ^ babgbag ^ ^^ babgbag ^ ^^ babgbag ^^^ 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划-一维 O(n^2) O(n) 02 动态规划-二维 O(n^2) O(n^2) func numDistinct(s string, t string) int { dp := make([]int, len(t)+1) dp[0] = 1 for i := 1; i = 1; j-- { if s[i-1] == t[j-1] { dp[j] = dp[j] + dp[j-1] } } } return dp[len(t)] } # 2 func numDistinct(s string, t string) int { // dp[i][j]为使用s的前i个字符能够最多组成多少个t的前j个字符 dp := make([][]int, len(s)+1) for i := 0; i 123.买卖股票的最佳时机III(2) 题目 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。 注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1:输入: [3,3,5,0,0,3,1,4] 输出: 6 解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出， 这笔交易所能获得利润 = 3-0 = 3 。 随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出， 这笔交易所能获得利润 = 4-1 = 3 。 示例 2:输入: [1,2,3,4,5] 输出: 4 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3:输入: [7,6,4,3,1] 输出: 0 解释: 在这个情况下, 没有交易完成, 所以最大利润为 0。 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划-三维 O(n) O(n) 02 动态规划 O(n) O(1) func maxProfit(prices []int) int { n := len(prices) if n b { return a } return b } # 2 func maxProfit(prices []int) int { buy1, buy2 := math.MaxInt32, math.MaxInt32 profit1, profit2 := 0, 0 for i := 0; i b { return a } return b } func min(a, b int) int { if a > b { return b } return a } 124.二叉树中的最大路径和(2) 题目 给定一个非空二叉树，返回其最大路径和。 本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。 示例 1:输入: [1,2,3] 1 / \\ 2 3 输出: 6 示例 2:输入: [-10,9,20,null,null,15,7] -10 / \\ 9 20 / \\ 15 7 输出: 42 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 迭代 O(n) O(n) var res int func maxPathSum(root *TreeNode) int { res = math.MinInt32 dfs(root) return res } func dfs(root *TreeNode) int { if root == nil { return 0 } left := max(dfs(root.Left), 0) right := max(dfs(root.Right), 0) // 该顶点路径和=root.Val+2边和 value := left + right + root.Val res = max(res, value) // 单分支 return root.Val + max(left, right) } func max(a, b int) int { if a > b { return a } return b } # 2 var res int func maxPathSum(root *TreeNode) int { res = math.MinInt32 queue := make([]*TreeNode, 0) queue = append(queue, root) stack := make([]*TreeNode, 0) for len(queue) > 0 { node := queue[0] queue = queue[1:] if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } stack = append(stack, node) } for len(stack) > 0 { node := stack[len(stack)-1] stack = stack[:len(stack)-1] res = max(res, node.Val) var left, right int if node.Left == nil { left = 0 } else { left = max(node.Left.Val, 0) } if node.Right == nil { right = 0 } else { right = max(node.Right.Val, 0) } sum := node.Val + left + right res = max(res, sum) node.Val = node.Val + max(left, right) } return res } func max(a, b int) int { if a > b { return a } return b } 128.最长连续序列(3) 题目 给定一个未排序的整数数组，找出最长连续序列的长度。 要求算法的时间复杂度为 O(n)。 示例:输入: [100, 4, 200, 1, 3, 2] 输出: 4 解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(n) 02 排序遍历 O(nlog(n)) O(1) 03 哈希辅助 O(n) O(n) func longestConsecutive(nums []int) int { m := make(map[int]bool) for i := 0; i b { return a } return b } # 2 func longestConsecutive(nums []int) int { if len(nums) b { return a } return b } # 3 func longestConsecutive(nums []int) int { m := make(map[int]int) res := 0 for i := 0; i 0 { continue } left := m[nums[i]-1] right := m[nums[i]+1] sum := left + 1 + right res = max(res, sum) m[nums[i]] = sum m[nums[i]-left] = sum m[nums[i]+right] = sum } return res } func max(a, b int) int { if a > b { return a } return b } 135.分发糖果(2) 题目 老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。 你需要按照以下要求，帮助老师给这些孩子分发糖果： 每个孩子至少分配到 1 个糖果。 相邻的孩子中，评分高的孩子必须获得更多的糖果。 那么这样下来，老师至少需要准备多少颗糖果呢？ 示例 1:输入: [1,0,2] 输出: 5 解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。 示例 2:输入: [1,2,2] 输出: 4 解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。 第三个孩子只得到 1 颗糖果，这已满足上述两个条件。 解题思路 No. 思路 时间复杂度 空间复杂度 01 贪心 O(n) O(n) 02 贪心 O(n) O(n) func candy(ratings []int) int { arr := make([]int, len(ratings)) // 规则1：每个孩子至少分配到 1 个糖果。 for i := 0; i ratings[i-1] && arr[i] = 0; i-- { if ratings[i] > ratings[i+1] && arr[i] ratings[i-1] { left[i] = left[i-1] + 1 } } for i := n - 2; i >= 0; i-- { if ratings[i] > ratings[i+1] { right[i] = right[i+1] + 1 } } res := 0 for i := 0; i b { return a } return b } 145.二叉树的后序遍历(4) 题目 给定一个二叉树，返回它的 后序 遍历。 示例:输入: [1,null,2,3] 1 \\ 2 / 3 输出: [3,2,1] 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(n) 02 递归 O(n) O(n) 03 迭代 O(n) O(n) 04 迭代 O(n) O(n) var res []int func postorderTraversal(root *TreeNode) []int { res = make([]int, 0) dfs(root) return res } func dfs(root *TreeNode) { if root != nil { dfs(root.Left) dfs(root.Right) res = append(res, root.Val) } } # 2 func postorderTraversal(root *TreeNode) []int { if root == nil { return nil } res := make([]int, 0) if root.Left != nil { res = append(res, postorderTraversal(root.Left)...) } if root.Right != nil { res = append(res, postorderTraversal(root.Right)...) } res = append(res, root.Val) return res } # 3 func postorderTraversal(root *TreeNode) []int { if root == nil { return nil } res := make([]int, 0) stack := make([]*TreeNode, 0) stack = append(stack, root) for len(stack) > 0 { last := stack[len(stack)-1] stack = stack[:len(stack)-1] if last != nil { stack = append(stack, last) stack = append(stack, nil) if last.Right != nil { stack = append(stack, last.Right) } if last.Left != nil { stack = append(stack, last.Left) } } else { node := stack[len(stack)-1] stack = stack[:len(stack)-1] res = append(res, node.Val) } } return res } # 4 func postorderTraversal(root *TreeNode) []int { if root == nil { return nil } res := make([]int, 0) stack := make([]*TreeNode, 0) stack = append(stack, root) // 根->右->左 for len(stack) != 0 { node := stack[len(stack)-1] stack = stack[:len(stack)-1] if node.Left != nil { stack = append(stack, node.Left) } if node.Right != nil { stack = append(stack, node.Right) } res = append(res, node.Val) } for i := 0; i 149.直线上最多的点数 题目 给定一个二维平面，平面上有 n 个点，求最多有多少个点在同一条直线上。 示例 1:输入: [[1,1],[2,2],[3,3]] 输出: 3 解释: ^ | | o | o | o +-------------> 0 1 2 3 4 示例 2:输入: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]] 输出: 4 解释: ^ | | o | o o | o | o o +-------------------> 0 1 2 3 4 5 6 解题思路 No. 思路 时间复杂度 空间复杂度 01 二分查找 O(log(n)) O(1) 154.寻找旋转排序数组中的最小值II(4) 题目 假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 请找出其中最小的元素。 注意数组中可能存在重复的元素。 示例 1：输入: [1,3,5] 输出: 1 示例 2：输入: [2,2,2,0,1]输出: 0 说明：这道题是 寻找旋转排序数组中的最小值 的延伸题目。 允许重复会影响算法的时间复杂度吗？会如何影响，为什么？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 二分查找 O(log(n)) O(1) 02 排序 O(nlog(n)) O(1) 03 遍历 O(n) O(1) 04 二分查找 O(log(n)) O(1) func findMin(nums []int) int { left := 0 right := len(nums) - 1 for left nums[right] { left = mid + 1 } else if nums[mid] = nums[right] { if right-left == 1 { mid = right break } mid = (left + right) / 2 if nums[left] == nums[right] && nums[mid] == nums[left] { return minInorder(nums, left, right) } if nums[mid] >= nums[left] { left = mid } else if nums[mid] numbers[i] { result = numbers[i] } } return result } 164.最大间距(2) 题目 给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。 如果数组元素个数小于 2，则返回 0。 示例 1:输入: [3,6,9,1] 输出: 3 解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。 示例 2:输入: [10] 输出: 0 解释: 数组元素个数小于 2，因此返回 0。 说明:你可以假设数组中所有元素都是非负整数，且数值在 32 位有符号整数范围内。 请尝试在线性时间复杂度和空间复杂度的条件下解决此问题。 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序 O(nlog(n)) O(1) 02 桶排序 O(n) O(n) func maximumGap(nums []int) int { res := 0 sort.Ints(nums) for i := 1; i res { res = nums[i] - nums[i-1] } } return res } # 2 func maximumGap(nums []int) int { if len(nums) b { return a } return b } func min(a, b int) int { if a > b { return b } return a } 188.买卖股票的最佳时机IV(3) 题目 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。 注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1:输入: [2,4,1], k = 2 输出: 2 解释: 在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出， 这笔交易所能获得利润 = 4-2 = 2 。 示例 2:输入: [3,2,6,5,0,3], k = 2 输出: 7 解释: 在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。 随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划-一维 O(n^2) O(n) 02 动态规划-二维 O(n^2) O(n^2) 03 动态规划-三维 O(n^2) O(n^2) func maxProfit(k int, prices []int) int { res := 0 if k >= len(prices)/2 { for i := 0; i = 1; j-- { dp0[j] = max(dp0[j], dp1[j]+prices[i]) dp1[j] = max(dp1[j], dp0[j-1]-prices[i]) } } return dp0[k] } func max(a, b int) int { if a > b { return a } return b } # 2 func maxProfit(k int, prices []int) int { res := 0 if k >= len(prices)/2 { for i := 0; i b { return a } return b } # 3 func maxProfit(k int, prices []int) int { res := 0 if k >= len(prices)/2 { for i := 0; i b { return a } return b } Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 10:11:52 "},"docs/source/question/0201-0300.html":{"url":"docs/source/question/0201-0300.html","title":"0201-0300","keywords":"","body":"0201-0300-Easy 0201-0300-Easy 202.快乐数(2) 203.移除链表元素(2) 204.计数质数(2) 205.同构字符串(3) 206.反转链表(4) 217.存在重复元素(2) 219.存在重复元素 II(2) 225.用队列实现栈(4) 226.翻转二叉树(2) 231.2的幂(3) 232.用栈实现队列(3) 234.回文链表(4) 235.二叉搜索树的最近公共祖先(2) 237.删除链表中的节点(1) 242.有效的字母异位词(2) 257.二叉树的所有路径(2) 258.各位相加(4) 263.丑数(2) 268.缺失数字(5) 278.第一个错误的版本(2) 283.移动零(3) 290.单词规律(2) 292.Nim 游戏(1) 299.猜数字游戏(2) 0201-0300-Medium 201.数字范围按位与(2) 207.课程表(2) 208.实现Trie(前缀树)(2) 209.长度最小的子数组(3) 210.课程表II(2) 211.添加与搜索单词-数据结构设计(1) 213.打家劫舍II(3) 215.数组中的第K个最大元素(3) 216.组合总和III(1) 220.存在重复元素III(2) 221.最大正方形(3) 222.完全二叉树的节点个数(3) 223.矩形面积(1) 227.基本计算器II 题目 解题思路 228.汇总区间(2) 229.求众数II(2) 230.二叉搜索树中第K小的元素(3) 236.二叉树的最近公共祖先(2) 238.除自身以外数组的乘积(3) 240.搜索二维矩阵II(6) 241.为运算表达式设计优先级 题目 解题思路 260.只出现一次的数字III(3) 264.丑数II(1) 274.H指数(2) 275.H指数II(2) 279.完全平方数(5) 284.顶端迭代器 题目 解题思路 287.寻找重复数(8) 289.生命游戏(2) 300.最长上升子序列(2) 0201-0300-Hard 214.最短回文串(3) 233.数字1的个数(3) 239.滑动窗口最大值(3) 295.数据流的中位数(1) 297.二叉树的序列化与反序列化(2) 202.快乐数(2) 题目 编写一个算法来判断一个数 n 是不是快乐数。 「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和， 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。 如果 可以变为 1，那么这个数就是快乐数。 如果 n 是快乐数就返回 True ；不是，则返回 False 。 示例： 输入：19 输出：true 解释： 12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希+遍历 O(log(n)) O(log(n)) 02 遍历+快慢判断环 O(log(n)) O(1) func isHappy(n int) bool { now, next := n, nextValue(n) m := make(map[int]int) m[now] = 1 for { if next == 1 { break } if _, ok := m[next]; ok { break } else { m[next] = 1 } next = nextValue(next) } if next == 1 { return true } return false } func nextValue(n int) int { ret := 0 for n != 0 { ret = ret + (n%10)*(n%10) n = n / 10 } return ret } # func isHappy(n int) bool { now, next := n, nextValue(n) for now != next { now = nextValue(now) next = nextValue(nextValue(next)) } if now == 1 { return true } return false } func nextValue(n int) int { ret := 0 for n != 0 { ret = ret + (n%10)*(n%10) n = n / 10 } return ret } 203.移除链表元素(2) 题目 删除链表中等于给定值 val 的所有节点。 示例: 输入: 1->2->6->3->4->5->6, val = 6 输出: 1->2->3->4->5 解题思路 No. 思路 时间复杂度 空间复杂度 01 哨兵结点+链表遍历 O(n) O(1) 02 递归 O(n) O(n) func removeElements(head *ListNode, val int) *ListNode { headPre := &ListNode{Next: head} temp := headPre for temp.Next != nil { if temp.Next.Val == val { //delete temp.Next = temp.Next.Next } else { temp = temp.Next } } return headPre.Next } # 递归 func removeElements(head *ListNode, val int) *ListNode { if head == nil { return nil } head.Next = removeElements(head.Next, val) if head.Val == val { return head.Next } return head } 204.计数质数(2) 题目 统计所有小于非负整数 n 的质数的数量。 示例: 输入: 10 输出: 4 解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。 解题思路 No. 思路 时间复杂度 空间复杂度 01 筛选质数(厄拉多塞筛法) O(n^2) O(n) 02 筛选质数优化 O(n) O(n) func countPrimes(n int) int { if n 205.同构字符串(3) 题目 给定两个字符串 s 和 t，判断它们是否是同构的。 如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。 所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。 两个字符不能映射到同一个字符上，但字符可以映射自己本身。 示例 1: 输入: s = \"egg\", t = \"add\" 输出: true 示例 2:输入: s = \"foo\", t = \"bar\" 输出: false 示例 3: 输入: s = \"paper\", t = \"title\" 输出: true 说明:你可以假设 s 和 t 具有相同的长度。 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组映射 O(n) O(n) 02 哈希映射 O(n) O(n) 03 字符串查找匹配 O(n) O(1) func isIsomorphic(s string, t string) bool { if len(s) != len(t) { return false } m1 := make([]int, 256) m2 := make([]int, 256) for i := 0; i 206.反转链表(4) 题目 反转一个单链表。 示例: 输入: 1->2->3->4->5->NULL 输出: 5->4->3->2->1->NULL 进阶: 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(n) 02 迭代 O(n) O(1) 03 数组辅助 O(n) O(n) 04 迭代-新建节点 O(n) O(1) func reverseList(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } result := reverseList(head.Next) head.Next.Next = head head.Next = nil return result } // func reverseList(head *ListNode) *ListNode { var result *ListNode var temp *ListNode for head != nil { temp = head.Next head.Next = result result = head head = temp } return result } # func reverseList(head *ListNode) *ListNode { result := &ListNode{} arr := make([]*ListNode, 0) for head != nil { arr = append(arr, head) head = head.Next } temp := result for i := len(arr) - 1; i >= 0; i-- { arr[i].Next = nil temp.Next = arr[i] temp = temp.Next } return result.Next } # func reverseList(head *ListNode) *ListNode { var res *ListNode for { if head == nil { break } res = &ListNode{head.Val, res} head = head.Next } return res } 217.存在重复元素(2) 题目 给定一个整数数组，判断是否存在重复元素。 如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。 示例 1:输入: [1,2,3,1] 输出: true 示例 2:输入: [1,2,3,4] 输出: false 示例 3:输入: [1,1,1,3,3,4,3,2,4,2] 输出: true 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助遍历 O(n) O(n) 02 排序后遍历 O(nlog(n)) O(1) func containsDuplicate(nums []int) bool { m := make(map[int]int) for i := 0; i 219.存在重复元素 II(2) 题目 给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j， 使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。 示例 1:输入: nums = [1,2,3,1], k = 3输出: true 示例 2:输入: nums = [1,0,1,1], k = 1 输出: true 示例 3:输入: nums = [1,2,3,1,2,3], k = 2 输出: false 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助遍历 O(n) O(n) 02 哈希表+滑动窗口 O(n) O(n) # func containsNearbyDuplicate(nums []int, k int) bool { m := make(map[int]int) for i, n := range nums { if m[n] != 0 && (i+1)-m[n] k { delete(m, nums[i-k]) } } return false } 225.用队列实现栈(4) 题目 使用队列实现栈的下列操作： push(x) -- 元素 x 入栈 pop() -- 移除栈顶元素 top() -- 获取栈顶元素 empty() -- 返回栈是否为空 注意: 你只能使用队列的基本操作-- 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。 你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。 你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。 解题思路 No. 思路 时间复杂度 空间复杂度 01 使用切片实现 O(1) O(n) 02 使用1个list实现 O(1) O(n) 03 使用2个list实现 O(n) O(n) 04 使用2个双端队列deque实现 O(n) O(n) type MyStack struct { arr []int } func Constructor() MyStack { return MyStack{} } func (m *MyStack) Push(x int) { m.arr = append(m.arr, x) } func (m *MyStack) Pop() int { if len(m.arr) == 0 { return 0 } last := m.arr[len(m.arr)-1] m.arr = m.arr[0 : len(m.arr)-1] return last } func (m *MyStack) Top() int { if len(m.arr) == 0 { return 0 } return m.arr[len(m.arr)-1] } func (m *MyStack) Empty() bool { if len(m.arr) == 0 { return true } return false } # 使用1个list实现 type MyStack struct { *list.List } func Constructor() MyStack { return MyStack{ list.New(), } } func (m *MyStack) Push(x int) { m.PushBack(x) } func (m *MyStack) Pop() int { if m.Len() == 0 { return -1 } return m.Remove(m.Back()).(int) } func (m *MyStack) Top() int { if m.Len() == 0 { return -1 } return m.Back().Value.(int) } func (m *MyStack) Empty() bool { return m.Len() == 0 } # 使用2个list实现 /* 入栈过程： 1、q1 为空，放入 q2，否则放入 q1 出栈过程： 1、q1为空：依次取出q2中的元素（除了最后一个），并且放入q1中 取出q2中的最后一个元素，返回结果 否则 依次取出q1中的元素（除了最后一个），并且放入q2中 取出q1中的最后一个元素，返回结果 */ type MyStack struct { l1 *list.List l2 *list.List } func Constructor() MyStack { return MyStack{ l1: list.New(), l2: list.New(), } } func (m *MyStack) Push(x int) { if m.l1.Len() == 0 { m.l2.PushBack(x) } else { m.l1.PushBack(x) } } func (m *MyStack) Pop() int { var top int if m.l1.Len() > 0 { for m.l1.Len() > 1 { m.l2.PushBack(m.l1.Remove(m.l1.Front())) } top = m.l1.Remove(m.l1.Front()).(int) } else { for m.l2.Len() > 1 { m.l1.PushBack(m.l2.Remove(m.l2.Front())) } top = m.l2.Remove(m.l2.Front()).(int) } return top } func (m *MyStack) Top() int { var top int if m.l1.Len() > 0 { for m.l1.Len() > 1 { m.l2.PushBack(m.l1.Remove(m.l1.Front())) } top = m.l1.Back().Value.(int) m.l2.PushBack(m.l1.Remove(m.l1.Front())) } else { for m.l2.Len() > 1 { m.l1.PushBack(m.l2.Remove(m.l2.Front())) } top = m.l2.Back().Value.(int) m.l1.PushBack(m.l2.Remove(m.l2.Front())) } return top } func (m *MyStack) Empty() bool { return m.l1.Len() == 0 && m.l2.Len() == 0 } # 使用2个双端队列deque实现 type MyStack struct { l1 *Queue l2 *Queue } func Constructor() MyStack { return MyStack{ l1: NewQueue(), l2: NewQueue(), } } func (m *MyStack) Push(x int) { m.l1.Push(x) } func (m *MyStack) Pop() int { if m.l2.Len() == 0 { m.l1, m.l2 = m.l2, m.l1 } for m.l2.Len() > 1 { m.l1.Push(m.l2.Pop()) } return m.l2.Pop() } func (m *MyStack) Top() int { res := m.Pop() m.l1.Push(res) return res } func (m *MyStack) Empty() bool { return (m.l1.Len() + m.l2.Len()) == 0 } type Queue struct { nums []int } func NewQueue() *Queue { return &Queue{ nums: []int{}, } } func (q *Queue) Push(n int) { q.nums = append(q.nums, n) } func (q *Queue) Pop() int { if len(q.nums) == 0 { return 0 } res := q.nums[0] q.nums = q.nums[1:] return res } func (q *Queue) Len() int { return len(q.nums) } func (q *Queue) IsEmpty() bool { return q.Len() == 0 } 226.翻转二叉树(2) 题目 翻转一棵二叉树。 示例： 输入： 4 / \\ 2 7 / \\ / \\ 1 3 6 9 输出： 4 / \\ 7 2 / \\ / \\ 9 6 3 1 备注: 这个问题是受到 Max Howell 的 原问题 启发的 ： 谷歌：我们90％的工程师使用您编写的软件(Homebrew)， 但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(n) 02 迭代 O(n) O(n) func invertTree(root *TreeNode) *TreeNode { if root == nil || (root.Left == nil && root.Right == nil) { return root } root.Left, root.Right = invertTree(root.Right), invertTree(root.Left) return root } # func invertTree(root *TreeNode) *TreeNode { if root == nil { return root } var queue []*TreeNode queue = append(queue, root) for len(queue) > 0 { node := queue[0] queue = queue[1:] node.Left, node.Right = node.Right, node.Left if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } return root } 231.2的幂(3) 题目 给定一个整数，编写一个函数来判断它是否是 2 的幂次方。 示例 1:输入: 1 输出: true 解释: 2^0 = 1 示例 2:输入: 16 输出: true 解释: 2^4 = 16 示例 3:输入: 218 输出: false 解题思路 No. 思路 时间复杂度 空间复杂度 01 迭代 O(log(n)) O(1) 02 位运算 O(1) O(1) 03 递归 O(log(n)) O(log(n)) func isPowerOfTwo(n int) bool { if n 1 { if n%2 == 1 { return false } n = n / 2 } return true } # func isPowerOfTwo(n int) bool { if n 232.用栈实现队列(3) 题目 使用栈实现队列的下列操作： push(x) -- 将一个元素放入队列的尾部。 pop() -- 从队列首部移除元素。 peek() -- 返回队列首部的元素。 empty() -- 返回队列是否为空。 示例: MyQueue queue = new MyQueue(); queue.push(1); queue.push(2); queue.peek(); // 返回 1 queue.pop(); // 返回 1 queue.empty(); // 返回 false 说明: 你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。 解题思路 No. 思路 时间复杂度 空间复杂度 01 使用切片实现 O(1) O(n) 02 使用2个栈实现 O(n) O(n) 03 使用2个切片实现 O(n) O(n) type MyQueue struct { a []int } func Constructor() MyQueue { return MyQueue{} } func (m *MyQueue) Push(x int) { m.a = append(m.a, x) } func (m *MyQueue) Pop() int { if len(m.a) == 0 { return 0 } first := m.a[0] m.a = m.a[1:] return first } func (m *MyQueue) Peek() int { if len(m.a) == 0 { return 0 } return m.a[0] } func (m *MyQueue) Empty() bool { if len(m.a) == 0 { return true } return false } # 使用2个栈实现 /* 入队: 直接入栈a 出队: 栈b为空，则把栈a中全部数据出栈进入栈b，然后出栈b,不为空直接出栈b */ type MyQueue struct { a, b *Stack } func Constructor() MyQueue { return MyQueue{ a: NewStack(), b: NewStack(), } } func (m *MyQueue) Push(x int) { m.a.Push(x) } func (m *MyQueue) Pop() int { if m.b.Len() == 0 { for m.a.Len() > 0 { m.b.Push(m.a.Pop()) } } return m.b.Pop() } func (m *MyQueue) Peek() int { res := m.Pop() m.b.Push(res) return res } func (m *MyQueue) Empty() bool { return m.a.Len() == 0 && m.b.Len() == 0 } type Stack struct { nums []int } func NewStack() *Stack { return &Stack{ nums: []int{}, } } func (s *Stack) Push(n int) { s.nums = append(s.nums, n) } func (s *Stack) Pop() int { res := s.nums[len(s.nums)-1] s.nums = s.nums[:len(s.nums)-1] return res } func (s *Stack) Len() int { return len(s.nums) } func (s *Stack) IsEmpty() bool { return s.Len() == 0 } # 使用2个切片实现 type MyQueue struct { a []int b []int } func Constructor() MyQueue { return MyQueue{} } func (m *MyQueue) Push(x int) { m.a = append(m.a, x) } func (m *MyQueue) Pop() int { m.Peek() temp := m.b[len(m.b)-1] m.b = m.b[:len(m.b)-1] return temp } func (m *MyQueue) Peek() int { if len(m.b) == 0 { for len(m.a) > 0 { m.b = append(m.b, m.a[len(m.a)-1]) m.a = m.a[:len(m.a)-1] } } if len(m.b) == 0 { return -1 } return m.b[len(m.b)-1] } func (m *MyQueue) Empty() bool { return len(m.a) == 0 && len(m.b) == 0 } 234.回文链表(4) 题目 请判断一个链表是否为回文链表。 示例 1:输入: 1->2 输出: false 示例 2:输入: 1->2->2->1 输出: true 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组辅助 O(n) O(n) 02 快慢指针反转链表 O(n) O(1) 03 栈辅助 O(n) O(n) 04 递归 O(n) O(n) func isPalindrome(head *ListNode) bool { m := make([]int, 0) for head != nil { m = append(m, head.Val) head = head.Next } i, j := 0, len(m)-1 for i 235.二叉搜索树的最近公共祖先(2) 题目 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x， 满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5] 示例 1:输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 示例 2:输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 输出: 2 解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉搜索树中。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(log(n)) O(log(n)) 02 迭代 O(log(n)) O(1) func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if p.Val > root.Val && q.Val > root.Val{ return lowestCommonAncestor(root.Right, p, q) }else if p.Val root.Val && q.Val > root.Val{ root = root.Right }else if p.Val 237.删除链表中的节点(1) 题目 请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。 现有一个链表 -- head = [4,5,1,9]，它可以表示为: 示例 1: 输入: head = [4,5,1,9], node = 5 输出: [4,1,9] 解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9. 示例 2:输入: head = [4,5,1,9], node = 1 输出: [4,5,9] 解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9. 说明: 链表至少包含两个节点。 链表中所有节点的值都是唯一的。 给定的节点为非末尾节点并且一定是链表中的一个有效节点。 不要从你的函数中返回任何结果。 解题思路 No. 思路 时间复杂度 空间复杂度 01 把当前节点替换成下一个节点 O(1) O(1) func deleteNode(node *ListNode) { node.Val = node.Next.Val node.Next = node.Next.Next } 242.有效的字母异位词(2) 题目 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。 示例 1:输入: s = \"anagram\", t = \"nagaram\"输出: true 示例 2:输入: s = \"rat\", t = \"car\"输出: false 说明:你可以假设字符串只包含小写字母。 进阶:如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(1) 02 排序比较 O(nlog(n)) O(n) func isAnagram(s string, t string) bool { if len(s) != len(t) { return false } sr := []rune(s) tr := []rune(t) rec := make(map[rune]int, len(sr)) for i := range sr { rec[sr[i]]++ rec[tr[i]]-- } for _, n := range rec { if n != 0 { return false } } return true } # func isAnagram(s string, t string) bool { if len(s) != len(t) { return false } sArr := make([]int, len(s)) tArr := make([]int, len(t)) for i := 0; i 257.二叉树的所有路径(2) 题目 给定一个二叉树，返回所有从根节点到叶子节点的路径。 说明: 叶子节点是指没有子节点的节点。 示例: 输入: 1 / \\ 2 3 \\ 5 输出: [\"1->2->5\", \"1->3\"] 解释: 所有根节点到叶子节点的路径为: 1->2->5, 1->3 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 迭代 O(n) O(n) # func binaryTreePaths(root *TreeNode) []string { if root == nil { return nil } res := make([]string, 0) var dfs func(string, *TreeNode) dfs = func(pre string, root *TreeNode) { if pre == \"\" { pre = strconv.Itoa(root.Val) } else { pre += \"->\" + strconv.Itoa(root.Val) } if root.Left != nil { dfs(pre, root.Left) } if root.Right != nil { dfs(pre, root.Right) } if root.Left == nil && root.Right == nil { res = append(res, pre) } } dfs(\"\", root) return res } # func binaryTreePaths(root *TreeNode) []string { res := make([]string, 0) if root == nil { return res } var queue []*TreeNode var stringQueue []string queue = append(queue, root) stringQueue = append(stringQueue, strconv.Itoa(root.Val)) for len(queue) > 0 { node := queue[0] path := stringQueue[0] queue = queue[1:] stringQueue = stringQueue[1:] if node.Left == nil && node.Right == nil { res = append(res, path) } if node.Left != nil { queue = append(queue, node.Left) stringQueue = append(stringQueue, path+\"->\"+strconv.Itoa(node.Left.Val)) } if node.Right != nil { queue = append(queue, node.Right) stringQueue = append(stringQueue, path+\"->\"+strconv.Itoa(node.Right.Val)) } } return res } 258.各位相加(4) 题目 给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。 示例: 输入: 38 输出: 2 解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于 2 是一位数，所以返回 2。 进阶: 你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 找规律1 O(1) O(1) 02 找规律2 O(1) O(1) 03 模拟计算-字符串 O(log(n)) O(1) 04 模拟计算-递归 O(log(n)) O(log(n)) # 找规律1 func addDigits(num int) int { if num = 10 { num = sumDigits(num) } return num } func sumDigits(num int) int { sumVal := 0 str := strconv.Itoa(num) for i := range str { sumVal = sumVal + int(str[i]-'0') } return sumVal } # 模拟计算-递归 func addDigits(num int) int { sum := 0 for num != 0 { sum = sum + num%10 num = num / 10 } if sum/10 == 0 { return sum } return addDigits(sum) } 263.丑数(2) 题目 丑数就是只包含质因数 2, 3, 5 的正整数。 示例 1:输入: 6 输出: true 解释: 6 = 2 × 3 示例 2:输入: 8 输出: true 解释: 8 = 2 × 2 × 2 示例 3: 输入: 14 输出: false 解释: 14 不是丑数，因为它包含了另外一个质因数 7。 说明： 1 是丑数。 输入不会超过 32 位有符号整数的范围: [−231, 231 − 1]。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(log(n)) O(log(n)) 02 迭代 O(log(n)) O(1) func isUgly(num int) bool { if num 268.缺失数字(5) 题目 给定一个包含 0, 1, 2, ..., n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。 示例 1:输入: [3,0,1]输出: 2 示例 2:输入: [9,6,4,2,3,5,7,0,1] 输出: 8 说明:你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现? 解题思路 No. 思路 时间复杂度 空间复杂度 01 数学计算 O(n) O(1) 02 排序遍历 O(nlog(n)) O(1) 03 异或-位运算 O(n) O(1) 04 交换排序(就地排序) O(n) O(1) 05 哈希辅助 O(n) O(n) func missingNumber(nums []int) int { n := len(nums) sum := n * (n + 1) / 2 for i := 0; i 278.第一个错误的版本(2) 题目 你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。 由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。 假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。 实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。 示例: 给定 n = 5，并且 version = 4 是第一个错误的版本。 调用 isBadVersion(3) -> false 调用 isBadVersion(5) -> true 调用 isBadVersion(4) -> true 所以，4 是第一个错误的版本。 解题思路 No. 思路 时间复杂度 空间复杂度 01 二分查找 O(log(n)) O(1) 02 二分查找 O(log(n)) O(1) func firstBadVersion(n int) int { low := 1 high := n for low 283.移动零(3) 题目 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例: 输入: [0,1,0,3,12] 输出: [1,3,12,0,0] 说明: 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。 解题思路 No. 思路 时间复杂度 空间复杂度 01 前移补零 O(n) O(1) 02 遇零交换 O(n) O(1) 03 数组辅助 O(n) O(n) func moveZeroes(nums []int) { length := 0 for i := 0; i 290.单词规律(2) 题目 给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。 这里的 遵循 指完全匹配， 例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。 示例1:输入: pattern = \"abba\", str = \"dog cat cat dog\"输出: true 示例 2:输入:pattern = \"abba\", str = \"dog cat cat fish\"输出: false 示例 3:输入: pattern = \"aaaa\", str = \"dog cat cat dog\"输出: false 示例 4:输入: pattern = \"abba\", str = \"dog dog dog dog\" 输出: false 说明: 你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母。 解题思路 No. 思路 时间复杂度 空间复杂度 01 双哈希相互映射 O(n) O(n) 02 单哈希相互映射 O(n) O(n) func wordPattern(pattern string, str string) bool { pa := strings.Split(pattern, \"\") sa := strings.Split(str, \" \") if len(pa) != len(sa) { return false } length := len(pa) pMap := make(map[string]string, length) sMap := make(map[string]string, length) for i := 0; i 292.Nim 游戏(1) 题目 你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。 你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。 示例: 输入: 4 输出: false 解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛； 因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。 解题思路 No. 思路 时间复杂度 空间复杂度 01 推理 O(1) O(1) func canWinNim(n int) bool { // return n&3 != 0 return n%4 != 0 } 299.猜数字游戏(2) 题目 你正在和你的朋友玩 猜数字（Bulls and Cows）游戏：你写下一个数字让你的朋友猜。 每次他猜测后，你给他一个提示，告诉他有多少位数字和确切位置都猜对了（称为“Bulls”, 公牛）， 有多少位数字猜对了但是位置不对（称为“Cows”, 奶牛）。 你的朋友将会根据提示继续猜，直到猜出秘密数字。 请写出一个根据秘密数字和朋友的猜测数返回提示的函数，用 A 表示公牛，用 B 表示奶牛。 请注意秘密数字和朋友的猜测数都可能含有重复数字。 示例 1:输入: secret = \"1807\", guess = \"7810\"输出: \"1A3B\" 解释: 1 公牛和 3 奶牛。公牛是 8，奶牛是 0, 1 和 7。 示例 2:输入: secret = \"1123\", guess = \"0111\"输出: \"1A1B\" 解释: 朋友猜测数中的第一个 1 是公牛，第二个或第三个 1 可被视为奶牛。 说明: 你可以假设秘密数字和朋友的猜测数都只包含数字，并且它们的长度永远相等。 解题思路 No. 思路 时间复杂度 空间复杂度 01 双哈希辅助 O(n) O(1) 02 单哈希辅助 O(n) O(1) func getHint(secret string, guess string) string { length := len(secret) right := 0 wrongLoc := 0 m := make(map[byte]int) n := make(map[byte]int) for i := 0; i 0{ wrongNum = wrongNum + m[i] } } // wrongLoc = 总数 - 猜对的数 - 猜错的数 wrongLoc := length - right - wrongNum return fmt.Sprintf(\"%dA%dB\", right, wrongLoc) } 0201-0300-Medium 201.数字范围按位与(2) 题目 给定范围 [m, n]，其中 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 位运算 O(1) O(1) 02 位运算 O(1) O(1) func rangeBitwiseAnd(m int, n int) int { count := 0 // 找m,n的32位二进制，前面相同的位数，然后后面添0 for m != n { count++ // 同时右移去除末尾1位 m = m >> 1 n = n >> 1 } return m 207.课程表(2) 题目 你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1] 给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？ 示例 1:输入: 2, [[1,0]] 输出: true 解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。 示例 2:输入: 2, [[1,0],[0,1]] 输出: false 解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前， 你还应先完成课程 1。这是不可能的。 提示： 输入的先决条件是由 边缘列表 表示的图形，而不是 邻接矩阵 。详情请参见图的表示法。 你可以假定输入的先决条件中没有重复的边。 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 深度优先搜索-判断环 O(n) O(n) 02 广度优先搜索-拓扑排序 O(n) O(n) var res bool var visited []int var path []int var edges [][]int func canFinish(numCourses int, prerequisites [][]int) bool { res = true edges = make([][]int, numCourses) // 邻接表 visited = make([]int, numCourses) path = make([]int, 0) for i := 0; i cur prev := prerequisites[i][1] cur := prerequisites[i][0] edges[prev] = append(edges[prev], cur) } for i := 0; i cur prev := prerequisites[i][1] cur := prerequisites[i][0] edges[prev] = append(edges[prev], cur) inEdges[cur]++ // 入度 } // 入度为0 queue := make([]int, 0) for i := 0; i 0 { start := queue[0] queue = queue[1:] path = append(path, start) for i := 0; i 208.实现Trie(前缀树)(2) 题目 实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。 示例:Trie trie = new Trie(); trie.insert(\"apple\"); trie.search(\"apple\"); // 返回 true trie.search(\"app\"); // 返回 false trie.startsWith(\"app\"); // 返回 true trie.insert(\"app\"); trie.search(\"app\"); // 返回 true 说明:你可以假设所有的输入都是由小写字母 a-z 构成的。 保证所有输入均为非空字符串。 解题思路 No. 思路 时间复杂度 空间复杂度 01 trie树 O(n) O(n) 02 trie树 O(n) O(n) type Trie struct { next [26]*Trie ending int } func Constructor() Trie { return Trie{ next: [26]*Trie{}, ending: 0, } } func (this *Trie) Insert(word string) { temp := this for _, v := range word { value := v - 'a' if temp.next[value] == nil { temp.next[value] = &Trie{ next: [26]*Trie{}, ending: 0, } } temp = temp.next[value] } temp.ending++ } func (this *Trie) Search(word string) bool { temp := this for _, v := range word { value := v - 'a' if temp = temp.next[value]; temp == nil { return false } } if temp.ending > 0 { return true } return false } func (this *Trie) StartsWith(prefix string) bool { temp := this for _, v := range prefix { value := v - 'a' if temp = temp.next[value]; temp == nil { return false } } return true } # 2 type Trie struct { next map[byte]*Trie ending int } /** Initialize your data structure here. */ func Constructor() Trie { return Trie{ next: make(map[byte]*Trie), ending: 0, } } /** Inserts a word into the trie. */ func (this *Trie) Insert(word string) { temp := this for _, v := range word { value := byte(v - 'a') if temp.next[value] == nil { temp.next[value] = &Trie{ next: make(map[byte]*Trie), ending: 0, } } temp = temp.next[value] } temp.ending++ } /** Returns if the word is in the trie. */ func (this *Trie) Search(word string) bool { temp := this for _, v := range word { value := byte(v - 'a') if temp = temp.next[value]; temp == nil { return false } } if temp.ending > 0 { return true } return false } /** Returns if there is any word in the trie that starts with the given prefix. */ func (this *Trie) StartsWith(prefix string) bool { temp := this for _, v := range prefix { value := byte(v - 'a') if temp = temp.next[value]; temp == nil { return false } } return true } 209.长度最小的子数组(3) 题目 给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组， 并返回其长度。如果不存在符合条件的子数组，返回 0。 示例：输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。 进阶：如果你已经完成了 O(n) 时间复杂度的解法, 请尝试 O(n log n) 时间复杂度的解法。 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法 O(n^2) O(1) 02 前缀和-二分查找 O(nlog(n)) O(n) 03 双指针 O(n) O(1) func minSubArrayLen(s int, nums []int) int { res := math.MaxInt32 for i := 0; i = s { if res > j-i+1 { res = j - i + 1 } break } } } if res == math.MaxInt32 { return 0 } return res } # 2 func minSubArrayLen(s int, nums []int) int { res := math.MaxInt32 arr := make([]int, len(nums)+1) for i := 1; i index-i+1 { res = index - i + 1 } } } if res == math.MaxInt32 { return 0 } return res } # 3 func minSubArrayLen(s int, nums []int) int { res := math.MaxInt32 i, j := 0, 0 sum := 0 for ; j = s { if res > j-i+1 { res = j - i + 1 } sum = sum - nums[i] i++ } } if res == math.MaxInt32 { return 0 } return res } 210.课程表II(2) 题目 现在你总共有 n 门课需要选，记为 0 到 n-1。 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1] 给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。 可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。 示例 1:输入: 2, [[1,0]] 输出: [0,1] 解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。 示例 2:输入: 4, [[1,0],[2,0],[3,1],[3,2]] 输出: [0,1,2,3] or [0,2,1,3] 解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。 并且课程 1 和课程 2 都应该排在课程 0 之后。 因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。 说明:输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。 你可以假定输入的先决条件中没有重复的边。 提示: 这个问题相当于查找一个循环是否存在于有向图中。 如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。 通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。 拓扑排序也可以通过 BFS 完成。 解题思路 No. 思路 时间复杂度 空间复杂度 01 深度优先搜索 O(n) O(n) 02 广度优先搜索-拓扑排序 O(n) O(n) var res bool var visited []int var path []int var edges [][]int func findOrder(numCourses int, prerequisites [][]int) []int { res = true edges = make([][]int, numCourses) // 邻接表 visited = make([]int, numCourses) path = make([]int, 0) for i := 0; i cur prev := prerequisites[i][1] cur := prerequisites[i][0] edges[prev] = append(edges[prev], cur) } for i := 0; i cur prev := prerequisites[i][1] cur := prerequisites[i][0] edges[prev] = append(edges[prev], cur) inEdges[cur]++ // 入度 } // 入度为0 queue := make([]int, 0) for i := 0; i 0 { start := queue[0] queue = queue[1:] path = append(path, start) for i := 0; i 211.添加与搜索单词-数据结构设计(1) 题目 如果数据结构中有任何与word匹配的字符串，则bool search（word）返回true，否则返回false。 单词可能包含点“。” 点可以与任何字母匹配的地方。 请你设计一个数据结构，支持 添加新单词 和 查找字符串是否与任何先前添加的字符串匹配 。 实现词典类 WordDictionary ： WordDictionary() 初始化词典对象 void addWord(word) 将 word 添加到数据结构中，之后可以对它进行匹配 bool search(word) 如果数据结构中存在字符串与 word 匹配，则返回 true ； 否则，返回 false 。word 中可能包含一些 '.' ，每个 . 都可以表示任何一个字母。 示例：输入： [\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"] [[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]] 输出：[null,null,null,null,false,true,true,true] 解释： WordDictionary wordDictionary = new WordDictionary(); wordDictionary.addWord(\"bad\"); wordDictionary.addWord(\"dad\"); wordDictionary.addWord(\"mad\"); wordDictionary.search(\"pad\"); // return False wordDictionary.search(\"bad\"); // return True wordDictionary.search(\".ad\"); // return True wordDictionary.search(\"b..\"); // return True 提示：1 解题思路 No. 思路 时间复杂度 空间复杂度 01 trie树 O(n) O(n) type Trie struct { next [26]*Trie ending int } func (this *Trie) Insert(word string) { temp := this for _, v := range word { value := v - 'a' if temp.next[value] == nil { temp.next[value] = &Trie{ next: [26]*Trie{}, ending: 0, } } temp = temp.next[value] } temp.ending++ } func (this *Trie) Search(word string, k int) bool { temp := this for i := k; i 0 { return true } return false } type WordDictionary struct { trie *Trie } func Constructor() WordDictionary { return WordDictionary{trie: &Trie{}} } func (this *WordDictionary) AddWord(word string) { this.trie.Insert(word) } func (this *WordDictionary) Search(word string) bool { return this.trie.Search(word, 0) } 213.打家劫舍II(3) 题目 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。 这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。 同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1:输入: [2,3,2] 输出: 3 解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 示例 2:输入: [1,2,3,1] 输出: 4 解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。 偷窃到的最高金额 = 1 + 3 = 4 。 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n) O(n) 02 动态规划 O(n) O(n) 03 动态规划 O(n) O(1) func rob(nums []int) int { n := len(nums) if n == 0 { return 0 } else if n == 1 { return nums[0] } dp1 := make([]int, n) // 从第一家开始打劫，最后一家不可选 dp2 := make([]int, n) // 从第二家开始打劫，最后一家可以选 dp1[0] = nums[0] dp1[1] = max(nums[0], nums[1]) dp2[0] = 0 dp2[1] = nums[1] for i := 2; i b { return a } return b } # 2 func rob(nums []int) int { n := len(nums) if n == 0 { return 0 } else if n == 1 { return nums[0] } else if n == 2 { return max(nums[0], nums[1]) } return max(getMax(nums[:n-1]), getMax(nums[1:])) } func getMax(nums []int) int { n := len(nums) dp := make([]int, n+1) dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i := 2; i b { return a } return b } # 3 func rob(nums []int) int { n := len(nums) if n == 0 { return 0 } else if n == 1 { return nums[0] } else if n == 2 { return max(nums[0], nums[1]) } return max(getMax(nums[:n-1]), getMax(nums[1:])) } func getMax(nums []int) int { var a, b int for i, v := range nums { if i%2 == 0 { a = max(a+v, b) } else { b = max(a, b+v) } } return max(a, b) } func max(a, b int) int { if a > b { return a } return b } 215.数组中的第K个最大元素(3) 题目 在未排序的数组中找到第 k 个最大的元素。 请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例 1:输入: [3,2,1,5,6,4] 和 k = 2 输出: 5 示例 2:输入: [3,2,3,1,2,4,5,5,6] 和 k = 4 输出: 4 说明:你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序 O(nlog(n)) O(1) 02 堆排序 O(nlog(n)) O(log(n)) 03 快排 O(n) O(log(n)) func findKthLargest(nums []int, k int) int { sort.Ints(nums) return nums[len(nums)-k] } # 2 func findKthLargest(nums []int, k int) int { heapSize := len(nums) buildMaxHeap(nums, heapSize) for i := len(nums) - 1; i >= len(nums)-k+1; i-- { nums[0], nums[i] = nums[i], nums[0] heapSize-- maxHeapify(nums, 0, heapSize) } return nums[0] } func buildMaxHeap(a []int, heapSize int) { for i := heapSize / 2; i >= 0; i-- { maxHeapify(a, i, heapSize) } } func maxHeapify(a []int, i, heapSize int) { l, r, largest := i*2+1, i*2+2, i if l a[largest] { largest = l } if r a[largest] { largest = r } if largest != i { a[i], a[largest] = a[largest], a[i] maxHeapify(a, largest, heapSize) } } # 3 func findKthLargest(nums []int, k int) int { return findK(nums, 0, len(nums)-1, k) } func findK(nums []int, start, end int, k int) int { if start >= end { return nums[end] } index := partition(nums, start, end) if index+1 == k { return nums[index] } else if index+1 temp { if i != j { nums[i], nums[j] = nums[j], nums[i] } i++ } } nums[i], nums[end] = nums[end], nums[i] return i } 216.组合总和III(1) 题目 找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。 说明： 所有数字都是正整数。 解集不能包含重复的组合。 示例 1:输入: k = 3, n = 7 输出: [[1,2,4]] 示例 2:输入: k = 3, n = 9 输出: [[1,2,6], [1,3,5], [2,3,4]] 解题思路 No. 思路 时间复杂度 空间复杂度 01 回溯算法 O(n*C(9,n)) O(n) var res [][]int func combinationSum3(k int, n int) [][]int { res = make([][]int, 0) arr := make([]int, 0) dfs(k, n, 1, arr) return res } func dfs(k, n int, level int, arr []int) { if k == 0 || n 220.存在重复元素III(2) 题目 在整数数组 nums 中，是否存在两个下标 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值小于等于 t ， 且满足 i 和 j 的差的绝对值也小于等于 ķ 。 如果存在则返回 true，不存在返回 false。 示例 1:输入: nums = [1,2,3,1], k = 3, t = 0 输出: true 示例 2:输入: nums = [1,0,1,1], k = 1, t = 2 输出: true 示例 3:输入: nums = [1,5,9,1,5,9], k = 2, t = 3 输出: false 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法 O(n^2) O(1) 02 桶 O(n) O(n) func containsNearbyAlmostDuplicate(nums []int, k int, t int) bool { if len(nums) = k { // 满足i和j的差的绝对值也小于等于ķ delete(m, getKey(nums[i-k], width)) } } return false } func getKey(value, width int) int { if value b { return a - b } return b - a } 221.最大正方形(3) 题目 在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。 示例:输入: 1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0 输出: 4 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法 O(n^4) O(1) 02 动态规划 O(n^2) O(n^2) 03 动态规划 O(n^2) O(1) func maximalSquare(matrix [][]byte) int { if len(matrix) == 0 || len(matrix[0]) == 0 { return 0 } res := 0 n, m := len(matrix), len(matrix[0]) for i := 0; i b { return a } return b } func min(a, b int) int { if a > b { return b } return a } # 2 func maximalSquare(matrix [][]byte) int { if len(matrix) == 0 || len(matrix[0]) == 0 { return 0 } res := 0 n, m := len(matrix), len(matrix[0]) dp := make([][]int, n) for i := 0; i b { return a } return b } func min(a, b int) int { if a > b { return b } return a } # 3 func maximalSquare(matrix [][]byte) int { if len(matrix) == 0 || len(matrix[0]) == 0 { return 0 } res := 0 n, m := len(matrix), len(matrix[0]) for i := 0; i b { return a } return b } func min(a, b int) int { if a > b { return b } return a } 222.完全二叉树的节点个数(3) 题目 给出一个完全二叉树，求出该树的节点个数。 说明： 完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值， 并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。 示例:输入: 1 / \\ 2 3 / \\ / 4 5 6 输出: 6 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 迭代 O(n) O(n) 03 递归 O(log(n)^2) O(log(n)) func countNodes(root *TreeNode) int { if root == nil { return 0 } return 1 + countNodes(root.Left) + countNodes(root.Right) } # 2 func countNodes(root *TreeNode) int { if root == nil { return 0 } res := 0 queue := make([]*TreeNode, 0) queue = append(queue, root) for len(queue) > 0 { node := queue[0] queue = queue[1:] res++ if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } return res } # 3 func countNodes(root *TreeNode) int { if root == nil { return 0 } left := getLevel(root.Left) right := getLevel(root.Right) if left == right{ return 1 223.矩形面积(1) 题目 在二维平面上计算出两个由直线构成的矩形重叠后形成的总面积。 每个矩形由其左下顶点和右上顶点坐标表示，如图所示。 示例:输入: -3, 0, 3, 4, 0, -1, 9, 2 输出: 45 说明: 假设矩形面积不会超出 int 的范围。 解题思路 No. 思路 时间复杂度 空间复杂度 01 数学计算 O(1) O(1) func computeArea(A int, B int, C int, D int, E int, F int, G int, H int) int { left, right := max(A, E), min(C, G) bottom, top := max(B, F), min(D, H) area1, area2 := (C-A)*(D-B), (G-E)*(H-F) if left b { return a } return b } func min(a, b int) int { if a > b { return b } return a } 227.基本计算器II 题目 实现一个基本的计算器来计算一个简单的字符串表达式的值。 字符串表达式仅包含非负整数，+， - ，*，/ 四种运算符和空格 。 整数除法仅保留整数部分。 示例 1:输入: \"3+2*2\" 输出: 7 示例 2:输入: \" 3/2 \" 输出: 1 示例 3:输入: \" 3+5 / 2 \" 输出: 5 说明： 你可以假设所给定的表达式都是有效的。 请不要使用内置的库函数 eval。 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n) O(n) 228.汇总区间(2) 题目 给定一个无重复元素的有序整数数组，返回数组区间范围的汇总。 示例 1:输入: [0,1,2,4,5,7]输出: [\"0->2\",\"4->5\",\"7\"] 解释: 0,1,2 可组成一个连续的区间; 4,5 可组成一个连续的区间。 示例 2:输入: [0,2,3,4,6,8,9]输出: [\"0\",\"2->4\",\"6\",\"8->9\"] 解释: 2,3,4 可组成一个连续的区间; 8,9 可组成一个连续的区间。 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n) O(n) 02 双指针 O(n) O(n) func summaryRanges(nums []int) []string { res := make([]string, 0) if len(nums) == 0 { return res } i, j := 0, 1 for j 1 { str = strconv.Itoa(nums[i]) + \"->\" + strconv.Itoa(nums[j-1]) } else { str = strconv.Itoa(nums[i]) } res = append(res, str) i = j } j++ } if j == len(nums) { str := \"\" if j-i > 1 { str = strconv.Itoa(nums[i]) + \"->\" + strconv.Itoa(nums[j-1]) } else { str = strconv.Itoa(nums[i]) } res = append(res, str) } return res } # 2 func summaryRanges(nums []int) []string { res := make([]string, 0) if len(nums) == 0 { return res } nums = append(nums, nums[0]) i, j := 0, 1 index := 0 res = append(res, strconv.Itoa(nums[i])) for j = 1; j 1 { str := strconv.Itoa(nums[i]) + \"->\" + strconv.Itoa(nums[j-1]) res[index] = str } res = append(res, strconv.Itoa(nums[j])) i = j index++ } } return res[:index] } 229.求众数II(2) 题目 给定一个大小为 n 的数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。 说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1)。 示例 1:输入: [3,2,3] 输出: [3] 示例 2:输入: [1,1,1,3,3,2,2,2] 输出: [1,2] 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(n) 02 摩尔投票法 O(n) O(1) func majorityElement(nums []int) []int { m := make(map[int]int) res := make([]int, 0) for i := 0; i len(nums)/3 { res = append(res, k) } } return res } # 2 func majorityElement(nums []int) []int { res := make([]int, 0) if len(nums) == 0 { return res } a, b := nums[0], nums[0] countA, countB := 0, 0 for i := 0; i len(nums)/3 { res = append(res, a) } if countB > len(nums)/3 { res = append(res, b) } return res } 230.二叉搜索树中第K小的元素(3) 题目 给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。 说明：你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。 示例 1:输入: root = [3,1,4,null,2], k = 1 3 / \\ 1 4 \\ 2 输出: 1 示例 2:输入: root = [5,3,6,2,4,null,null,1], k = 3 5 / \\ 3 6 / \\ 2 4 / 1 输出: 3 进阶：如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值， 你将如何优化 kthSmallest 函数？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 迭代 O(n) O(n) 03 递归 O(n) O(n) var res int var index int func kthSmallest(root *TreeNode, k int) int { res = 0 index = k dfs(root) return res } func dfs(root *TreeNode) { if root != nil { dfs(root.Left) index-- if index == 0 { res = root.Val return } dfs(root.Right) } } # 2 func kthSmallest(root *TreeNode, k int) int { res := 0 stack := make([]*TreeNode, 0) for k > 0 { for root != nil { stack = append(stack, root) root = root.Left } root = stack[len(stack)-1] stack = stack[:len(stack)-1] res = root.Val k-- root = root.Right } return res } # 3 var res []int func kthSmallest(root *TreeNode, k int) int { res = make([]int, 0) dfs(root) return res[k-1] } func dfs(root *TreeNode) { if root != nil { dfs(root.Left) res = append(res, root.Val) dfs(root.Right) } } 236.二叉树的最近公共祖先(2) 题目 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x， 满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4] 示例 1:输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出: 3 解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 示例 2:输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出: 5 解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 说明:所有节点的值都是唯一的。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 递归 O(n) O(n) func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if root == nil { return nil } if root.Val == p.Val || root.Val == q.Val { return root } left := lowestCommonAncestor(root.Left, p, q) right := lowestCommonAncestor(root.Right, p, q) if left != nil && right != nil { return root } if left == nil { return right } return left } # 2 var m map[int]*TreeNode func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if root == nil { return nil } m = make(map[int]*TreeNode) dfs(root) visited := make(map[int]bool) for p != nil { visited[p.Val] = true p = m[p.Val] } for q != nil { if visited[q.Val] == true { return q } q = m[q.Val] } return nil } func dfs(root *TreeNode) { if root == nil { return } if root.Left != nil { m[root.Left.Val] = root dfs(root.Left) } if root.Right != nil { m[root.Right.Val] = root dfs(root.Right) } } 238.除自身以外数组的乘积(3) 题目 给你一个长度为 n 的整数数组 nums，其中 n > 1，返回输出数组 output ， 其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。 示例:输入: [1,2,3,4] 输出: [24,12,8,6] 提示：题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。 说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。 进阶：你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。） 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组辅助 O(n) O(n) 02 暴力法 O(n^2) O(n) 03 遍历 O(n) O(n) func productExceptSelf(nums []int) []int { left := make([]int, len(nums)) right := make([]int, len(nums)) res := make([]int, 0) left[0] = 1 right[len(nums)-1] = 1 for i := 1; i = 0; i-- { right[i] = right[i+1] * nums[i+1] } for i := 0; i = 0; i-- { res[i] = res[i] * value value = value * nums[i] } return res } 240.搜索二维矩阵II(6) 题目 编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性： 每行的元素从左到右升序排列。 每列的元素从上到下升序排列。 示例:现有矩阵 matrix 如下： [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] 给定 target = 5，返回 true。 给定 target = 20，返回 false。 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法 O(n^2) O(1) 02 暴力法-优化 O(n^2) O(1) 03 二分查找 O(nlog(n)) O(1) 04 左下角查找 O(n) O(1) 05 右上角查找 O(n) O(1) 06 内置函数 O(n^2) O(1) func searchMatrix(matrix [][]int, target int) bool { if len(matrix) == 0 { return false } if len(matrix[0]) == 0 { return false } for i := 0; i = target { for j := 0; j = target { res := binarySearch(matrix[i], target) if res == true { return true } } } return false } func binarySearch(arr []int, target int) bool { left := 0 right := len(arr) - 1 for left target { right = mid - 1 } else { left = mid + 1 } } return false } # 4 func searchMatrix(matrix [][]int, target int) bool { if len(matrix) == 0 { return false } if len(matrix[0]) == 0 { return false } i := len(matrix) - 1 j := 0 for i >= 0 && j target { i-- } else { j++ } } return false } # 5 func searchMatrix(matrix [][]int, target int) bool { if len(matrix) == 0 { return false } if len(matrix[0]) == 0 { return false } i := 0 j := len(matrix[0]) - 1 for j >= 0 && i target { j-- } else { i++ } } return false } # 6 func searchMatrix(matrix [][]int, target int) bool { if len(matrix) == 0 { return false } if len(matrix[0]) == 0 { return false } for i := 0; i 241.为运算表达式设计优先级 题目 给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。 你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。 示例 1:输入: \"2-1-1\" 输出: [0, 2] 解释: ((2-1)-1) = 0 (2-(1-1)) = 2 示例 2:输入: \"2*3-4*5\" 输出: [-34, -14, -10, -10, 10] 解释: (2*(3-(4*5))) = -34 ((2*3)-(4*5)) = -14 ((2*(3-4))*5) = -10 (2*((3-4)*5)) = -10 (((2*3)-4)*5) = 10 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n) O(n) 260.只出现一次的数字III(3) 题目 给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。 示例 : 输入: [1,2,1,3,2,5] 输出: [3,5] 注意： 结果输出的顺序并不重要，对于上面的例子， [5, 3] 也是正确答案。 你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(n) 02 位运算 O(n) O(1) 03 位运算 O(n) O(1) func singleNumber(nums []int) []int { res := make([]int, 0) m := make(map[int]int) for i := 0; i > 1 b = b 264.丑数II(1) 题目 编写一个程序，找出第 n 个丑数。 丑数就是质因数只包含 2, 3, 5 的正整数。 示例:输入: n = 10 输出: 12 解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。 说明: 1 是丑数。 n 不超过1690。 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n) O(n) func nthUglyNumber(n int) int { dp := make([]int, n) dp[0] = 1 // 丑数*2或3或5之后还是丑数 idx2, idx3, idx5 := 0, 0, 0 for i := 1; i b { return b } return a } 274.H指数(2) 题目 给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 h 指数。 h 指数的定义：h 代表“高引用次数”（high citations）， 一名科研人员的 h 指数是指他（她）的 （N 篇论文中）总共有 h 篇论文分别被引用了至少 h 次。 （其余的 N - h 篇论文每篇被引用次数 不超过 h 次。） 例如：某人的 h 指数是 20，这表示他已发表的论文中，每篇被引用了至少 20 次的论文总共有 20 篇。 示例：输入：citations = [3,0,6,1,5]输出：3 解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。 由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次， 所以她的 h 指数是 3。 提示：如果 h 有多种可能的值，h 指数是其中最大的那个。 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序 O(nlog(n)) O(1) 02 计数 O(n) O(n) func hIndex(citations []int) int { sort.Ints(citations) for i := 0; i = len(citations)-i { return len(citations) - i } } return 0 } # func hIndex(citations []int) int { arr := make([]int, len(citations)+1) for i := 0; i = len(citations) { arr[len(citations)]++ } else { arr[citations[i]]++ } } count := 0 for i := len(citations); i >= 0; i-- { count = count + arr[i] if count >= i { return i } } return 0 } 275.H指数II(2) 题目 给定一位研究者论文被引用次数的数组（被引用次数是非负整数），数组已经按照升序排列。 编写一个方法，计算出研究者的 h 指数。 h 指数的定义: “h 代表“高引用次数”（high citations）， 一名科研人员的 h 指数是指他（她）的 （N 篇论文中）总共有 h 篇论文分别被引用了至少 h 次。 （其余的 N - h 篇论文每篇被引用次数不多于 h 次。）\" 示例:输入: citations = [0,1,3,5,6] 输出: 3 解释: 给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 0, 1, 3, 5, 6 次。 由于研究者有 3 篇论文每篇至少被引用了 3 次，其余两篇论文每篇被引用不多于 3 次， 所以她的 h 指数是 3。 说明:如果 h 有多有种可能的值 ，h 指数是其中最大的那个。 进阶： 这是 H指数 的延伸题目，本题中的 citations 数组是保证有序的。 你可以优化你的算法到对数时间复杂度吗？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 二分查找 O(log(n)) O(1) func hIndex(citations []int) int { for i := 0; i = len(citations)-i { return len(citations) - i } } return 0 } # func hIndex(citations []int) int { left := 0 right := len(citations) - 1 for left len(citations)-mid { right = mid - 1 } else if citations[mid] 279.完全平方数(5) 题目 给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。 你需要让组成和的完全平方数的个数最少。 示例 1:输入: n = 12 输出: 3 解释: 12 = 4 + 4 + 4. 示例 2:输入: n = 13 输出: 2 解释: 13 = 4 + 9. 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n^(3/2)) O(n) 02 动态规划 O(n^(3/2)) O(n) 03 广度优先搜索 O(n^1/2) O(n^1/2) 04 递归 O(n^1/2) O(n^1/2) 05 数学 O(n^1/2) O(1) func numSquares(n int) int { dp := make([]int, n+1) for i := 1; i b { return b } return a } # func numSquares(n int) int { dp := make([]int, n+1) for i := 1; i b { return b } return a } # 3 func numSquares(n int) int { if n == 0 { return 0 } list := make([]int, 0) list = append(list, n) level := 0 for len(list) > 0 { level++ length := len(list) for i := 0; i 0 { return m[n] } if n == 0 { return 0 } count := math.MaxInt32 for i := 1; i*i b { return b } return a } # 5 func numSquares(n int) int { if judge(n) { return 1 } res := n for res%4 == 0 { res = res / 4 } if res%8 == 7 { return 4 } for i := 1; i*i 284.顶端迭代器 题目 解题思路 287.寻找重复数(8) 题目 给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n）， 可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。 示例 1:输入: [1,3,4,2,2] 输出: 2 示例 2:输入: [3,1,3,4,2] 输出: 3 说明： 不能更改原数组（假设数组是只读的）。 只能使用额外的 O(1) 的空间。 时间复杂度小于 O(n^2) 。 数组中只有一个重复的数字，但它可能不止重复出现一次。 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(n) 02 排序 O(nlog(n)) O(1) 03 暴力法 O(n^2) O(1) 04 二分查找 O(nlog(n)) O(1) 05 快慢指针 O(n) O(1) 06 位运算 O(n) O(1) 07 交换 O(n) O(1) 08 负号标记 O(n) O(1) func findDuplicate(nums []int) int { m := make(map[int]int) for i := 0; i 0 { return nums[i] } m[nums[i]] = 1 } return -1 } # 2 func findDuplicate(nums []int) int { sort.Ints(nums) for i := 1; i 0 { arrV[j]++ } if index > 0 && (index&(1 0) { arrI[j]++ } } } for i := 0; i arrI[i] { res = res ^ (1 0 { nums[index] = -1 * nums[index] } else { return abs(nums[i]) } } return 0 } func abs(a int) int { if a >= 0 { return a } return -a } 289.生命游戏(2) 题目 根据 百度百科 ，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。 给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态： 1 即为活细胞（live），或 0 即为死细胞（dead）。 每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律： 如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡； 如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活； 如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡； 如果死细胞周围正好有三个活细胞，则该位置死细胞复活； 根据当前状态，写一个函数来计算面板上所有细胞的下一个（一次更新后的）状态。 下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。 示例：输入： [ [0,1,0], [0,0,1], [1,1,1], [0,0,0] ] 输出： [ [0,0,0], [1,0,1], [0,1,1], [0,1,0] ] 进阶： 你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新： 你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。 本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。 你将如何解决这些问题？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组辅助 O(n^2) O(n^2) 02 遍历 O(n^2) O(1) func gameOfLife(board [][]int) { temp := make([][]int, len(board)) for i := 0; i 3 { temp[i][j] = 0 } if count == 3 && temp[i][j] == 0 { temp[i][j] = 1 } } } copy(board, temp) } # 2 func gameOfLife(board [][]int) { // 0 00 => 死 // 1 01 => 活 // 2 10 => 死=>活 // 3 11 => 活=>死 for i := 0; i 3) && board[i][j] == 1 { board[i][j] = 3 } if count == 3 && board[i][j] == 0 { board[i][j] = 2 } } } for i := 0; i 300.最长上升子序列(2) 题目 给定一个无序的整数数组，找到其中最长上升子序列的长度。 示例:输入: [10,9,2,5,3,7,101,18] 输出: 4 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。 说明:可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。 你算法的时间复杂度应该为 O(n2) 。 进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗? 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n^2) O(n) 02 贪心+二分查找 O(nlog(n)) O(n) /* dp[i] = max(dp[j]+1, dp[i]),其中0 b { return a } return b } # 2 func lengthOfLIS(nums []int) int { if len(nums) 0201-0300-Hard 214.最短回文串(3) 题目 给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。 找到并返回可以用这种方式转换的最短回文串。 示例 1:输入: \"aacecaaa\" 输出: \"aaacecaaa\" 示例 2:输入: \"abcd\" 输出: \"dcbabcd\" 解题思路 No. 思路 时间复杂度 空间复杂度 01 反转比较 O(n^2) O(n) 02 遍历 O(n^2) O(n) 03 manacher O(n^2) O(n) func shortestPalindrome(s string) string { str := reverse(s) i := 0 for i = 0; i = 0; i-- { res = append(res, s[i]) } return string(res) } # 2 func shortestPalindrome(s string) string { i := len(s) for { if isPalindrome(s[:i]) == true { break } i-- } res := s for j := i; j 0; j-- { if str[i-j] != str[i+j] { break } } if j == 0 { index = i break } } res := s for j := index; j 233.数字1的个数(3) 题目 给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。 示例:输入: 13输出: 6 解释: 数字 1 出现在以下数字中: 1, 10, 11, 12, 13 。 解题思路 No. 思路 时间复杂度 空间复杂度 01 找规律-遍历 O(log(n)) O(1) 02 找规律-递归 O(log(n)) O(log(n)) 03 找规律 O(log(n)) O(1) func countDigitOne(n int) int { res := 0 digit := 1 high := n / 10 cur := n % 10 low := 0 for high != 0 || cur != 0 { if cur == 0 { res = res + high*digit } else if cur == 1 { res = res + high*digit + low + 1 } else { res = res + (high+1)*digit } low = low + cur*digit cur = high % 10 high = high / 10 digit = digit * 10 } return res } # 2 func countDigitOne(n int) int { if n = 1 { return 1 } count := 0 if first > 1 { count = int(math.Pow(float64(10), float64(len(str)-1))) } else if first == 1 { count, _ = strconv.Atoi(str[1:]) count = count + 1 } other := first * (len(str) - 1) * int(math.Pow(float64(10), float64(len(str)-2))) numLeft := dfs(str[1:]) return count + numLeft + other } # 3 func countDigitOne(n int) int { if n 239.滑动窗口最大值(3) 题目 给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。 你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回滑动窗口中的最大值。 进阶：你能在线性时间复杂度内解决此题吗？ 示例:输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3 输出: [3,3,5,5,6,7] 解释: 滑动窗口的位置 最大值 --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法 O(n^2) O(n) 02 暴力法-有条件更新最大值 O(n^2) O(n) 03 双端队列 O(n) O(n) 04 堆排序(超时) O(nlog(n)) O(n) func maxSlidingWindow(nums []int, k int) []int { res := make([]int, 0) if len(nums) == 0 { return res } for i := 0; i max { max = nums[j] } } res = append(res, max) } return res } # 2 func maxSlidingWindow(nums []int, k int) []int { res := make([]int, 0) if len(nums) == 0 { return res } max := math.MaxInt32 for i := 0; i max { max = nums[j] } } } else { if nums[i+k-1] > max { max = nums[i+k-1] } } res = append(res, max) } return res } # 3 func maxSlidingWindow(nums []int, k int) []int { res := make([]int, 0) if len(nums) == 0 { return res } // 递减下标 deque := make([]int, 0) for i := 0; i 0 && nums[i] >= nums[deque[len(deque)-1]] { deque = deque[:len(deque)-1] } deque = append(deque, i) } for i := k; i 0 && nums[i] >= nums[deque[len(deque)-1]] { deque = deque[:len(deque)-1] } if len(deque) > 0 && deque[0] i[y] } func (i IntHeap) Swap(x, y int) { i[x], i[y] = i[y], i[x] } func (i *IntHeap) Push(v interface{}) { *i = append(*i, v.(int)) } func (i *IntHeap) Pop() interface{} { value := (*i)[len(*i)-1] *i = (*i)[:len(*i)-1] return value } func (i *IntHeap) Remove(x interface{}) { for j := 0; j 295.数据流的中位数(1) 题目 中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。 例如，[2,3,4] 的中位数是 3 [2,3] 的中位数是 (2 + 3) / 2 = 2.5 设计一个支持以下两种操作的数据结构： void addNum(int num) - 从数据流中添加一个整数到数据结构中。 double findMedian() - 返回目前所有元素的中位数。 示例： addNum(1) addNum(2) findMedian() -> 1.5 addNum(3) findMedian() -> 2 进阶: 如果数据流中所有整数都在 0 到 100 范围内，你将如何优化你的算法？ 如果数据流中 99% 的整数都在 0 到 100 范围内，你将如何优化你的算法？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 大小根堆-内置heap接口 O(log(n)) O(n) type MinHeap []int func (i MinHeap) Len() int { return len(i) } func (i MinHeap) Less(x, y int) bool { return i[x] i[y] } func (i MaxHeap) Swap(x, y int) { i[x], i[y] = i[y], i[x] } func (i *MaxHeap) Push(v interface{}) { *i = append(*i, v.(int)) } func (i *MaxHeap) Pop() interface{} { value := (*i)[len(*i)-1] *i = (*i)[:len(*i)-1] return value } type MedianFinder struct { minArr *MinHeap maxArr *MaxHeap } func Constructor() MedianFinder { res := new(MedianFinder) res.minArr = new(MinHeap) res.maxArr = new(MaxHeap) heap.Init(res.minArr) heap.Init(res.maxArr) return *res } func (this *MedianFinder) AddNum(num int) { if this.maxArr.Len() == this.minArr.Len() { heap.Push(this.minArr, num) heap.Push(this.maxArr, heap.Pop(this.minArr)) } else { heap.Push(this.maxArr, num) heap.Push(this.minArr, heap.Pop(this.maxArr)) } } func (this *MedianFinder) FindMedian() float64 { if this.minArr.Len() == this.maxArr.Len() { return (float64((*this.maxArr)[0]) + float64((*this.minArr)[0])) / 2 } else { return float64((*this.maxArr)[0]) } } 297.二叉树的序列化与反序列化(2) 题目 序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中， 同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。 请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑， 你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。 示例: 你可以将以下二叉树： 1 / \\ 2 3 / \\ 4 5 序列化为 \"[1,2,3,null,null,4,5]\" 提示: 这与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。 你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。 说明: 不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(n) 02 迭代 O(n) O(n) type Codec struct { res []string } func Constructor() Codec { return Codec{} } // Serializes a tree to a single string. func (this *Codec) serialize(root *TreeNode) string { if root == nil { return \"#\" } return strconv.Itoa(root.Val) + \",\" + this.serialize(root.Left) + \",\" + this.serialize(root.Right) } // Deserializes your encoded data to tree. func (this *Codec) deserialize(data string) *TreeNode { this.res = strings.Split(data, \",\") return this.dfsDeserialize() } func (this *Codec) dfsDeserialize() *TreeNode { node := this.res[0] this.res = this.res[1:] if node == \"#\" { return nil } value, _ := strconv.Atoi(node) return &TreeNode{ Val: value, Left: this.dfsDeserialize(), Right: this.dfsDeserialize(), } } # 2 type Codec struct { res []string } func Constructor() Codec { return Codec{} } // Serializes a tree to a single string. func (this *Codec) serialize(root *TreeNode) string { if root == nil { return \"\" } res := make([]string, 0) queue := make([]*TreeNode, 0) queue = append(queue, root) for len(queue) > 0 { node := queue[0] queue = queue[1:] if node != nil { res = append(res, strconv.Itoa(node.Val)) queue = append(queue, node.Left, node.Right) } else { res = append(res, \"#\") } } return strings.Join(res, \",\") } // Deserializes your encoded data to tree. func (this *Codec) deserialize(data string) *TreeNode { if len(data) == 0 || data == \"\" { return nil } res := strings.Split(data, \",\") root := &TreeNode{} root.Val, _ = strconv.Atoi(res[0]) res = res[1:] queue := make([]*TreeNode, 0) queue = append(queue, root) for len(queue) > 0 { if res[0] != \"#\" { left, _ := strconv.Atoi(res[0]) queue[0].Left = &TreeNode{Val: left} queue = append(queue, queue[0].Left) } if res[1] != \"#\" { right, _ := strconv.Atoi(res[1]) queue[0].Right = &TreeNode{Val: right} queue = append(queue, queue[0].Right) } queue = queue[1:] res = res[2:] } return root } Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 10:17:20 "},"docs/source/question/0301-0400.html":{"url":"docs/source/question/0301-0400.html","title":"0301-0400","keywords":"","body":"0301-0400-Easy 0301-0400-Easy 303.区域和检索-数组不可变(2) 326.3的幂(3) 342.4的幂(4) 344.反转字符串(3) 345.反转字符串中的元音字母(2) 349.两个数组的交集(3) 350.两个数组的交集 II(3) 367.有效的完全平方数(4) 371.两整数之和(2) 374.猜数字大小(2) 383.赎金信(3) 387.字符串中的第一个唯一字符(3) 389.找不同(5) 392.判断子序列(4) 0301-0400-Medium 304.二维区域和检索-矩阵不可变(1) 306.累加数 题目 解题思路 309.最佳买卖股票时机含冷冻期(2) 319.灯泡开关(1) 322.零钱兑换(4) 328.奇偶链表(3) 334.递增的三元子序列(4) 337.打家劫舍III(1) 338.比特位计数(4) 343.整数拆分(2) 347.前K个高频元素(3) 365.水壶问题(3) 378.有序矩阵中第K小的元素(3) 380.常数时间插入、删除和获取随机元素(2) 384.打乱数组(2) 394.字符串解码(2) 400.第N个数字(2) 0301-0400-Hard 301.删除无效的括号(2) 312.戳气球(3) 316.去除重复字母(2) 354.俄罗斯套娃信封问题(3) 303.区域和检索-数组不可变(2) 题目 给定一个整数数组 nums，求出数组从索引 i 到 j (i ≤ j) 范围内元素的总和，包含 i, j 两点。 示例： 给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange() sumRange(0, 2) -> 1 sumRange(2, 5) -> -1 sumRange(0, 5) -> -3 说明: 你可以假设数组不可变。 会多次调用 sumRange 方法。 解题思路 No. 思路 时间复杂度 空间复杂度 01 一维前缀和 O(1) O(n) 02 遍历计算 O(n) O(1) type NumArray struct { arr []int } func Constructor(nums []int) NumArray { size := len(nums) arr := make([]int, size+1) for i := 1; i 326.3的幂(3) 题目 给定一个整数，写一个函数来判断它是否是 3 的幂次方。 示例 1: 输入: 27 输出: true 示例 2: 输入: 0 输出: false 示例 3: 输入: 9 输出: true 示例 4: 输入: 45 输出: false 进阶：你能不使用循环或者递归来完成本题吗？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 迭代 I O(1) 02 转3进制判断 O(log(n)) O(1) 03 递归 O(log(n)) O(log(n)) func isPowerOfThree(n int) bool { if n 1 { if n % 3 != 0{ return false } n = n / 3 } return n == 1 } # func isPowerOfThree(n int) bool { if n 342.4的幂(4) 题目 给定一个整数 (32 位有符号整数)，请编写一个函数来判断它是否是 4 的幂次方。 示例 1: 输入: 16 输出: true 示例 2: 输入: 5 输出: false 进阶：你能不使用循环或者递归来完成本题吗？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 迭代 O(log(n)) O(1) 02 递归 O(log(n)) O(log(n)) 03 位运算 O(1) O(1) 04 转4进制 O(log(n)) O(1) func isPowerOfFour(num int) bool { if num 1 { if num%4 != 0 { return false } num = num / 4 } return num == 1 } # func isPowerOfFour(num int) bool { if num 344.反转字符串(3) 题目 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。 示例 1： 输入：[\"h\",\"e\",\"l\",\"l\",\"o\"] 输出：[\"o\",\"l\",\"l\",\"e\",\"h\"] 示例 2： 输入：[\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"] 输出：[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"] 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n) O(1) 02 递归 O(n) O(n) 03 单指针 O(n) O(1) func reverseString(s []byte) { i, j := 0, len(s)-1 for i 345.反转字符串中的元音字母(2) 题目 编写一个函数，以字符串作为输入，反转该字符串中的元音字母。 示例 1:输入: \"hello\"输出: \"holle\" 示例 2:输入: \"leetcode\"输出: \"leotcede\" 说明:元音字母不包含字母\"y\"。 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n) O(1) 02 数组辅助替换 O(n) O(n) func reverseVowels(s string) string { bytes := []byte(s) length := len(s) i, j := 0, length-1 for i 349.两个数组的交集(3) 题目 给定两个数组，编写一个函数来计算它们的交集。 示例 1:输入: nums1 = [1,2,2,1], nums2 = [2,2]输出: [2] 示例 2:输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [9,4] 说明: 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。 解题思路 No. 思路 时间复杂度 空间复杂度 01 单哈希辅助 O(n) O(n) 02 双哈希辅助 O(n) O(n) 03 排序双指针 O(nlog(n)) O(n) func intersection(nums1 []int, nums2 []int) []int { res := make([]int, 0) m := make(map[int]int) for _, v := range nums1 { m[v] = 1 } for _, v := range nums2 { if m[v] == 1 { res = append(res, v) m[v] += 1 } } return res } # func intersection(nums1 []int, nums2 []int) []int { m1 := make(map[int]bool) m2 := make(map[int]bool) res := make([]int, 0) for _, v := range nums1 { m1[v] = true } for _, v := range nums2 { if m1[v] != false { m2[v] = true } } for k := range m2 { res = append(res, k) } return res } # func intersection(nums1 []int, nums2 []int) []int { sort.Ints(nums1) sort.Ints(nums2) res := make([]int, 0) i := 0 j := 0 for i nums2[j] { j++ } else { if len(res) == 0 || res[len(res)-1] != nums1[i] { res = append(res, nums1[i]) } i++ j++ } } return res } 350.两个数组的交集 II(3) 题目 给定两个数组，编写一个函数来计算它们的交集。 示例 1: 输入: nums1 = [1,2,2,1], nums2 = [2,2] 输出: [2,2] 示例 2: 输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出: [4,9] 说明：输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。 我们可以不考虑输出结果的顺序。 进阶: 如果给定的数组已经排好序呢？你将如何优化你的算法？ 如果 nums1 的大小比 nums2 小很多，哪种方法更优？ 如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 单哈希辅助 O(n) O(n) 02 双哈希辅助 O(n) O(n) 03 排序双指针 O(nlog(n)) O(n) func intersect(nums1 []int, nums2 []int) []int { m1 := make(map[int]int) res := make([]int, 0) for _, v := range nums1 { m1[v] += 1 } for _, v := range nums2 { if m1[v] > 0 { res = append(res, v) m1[v]-- } } return res } # func intersect(nums1 []int, nums2 []int) []int { m1 := make(map[int]int) m2 := make(map[int]int) res := make([]int, 0) for _, v := range nums1 { m1[v]++ } for _, v := range nums2 { if m1[v] != 0 && m1[v] > m2[v] { m2[v]++ } } for k := range m2 { for i := 0; i nums2[j] { j++ } else { res = append(res, nums1[i]) i++ j++ } } return res } 367.有效的完全平方数(4) 题目 给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。 说明：不要使用任何内置的库函数，如 sqrt。 示例 1：输入：16 输出：True 示例 2：输入：14 输出：False 解题思路 No. 思路 时间复杂度 空间复杂度 01 二分查找 O(log(n)) O(1) 02 牛顿迭代法 O(log(n)) O(1) 03 数学法 O(n^1/2) O(1) 04 暴力法 O(n^1/2) O(1) func isPerfectSquare(num int) bool { if num num { right = mid - 1 } else { left = mid + 1 } } return false } # func isPerfectSquare(num int) bool { if num num { x = (x + num/x) / 2 } return x*x == num } # func isPerfectSquare(num int) bool { i := 1 for num > 0 { num = num - i i = i + 2 } return num == 0 } # func isPerfectSquare(num int) bool { i := 1 for i * i 371.两整数之和(2) 题目 不使用运算符 + 和 - ，计算两整数a,b之和。 示例 1:输入: a = 1, b = 2 输出: 3 示例 2:输入: a = -2, b = 3 输出: 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 迭代 O(1) O(1) 02 递归 O(1) O(1) func getSum(a int, b int) int { for b != 0 { a, b = a^b, (a&b) 374.猜数字大小(2) 题目 我们正在玩一个猜数字游戏。 游戏规则如下： 我从 1 到 n 选择一个数字。 你需要猜我选择了哪个数字。 每次你猜错了，我会告诉你这个数字是大了还是小了。 你调用一个预先定义好的接口 guess(int num)，它会返回 3 个可能的结果（-1，1 或 0）： -1 : 我的数字比较小 1 : 我的数字比较大 0 : 恭喜！你猜对了！ 示例 :输入: n = 10, pick = 6 输出: 6 解题思路 No. 思路 时间复杂度 空间复杂度 01 二分查找 O(log(n)) O(1) 02 递归 O(log(n)) O(log(n)) func guessNumber(n int) int { low := 1 high := n for low 383.赎金信(3) 题目 给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串， 判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。 如果可以构成，返回 true ；否则返回 false。 (题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。 杂志字符串中的每个字符只能在赎金信字符串中使用一次。) 注意：你可以假设两个字符串均只含有小写字母。 canConstruct(\"a\", \"b\") -> false canConstruct(\"aa\", \"ab\") -> false canConstruct(\"aa\", \"aab\") -> true 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组辅助 O(n) O(1) 02 哈希辅助 O(n) O(1) 03 排序双指针 O(nlog(n)) O(n) func canConstruct(ransomNote string, magazine string) bool { index := [26]int{} for i := 0; i magazineArr[j] { j++ } else if ransomNoteArr[i] 387.字符串中的第一个唯一字符(3) 题目 给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。 案例: s = \"leetcode\"返回 0. s = \"loveleetcode\",返回 2. 注意事项：您可以假定该字符串只包含小写字母。 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组辅助 O(n) O(1) 02 哈希辅助 O(n) O(1) 03 暴力法 O(n^2) O(1) func firstUniqChar(s string) int { m := [26]int{} for i := 0; i 389.找不同(5) 题目 给定两个字符串 s 和 t，它们只包含小写字母。 字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。 请找出在 t 中被添加的字母。 示例:输入：s = \"abcd\"t = \"abcde\"输出：e 解释：'e' 是那个被添加的字母。 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组辅助 O(n) O(1) 02 哈希辅助 O(n) O(1) 03 位计算 O(n) O(1) 04 数学计算 O(n) O(1) 05 排序遍历 O(nlog(n)) O(1) func findTheDifference(s string, t string) byte { m := [26]int{} bytest := []byte(t) bytess := []byte(s) for _, v := range bytest { m[v-'a']++ } for _, v := range bytess { m[v-'a']-- } for k, _ := range m { if m[k] == 1 { return byte(k + 'a') } } return 0 } # func findTheDifference(s string, t string) byte { m := make(map[byte]int) bytest := []byte(t) bytess := []byte(s) for _, v := range bytest { m[v]++ } for _, v := range bytess { m[v]-- } for k, _ := range m { if m[k] == 1 { return k } } return 0 } # func findTheDifference(s string, t string) byte { ch := byte(0) for _, value := range s { ch ^= byte(value) } for _, value := range t { ch ^= byte(value) } return ch } # func findTheDifference(s string, t string) byte { ch := byte(0) for _, value := range t { ch += byte(value) } for _, value := range s { ch -= byte(value) } return ch } # func findTheDifference(s string, t string) byte { sArr := strings.Split(s, \"\") tArr := strings.Split(t, \"\") sort.Strings(sArr) sort.Strings(tArr) for i := 0; i 392.判断子序列(4) 题目 给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 你可以认为 s 和 t 中仅包含英文小写字母。 字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 = 10亿， 你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n) O(1) 02 单指针遍历 O(n^2) O(1) 03 二分查找 O(nlog(n)) o 04 动态规划 O(n^2) O(n^2) func isSubsequence(s string, t string) bool { if len(s) > len(t){ return false } i := 0 j := 0 for i prev { right = mid } else { left = mid + 1 } } if left > right || m[value][left] len(t) { return false } dp := make([][]bool, len(s)+1) for i := 0; i 0301-0400-Medium 304.二维区域和检索-矩阵不可变(1) 题目 给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ， 右下角为 (row2, col2)。 Range Sum Query 2D 上图子矩阵左上角 (row1, col1) = (2, 1) ，右下角(row2, col2) = (4, 3)， 该子矩形内元素的总和为 8。 示例: 给定 matrix = [ [3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5] ] sumRegion(2, 1, 4, 3) -> 8 sumRegion(1, 1, 2, 2) -> 11 sumRegion(1, 2, 2, 4) -> 12 说明:你可以假设矩阵不可变。 会多次调用 sumRegion 方法。 你可以假设 row1 ≤ row2 且 col1 ≤ col2。 解题思路 No. 思路 时间复杂度 空间复杂度 01 前缀和 O(1) O(n^2) type NumMatrix struct { arr [][]int } func Constructor(matrix [][]int) NumMatrix { if matrix == nil || len(matrix) == 0 || matrix[0] == nil || len(matrix[0]) == 0 { arr := make([][]int, 1) for i := 0; i 306.累加数 题目 累加数是一个字符串，组成它的数字可以形成累加序列。 一个有效的累加序列必须至少包含 3 个数。除了最开始的两个数以外，字符串中的其他数都等于它之前两个数相加的和。 给定一个只包含数字 '0'-'9' 的字符串，编写一个算法来判断给定输入是否是累加数。 说明: 累加序列里的数不会以 0 开头，所以不会出现 1, 2, 03 或者 1, 02, 3 的情况。 示例 1:输入: \"112358\" 输出: true 解释: 累加序列为: 1, 1, 2, 3, 5, 8 。1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8 示例 2:输入: \"199100199\" 输出: true 解释: 累加序列为: 1, 99, 100, 199。1 + 99 = 100, 99 + 100 = 199 进阶:你如何处理一个溢出的过大的整数输入? 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n^2) O(n) 309.最佳买卖股票时机含冷冻期(2) 题目 给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​ 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 示例:输入: [1,2,3,0,2] 输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出] 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划-二维 O(n) O(n) 02 动态规划 O(n) O(1) func maxProfit(prices []int) int { if len(prices) == 0 { return 0 } n := len(prices) dp := make([][3]int, n) // 0 => 持有 // 1 => 不持有，本日卖出，下一日冷冻期 // 2 => 不持有，本日无卖出，下一日不是冷冻期 dp[0][0] = -prices[0] // 第0天买入，亏损-price[0] for i := 1; i b { return a } return b } # 2 func maxProfit(prices []int) int { if len(prices) == 0 { return 0 } n := len(prices) // a => 持有 // b => 不持有，本日卖出，下一日冷冻期 // c => 不持有，本日无卖出，下一日不是冷冻期 var a, b, c int a = -prices[0] // 第0天买入，亏损-price[0] for i := 1; i b { return a } return b } 319.灯泡开关(1) 题目 初始时有 n 个灯泡关闭。 第 1 轮，你打开所有的灯泡。 第 2 轮，每两个灯泡你关闭一次。 第 3 轮，每三个灯泡切换一次开关（如果关闭则开启，如果开启则关闭）。 第 i 轮，每 i 个灯泡切换一次开关。 对于第 n 轮，你只切换最后一个灯泡的开关。 找出 n 轮后有多少个亮着的灯泡。 示例:输入: 3输出: 1 解释: 初始时, 灯泡状态 [关闭, 关闭, 关闭]. 第一轮后, 灯泡状态 [开启, 开启, 开启]. 第二轮后, 灯泡状态 [开启, 关闭, 开启]. 第三轮后, 灯泡状态 [开启, 关闭, 关闭]. 你应该返回 1，因为只有一个灯泡还亮着。 解题思路 No. 思路 时间复杂度 空间复杂度 01 内置函数 O(log(n)) O(1) func bulbSwitch(n int) int { // 第i个灯泡的反转次数等于它所有因子（包括1和i）的个数 // 反转奇数次=>变成亮 // 只有平方数才有奇数个因子 return int(math.Sqrt(float64(n))) } 322.零钱兑换(4) 题目 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。 如果没有任何一种硬币组合能组成总金额，返回 -1。 示例 1:输入: coins = [1, 2, 5], amount = 11 输出: 3 解释: 11 = 5 + 5 + 1 示例 2:输入: coins = [2], amount = 3 输出: -1 说明:你可以认为每种硬币的数量是无限的。 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n^2) O(n) 02 动态规划 O(n^2) O(n) 03 深度优先搜索 O(n^k) O(n) 04 广度优先搜索 O(n) O(n) func coinChange(coins []int, amount int) int { dp := make([]int, amount+1) for i := 1; i dp[prev]+1 { dp[i] = dp[prev] + 1 } } } return dp[amount] } # 2 func coinChange(coins []int, amount int) int { dp := make([]int, amount+1) for i := 0; i b { return b } return a } # 3 var res int func coinChange(coins []int, amount int) int { for i := 0; i = 0 && i+count b { return b } return a } # 4 func coinChange(coins []int, amount int) int { if amount == 0 { return 0 } res := 1 sort.Ints(coins) list := make([]int, 0) list = append(list, amount) arr := make([]bool, amount+1) arr[amount] = true for len(list) > 0 { length := len(list) for i := 0; i 328.奇偶链表(3) 题目 给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。 请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。 请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。 示例 1:输入: 1->2->3->4->5->NULL 输出: 1->3->5->2->4->NULL 示例 2:输入: 2->1->3->5->6->4->7->NULL 输出: 2->3->6->7->1->5->4->NULL 说明:应当保持奇数节点和偶数节点的相对顺序。 链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n) O(1) 02 数组辅助 O(n) O(n) 03 双指针 O(n) O(1) func oddEvenList(head *ListNode) *ListNode { odd := &ListNode{} even := &ListNode{} a := odd b := even count := 1 for head != nil { if count%2 == 1 { a.Next = head a = head } else { b.Next = head b = head } count++ head = head.Next } b.Next = nil a.Next = even.Next return odd.Next } # 2 func oddEvenList(head *ListNode) *ListNode { odd := make([]*ListNode, 0) even := make([]*ListNode, 0) count := 1 for head != nil { if count%2 == 1 { odd = append(odd, head) } else { even = append(even, head) } count++ head = head.Next } temp := &ListNode{} node := temp for i := 0; i 334.递增的三元子序列(4) 题目 给定一个未排序的数组，判断这个数组中是否存在长度为 3 的递增子序列。 数学表达式如下: 如果存在这样的 i, j, k, 且满足 0 ≤ i 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 数组辅助 O(n) O(n) 03 动态规划 O(n) O(n) 04 暴力法 O(n^3) O(1) func increasingTriplet(nums []int) bool { a, b := math.MaxInt32, math.MaxInt32 for i := 0; i = nums[i] { a = nums[i] } else if b >= nums[i] { b = nums[i] } else { return true } } return false } # 2 func increasingTriplet(nums []int) bool { if len(nums) = 0; i-- { b[i] = max(b[i+1], nums[i]) } for i := 0; i b { return b } return a } func max(a, b int) int { if a > b { return a } return b } # 3 func increasingTriplet(nums []int) bool { dp := make([]int, len(nums)+1) for i := 0; i = 2 { return true } } return false } func max(a, b int) int { if a > b { return a } return b } # 4 func increasingTriplet(nums []int) bool { for i := 0; i = nums[j] { continue } for k := j + 1; k 337.打家劫舍III(1) 题目 在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。 这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。 一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。 计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。 示例 1:输入: [3,2,3,null,3,null,1] 3 / \\ 2 3 \\ \\ 3 1 输出: 7 解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7. 示例 2:输入: [3,4,5,1,3,null,1] 3 / \\ 4 5 / \\ \\ 1 3 1 输出: 9解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9. 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) func rob(root *TreeNode) int { a, b := dfs(root) return max(a, b) } func dfs(root *TreeNode) (int, int) { if root == nil { return 0, 0 } leftA, leftB := dfs(root.Left) rightA, rightB := dfs(root.Right) a := root.Val + leftB + rightB // A=>偷 b := max(leftA, leftB) + max(rightA, rightB) // B=>不偷 return a, b } func max(a, b int) int { if a > b { return a } return b } 338.比特位计数(4) 题目 给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ， 计算其二进制数中的 1 的数目并将它们作为数组返回。 示例 1:输入: 2 输出: [0,1,1] 示例 2:输入: 5 输出: [0,1,1,2,1,2] 进阶:给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？ 要求算法的空间复杂度为O(n)。 你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数 （如 C++ 中的 __builtin_popcount）来执行此操作。 解题思路 No. 思路 时间复杂度 空间复杂度 01 位运算 O(n) O(n) 02 动态规划 O(n) O(n) 03 暴力法 O(n) O(n) 04 内置函数 O(n) O(n) func countBits(num int) []int { res := make([]int, num+1) for i := 1; i 343.整数拆分(2) 题目 给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。 示例 1:输入: 2 输出: 1 解释: 2 = 1 + 1, 1 × 1 = 1。 示例 2:输入: 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。 说明: 你可以假设 n 不小于 2 且不大于 58。 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n^2) O(n) 02 贪心法 O(1) O(1) func integerBreak(n int) int { if n max { max = length } dp[i] = max } } return dp[n] } # func integerBreak(n int) int { if n 347.前K个高频元素(3) 题目 给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 示例 1:输入: nums = [1,1,1,2,2,3], k = 2 输出: [1,2] 示例 2:输入: nums = [1], k = 1 输出: [1] 提示：你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。 你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。 你可以按任意顺序返回答案。 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(nlog(n)) O(n) 02 堆 O(nlog(n)) O(n) 03 桶排序 O(n) O(n) func topKFrequent(nums []int, k int) []int { m := make(map[int]int) for i := 0; i arr[j][1] }) res := make([]int, 0) for i := 0; i 0 && k > 0 { k-- node := heap.Pop(&h).([2]int) res = append(res, node[0]) } return res } type IntHeap [][2]int func (h IntHeap) Len() int { return len(h) } func (h IntHeap) Less(i, j int) bool { return h[i][1] > h[j][1] } func (h IntHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] } func (h *IntHeap) Push(x interface{}) { *h = append(*h, x.([2]int)) } func (h *IntHeap) Pop() interface{} { old := *h n := len(old) x := old[n-1] *h = old[0 : n-1] return x } # 3 func topKFrequent(nums []int, k int) []int { m := make(map[int]int) for i := 0; i = 0; i-- { // 避免出现0=>x次的情况 if _, ok := temp[i]; ok { for j := 0; j 365.水壶问题(3) 题目 有两个容量分别为 x升 和 y升 的水壶以及无限多的水。 请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？ 如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。 你允许： 装满任意一个水壶 清空任意一个水壶 从一个水壶向另外一个水壶倒水，直到装满或者倒空 示例 1: (From the famous \"Die Hard\" example) 输入: x = 3, y = 5, z = 4 输出: True 示例 2:输入: x = 2, y = 6, z = 5 输出: False 解题思路 No. 思路 时间复杂度 空间复杂度 01 数学 O(log(n)) O(1) 02 递归 O(log(n)) O(log(n)) 03 广度优先搜索 O(n^2) O(n^2) // ax+by=z func canMeasureWater(x int, y int, z int) bool { if x > y { x, y = y, x } if x+y x+y || y == 0 { return false } return canMeasureWater(y, x%y, z%y) } # 3 func canMeasureWater(x int, y int, z int) bool { if x+y 0 { a, b := queue[0][0], queue[0][1] queue = queue[1:] if m[[2]int{a, b}] == true { continue } m[[2]int{a, b}] = true if a == z || b == z || a+b == z { return true } // +x c, d := x, b queue = append(queue, [2]int{c, d}) // +y c, d = a, y queue = append(queue, [2]int{c, d}) // -x c, d = 0, b queue = append(queue, [2]int{c, d}) // -y c, d = a, 0 queue = append(queue, [2]int{c, d}) // x->y if a > y-b { c, d = a+b-y, y queue = append(queue, [2]int{c, d}) } else { c, d = 0, a+b queue = append(queue, [2]int{c, d}) } // y->x if b > x-a { c, d = x, a+b-x queue = append(queue, [2]int{c, d}) } else { c, d = a+b, 0 queue = append(queue, [2]int{c, d}) } } return false } 378.有序矩阵中第K小的元素(3) 题目 给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。 请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。 示例：matrix = [ [ 1, 5, 9], [10, 11, 13], [12, 13, 15] ], k = 8, 返回 13。 提示：你可以假设 k 的值永远是有效的，1 ≤ k ≤ n2 。 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组辅助排序 O(n^2log(n)) O(n^2) 02 二分查找 O(nlog(n)) O(1) 03 堆 O(n^2log(n)) O(n^2) func kthSmallest(matrix [][]int, k int) int { res := make([]int, 0) for i := 0; i = 0 && j = k } # 3 func kthSmallest(matrix [][]int, k int) int { var h IntHeap heap.Init(&h) for i := 0; i 0 && k > 0 { k-- res := heap.Pop(&h).(int) if k == 0 { return res } } return 0 } type IntHeap []int func (h IntHeap) Len() int { return len(h) } func (h IntHeap) Less(i, j int) bool { return h[i] 380.常数时间插入、删除和获取随机元素(2) 题目 设计一个支持在平均 时间复杂度 O(1) 下，执行以下操作的数据结构。 insert(val)：当元素 val 不存在时，向集合中插入该项。 remove(val)：元素 val 存在时，从集合中移除该项。 getRandom：随机返回现有集合中的一项。每个元素应该有相同的概率被返回。 示例 : // 初始化一个空的集合。 RandomizedSet randomSet = new RandomizedSet(); // 向集合中插入 1 。返回 true 表示 1 被成功地插入。 randomSet.insert(1); // 返回 false ，表示集合中不存在 2 。 randomSet.remove(2); // 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。 randomSet.insert(2); // getRandom 应随机返回 1 或 2 。 randomSet.getRandom(); // 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。 randomSet.remove(1); // 2 已在集合中，所以返回 false 。 randomSet.insert(2); // 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。 randomSet.getRandom(); 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希表+数组 O(1) O(n) 02 哈希表 O(n) O(n) type RandomizedSet struct { m map[int]int arr []int } func Constructor() RandomizedSet { return RandomizedSet{ m: make(map[int]int), arr: make([]int, 0), } } func (this *RandomizedSet) Insert(val int) bool { if _, ok := this.m[val]; ok { return false } this.arr = append(this.arr, val) this.m[val] = len(this.arr) - 1 return true } func (this *RandomizedSet) Remove(val int) bool { if _, ok := this.m[val]; !ok { return false } index := this.m[val] this.arr[index], this.arr[len(this.arr)-1] = this.arr[len(this.arr)-1], this.arr[index] this.m[this.arr[index]] = index this.arr = this.arr[:len(this.arr)-1] delete(this.m, val) return true } func (this *RandomizedSet) GetRandom() int { if len(this.arr) == 0 { return -1 } index := rand.Intn(len(this.arr)) return this.arr[index] } # 2 type RandomizedSet struct { m map[int]bool } func Constructor() RandomizedSet { return RandomizedSet{ m: make(map[int]bool), } } func (this *RandomizedSet) Insert(val int) bool { if _, ok := this.m[val]; ok { return false } this.m[val] = true return true } func (this *RandomizedSet) Remove(val int) bool { if _, ok := this.m[val]; !ok { return false } delete(this.m, val) return true } func (this *RandomizedSet) GetRandom() int { if len(this.m) == 0 { return -1 } index := rand.Intn(len(this.m)) res := -1 for res = range this.m { index-- if index == -1 { break } } return res } 384.打乱数组(2) 题目 打乱一个没有重复元素的数组。 示例: // 以数字集合 1, 2 和 3 初始化数组。 int[] nums = {1,2,3}; Solution solution = new Solution(nums); // 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。 solution.shuffle(); // 重设数组到它的初始状态[1,2,3]。 solution.reset(); // 随机返回数组[1,2,3]打乱后的结果。 solution.shuffle(); 解题思路 No. 思路 时间复杂度 空间复杂度 01 内置函数 O(n^2) O(n) 02 内置函数 O(n^2) O(n) type Solution struct { nums []int } func Constructor(nums []int) Solution { return Solution{nums: nums} } func (this *Solution) Reset() []int { return this.nums } func (this *Solution) Shuffle() []int { arr := make([]int, len(this.nums)) copy(arr, this.nums) rand.Shuffle(len(arr), func(i, j int) { arr[i], arr[j] = arr[j], arr[i] }) return arr } # type Solution struct { nums []int } func Constructor(nums []int) Solution { return Solution{nums: nums} } func (this *Solution) Reset() []int { return this.nums } func (this *Solution) Shuffle() []int { arr := make([]int, len(this.nums)) copy(arr, this.nums) res := make([]int, len(this.nums)) for i := 0; i 394.字符串解码(2) 题目 给定一个经过编码的字符串，返回它解码后的字符串。 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。 注意 k 保证为正整数。 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。 示例 1：输入：s = \"3[a]2[bc]\" 输出：\"aaabcbc\" 示例 2：输入：s = \"3[a2[c]]\" 输出：\"accaccacc\" 示例 3：输入：s = \"2[abc]3[cd]ef\" 输出：\"abcabccdcdcdef\" 示例 4：输入：s = \"abc3[cd]xyz\" 输出：\"abccdcdcdxyz\" 解题思路 No. 思路 时间复杂度 空间复杂度 01 栈辅助 O(n) O(n) 02 递归 O(n) O(n) func decodeString(s string) string { res := make([]byte, 0) numStack := make([]int, 0) lenStack := make([]int, 0) var count int for i := 0; i 400.第N个数字(2) 题目 在无限的整数序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...中找到第 n 个数字。 注意:n 是正数且在32位整数范围内 ( n 解题思路 No. 思路 时间复杂度 空间复杂度 01 找规律 O(log(n)) O(1) 02 找规律 O(log(n)) O(1) func findNthDigit(n int) int { if n 0 { n = n - digits*count digits++ count = count * 10 number = number * 10 } number = number + (n-1)/digits index := (n - 1) % digits str := strconv.Itoa(number) return int(str[index] - '0') } 0301-0400-Hard 301.删除无效的括号(2) 题目 删除最小数量的无效括号，使得输入的字符串有效，返回所有可能的结果。 说明: 输入可能包含了除 ( 和 ) 以外的字符。 示例 1:输入: \"()())()\" 输出: [\"()()()\", \"(())()\"] 示例 2:输入: \"(a)())()\" 输出: [\"(a)()()\", \"(a())()\"] 示例 3:输入: \")(\" 输出: [\"\"] 解题思路 No. 思路 时间复杂度 空间复杂度 01 广度优先搜索 O(2^n) O(n) 02 深度优先搜索 O(2^n) O(n) func removeInvalidParentheses(s string) []string { res := make([]string, 0) cur := make(map[string]int) cur[s] = 1 for { for k := range cur { if isValid(k) { res = append(res, k) } } if len(res) > 0 { return res } next := make(map[string]int) for k := range cur { for i := range k { if k[i] == '(' || k[i] == ')' { str := k[:i] + k[i+1:] next[str] = 1 } } } cur = next } } func isValid(s string) bool { left := 0 for i := 0; i max { max = len(temp) m = make(map[string]bool) m[temp] = true } else if max == len(temp) { m[temp] = true } } return } if s[start] == '(' { dfs(s, start+1, count+1, temp+\"(\") } else if s[start] == ')' { dfs(s, start+1, count-1, temp+\")\") } else { dfs(s, start+1, count, temp+string(s[start])) } if s[start] == '(' || s[start] == ')' { dfs(s, start+1, count, temp) } } 312.戳气球(3) 题目 有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。 现在要求你戳破所有的气球。如果你戳破气球 i ，就可以获得 nums[left] * nums[i] * nums[right] 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。 注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。 求所能获得硬币的最大数量。 说明:你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100 示例:输入: [3,1,5,8] 输出: 167 解释: nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> [] coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归-记忆化搜索 O(n^3) O(n^2) 02 动态规划 O(n^3) O(n^2) 03 动态规划 O(n^3) O(n^2) var res [][]int var arr []int func maxCoins(nums []int) int { n := len(nums) arr = make([]int, n+2) arr[0], arr[len(arr)-1] = 1, 1 for i := 1; i = right { return 0 } if res[left][right] != -1 { return res[left][right] } for i := left + 1; i b { return a } return b } # 2 func maxCoins(nums []int) int { n := len(nums) arr := make([]int, n+2) arr[0], arr[len(arr)-1] = 1, 1 for i := 1; i left // k => i // j => right // i不能0->n+1 for i := n - 1; i >= 0; i-- { for j := i + 2; j b { return a } return b } # 3 func maxCoins(nums []int) int { n := len(nums) arr := make([]int, n+2) arr[0], arr[len(arr)-1] = 1, 1 for i := 1; i left // k => i // j => right for j := 2; j = 0; i-- { for k := i + 1; k b { return a } return b } 316.去除重复字母(2) 题目 给你一个仅包含小写字母的字符串，请你去除字符串中重复的字母，使得每个字母只出现一次。 需保证返回结果的字典序最小（要求不能打乱其他字符的相对位置）。 示例 1:输入: \"bcabc\" 输出: \"abc\" 示例 2:输入: \"cbacdcbc\" 输出: \"acdb\" 注意：该题与 1081 https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters 相同 解题思路 No. 思路 时间复杂度 空间复杂度 01 单调栈 O(n) O(n) 02 递归 O(n) O(n) func removeDuplicateLetters(s string) string { stack := make([]byte, 0) arr := [256]byte{} m := make(map[byte]bool) for i := 0; i s[i]:说明字典序不满足 for len(stack) > 0 && stack[len(stack)-1] > s[i] && arr[stack[len(stack)-1]] > 0 { m[stack[len(stack)-1]] = false stack = stack[:len(stack)-1] } stack = append(stack, s[i]) arr[s[i]]-- m[s[i]] = true } return string(stack) } # 2 func removeDuplicateLetters(s string) string { arr := [26]int{} pos := 0 for i := 0; i 354.俄罗斯套娃信封问题(3) 题目 给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 (w, h) 出现。 当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。 请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。 说明: 不允许旋转信封。 示例:输入: envelopes = [[5,4],[6,4],[6,7],[2,3]] 输出: 3 解释: 最多信封的个数为 3, 组合为: [2,3] => [5,4] => [6,7]。 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n^2) O(n) 02 贪心-二分查找 O(nlog(n)) O(n) 03 动态规划 O(n^2) O(n) func maxEnvelopes(envelopes [][]int) int { if len(envelopes) envelopes[j][0] && envelopes[i][1] > envelopes[j][1] { dp[i] = max(dp[i], dp[j]+1) } } res = max(res, dp[i]) } return res } func max(a, b int) int { if a > b { return a } return b } # 2 func maxEnvelopes(envelopes [][]int) int { if len(envelopes) arr[mid] { left = mid + 1 } else { right = mid - 1 } } if left >= len(arr) { arr = append(arr, envelopes[i][1]) } else { arr[left] = envelopes[i][1] } } return len(arr) } # 3 func maxEnvelopes(envelopes [][]int) int { if len(envelopes) = 0; j-- { if envelopes[i][0] > envelopes[j][0] && envelopes[i][1] > envelopes[j][1] && dp[j] > temp { temp = dp[j] } } dp[i] = temp + 1 if dp[i] > res { res = dp[i] } } return res } Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 10:19:20 "},"docs/source/question/0401-0500.html":{"url":"docs/source/question/0401-0500.html","title":"0401-0500","keywords":"","body":"0401-0500-Easy 0401-0500-Easy 401.二进制手表(3) 404.左叶子之和(2) 405.数字转换为十六进制数(2) 409.最长回文串(2) 412.Fizz Buzz(1) 414.第三大的数(2) 415.字符串相加(2) 434.字符串中的单词数(2) 437.路径总和III(4) 441.排列硬币(3) 443.压缩字符串(1) 447.回旋镖的数量(1) 448.找到所有数组中消失的数字(3) 453.最小移动次数使数组元素相等(2) 455.分发饼干(1) 459.重复的子字符串(2) 461.汉明距离(3) 463.岛屿的周长(3) 475.供暖器(2) 476.数字的补数(3) 482.密钥格式化(2) 485.最大连续1的个数(2) 492.构造矩形(1) 496.下一个更大元素 I(3) 500.键盘行(4) 0401-0500-Medium 406.根据身高重建队列(2) 416.分割等和子集(3) 438.找到字符串中所有字母异位词(2) 442.数组中重复的数据(5) 445.两数相加II(3) 486.预测赢家(3) 494.目标和(5) 491.递增子序列(2) 498.对角线遍历(2) 0401-0500-Hard 410.分割数组的最大值(3) 460.LFU缓存 题目 解题思路 401.二进制手表(3) 题目 二进制手表顶部有 4 个 LED 代表小时（0-11），底部的 6 个 LED 代表分钟（0-59）。 每个 LED 代表一个 0 或 1，最低位在右侧。 例如，上面的二进制手表读取 “3:25”。 给定一个非负整数 n 代表当前 LED 亮着的数量，返回所有可能的时间。 案例:输入: n = 1 返回: [\"1:00\", \"2:00\", \"4:00\", \"8:00\", \"0:01\", \"0:02\", \"0:04\", \"0:08\", \"0:16\", \"0:32\"] 注意事项: 输出的顺序没有要求。 小时不会以零开头，比如 “01:00” 是不允许的，应为 “1:00”。 分钟必须由两位数组成，可能会以零开头，比如 “10:2” 是无效的，应为 “10:02”。 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法 O(1) O(1) 02 暴力法 O(1) O(1) 03 回溯法 O(2^n) O(n) func binCount(num int) int { count := make([]int, 0) for num != 0 { temp := num % 2 count = append(count, temp) num = num / 2 } countNum := 0 for i := 0; i 404.左叶子之和(2) 题目 计算给定二叉树的所有左叶子之和。 示例： 3 / \\ 9 20 / \\ 15 7 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 迭代 O(n) O(n) func sumOfLeftLeaves(root *TreeNode) int { if root == nil { return 0 } if root.Left == nil { return sumOfLeftLeaves(root.Right) } if root.Left.Left == nil && root.Left.Right == nil { return root.Left.Val + sumOfLeftLeaves(root.Right) } return sumOfLeftLeaves(root.Left) + sumOfLeftLeaves(root.Right) } # func sumOfLeftLeaves(root *TreeNode) int { sum := 0 if root == nil{ return 0 } queue := make([]*TreeNode,0) queue = append(queue, root) for len(queue) > 0{ node := queue[0] queue = queue[1:] if node.Left != nil && node.Left.Left == nil && node.Left.Right == nil{ sum = sum + node.Left.Val } if node.Left != nil{ queue = append(queue, node.Left) } if node.Right != nil{ queue = append(queue, node.Right) } } return sum } 405.数字转换为十六进制数(2) 题目 给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。 注意: 十六进制中所有字母(a-f)都必须是小写。 十六进制字符串中不能包含多余的前导零。 如果要转化的数为0，那么以单个字符'0'来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。 给定的数确保在32位有符号整数范围内。 不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。 示例 1： 输入:26 输出:\"1a\" 示例 2： 输入:-1 输出:\"ffffffff\" 解题思路 No. 思路 时间复杂度 空间复杂度 01 位运算 O(1) O(1) 02 遍历 O(1) O(1) var h = []string{ \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", } func toHex(num int) string { hex := \"\" if num == 0 { return \"0\" } for i := 0; i > 4 } return hex } # var h = []string{ \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", } func toHex(num int) string { res := \"\" if num == 0{ return \"0\" } if num 409.最长回文串(2) 题目 给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。 在构造过程中，请注意区分大小写。比如 \"Aa\" 不能当做一个回文字符串。 注意:假设字符串的长度不会超过 1010。 示例 1:输入:\"abccccdd\"输出:7 解释:我们可以构造的最长的回文串是\"dccaccd\", 它的长度是 7。 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组辅助 O(n) O(1) 02 哈希辅助 O(n) O(1) func longestPalindrome(s string) int { ret := 0 a := [123]int{} for i := range s { a[s[i]]++ } hasOdd := 0 for i := range a { if a[i] == 0 { continue } if a[i] % 2 == 0 { ret += a[i] } else { ret += a[i] - 1 hasOdd = 1 } } return ret + hasOdd } # func longestPalindrome(s string) int { ret := 0 a := make(map[byte]int) for i := range s { a[s[i]]++ } hasOdd := 0 for i := range a { if a[i] == 0 { continue } if a[i]%2 == 0 { ret += a[i] } else { ret += a[i] - 1 hasOdd = 1 } } return ret + hasOdd } 412.Fizz Buzz(1) 题目 写一个程序，输出从 1 到 n 数字的字符串表示。 1. 如果 n 是3的倍数，输出“Fizz”； 2. 如果 n 是5的倍数，输出“Buzz”； 3.如果 n 同时是3和5的倍数，输出 “FizzBuzz”。 示例：n = 15, 返回: [ \"1\", \"2\", \"Fizz\", \"4\", \"Buzz\", \"Fizz\", \"7\", \"8\", \"Fizz\", \"Buzz\", \"11\", \"Fizz\", \"13\", \"14\", \"FizzBuzz\" ] 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) func fizzBuzz(n int) []string { ret := make([]string, n) for i := range ret { x := i + 1 switch { case x%15 == 0: ret[i] = \"FizzBuzz\" case x%5 == 0: ret[i] = \"Buzz\" case x%3 == 0: ret[i] = \"Fizz\" default: ret[i] = strconv.Itoa(x) } } return ret } 414.第三大的数(2) 题目 给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。 示例 1:输入: [3, 2, 1]输出: 1 解释: 第三大的数是 1. 示例 2:输入: [1, 2]输出: 2 解释: 第三大的数不存在, 所以返回最大的数 2 . 示例 3:输入: [2, 2, 3, 1]输出: 1 解释: 注意，要求返回第三大的数，是指第三大且唯一出现的数。存在两个值为2的数，它们都排第二。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 排序遍历 O(nlog(n)) O(1) func thirdMax(nums []int) int { max1, max2, max3 := math.MinInt64, math.MinInt64, math.MinInt64 for _, n := range nums { if n == max1 || n == max2 { continue } switch { case max1 = 0; i-- { if nums[i] != nums[i+1] { k-- } if k == 0 { return nums[i] } } return maxValue } 415.字符串相加(2) 题目 给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。 注意： num1 和num2 的长度都小于 5100. num1 和num2 都只包含数字 0-9. num1 和num2 都不包含任何前导零。 你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。 解题思路 No. 思路 时间复杂度 空间复杂度 01 模拟遍历 O(n) O(1) 02 逆置进位模拟 O(n) O(1) func addStrings(num1 string, num2 string) string { if len(num1) > len(num2) { num1, num2 = num2, num1 } n1, n2 := len(num1), len(num2) a1, a2 := []byte(num1), []byte(num2) carry := byte(0) buf := make([]byte, n2+1) buf[0] = '1' for i := 1; i '9' { buf[n2+1-i] = buf[n2+1-i] - 10 carry = byte(1) } else { carry = byte(0) } } if carry == 1 { return string(buf) } return string(buf[1:]) } # func addStrings(num1 string, num2 string) string { if len(num1) > len(num2) { num1, num2 = num2, num1 } n1, n2 := len(num1), len(num2) a1, a2 := []byte(num1), []byte(num2) a1 = reverse(a1) a2 = reverse(a2) carry := 0 buf := make([]byte, 0) for i := 0; i 9 { buf = append(buf, byte(temp-10+'0')) carry = 1 } else { buf = append(buf, byte(temp+'0')) carry = 0 } } if carry == 1 { buf = append(buf, byte('1')) } return string(reverse(buf)) } func reverse(arr []byte) []byte { for i := 0; i 434.字符串中的单词数(2) 题目 统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。 请注意，你可以假定字符串里不包括任何不可打印的字符。 示例:输入: \"Hello, my name is John\"输出: 5 解释: 这里的单词是指连续的不是空格的字符，所以 \"Hello,\" 算作 1 个单词。 解题思路 No. 思路 时间复杂度 空间复杂度 01 内置函数 O(n) O(n) 02 遍历 O(n) O(1) func countSegments(s string) int { if len(s) == 0 { return 0 } return len(strings.Fields(s)) } # func countSegments(s string) int { count := 0 for i := 0; i 437.路径总和III(4) 题目 给定一个二叉树，它的每个结点都存放着一个整数值。 找出路径和等于给定数值的路径总数。 路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。 二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。 示例： root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \\ 5 -3 / \\ \\ 3 2 11 / \\ \\ 3 -2 1 返回 3。和等于 8 的路径有: 1. 5 -> 3 2. 5 -> 2 -> 1 3. -3 -> 11 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n^2) O(n) 02 2次递归 O(n^2) O(n) 03 迭代+递归 O(n^2) O(n) 04 保存路径 O(n^2) O(n) func pathSum(root *TreeNode, sum int) int { if root == nil { return 0 } res := 0 var helper func(*TreeNode, int) helper = func(node *TreeNode, sum int) { if node == nil { return } sum = sum - node.Val // 路径不需要从根节点开始，也不需要在叶子节点结束 if sum == 0 { res++ } helper(node.Left, sum) helper(node.Right, sum) } helper(root, sum) return res + pathSum(root.Left, sum) + pathSum(root.Right, sum) } # func helper(node *TreeNode, sum int) int { if node == nil { return 0 } sum = sum - node.Val res := 0 if sum == 0 { res = 1 } return res + helper(node.Left, sum) + helper(node.Right, sum) } func pathSum(root *TreeNode, sum int) int { if root == nil { return 0 } return helper(root, sum) + pathSum(root.Left, sum) + pathSum(root.Right, sum) } # 迭代+递归 func helper(node *TreeNode, sum int, curSum int) int { res := 0 curSum = curSum + node.Val if curSum == sum { res++ } if node.Left != nil { res += helper(node.Left, sum, curSum) } if node.Right != nil { res += helper(node.Right, sum, curSum) } return res } func pathSum(root *TreeNode, sum int) int { if root == nil { return 0 } queue := make([]*TreeNode, 0) queue = append(queue, root) res := 0 for len(queue) > 0 { node := queue[0] queue = queue[1:] tempSum := 0 res += helper(node, sum, tempSum) if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } return res } # func helper(node *TreeNode, sum int, path []int, level int) int { if node == nil { return 0 } res := 0 if sum == node.Val { res = 1 } temp := node.Val for i := level - 1; i >= 0; i-- { temp = temp + path[i] if temp == sum { res++ } } path[level] = node.Val return res + helper(node.Left, sum, path, level+1) + helper(node.Right, sum, path, level+1) } func pathSum(root *TreeNode, sum int) int { return helper(root, sum, make([]int, 1001), 0) } 441.排列硬币(3) 题目 你总共有 n 枚硬币，你需要将它们摆成一个阶梯形状，第 k 行就必须正好有 k 枚硬币。 给定一个数字 n，找出可形成完整阶梯行的总行数。 n 是一个非负整数，并且在32位有符号整型的范围内。 示例 1:n = 5 硬币可排列成以下几行: ¤ ¤ ¤ ¤ ¤ 因为第三行不完整，所以返回2. 示例 2:n = 8 硬币可排列成以下几行: ¤ ¤ ¤ ¤ ¤ ¤ ¤ ¤ 因为第四行不完整，所以返回3. 解题思路 No. 思路 时间复杂度 空间复杂度 01 数学法 O(1) O(1) 02 迭代 O(n^1/2) O(1) 03 二分查找 O(log(n)) O(1) func arrangeCoins(n int) int { return int(math.Sqrt(float64(2*n)+0.25) - 0.5) } # func arrangeCoins(n int) int { i := 1 for i 443.压缩字符串(1) 题目 给定一组字符，使用原地算法将其压缩。 压缩后的长度必须始终小于或等于原数组长度。 数组的每个元素应该是长度为1 的字符（不是 int 整数类型）。 在完成原地修改输入数组后，返回数组的新长度。 进阶：你能否仅使用O(1) 空间解决问题？ 示例 1：输入：[\"a\",\"a\",\"b\",\"b\",\"c\",\"c\",\"c\"] 输出：返回6，输入数组的前6个字符应该是：[\"a\",\"2\",\"b\",\"2\",\"c\",\"3\"] 说明：\"aa\"被\"a2\"替代。\"bb\"被\"b2\"替代。\"ccc\"被\"c3\"替代。 示例 2：输入：[\"a\"] 输出：返回1，输入数组的前1个字符应该是：[\"a\"] 说明：没有任何字符串被替代。 示例 3：输入：[\"a\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"] 输出：返回4，输入数组的前4个字符应该是：[\"a\",\"b\",\"1\",\"2\"]。 说明：由于字符\"a\"不重复，所以不会被压缩。\"bbbbbbbbbbbb\"被“b12”替代。 注意每个数字在数组中都有它自己的位置。 注意： 所有字符都有一个ASCII值在[35, 126]区间内。 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n) O(1) func compress(chars []byte) int { j := 0 count := 1 for i := 0; i 1 { for _, num := range strconv.Itoa(count) { chars[j] = byte(num) j++ } } count = 1 } } return j } 447.回旋镖的数量(1) 题目 给定平面上 n 对不同的点，“回旋镖” 是由点表示的元组 (i, j, k) ， 其中 i 和 j 之间的距离和 i 和 k 之间的距离相等（需要考虑元组的顺序）。 找到所有回旋镖的数量。你可以假设 n 最大为 500，所有点的坐标在闭区间 [-10000, 10000] 中。 示例: 输入:[[0,0],[1,0],[2,0]] 输出:2 解释:两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]] 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助+遍历 O(n^2) O(n) func numberOfBoomerangs(points [][]int) int { res := 0 size := len(points) if size 448.找到所有数组中消失的数字(3) 题目 给定一个范围在 1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。 找到所有在 [1, n] 范围之间没有出现在数组中的数字。 您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。 示例:输入:[4,3,2,7,8,2,3,1]输出:[5,6] 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历交换 O(n) O(1) 02 遍历置反 O(n) O(1) 03 哈希辅助 O(n) O(n) func findDisappearedNumbers(nums []int) []int { for i := 0; i 0{ nums[value-1] = -nums[value-1] } } res := make([]int, 0) for key, value := range nums { if value > 0{ res = append(res, key+1) } } return res } # func findDisappearedNumbers(nums []int) []int { m := make(map[int]int) for i := 0; i 453.最小移动次数使数组元素相等(2) 题目 给定一个长度为 n 的非空整数数组，找到让数组所有元素相等的最小移动次数。每次移动可以使 n - 1 个元素增加 1。 示例:输入:[1,2,3]输出:3 解释:只需要3次移动（注意每次移动会增加两个元素的值）： [1,2,3] => [2,3,3] => [3,4,3] => [4,4,4] 解题思路 No. 思路 时间复杂度 空间复杂度 01 数学公式 O(n) O(1) 02 排序遍历 O(nlog(n)) O(1) func minMoves(nums []int) int { sum := 0 min := nums[0] for _, n := range nums { sum += n if min > n { min = n } } return sum - min*len(nums) } # func minMoves(nums []int) int { sum := 0 sort.Ints(nums) for i := 1; i 455.分发饼干(1) 题目 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。 对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸； 并且每块饼干 j ，都有一个尺寸 sj 。 如果 sj >= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。 你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 注意：你可以假设胃口值为正。一个小朋友最多只能拥有一块饼干。 示例 1:输入: [1,2,3], [1,1] 输出: 1 解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。 虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。 示例 2:输入: [1,2], [1,2,3] 输出: 2 解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。 你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2. 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序双指针 O(nlog(n)) O(1) func findContentChildren(g []int, s []int) int { sort.Ints(g) sort.Ints(s) var i, j int for i 459.重复的子字符串(2) 题目 给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。 给定的字符串只含有小写英文字母，并且长度不超过10000。 示例 1:输入: \"abab\"输出: True 解释: 可由子字符串 \"ab\" 重复两次构成。 示例 2:输入: \"aba\"输出: False 示例 3:输入: \"abcabcabcabc\"输出: True 解释: 可由子字符串 \"abc\" 重复四次构成。 (或者子字符串 \"abcabc\" 重复两次构成。) 解题思路 No. 思路 时间复杂度 空间复杂度 01 2倍去除首尾匹配 O(n) O(1) 02 暴力匹配 O(n^2) O(1) func repeatedSubstringPattern(s string) bool { if len(s) == 0 { return false } size := len(s) ss := (s + s)[1 : size*2-1] return strings.Contains(ss, s) } # func repeatedSubstringPattern(s string) bool { if len(s) == 0 { return false } size := len(s) for i := 1; i 461.汉明距离(3) 题目 两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。 给出两个整数 x 和 y，计算它们之间的汉明距离。 注意： 0 ≤ x, y 解题思路 No. 思路 时间复杂度 空间复杂度 01 位运算+遍历统计 O(1) O(1) 02 位运算 O(1) O(1) 03 内置函数 O(1) O(1) func hammingDistance(x int, y int) int { x = x ^ y res := 0 for x > 0 { if x&1 == 1{ res++ } x = x >> 1 } return res } # func hammingDistance(x int, y int) int { x = x ^ y res := 0 for x > 0 { res++ x = x & (x-1) } return res } # func hammingDistance(x int, y int) int { x = x ^ y return bits.OnesCount(uint(x)) } 463.岛屿的周长(3) 题目 给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。 网格中的格子水平和垂直方向相连（对角线方向不相连）。 整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。 岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。 网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。 示例 : 输入: [[0,1,0,0], [1,1,1,0], [0,1,0,0], [1,1,0,0]] 输出: 16 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法 O(n^2) O(1) 02 暴力法 O(n^2) O(1) 03 深度优先搜索 O(n^2) O(n^2) func islandPerimeter(grid [][]int) int { var dx = []int{-1, 1, 0, 0} var dy = []int{0, 0, -1, 1} m, n := len(grid), len(grid[0]) res := 0 for i := 0; i 0 && grid[i-1][j] == 1 { res -= 2 } if j > 0 && grid[i][j-1] == 1 { res -= 2 } } } return res } # func islandPerimeter(grid [][]int) int { m, n := len(grid), len(grid[0]) for i := 0; i 475.供暖器(2) 题目 冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。 现在，给出位于一条水平线上的房屋和供暖器的位置，找到可以覆盖所有房屋的最小加热半径。 所以，你的输入将会是房屋和供暖器的位置。你将输出供暖器的最小加热半径。 说明: 给出的房屋和供暖器的数目是非负数且不会超过 25000。 给出的房屋和供暖器的位置均是非负数且不会超过10^9。 只要房屋位于供暖器的半径内(包括在边缘上)，它就可以得到供暖。 所有供暖器都遵循你的半径标准，加热的半径也一样。 示例 1:输入: [1,2,3],[2] 输出: 1 解释: 仅在位置2上有一个供暖器。如果我们将加热半径设为1，那么所有房屋就都能得到供暖。 示例 2:输入: [1,2,3,4],[1,4] 输出: 1 解释: 在位置1, 4上有两个供暖器。我们需要将加热半径设为1，这样所有房屋就都能得到供暖。 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序双指针 O(nlog(n)) O(1) 02 排序二分查找 O(nlog(n)) O(1) func findRadius(houses []int, heaters []int) int { if len(heaters) == 0 { return 0 } sort.Ints(houses) sort.Ints(heaters) res := 0 j := 0 for i := 0; i =确保出现重复的供暖器会往后走 for j = Abs(houses[i], heaters[j+1]) { j++ } res = Max(Abs(houses[i], heaters[j]), res) } return res } func Abs(a, b int) int { if a > b { return a - b } return b - a } func Max(a, b int) int { if a > b { return a } return b } # func findRadius(houses []int, heaters []int) int { if len(heaters) == 0 { return 0 } sort.Ints(houses) sort.Ints(heaters) res := 0 length := len(heaters) for i := 0; i houses[i] { if left == 0 { dis = heaters[0] - houses[i] } else { dis = Min(heaters[left]-houses[i], houses[i]-heaters[left-1]) } } res = Max(res, dis) } return res } func Min(a, b int) int { if a > b { return b } return a } func Max(a, b int) int { if a > b { return a } return b } 476.数字的补数(3) 题目 给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。 示例 1:输入: 5 输出: 2 解释: 5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。 示例 2:输入: 1 输出: 0 解释: 1 的二进制表示为 1（没有前导零位），其补数为 0。所以你需要输出 0 。 注意: 给定的整数保证在 32 位带符号整数的范围内。 你可以假定二进制数不包含前导零位。 本题与 1009 https://leetcode-cn.com/problems/complement-of-base-10-integer/ 相同 解题思路 No. 思路 时间复杂度 空间复杂度 01 位运算 O(log(n)) O(1) 02 位运算 O(log(n)) O(1) 03 遍历 O(log(n)) O(1) func findComplement(num int) int { temp := 1 for num >= temp { temp = temp 0 { temp = temp >> 1 res = res 0 { temp := num % 2 if temp == 0 { res = res + exp exp = exp * 2 } else { exp = exp * 2 } num = num / 2 } return res } 482.密钥格式化(2) 题目 有一个密钥字符串 S ，只包含字母，数字以及 '-'（破折号）。 其中， N 个 '-' 将字符串分成了 N+1 组。 给你一个数字 K，请你重新格式化字符串，除了第一个分组以外，每个分组要包含 K 个字符； 而第一个分组中，至少要包含 1 个字符。 两个分组之间需要用 '-'（破折号）隔开，并且将所有的小写字母转换为大写字母。 给定非空字符串 S 和数字 K，按照上面描述的规则进行格式化。 示例 1：输入：S = \"5F3Z-2e-9-w\", K = 4 输出：\"5F3Z-2E9W\" 解释：字符串 S 被分成了两个部分，每部分 4 个字符；注意，两个额外的破折号需要删掉。 示例 2：输入：S = \"2-5g-3-J\", K = 2 输出：\"2-5G-3J\" 解释：字符串 S 被分成了 3 个部分，按照前面的规则描述， 第一部分的字符可以少于给定的数量，其余部分皆为 2 个字符。 提示: S 的长度可能很长，请按需分配大小。K 为正整数。 S 只包含字母数字（a-z，A-Z，0-9）以及破折号'-' S 非空 解题思路 No. 思路 时间复杂度 空间复杂度 01 内置函数 O(n) O(1) 02 遍历 O(n) O(1) func licenseKeyFormatting(S string, K int) string { arr := strings.Join(strings.Split(strings.ToUpper(S), \"-\"), \"\") count := len(arr) / K first := len(arr) % K if first > 0 { count++ } str := arr[:first] if first != 0 { count = count - 1 } for i := 0; i = 0; i-- { value := temp[i] if value >= 'a' { value = value - 'a' + 'A' } if value == '-' { continue } count++ res = append([]rune{value}, res...) if count == K { res = append([]rune{'-'}, res...) count = 0 } } if len(res) == 0 { return \"\" } if res[0] == '-' { res = res[1:] } return string(res) } 485.最大连续1的个数(2) 题目 给定一个二进制数组， 计算其中最大连续1的个数。 示例 1:输入: [1,1,0,1,1,1]输出: 3 解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3. 注意： 输入的数组只包含 0 和1。 输入数组的长度是正整数，且不超过 10,000。 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n) O(1) 02 单指针 O(n) O(1) func findMaxConsecutiveOnes(nums []int) int { max := 0 for i, j := 0, -1; i max { max = count } count = 0 } } if count > max { max = count } return max } 492.构造矩形(1) 题目 作为一位web开发者， 懂得怎样去规划一个页面的尺寸是很重要的。 现给定一个具体的矩形页面面积，你的任务是设计一个长度为 L 和宽度为 W 且满足以下要求的矩形的页面。要求： 1. 你设计的矩形页面必须等于给定的目标面积。 2. 宽度 W 不应大于长度 L，换言之，要求 L >= W 。 3. 长度 L 和宽度 W 之间的差距应当尽可能小。 你需要按顺序输出你设计的页面的长度 L 和宽度 W。 示例： 输入: 4 输出: [2, 2] 解释: 目标面积是 4， 所有可能的构造方案有 [1,4], [2,2], [4,1]。 但是根据要求2，[1,4] 不符合要求; 根据要求3，[2,2] 比 [4,1] 更能符合要求. 所以输出长度 L 为 2， 宽度 W 为 2。 说明: 给定的面积不大于 10,000,000 且为正整数。 你设计的页面的长度和宽度必须都是正整数。 解题思路 No. 思路 时间复杂度 空间复杂度 01 开方向下遍历 O(n) O(1) func constructRectangle(area int) []int { for i := int(math.Sqrt(float64(area))); i > 1; i-- { if area%i == 0 { return []int{area / i, i} } } return []int{area, 1} } 496.下一个更大元素 I(3) 题目 给定两个没有重复元素的数组nums1 和 nums2 ，其中nums1 是 nums2 的子集。 找到 nums1 中每个元素在 nums2 中的下一个比其大的值。 nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。 如果不存在，对应位置输出 -1 。 示例 1: 输入: nums1 = [4,1,2], nums2 = [1,3,4,2]. 输出: [-1,3,-1] 解释: 对于num1中的数字4，你无法在第二个数组中找到下一个更大的数字，因此输出 -1。 对于num1中的数字1，第二个数组中数字1右边的下一个较大数字是 3。 对于num1中的数字2，第二个数组中没有下一个更大的数字，因此输出 -1。 示例 2: 输入: nums1 = [2,4], nums2 = [1,2,3,4]. 输出: [3,-1] 解释: 对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。 对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出 -1 。 提示： nums1和nums2中所有元素是唯一的。 nums1和nums2 的数组大小都不超过1000。 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n^2) O(n) 02 哈希辅助 O(n^2) O(n) 02 栈+哈希辅助 O(n) O(n) func nextGreaterElement(nums1 []int, nums2 []int) []int { m := make(map[int]int) for i, n := range nums2 { m[n] = i } res := make([]int, len(nums1)) for i, n := range nums1 { res[i] = -1 for j := m[n] + 1; j nums2[i] { m[nums2[i]] = nums2[j] break } } } for key, value := range nums1 { if _, ok := m[value]; ok { res[key] = m[value] } else { res[key] = -1 } } return res } # func nextGreaterElement(nums1 []int, nums2 []int) []int { m := make(map[int]int) res := make([]int, len(nums1)) stack := make([]int, 0) for i := 0; i 0 { for len(stack) > 0 && nums2[i] > stack[len(stack)-1] { top := stack[len(stack)-1] m[top] = nums2[i] stack = stack[:len(stack)-1] } } stack = append(stack, nums2[i]) } for key, value := range nums1 { if _, ok := m[value]; ok { res[key] = m[value] } else { res[key] = -1 } } return res } 500.键盘行(4) 题目 给定一个单词列表，只返回可以使用在键盘同一行的字母打印出来的单词。键盘如下图所示。 示例： 输入: [\"Hello\", \"Alaska\", \"Dad\", \"Peace\"] 输出: [\"Alaska\", \"Dad\"] 注意： 你可以重复使用键盘上同一字符。 你可以假设输入的字符串将只包含字母。 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n^2) O(1) 02 哈希辅助 O(n^2) O(1) 03 遍历 O(n^2) O(1) 04 内置函数 O(n^2) O(1) func findWords(words []string) []string { m := make(map[byte]int) m['q'] = 1 m['w'] = 1 m['e'] = 1 m['r'] = 1 m['t'] = 1 m['y'] = 1 m['u'] = 1 m['i'] = 1 m['o'] = 1 m['p'] = 1 m['a'] = 2 m['s'] = 2 m['d'] = 2 m['f'] = 2 m['g'] = 2 m['h'] = 2 m['j'] = 2 m['k'] = 2 m['l'] = 2 m['z'] = 3 m['x'] = 3 m['c'] = 3 m['v'] = 3 m['b'] = 3 m['n'] = 3 m['m'] = 3 res := make([]string, 0) for i := 0; i 0401-0500-Medium 406.根据身高重建队列(2) 题目 假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。 注意： 总人数少于1100人。 示例 输入:[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]] 输出:[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序遍历 O(n^2) O(n) 02 排序遍历 O(n^2) O(n) func reconstructQueue(people [][]int) [][]int { sort.Slice(people, func(i, j int) bool { if people[i][0] == people[j][0] { return people[i][1] people[j][0] // 升高 递减 }) for i := 0; i people[j][0] // 升高 递减 }) for i := 0; i index; j-- { people[j] = people[j-1] } people[index] = p } return people } 416.分割等和子集(3) 题目 给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 注意:每个数组中的元素不会超过 100 数组的大小不会超过 200 示例 1:输入: [1, 5, 11, 5] 输出: true 解释: 数组可以分割成 [1, 5, 5] 和 [11]. 示例 2:输入: [1, 2, 3, 5] 输出: false 解释: 数组不能分割成两个元素和相等的子集. 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n^2) O(n^2) 02 动态规划 O(n^2) O(n) 03 回溯-递归 O(n!) O(n) func canPartition(nums []int) bool { sum := 0 for i := 0; i = 0; j-- { if j-nums[i] >= 0 && dp[j-nums[i]] == true { dp[j] = true } } } return dp[target] } # 3 func canPartition(nums []int) bool { sort.Ints(nums) sum := 0 for i := 0; i 438.找到字符串中所有字母异位词(2) 题目 给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。 字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。 说明：字母异位词指字母相同，但排列不同的字符串。 不考虑答案输出的顺序。 示例 1:输入: s: \"cbaebabacd\" p: \"abc\"输出: [0, 6] 解释:起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的字母异位词。 起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的字母异位词。 示例 2:输入: s: \"abab\" p: \"ab\"输出: [0, 1, 2] 解释:起始索引等于 0 的子串是 \"ab\", 它是 \"ab\" 的字母异位词。 起始索引等于 1 的子串是 \"ba\", 它是 \"ab\" 的字母异位词。 起始索引等于 2 的子串是 \"ab\", 它是 \"ab\" 的字母异位词。 解题思路 No. 思路 时间复杂度 空间复杂度 01 滑动窗口 O(n) O(1) 02 滑动窗口 O(n) O(1) func findAnagrams(s string, p string) []int { res := make([]int, 0) if len(p) > len(s) { return res } arr1, arr2 := [26]int{}, [26]int{} for i := 0; i len(s) { return res } m1, m2 := make(map[byte]int), make(map[byte]int) for i := 0; i 442.数组中重复的数据(5) 题目 给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。 找到所有出现两次的元素。 你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗？ 示例：输入: [4,3,2,7,8,2,3,1] 输出:[2,3] 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(n) 02 置反 O(n) O(1) 03 置换 O(n) O(1) 04 累加 O(n) O(1) 05 排序 O(nlog(n)) O(1) func findDuplicates(nums []int) []int { res := make([]int, 0) m := make(map[int]int) for i := 0; i = 0 { return a } return -a } # 3 func findDuplicates(nums []int) []int { res := make([]int, 0) for i := 0; i 445.两数相加II(3) 题目 给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。 它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。 你可以假设除了数字 0 之外，这两个数字都不会以零开头。 进阶：如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。 示例：输入：(7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4) 输出：7 -> 8 -> 0 -> 7 解题思路 No. 思路 时间复杂度 空间复杂度 01 反转遍历 O(n) O(n) 02 栈辅助 O(n) O(n) 03 递归 O(n) O(n) func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { l1 = reverse(l1) l2 = reverse(l2) res := &ListNode{} cur := res carry := 0 for l1 != nil || l2 != nil || carry > 0 { sum := carry if l1 != nil { sum += l1.Val l1 = l1.Next } if l2 != nil { sum += l2.Val l2 = l2.Next } carry = sum / 10 // 进位 cur.Next = &ListNode{Val: sum % 10} cur = cur.Next } return reverse(res.Next) } func reverse(head *ListNode) *ListNode { var result *ListNode var temp *ListNode for head != nil { temp = head.Next head.Next = result result = head head = temp } return result } # 2 func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { stack1 := make([]int, 0) stack2 := make([]int, 0) for l1 != nil { stack1 = append(stack1, l1.Val) l1 = l1.Next } for l2 != nil { stack2 = append(stack2, l2.Val) l2 = l2.Next } var res *ListNode carry := 0 for len(stack1) > 0 || len(stack2) > 0 || carry > 0 { if len(stack1) > 0 { carry = carry + stack1[len(stack1)-1] stack1 = stack1[:len(stack1)-1] } if len(stack2) > 0 { carry = carry + stack2[len(stack2)-1] stack2 = stack2[:len(stack2)-1] } temp := &ListNode{ Val: carry % 10, Next: res, } carry = carry / 10 res = temp } return res } # 3 func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { a, b := l1, l2 length1, length2 := 0, 0 for a != nil { length1++ a = a.Next } for b != nil { length2++ b = b.Next } res, carry := add(l1, l2, length1, length2) if carry > 0 { return &ListNode{Val: carry, Next: res} } return res } func add(l1, l2 *ListNode, length1, length2 int) (res *ListNode, carry int) { if l1 != nil && l2 != nil { if l1.Next == nil && l2.Next == nil { val := l1.Val + l2.Val carry = val / 10 res = &ListNode{Val: val % 10, Next: nil} return } } a := &ListNode{} var b, n int if length1 > length2 { a, b = add(l1.Next, l2, length1-1, length2) n = l1.Val + b } else if length1 486.预测赢家(3) 题目 给定一个表示分数的非负整数数组。 玩家 1 从数组任意一端拿取一个分数， 随后玩家 2 继续从剩余数组任意一端拿取分数，然后玩家 1 拿，…… 。 每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。 最终获得分数总和最多的玩家获胜。 给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。 示例 1：输入：[1, 5, 2] 输出：False 解释：一开始，玩家1可以从1和2中进行选择。 如果他选择 2（或者 1 ），那么玩家 2 可以从 1（或者 2 ）和 5 中进行选择。 如果玩家 2 选择了 5 ，那么玩家 1 则只剩下 1（或者 2 ）可选。 所以，玩家 1 的最终分数为 1 + 2 = 3，而玩家 2 为 5 。 因此，玩家 1 永远不会成为赢家，返回 False 。 示例 2：输入：[1, 5, 233, 7] 输出：True 解释：玩家 1 一开始选择 1 。然后玩家 2 必须从 5 和 7 中进行选择。 无论玩家 2 选择了哪个，玩家 1 都可以选择 233 。 最终，玩家 1（234 分）比玩家 2（12 分）获得更多的分数，所以返回 True，表示玩家 1 可以成为赢家。 提示：1 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(2^n) O(n) 02 动态规划-一维 O(n^2) O(n) 03 动态规划-二维 O(n^2) O(n^2) func PredictTheWinner(nums []int) bool { return dfs(nums, 0, len(nums)-1) >= 0 } func dfs(nums []int, start, end int) int { if start > end { return 0 } // 玩家得分：自己得分-对手得分 left := nums[start] - dfs(nums, start+1, end) right := nums[end] - dfs(nums, start, end-1) return max(left, right) } func max(a, b int) int { if a > b { return a } return b } # 2 func PredictTheWinner(nums []int) bool { dp := make([]int, len(nums)) for i := 0; i = 0; i-- { for j := i + 1; j = 0 } func max(a, b int) int { if a > b { return a } return b } # 3 func PredictTheWinner(nums []int) bool { n := len(nums) dp := make([][]int, n) for i := 0; i = 0; i-- { for j := i + 1; j = 0 } func max(a, b int) int { if a > b { return a } return b } 494.目标和(5) 题目 给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。 对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。 返回可以使最终数组和为目标数 S 的所有添加符号的方法数。 示例：输入：nums: [1, 1, 1, 1, 1], S: 3 输出：5 解释： -1+1+1+1+1 = 3 +1-1+1+1+1 = 3 +1+1-1+1+1 = 3 +1+1+1-1+1 = 3 +1+1+1+1-1 = 3 一共有5种方法让最终目标和为3。 提示：数组非空，且长度不会超过 20 。 初始的数组的和不会超过 1000 。 保证返回的最终结果能被 32 位整数存下。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(2^n) O(n) 02 动态规划 O(2^n) O(n) 03 回溯 O(2^n) O(n) 04 动态规划-01背包 O(n^2) O(n) 05 动态规划 O(n^2) O(n^2) func findTargetSumWays(nums []int, S int) int { if len(nums) == 0 { return 0 } if len(nums) == 1 { if nums[0] == 0 && S == 0 { return 2 } if nums[0] == S || nums[0] == -S { return 1 } } value := nums[0] nums = nums[1:] return findTargetSumWays(nums, S-value) + findTargetSumWays(nums, S+value) } # 2 func findTargetSumWays(nums []int, S int) int { dp := make(map[int]int) dp[nums[0]]++ dp[-nums[0]]++ for i := 1; i x+y=sum, x-y=S => (sum+S)/2=x target := (sum + S) / 2 dp := make([]int, target+1) dp[0] = 1 for i := 1; i = 0; j-- { if j >= nums[i-1] { // 背包足够大，都选 dp[j] = dp[j] + dp[j-nums[i-1]] } else { // 容量不够，不选 dp[j] = dp[j] } } } return dp[target] } # 5 func findTargetSumWays(nums []int, S int) int { sum := 0 // 非负整数数组 for i := 0; i x+y=sum, x-y=S => (sum+S)/2=x target := (sum + S) / 2 // 在前i个物品中选择，若当前背包的容量为j，则最多有x种方法可以恰好装满背包。 dp := make([][]int, len(nums)+1) for i := 0; i = nums[i-1] { // 背包足够大，都选 dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i-1]] } else { // 容量不够，不选 dp[i][j] = dp[i-1][j] } } } return dp[len(nums)][target] } 491.递增子序列(2) 题目 给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。 示例:输入: [4, 6, 7, 7] 输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]] 说明:给定数组的长度不会超过15。 数组中的整数范围是 [-100,100]。 给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。 解题思路 No. 思路 时间复杂度 空间复杂度 01 深度优先搜索-回溯 O(2^n) O(2^n) 02 深度优先搜索-回溯 O(2^n) O(2^n) var res [][]int func findSubsequences(nums []int) [][]int { res = make([][]int, 0) dfs(nums, 0, math.MinInt32, make([]int, 0)) return res } func dfs(nums []int, index int, prev int, arr []int) { if index == len(nums) { if len(arr) >= 2 { temp := make([]int, len(arr)) copy(temp, arr) res = append(res, temp) } return } if prev = 2 { temp := make([]int, len(arr)) copy(temp, arr) res = append(res, temp) } m := make(map[int]bool) for i := index; i 0 && nums[i] 498.对角线遍历(2) 题目 给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素， 对角线遍历如下图所示。 示例: 输入: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] 输出: [1,2,4,7,5,3,6,8,9] 说明:给定矩阵中的元素总数不会超过 100000 。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n^2) O(n^2) 02 遍历 O(n^2) O(n^2) func findDiagonalOrder(matrix [][]int) []int { res := make([]int, 0) if len(matrix) == 0 { return res } n, m := len(matrix), len(matrix[0]) if n == 1 { return matrix[0] } i, j := 0, 0 flag := false for j = 0 { temp = append(temp, matrix[a][b]) a, b = a+1, b-1 } if i%2 == 0 { reverse(temp) } res = append(res, temp...) } return res } func reverse(arr []int) { for i := 0; i 0401-0500-Hard 410.分割数组的最大值(3) 题目 给定一个非负整数数组和一个整数 m，你需要将这个数组分成 m 个非空的连续子数组。 设计一个算法使得这 m 个子数组各自和的最大值最小。 注意:数组长度 n 满足以下条件: 1 ≤ n ≤ 1000 1 ≤ m ≤ min(50, n) 示例:输入: nums = [7,2,5,10,8] m = 2输出:18 解释:一共有四种方法将nums分割为2个子数组。 其中最好的方式是将其分为[7,2,5] 和 [10,8]， 因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。 解题思路 No. 思路 时间复杂度 空间复杂度 01 二分查找 O(nlog(n)) O(1) 02 动态规划+前缀和 O(n^3) O(n^2) 03 二分查找 O(nlog(n)) O(1) func splitArray(nums []int, m int) int { left, right := 0, 0 // 最小值，最大值 for i := 0; i target { count++ sum = arr[i] } else { sum = sum + arr[i] } } return count b { return b } return a } func max(a, b int) int { if a > b { return a } return b } # 3 func splitArray(nums []int, m int) int { left, right := 0, 0 // 最小值，最大值 for i := 0; i m { left = mid + 1 } else { right = mid } } return left } // 区间和的最大值为target时，所得出的区间数 func check(arr []int, target int, m int) int { sum := 0 count := 1 for i := 0; i target { count++ sum = 0 } sum = sum + arr[i] } return count } 460.LFU缓存 题目 请你为 最不经常使用（LFU）缓存算法设计并实现数据结构。它应该支持以下操作：get 和 put。 get(key) - 如果键存在于缓存中，则获取键的值（总是正数），否则返回 -1。 put(key, value) - 如果键已存在，则变更其值；如果键不存在，请插入键值对。 当缓存达到其容量时，则应该在插入新项之前，使最不经常使用的项无效。 在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除最久未使用的键。 「项的使用次数」就是自插入该项以来对其调用 get 和 put 函数的次数之和。使用次数会在对应项被移除后置为 0 。 进阶：你是否可以在 O(1) 时间复杂度内执行两项操作？ 示例：LFUCache cache = new LFUCache( 2 /* capacity (缓存容量) */ ); cache.put(1, 1); cache.put(2, 2); cache.get(1); // 返回 1 cache.put(3, 3); // 去除 key 2 cache.get(2); // 返回 -1 (未找到key 2) cache.get(3); // 返回 3 cache.put(4, 4); // 去除 key 1 cache.get(1); // 返回 -1 (未找到 key 1) cache.get(3); // 返回 3 cache.get(4); // 返回 4 解题思路 No. 思路 时间复杂度 空间复杂度 01 反转遍历 O(n) O(n) Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 10:28:27 "},"docs/source/question/0501-0600.html":{"url":"docs/source/question/0501-0600.html","title":"0501-0600","keywords":"","body":"0501-0600-Easy 0501-0600-Easy 501.二叉搜索树中的众数(2) 504.七进制数(3) 506.相对名次(1) 507.完美数(1) 509.斐波那契数(6) 520.检测大写字母(2) 521.最长特殊序列Ⅰ(1) 530.二叉搜索树的最小绝对差(3) 532.数组中的K-diff数对(3) 538.把二叉搜索树转换为累加树(2) 541.反转字符串II(2) 543.二叉树的直径(2) 551.学生出勤记录 I(2) 557.反转字符串中的单词 III(2) 559.N叉树的最大深度(2) 561.数组拆分 I(2) 563.二叉树的坡度(2) 566.重塑矩阵(2) 572.另一个树的子树(3) 575.分糖果(2) 581.最短无序连续子数组(3) 589.N叉树的前序遍历(2) 590.N叉树的后序遍历(2) 594.最长和谐子序列(2) 598.范围求和 II(1) 599.两个列表的最小索引总和(2) 0501-0600-Medium 516.最长回文子序列(3) 518.零钱兑换II(2) 523.连续的子数组和(2) 542.01矩阵(3) 560.和为K的子数组(4) 567.字符串的排列(2) 0501-0600-Hard 502.IPO 题目 解题思路 501.二叉搜索树中的众数(2) 题目 给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。 假定 BST 有如下定义： 结点左子树中所含结点的值小于等于当前结点的值 结点右子树中所含结点的值大于等于当前结点的值 左子树和右子树都是二叉搜索树 例如： 给定 BST [1,null,2,2], 1 \\ 2 / 2 返回[2]. 提示：如果众数超过1个，不需考虑输出顺序 进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内） 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归+哈希辅助 O(n) O(n) 02 递归+中序遍历 O(n) O(log(n)) func findMode(root *TreeNode) []int { m := map[int]int{} dfs(root, m) max := -1 res := make([]int, 0) for i, v := range m { if max 504.七进制数(3) 题目 给定一个整数，将其转化为7进制，并以字符串形式输出。 示例 1:输入: 100 输出: \"202\" 示例 2: 输入: -7 输出: \"-10\" 注意: 输入范围是 [-1e7, 1e7] 。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(log(n)) O(1) 02 内置函数 O(log(n)) O(1) 03 递归 O(log(n)) O(log(n)) func convertToBase7(num int) string { if num == 0 { return \"0\" } minus := \"\" if num 0 { s = fmt.Sprintf(\"%d\", num%7) + s num = num / 7 } return minus + s } # func convertToBase7(num int) string { return strconv.FormatInt(int64(num), 7) } # func convertToBase7(num int) string { if num 506.相对名次(1) 题目 给出 N 名运动员的成绩，找出他们的相对名次并授予前三名对应的奖牌。 前三名运动员将会被分别授予 “金牌”，“银牌” 和“ 铜牌” （\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\"）。 (注：分数越高的选手，排名越靠前。) 示例 1: 输入: [5, 4, 3, 2, 1] 输出: [\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\", \"4\", \"5\"] 解释: 前三名运动员的成绩为前三高的， 因此将会分别被授予 “金牌”，“银牌”和“铜牌” (\"Gold Medal\", \"Silver Medal\" and \"Bronze Medal\"). 余下的两名运动员，我们只需要通过他们的成绩计算将其相对名次即可。 提示: N 是一个正整数并且不会超过 10000。 所有运动员的成绩都不相同。 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序+遍历 O(nlog(n)) O(n) func findRelativeRanks(nums []int) []string { temp := make([]int, len(nums)) copy(temp, nums) sort.Ints(temp) m := make(map[int]string) for i := 0; i 507.完美数(1) 题目 对于一个 正整数，如果它和除了它自身以外的所有正因子之和相等，我们称它为“完美数”。 给定一个 整数 n， 如果他是完美数，返回 True，否则返回 False 示例：输入: 28 输出: True 解释: 28 = 1 + 2 + 4 + 7 + 14 提示：输入的数字 n 不会超过 100,000,000. (1e8) 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n^1/2) O(1) func checkPerfectNumber(num int) bool { if num == 1 { return false } sum := 1 for i := 2; i 509.斐波那契数(6) 题目 斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。 该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), 其中 N > 1. 给定 N，计算 F(N)。 示例 1：输入：2输出：1 解释：F(2) = F(1) + F(0) = 1 + 0 = 1. 示例 2：输入：3输出：2 解释：F(3) = F(2) + F(1) = 1 + 1 = 2. 示例 3：输入：4输出：3 解释：F(4) = F(3) + F(2) = 2 + 1 = 3. 提示： 0 ≤ N ≤ 30 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 遍历+数组 O(n) O(n) 03 递归 O(2^n) O(n) 04 公式法 O(1) O(1) 05 矩阵快速幂 O(log(n)) O(1) 06 矩阵快速幂 O(n) O(1) func fib(N int) int { if N == 0 { return 0 } if N == 1 { return 1 } n1, n2 := 0, 1 for i := 2; i 0 { if N%2 == 1 { ans = multi(ans, m) } m = multi(m, m) N = N >> 1 } return ans.b } /* a b c d */ type matrix struct { a, b, c, d int } // 矩阵乘法 func multi(x, y matrix) matrix { newA := x.a*y.a + x.b*y.c newB := x.a*y.b + x.b*y.d newC := x.c*y.a + x.d*y.c newD := x.c*y.b + x.d*y.d return matrix{ a: newA, b: newB, c: newC, d: newD, } } # 6 func fib(N int) int { if N == 0 { return 0 } /* ans = [Fn+1 Fn Fn Fn-1] = [ 1 0 0 1] */ ans := matrix{ a: 1, b: 0, c: 0, d: 1, } m := matrix{ a: 1, b: 1, c: 1, d: 0, } for N > 0 { ans = multi(ans, m) N-- } return ans.b } /* a b c d */ type matrix struct { a, b, c, d int } // 矩阵乘法 func multi(x, y matrix) matrix { newA := x.a*y.a + x.b*y.c newB := x.a*y.b + x.b*y.d newC := x.c*y.a + x.d*y.c newD := x.c*y.b + x.d*y.d return matrix{ a: newA, b: newB, c: newC, d: newD, } } 520.检测大写字母(2) 题目 给定一个单词，你需要判断单词的大写使用是否正确。 我们定义，在以下情况时，单词的大写用法是正确的： 全部字母都是大写，比如\"USA\"。 单词中所有字母都不是大写，比如\"leetcode\"。 如果单词不只含有一个字母，只有首字母大写， 比如 \"Google\"。 否则，我们定义这个单词没有正确使用大写字母。 示例 1:输入: \"USA\"输出: True 示例 2:输入: \"FlaG\"输出: False 注意: 输入是由大写和小写拉丁字母组成的非空单词。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 正则 O(n) O(1) func detectCapitalUse(word string) bool { if word == \"\" { return false } count := 0 for i := 0; i = 'A' && word[i] = 'A' && word[0] 521.最长特殊序列Ⅰ(1) 题目 给你两个字符串，请你从这两个字符串中找出最长的特殊序列。 「最长特殊序列」定义如下：该序列为某字符串独有的最长子序列（即不能是其他字符串的子序列）。 子序列 可以通过删去字符串中的某些字符实现，但不能改变剩余字符的相对顺序。空序列为所有字符串的子序列，任何字符串为其自身的子序列。 输入为两个字符串，输出最长特殊序列的长度。如果不存在，则返回 -1。 示例 1：输入: \"aba\", \"cdc\" 输出: 3 解释: 最长特殊序列可为 \"aba\" (或 \"cdc\")，两者均为自身的子序列且不是对方的子序列。 示例 2：输入：a = \"aaa\", b = \"bbb\"输出：3 示例 3：输入：a = \"aaa\", b = \"aaa\"输出：-1 提示： 两个字符串长度均处于区间 [1 - 100] 。 字符串中的字符仅含有 'a'~'z' 。 解题思路 No. 思路 时间复杂度 空间复杂度 01 比较 O(1) O(1) func findLUSlength(a string, b string) int { if a == b { return -1 } return max(len(a), len(b)) } func max(a, b int) int { if a > b { return a } return b } 530.二叉搜索树的最小绝对差(3) 题目 给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。 示例： 输入： 1 \\ 3 / 2 输出：1 解释： 最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。 提示： 树中至少有 2 个节点。 本题与 783 https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/ 相同 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归+中序遍历 O(n) O(log(n)) 02 递归+遍历 O(n) O(n) 03 迭代 O(n) O(n) var minDiff, previous int func getMinimumDifference(root *TreeNode) int { minDiff, previous = math.MaxInt32, math.MaxInt32 dfs(root) return minDiff } func dfs(root *TreeNode) { if root == nil { return } dfs(root.Left) newDiff := diff(previous, root.Val) if minDiff > newDiff { minDiff = newDiff } previous = root.Val dfs(root.Right) } func diff(a, b int) int { if a > b { return a - b } return b - a } # func getMinimumDifference(root *TreeNode) int { arr := make([]int, 0) dfs(root, &arr) minDiff := arr[1] - arr[0] for i := 2; i arr[i]-arr[i-1] { minDiff = arr[i] - arr[i-1] } } return minDiff } func dfs(root *TreeNode, arr *[]int) { if root == nil { return } dfs(root.Left, arr) *arr = append(*arr, root.Val) dfs(root.Right, arr) } 532.数组中的K-diff数对(3) 题目 给定一个整数数组和一个整数 k, 你需要在数组里找到不同的 k-diff 数对。 这里将 k-diff 数对定义为一个整数对 (i, j), 其中 i 和 j 都是数组中的数字，且两数之差的绝对值是 k. 示例 1: 输入: [3, 1, 4, 1, 5], k = 2 输出: 2 解释: 数组中有两个 2-diff 数对, (1, 3) 和 (3, 5)。 尽管数组中有两个1，但我们只应返回不同的数对的数量。 示例 2:输入:[1, 2, 3, 4, 5], k = 1 输出: 4 解释: 数组中有四个 1-diff 数对, (1, 2), (2, 3), (3, 4) 和 (4, 5)。 示例 3:输入: [1, 3, 1, 5, 4], k = 0 输出: 1 解释: 数组中只有一个 0-diff 数对，(1, 1)。 注意: 数对 (i, j) 和数对 (j, i) 被算作同一数对。 数组的长度不超过10,000。 所有输入的整数的范围在 [-1e7, 1e7]。 解题思路 No. 思路 时间复杂度 空间复杂度 01 单哈希辅助 O(n) O(n) 02 双哈希辅助 O(n) O(n) 03 排序遍历 O(nlog(n)) O(1) func findPairs(nums []int, k int) int { if k 1 { res++ } } return res } else { for n := range record { if record[n-k] > 0 { res++ } } return res } } # func findPairs(nums []int, k int) int { if k 538.把二叉搜索树转换为累加树(2) 题目 给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)， 使得每个节点的值是原来的节点值加上所有大于它的节点值之和。 例如： 输入: 原始二叉搜索树: 5 / \\ 2 13 输出: 转换为累加树: 18 / \\ 20 13 注意： 本题和 1038: https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/ 相同 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 栈辅助 O(n) O(n) func convertBST(root *TreeNode) *TreeNode { sum := 0 dfs(root, &sum) return root } func dfs(root *TreeNode, sum *int) { if root == nil { return } dfs(root.Right, sum) *sum = *sum + root.Val root.Val = *sum dfs(root.Left, sum) } # func convertBST(root *TreeNode) *TreeNode { if root == nil { return root } stack := make([]*TreeNode, 0) temp := root sum := 0 for { if temp != nil { stack = append(stack, temp) temp = temp.Right } else if len(stack) != 0 { temp = stack[len(stack)-1] stack = stack[:len(stack)-1] temp.Val = temp.Val + sum sum = temp.Val temp = temp.Left } else { break } } return root } 541.反转字符串II(2) 题目 给定一个字符串和一个整数 k，你需要对从字符串开头算起的每个 2k 个字符的前k个字符进行反转。 如果剩余少于 k 个字符，则将剩余的所有全部反转。 如果有小于 2k 但大于或等于 k 个字符，则反转前 k 个字符，并将剩余的字符保持原样。 示例: 输入: s = \"abcdefg\", k = 2 输出: \"bacdfeg\" 要求: 该字符串只包含小写的英文字母。 给定字符串的长度和 k 在[1, 10000]范围内。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 遍历 O(n) O(1) func reverseStr(s string, k int) string { arr := []byte(s) for i := 0; i 543.二叉树的直径(2) 题目 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。 这条路径可能穿过也可能不穿过根结点。 示例 : 给定二叉树 1 / \\ 2 3 / \\ 4 5 返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。 注意：两结点之间的路径长度是以它们之间边的数目表示。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 栈辅助 O(n) O(n) var res int func diameterOfBinaryTree(root *TreeNode) int { res = 0 dfs(root) return res } func dfs(root *TreeNode) int { if root == nil { return 0 } left := dfs(root.Left) right := dfs(root.Right) path := max(left, right) res = max(left+right, res) // 当前节点最大直径与当前保存最大值比较 return path + 1 // 以该节点为根的最大深度 } func max(a, b int) int { if a > b { return a } return b } # func diameterOfBinaryTree(root *TreeNode) int { if root == nil { return 0 } max := 0 stack := make([]*TreeNode, 0) m := make(map[*TreeNode]int) cur := root var prev *TreeNode for cur != nil || len(stack) != 0 { for cur != nil { stack = append(stack, cur) cur = cur.Left } cur = stack[len(stack)-1] if cur.Right == nil || cur.Right == prev { cur = stack[len(stack)-1] stack = stack[:len(stack)-1] leftLen := 0 rightLen := 0 if v, ok := m[cur.Left]; ok { leftLen = v } if v, ok := m[cur.Right]; ok { rightLen = v } if leftLen > rightLen { m[cur] = leftLen + 1 } else { m[cur] = rightLen + 1 } if max 551.学生出勤记录 I(2) 题目 给定一个字符串来代表一个学生的出勤记录，这个记录仅包含以下三个字符： 'A' : Absent，缺勤 'L' : Late，迟到 'P' : Present，到场 如果一个学生的出勤记录中不超过一个'A'(缺勤)并且不超过两个连续的'L'(迟到),那么这个学生会被奖赏。 你需要根据这个学生的出勤记录判断他是否会被奖赏。 示例 1:输入: \"PPALLP\"输出: True 示例 2:输入: \"PPALLL\"输出: False 解题思路 No. 思路 时间复杂度 空间复杂度 01 内置函数 O(n) O(1) 02 遍历 O(n) O(1) func checkRecord(s string) bool { if strings.Count(s, \"A\") 557.反转字符串中的单词 III(2) 题目 给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。 示例 1: 输入: \"Let's take LeetCode contest\" 输出: \"s'teL ekat edoCteeL tsetnoc\" 注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。 解题思路分析 No. 思路 时间复杂度 空间复杂度 01 内置函数 O(n) O(n) 02 遍历 O(n) O(n) func reverseWords(s string) string { strS := strings.Split(s, \" \") for i, s := range strS { strS[i] = reverse(s) } return strings.Join(strS, \" \") } func reverse(s string) string { arr := []byte(s) i, j := 0, len(arr)-1 for i 559.N叉树的最大深度(2) 题目 给定一个 N 叉树，找到其最大深度。 最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。 例如，给定一个 3叉树 : 我们应返回其最大深度，3。 说明: 树的深度不会超过 1000。 树的节点总不会超过 5000。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 迭代 O(n) O(n) func maxDepth(root *Node) int { if root == nil { return 0 } depth := 0 for _, node := range root.Children { depth = max(depth, maxDepth(node)) } return depth + 1 } func max(a, b int) int { if a > b { return a } return b } # func maxDepth(root *Node) int { if root == nil { return 0 } queue := make([]*Node, 0) depth := 0 queue = append(queue, root) for len(queue) > 0 { length := len(queue) for i := 0; i b { return a } return b } 561.数组拆分 I(2) 题目 给定长度为 2n 的数组, 你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), ..., (an, bn) ， 使得从1 到 n 的 min(ai, bi) 总和最大。 示例 1:输入: [1,4,3,2]输出: 4 解释: n 等于 2, 最大总和为 4 = min(1, 2) + min(3, 4). 提示: n 是正整数,范围在 [1, 10000]. 数组中的元素范围在 [-10000, 10000]. 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序遍历 O(nlog(n)) P 02 数组辅助 O(n) O(1) func arrayPairSum(nums []int) int { sort.Ints(nums) sum := 0 for k, v := range nums { if k%2 == 0 { sum = sum + v } } return sum } # func arrayPairSum(nums []int) int { var arr [20010]int for _, num := range nums { arr[num+10000]++ } sum := 0 needAdd := true for num, count := range arr { for count > 0 { if needAdd { sum = sum + num - 10000 } needAdd = !needAdd count-- } } return sum } 563.二叉树的坡度(2) 题目 给定一个二叉树，计算整个树的坡度。 一个树的节点的坡度定义即为，该节点左子树的结点之和和右子树结点之和的差的绝对值。空结点的的坡度是0。 整个树的坡度就是其所有节点的坡度之和。 示例: 输入: 1 / \\ 2 3 输出: 1 解释: 结点的坡度 2 : 0 结点的坡度 3 : 0 结点的坡度 1 : |2-3| = 1 树的坡度 : 0 + 0 + 1 = 1 注意: 任何子树的结点的和不会超过32位整数的范围。 坡度的值不会超过32位整数的范围。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 迭代 O(n) O(n) var total int func findTilt(root *TreeNode) int { total = 0 dfs(root) return total } func dfs(root *TreeNode) int { if root == nil { return 0 } left := dfs(root.Left) right := dfs(root.Right) total = total + abs(left, right) return left + right + root.Val // 返回节点之和 } func abs(a, b int) int { if a > b { return a - b } return b - a } # func findTilt(root *TreeNode) int { if root == nil { return 0 } stack := make([]*TreeNode, 0) stack = append(stack, root) list := make([]*TreeNode, 0) total := 0 for len(stack) > 0 { node := stack[len(stack)-1] stack = stack[0 : len(stack)-1] list = append([]*TreeNode{node}, list...) if node.Left != nil { stack = append(stack, node.Left) } if node.Right != nil { stack = append(stack, node.Right) } } for i := range list { node := list[i] left := 0 right := 0 if node.Left != nil { left = node.Left.Val } if node.Right != nil { right = node.Right.Val } total = total + abs(left, right) node.Val = left + right + node.Val } return total } func abs(a, b int) int { if a > b { return a - b } return b - a } 566.重塑矩阵(2) 题目 在MATLAB中，有一个非常有用的函数 reshape，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。 给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。 重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。 如果具有给定参数的reshape操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。 示例 1:输入: nums = [[1,2], [3,4]] r = 1, c = 4 输出: [[1,2,3,4]] 解释:行遍历nums的结果是 [1,2,3,4]。新的矩阵是 1 * 4 矩阵, 用之前的元素值一行一行填充新矩阵。 示例 2:输入: nums = [[1,2], [3,4]] r = 2, c = 4 输出: [[1,2], [3,4]] 解释:没有办法将 2 * 2 矩阵转化为 2 * 4 矩阵。 所以输出原矩阵。 注意： 给定矩阵的宽和高范围在 [1, 100]。 给定的 r 和 c 都是正数。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n^2) O(n^2) 02 遍历 O(n^2) O(n^2) func matrixReshape(nums [][]int, r int, c int) [][]int { row, col := len(nums), len(nums[0]) if (row*col != r*c) || (row == r && col == c) { return nums } res := make([][]int, r) for i := 0; i 572.另一个树的子树(3) 题目 给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。 s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。 示例 1: 给定的树 s: 3 / \\ 4 5 / \\ 1 2 给定的树 t： 4 / \\ 1 2 返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。 示例 2: 给定的树 s： 3 / \\ 4 5 / \\ 1 2 / 0 给定的树 t： 4 / \\ 1 2 返回 false。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n^2) O(log(n)) 02 递归+字符串辅助 O(n) O(log(n)) 03 栈辅助 O(n) O(n) func isSubtree(s *TreeNode, t *TreeNode) bool { if s == nil { return false } return isSame(s, t) || isSubtree(s.Left, t) || isSubtree(s.Right, t) } func isSame(s *TreeNode, t *TreeNode) bool { if s == nil || t == nil{ return t == s } return isSame(s.Left, t.Left) && isSame(s.Right, t.Right) && s.Val == t.Val } # func isSubtree(s *TreeNode, t *TreeNode) bool { sStr := dfs(s, \"\") tStr := dfs(t, \"\") return strings.Contains(sStr, tStr) } func dfs(s *TreeNode, pre string) string { if s == nil { return pre } return fmt.Sprintf(\"#%d%s%s\", s.Val, dfs(s.Left, \"l\"), dfs(s.Right, \"r\")) } # func isSubtree(s *TreeNode, t *TreeNode) bool { sStr := preOrder(s) tStr := preOrder(t) return strings.Contains(sStr, tStr) } func preOrder(root *TreeNode) string { if root == nil { return \"\" } res := \"!\" stack := make([]*TreeNode,0) temp := root for { for temp != nil{ res += strconv.Itoa(temp.Val) res += \"!\" stack = append(stack, temp) temp = temp.Left } res += \"#!\" if len(stack) > 0{ node := stack[len(stack)-1] stack = stack[:len(stack)-1] temp = node.Right }else { break } } return res } 575.分糖果(2) 题目 给定一个偶数长度的数组，其中不同的数字代表着不同种类的糖果，每一个数字代表一个糖果。 你需要把这些糖果平均分给一个弟弟和一个妹妹。返回妹妹可以获得的最大糖果的种类数。 示例 1:输入: candies = [1,1,2,2,3,3] 输出: 3 解析: 一共有三种种类的糖果，每一种都有两个。 最优分配方案：妹妹获得[1,2,3],弟弟也获得[1,2,3]。这样使妹妹获得糖果的种类数最多。 示例 2 : 输入: candies = [1,1,2,3] 输出: 2 解析: 妹妹获得糖果[2,3],弟弟获得糖果[1,1]，妹妹有两种不同的糖果，弟弟只有一种。 这样使得妹妹可以获得的糖果种类数最多。 注意: 数组的长度为[2, 10,000]，并且确定为偶数。 数组中数字的大小在范围[-100,000, 100,000]内。 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(n) 02 排序遍历 O(nlog(n)) O(1) func distributeCandies(candies []int) int { n := len(candies) r := make(map[int]bool, n) for _, c := range candies { r[c] = true } return min(len(r), n/2) } func min(a, b int) int { if a = half { return half } return count } 581.最短无序连续子数组(3) 题目 给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。 你找到的子数组应是最短的，请输出它的长度。 示例 1:输入: [2, 6, 4, 8, 10, 9, 15] 输出: 5 解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。 说明 : 输入的数组长度范围在 [1, 10,000]。 输入的数组可能包含重复元素 ，所以升序的意思是 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n) O(1) 02 2次遍历 O(n) O(1) 03 排序遍历 O(nlog(n)) O(n) func findUnsortedSubarray(nums []int) int { length := len(nums) left, right := 0, -1 min, max := nums[length-1], nums[0] for i := 1; i = nums[j] { min = nums[j] } else { left = j } } return right - left + 1 } # func findUnsortedSubarray(nums []int) int { length := len(nums) right := -1 max := nums[0] for i := 1; i = 0; i-- { if min >= nums[i] { min = nums[i] } else { left = i } } return right - left + 1 } # func findUnsortedSubarray(nums []int) int { temp := make([]int,len(nums)) copy(temp,nums) sort.Ints(temp) i, j := 0, len(nums)-1 for i 589.N叉树的前序遍历(2) 题目 给定一个 N 叉树，返回其节点值的前序遍历。 例如，给定一个 3叉树 : 返回其前序遍历: [1,3,5,6,2,4]。 说明: 递归法很简单，你可以使用迭代法完成此题吗? 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 迭代 O(n) O(n) var res []int func preorder(root *Node) []int { res = make([]int, 0) dfs(root) return res } func dfs(root *Node) { if root == nil { return } res = append(res, root.Val) for _, value := range root.Children { dfs(value) } } # func preorder(root *Node) []int { res := make([]int, 0) if root == nil { return res } stack := make([]*Node, 0) stack = append(stack, root) for len(stack) > 0 { temp := stack[len(stack)-1] stack = stack[:len(stack)-1] res = append(res, temp.Val) for i := len(temp.Children) - 1; i >= 0; i-- { stack = append(stack, temp.Children[i]) } } return res } 590.N叉树的后序遍历(2) 题目 给定一个 N 叉树，返回其节点值的后序遍历。 例如，给定一个 3叉树 : 返回其后序遍历: [5,6,3,2,4,1]. 说明: 递归法很简单，你可以使用迭代法完成此题吗? 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 迭代 O(n) O(n) var res []int func postorder(root *Node) []int { res = make([]int, 0) dfs(root) return res } func dfs(root *Node) { if root == nil { return } for _, value := range root.Children { dfs(value) } res = append(res, root.Val) } # // 后序：(左右)根 // 前序：根(左右)=>根(右左)=>左右根 func postorder(root *Node) []int { res := make([]int, 0) if root == nil { return res } stack := make([]*Node, 0) stack = append(stack, root) for len(stack) > 0 { temp := stack[len(stack)-1] stack = stack[:len(stack)-1] res = append(res, temp.Val) for i := 0; i 594.最长和谐子序列(2) 题目 和谐数组是指一个数组里元素的最大值和最小值之间的差别正好是1。 现在，给定一个整数数组，你需要在所有可能的子序列中找到最长的和谐子序列的长度。 示例 1:输入: [1,3,2,2,5,2,3,7]输出: 5 原因: 最长的和谐数组是：[3,2,2,2,3]. 说明: 输入的数组长度最大不超过20,000. 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(n) 02 排序遍历 O(nlog(n)) O(1) func findLHS(nums []int) int { m := make(map[int]int, len(nums)) for _, n := range nums { m[n]++ } res := 0 for key, value := range m { value2, ok := m[key+1] if ok { t := value + value2 if res 1 { left++ } if nums[i]-nums[left] == 1 { if res 598.范围求和 II(1) 题目 给定一个初始元素全部为 0，大小为 m*n 的矩阵 M 以及在 M 上的一系列更新操作。 操作用二维数组表示，其中的每个操作用一个含有两个正整数 a 和 b 的数组表示， 含义是将所有符合 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 数学 O(n) O(1) func maxCount(m int, n int, ops [][]int) int { for _, o := range ops { m = min(m, o[0]) n = min(n, o[1]) } return m * n } func min(a, b int) int { if a 599.两个列表的最小索引总和(2) 题目 假设Andy和Doris想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。 你需要帮助他们用最少的索引和找出他们共同喜爱的餐厅。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设总是存在一个答案。 示例 1:输入: [\"Shogun\", \"Tapioca Express\", \"Burger King\", \"KFC\"] [\"Piatti\", \"The Grill at Torrey Pines\", \"Hungry Hunter Steakhouse\", \"Shogun\"] 输出: [\"Shogun\"] 解释: 他们唯一共同喜爱的餐厅是“Shogun”。 示例 2: 输入: [\"Shogun\", \"Tapioca Express\", \"Burger King\", \"KFC\"] [\"KFC\", \"Shogun\", \"Burger King\"] 输出: [\"Shogun\"] 解释: 他们共同喜爱且具有最小索引和的餐厅是“Shogun”，它有最小的索引和1(0+1)。 提示: 两个列表的长度范围都在 [1, 1000]内。 两个列表中的字符串的长度将在[1，30]的范围内。 下标从0开始，到列表的长度减1。 两个列表都没有重复的元素。 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(n) 02 暴力法 O(n^2) I func findRestaurant(list1 []string, list2 []string) []string { if len(list1) > len(list2) { list1, list2 = list2, list1 } m2 := make(map[string]int, len(list2)) for i := range list2 { m2[list2[i]] = i } min := 2000 res := make([]string, 0, 1000) for key, value := range list1 { if key2, ok := m2[value]; ok { if min == key+key2 { res = append(res, value) } if min > key+key2 { min = key + key2 res = []string{value} } } } return res } # func findRestaurant(list1 []string, list2 []string) []string { min := 2000 res := make([]string, 0, 1000) for key1, value1 := range list1 { for key2, value2 := range list2{ if value1 == value2{ if min == key1+key2 { res = append(res, value1) } if min > key1+key2 { min = key1 + key2 res = []string{value1} } } } } return res } 0501-0600-Medium 516.最长回文子序列(3) 题目 给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。 示例 1:输入:\"bbbab\"输出:4 一个可能的最长回文子序列为 \"bbbb\"。 示例 2:输入:\"cbbd\"输出:2 一个可能的最长回文子序列为 \"bb\"。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n^2) O(n^2) 02 动态规划 O(n^2) O(n) 03 递归 O(n^2) O(n^2) func longestPalindromeSubseq(s string) int { if len(s) = 0; i-- { for j := i + 1; j b { return a } return b } # 2 func longestPalindromeSubseq(s string) int { if len(s) = 0; i-- { prev := 0 for j := i + 1; j b { return a } return b } # 3 var dp [][]int func longestPalindromeSubseq(s string) int { if len(s) j { return 0 } if dp[i][j] > 0 { return dp[i][j] } if s[i] == s[j] { dp[i][j] = dfs(s, i+1, j-1) + 2 } else { dp[i][j] = max(dfs(s, i+1, j), dfs(s, i, j-1)) } return dp[i][j] } func max(a, b int) int { if a > b { return a } return b } 518.零钱兑换II(2) 题目 给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 示例 1:输入: amount = 5, coins = [1, 2, 5] 输出: 4 解释: 有四种方式可以凑成总金额: 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1 示例 2:输入: amount = 3, coins = [2] 输出: 0 解释: 只用面额2的硬币不能凑成总金额3。 示例 3:输入: amount = 10, coins = [10] 输出: 1 注意:你可以假设： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划-二维 O(n^2) O(n^2) 02 动态规划-一维 O(n^2) O(n) func change(amount int, coins []int) int { n := len(coins) dp := make([][]int, n+1) for i := 0; i = 0 { dp[i][j] = dp[i-1][j] + dp[i][j-coins[i-1]] } else { dp[i][j] = dp[i-1][j] } } } return dp[n][amount] } # 2 func change(amount int, coins []int) int { n := len(coins) dp := make([]int, amount+1) dp[0] = 1 for i := 1; i = 0 { dp[j] = dp[j] + dp[j-coins[i-1]] } } } return dp[amount] } 523.连续的子数组和(2) 题目 给定一个包含 非负数 的数组和一个目标 整数 k，编写一个函数来判断该数组是否含有连续的子数组， 其大小至少为 2，且总和为 k 的倍数，即总和为 n*k，其中 n 也是一个整数。 示例 1：输入：[23,2,4,6,7], k = 6 输出：True 解释：[2,4] 是一个大小为 2 的子数组，并且和为 6。 示例 2：输入：[23,2,6,4,7], k = 6 输出：True 解释：[23,2,6,4,7]是大小为 5 的子数组，并且和为 42。 说明： 数组的长度不会超过 10,000 。 你可以认为所有数字总和在 32 位有符号整数范围内。 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(n) 02 前缀和-暴力法 O(n^2) O(n) func checkSubarraySum(nums []int, k int) bool { if len(nums) == 0 { return false } m := make(map[int]int) m[0] = -1 sum := 0 for i := 0; i = 2 { return true } } else { m[sum] = i } } return false } # 2 func checkSubarraySum(nums []int, k int) bool { if len(nums) == 0 { return false } arr := make([]int, len(nums)) arr[0] = nums[0] for i := 1; i 542.01矩阵(3) 题目 给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。 两个相邻元素间的距离为 1 。 示例 1: 输入: 0 0 0 0 1 0 0 0 0 输出: 0 0 0 0 1 0 0 0 0 示例 2: 输入: 0 0 0 0 1 0 1 1 1 输出: 0 0 0 0 1 0 1 2 1 注意: 给定矩阵的元素个数不超过 10000。 给定矩阵中至少有一个元素是 0。 矩阵中的元素只在四个方向上相邻: 上、下、左、右。 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n^2) O(n^2) 02 广度优先搜索 O(n^2) O(n^2) 03 动态规划 O(n^2) O(1) func updateMatrix(matrix [][]int) [][]int { n := len(matrix) m := len(matrix[0]) dp := make([][]int, n) for i := 0; i 0 { dp[i][j] = min(dp[i][j], dp[i-1][j]+1) } if j > 0 { dp[i][j] = min(dp[i][j], dp[i][j-1]+1) } } else { dp[i][j] = 0 } } } for i := n - 1; i >= 0; i-- { for j := m - 1; j >= 0; j-- { if dp[i][j] > 1 { if i b { return b } return a } # 2 var dx = []int{-1, 1, 0, 0} var dy = []int{0, 0, -1, 1} func updateMatrix(matrix [][]int) [][]int { n := len(matrix) m := len(matrix[0]) queue := make([][2]int, 0) for i := 0; i 0 { node := queue[0] queue = queue[1:] for i := 0; i 0 { matrix[i][j] = min(matrix[i][j], matrix[i-1][j]+1) } if j > 0 { matrix[i][j] = min(matrix[i][j], matrix[i][j-1]+1) } } else { matrix[i][j] = 0 } } } for i := n - 1; i >= 0; i-- { for j := m - 1; j >= 0; j-- { if matrix[i][j] > 1 { if i b { return b } return a } 560.和为K的子数组(4) 题目 给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。 示例 1 :输入:nums = [1,1,1], k = 2 输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。 说明:数组的长度为 [1, 20,000]。 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法 O(n^2) O(1) 02 前缀和-遍历 O(n^2) O(n) 03 前缀和-哈希辅助 O(n) O(n) 04 前缀和-哈希辅助 O(n) O(n) func subarraySum(nums []int, k int) int { res := 0 for i := 0; i 567.字符串的排列(2) 题目 给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。 换句话说，第一个字符串的排列之一是第二个字符串的子串。 示例1:输入: s1 = \"ab\" s2 = \"eidbaooo\" 输出: True 解释: s2 包含 s1 的排列之一 (\"ba\"). 示例2:输入: s1= \"ab\" s2 = \"eidboaoo\" 输出: False 注意：输入的字符串只包含小写字母 两个字符串的长度都在 [1, 10,000] 之间 解题思路 No. 思路 时间复杂度 空间复杂度 01 滑动窗口 O(n) O(1) 02 滑动窗口 O(n) O(1) func checkInclusion(s1 string, s2 string) bool { if len(s1) > len(s2) { return false } arr1, arr2 := [26]int{}, [26]int{} for i := 0; i len(s2) { return false } m1, m2 := make(map[byte]int), make(map[byte]int) for i := 0; i 0501-0600-Hard 502.IPO 题目 假设 力扣（LeetCode）即将开始其 IPO。为了以更高的价格将股票卖给风险投资公司， 力扣 希望在 IPO 之前开展一些项目以增加其资本。 由于资源有限，它只能在 IPO 之前完成最多 k 个不同的项目。 帮助 力扣 设计完成最多 k 个不同项目后得到最大总资本的方式。 给定若干个项目。对于每个项目 i，它都有一个纯利润 Pi，并且需要最小的资本 Ci 来启动相应的项目。 最初，你有 W 资本。当你完成一个项目时，你将获得纯利润，且利润将被添加到你的总资本中。 总而言之，从给定项目中选择最多 k 个不同项目的列表，以最大化最终资本，并输出最终可获得的最多资本。 示例 1:输入: k=2, W=0, Profits=[1,2,3], Capital=[0,1,1]. 输出: 4 解释:由于你的初始资本为 0，你尽可以从 0 号项目开始。 在完成后，你将获得 1 的利润，你的总资本将变为 1。 此时你可以选择开始 1 号或 2 号项目。 由于你最多可以选择两个项目，所以你需要完成 2 号项目以获得最大的资本。 因此，输出最后最大化的资本，为 0 + 1 + 3 = 4。 注意:假设所有输入数字都是非负整数。 表示利润和资本的数组的长度不超过 50000。 答案保证在 32 位有符号整数范围内。 解题思路 No. 思路 时间复杂度 空间复杂度 01 滑动窗口 O(n) O(1) Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 10:31:30 "},"docs/source/question/0601-0700.html":{"url":"docs/source/question/0601-0700.html","title":"0601-0700","keywords":"","body":"0601-0700-Easy 0601-0700-Easy 605.种花问题(3) 606.根据二叉树创建字符串(2) 617.合并二叉树(2) 628.三个数的最大乘积(2) 633.平方数之和(2) 637.二叉树的层平均值(2) 643.子数组最大平均数 I(3) 645.错误的集合(5) 653.两数之和IV输入BST(4) 657.机器人能否返回原点(2) 661.图片平滑器(2) 665.非递减数列(3) 669.修剪二叉搜索树(2) 671.二叉树中第二小的节点(3) 674.最长连续递增序列(3) 680.验证回文字符串 Ⅱ(2) 682.棒球比赛(1) 686.重复叠加字符串匹配(2) 687.最长同值路径(3) 690.员工的重要性(2) 693.交替位二进制数(4) 696.计数二进制子串(3) 697.数组的度(3) 700.二叉搜索树中的搜索(2) 0601-0700-Medium 621.任务调度器(2) 622.设计循环队列(2) 647.回文子串(5) 695.岛屿的最大面积(2) 605.种花问题(3) 题目 假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。 可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。 给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。 能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。 示例 1:输入: flowerbed = [1,0,0,0,1], n = 1 输出: True 示例 2:输入: flowerbed = [1,0,0,0,1], n = 2 输出: False 注意: 数组内已种好的花不会违反种植规则。 输入的数组长度范围为 [1, 20000]。 n 是非负整数，且不会超过输入数组的大小。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 遍历统计 O(n) O(1) 03 补数+遍历统计 O(n) O(1) func canPlaceFlowers(flowerbed []int, n int) bool { length := len(flowerbed) // 判断条件 // 1:当前元素是0 // 2.前一个元素是0，或者当前是第一个元素 // 3.后一个元素是0，或者当前是最后一个元素 for i := 0; i 606.根据二叉树创建字符串(2) 题目 你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。 空节点则用一对空括号 \"()\" 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。 示例 1: 输入: 二叉树: [1,2,3,4] 1 / \\ 2 3 / 4 输出: \"1(2(4))(3)\" 解释: 原本将是“1(2(4)())(3())”， 在你省略所有不必要的空括号对之后， 它将是“1(2(4))(3)”。 示例 2: 输入: 二叉树: [1,2,3,null,4] 1 / \\ 2 3 \\ 4 输出: \"1(2()(4))(3)\" 解释: 和第一个示例相似， 除了我们不能省略第一个对括号来中断输入和输出之间的一对一映射关系。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 迭代 O(n) O(n) func tree2str(t *TreeNode) string { if t == nil { return \"\" } res := strconv.Itoa(t.Val) if t.Left == nil && t.Right == nil { return res } res += \"(\" + tree2str(t.Left) + \")\" if t.Right != nil{ res += \"(\" + tree2str(t.Right) + \")\" } return res } # func tree2str(t *TreeNode) string { if t == nil { return \"\" } stack := make([]*TreeNode, 0) m := make(map[*TreeNode]bool) stack = append(stack, t) res := \"\" for len(stack) > 0 { node := stack[len(stack)-1] if _, ok := m[node]; ok { stack = stack[:len(stack)-1] res = res + \")\" } else { m[node] = true res = res + \"(\" + strconv.Itoa(node.Val) if node.Left == nil && node.Right != nil { res = res + \"()\" } if node.Right != nil { stack = append(stack, node.Right) } if node.Left != nil { stack = append(stack, node.Left) } } } return res[1 : len(res)-1] } 617.合并二叉树(2) 题目 给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。 你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值， 否则不为 NULL 的节点将直接作为新二叉树的节点。 示例 1: 输入: Tree 1 Tree 2 1 2 / \\ / \\ 3 2 1 3 / \\ \\ 5 4 7 输出: 合并后的树: 3 / \\ 4 5 / \\ \\ 5 4 7 注意: 合并必须从两个树的根节点开始。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 迭代 O(n) O(n) func mergeTrees(t1 *TreeNode, t2 *TreeNode) *TreeNode { if t1 == nil { return t2 } if t2 == nil { return t1 } t1.Val = t1.Val + t2.Val t1.Left = mergeTrees(t1.Left, t2.Left) t1.Right = mergeTrees(t1.Right, t2.Right) return t1 } # func mergeTrees(t1 *TreeNode, t2 *TreeNode) *TreeNode { if t1 == nil { return t2 } if t2 == nil { return t1 } list := make([]*TreeNode, 0) list = append(list, t1) list = append(list, t2) for len(list) > 0 { node1 := list[0] node2 := list[1] node1.Val = node1.Val + node2.Val if node1.Left != nil && node2.Left != nil { list = append(list, node1.Left) list = append(list, node2.Left) } else if node1.Left == nil && node2.Left != nil { node1.Left = node2.Left } if node1.Right != nil && node2.Right != nil { list = append(list, node1.Right) list = append(list, node2.Right) } else if node1.Right == nil && node2.Right != nil { node1.Right = node2.Right } list = list[2:] } return t1 } 628.三个数的最大乘积(2) 题目 给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。 示例 1:输入: [1,2,3]输出: 6 示例 2:输入: [1,2,3,4]输出: 24 注意: 给定的整型数组长度范围是[3,104]，数组中所有的元素范围是[-1000, 1000]。 输入的数组中任意三个数的乘积不会超出32位有符号整数的范围。 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序 O(nlog(n)) O(1) 02 遍历 O(n) O(1) func maximumProduct(nums []int) int { sort.Ints(nums) return max(nums[0]*nums[1]*nums[len(nums)-1], nums[len(nums)-3]*nums[len(nums)-2]*nums[len(nums)-1]) } func max(a, b int) int { if a > b { return a } return b } # func maximumProduct(nums []int) int { max1, max2, max3 := math.MinInt32, math.MinInt32, math.MinInt32 min1, min2 := math.MaxInt32, math.MaxInt32 for i := 0; i = max1 { max3 = max2 max2 = max1 max1 = nums[i] } else if nums[i] >= max2 { max3 = max2 max2 = nums[i] } else if nums[i] >= max3 { max3 = nums[i] } } return max(min1*min2*max1, max1*max2*max3) } func max(a, b int) int { if a > b { return a } return b } 633.平方数之和(2) 题目 给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c。 示例1:输入: 5 输出: True 解释: 1 * 1 + 2 * 2 = 5 示例2:输入: 3 输出: False 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(log(n)) O(1) 02 遍历 O(log(n)) O(1) func judgeSquareSum(c int) bool { if c c { j-- } else { return true } } return false } # func judgeSquareSum(c int) bool { for i := 0; i 637.二叉树的层平均值(2) 题目 给定一个非空二叉树, 返回一个由每层节点平均值组成的数组. 示例 1: 输入: 3 / \\ 9 20 / \\ 15 7 输出: [3, 14.5, 11] 解释:第0层的平均值是 3, 第1层是 14.5, 第2层是 11. 因此返回 [3, 14.5, 11]. 注意： 节点值的范围在32位有符号整数范围内。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 迭代 O(n) O(n) func averageOfLevels(root *TreeNode) []float64 { var sum, node []int res := make([]float64, 0) sum = append(sum, root.Val) node = append(node, 1) sum, node = dfs(root, sum, node, 1) for i := 0; i = len(sum) { sum = append(sum, 0) node = append(node, 0) } if root.Left != nil { sum[level] += root.Left.Val node[level]++ } if root.Right != nil { sum[level] += root.Right.Val node[level]++ } sum, node = dfs(root.Left, sum, node, level+1) sum, node = dfs(root.Right, sum, node, level+1) return sum, node } # func averageOfLevels(root *TreeNode) []float64 { res := make([]float64, 0) list := make([]*TreeNode, 0) list = append(list, root) for len(list) > 0 { length := len(list) sum := 0 for i := 0; i 643.子数组最大平均数 I(3) 题目 给定 n 个整数，找出平均数最大且长度为 k 的连续子数组，并输出该最大平均数。 示例 1:输入: [1,12,-5,-6,50,3], k = 4 输出: 12.75 解释: 最大平均数 (12-5-6+50)/4 = 51/4 = 12.75 注意: 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历+滑动窗口 O(n) O(1) 02 遍历+暴力法 O(n^2) O(1) 03 遍历+累计求和 O(n) O(n) func findMaxAverage(nums []int, k int) float64 { temp := 0 for i := 0; i len(nums){ break } sum := 0 for j := i; j max{ max = sum } } return float64(max) / float64(k) } # func findMaxAverage(nums []int, k int) float64 { sum := make([]int, len(nums)) sum[0] = nums[0] for i := 1; i max { max = sum[i] - sum[i-k] } } return float64(max) / float64(k) } 645.错误的集合(5) 题目 集合 S 包含从1到 n 的整数。不幸的是，因为数据错误， 导致集合里面某一个元素复制了成了集合里面的另外一个元素的值，导致集合丢失了一个整数并且有一个元素重复。 给定一个数组 nums 代表了集合 S 发生错误后的结果。 你的任务是首先寻找到重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。 示例 1:输入: nums = [1,2,2,4]输出: [2,3] 注意: 给定数组的长度范围是 [2, 10000]。 给定的数组是无序的。 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组辅助 O(n) O(n) 02 置反 O(n) O(1) 03 位运算 O(n) O(1) 04 哈希辅助 O(n) O(n) 05 排序 O(nlog(n)) O(1) func findErrorNums(nums []int) []int { newNums := make([]int, len(nums)) var repeatNum int for _, v := range nums { if newNums[v-1] != 0 { repeatNum = v } newNums[v-1] = v } for i, v := range newNums { if v == 0 { return []int{repeatNum, i + 1} } } return []int{0, 0} } # func findErrorNums(nums []int) []int { repeatNum := 0 for i := 0; i 0 { misNum = i + 1 break } } return []int{repeatNum, misNum} } func abs(a int) int { if a > 0 { return a } return -a } # func findErrorNums(nums []int) []int { res := 0 // 异或得到repeatedNum^misNum for i := 0; i 653.两数之和IV输入BST(4) 题目 给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。 案例 1: 输入: 5 / \\ 3 6 / \\ \\ 2 4 7 Target = 9 输出: True 案例 2: 输入: 5 / \\ 3 6 / \\ \\ 2 4 7 Target = 28 输出: False 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归+哈希辅助 O(n) O(n) 02 递归 O(nlog(n)) O(log(n)) 03 迭代 O(n) O(n) 04 递归+二分查找 O(n) O(n) func findTarget(root *TreeNode, k int) bool { if root == nil { return false } m := map[int]int{} return dfs(root, k, m) } func dfs(node *TreeNode, k int, m map[int]int) bool { if node == nil { return false } if _, ok := m[k-node.Val]; ok { return true } m[node.Val] = node.Val return dfs(node.Left, k, m) || dfs(node.Right, k, m) } # func dfs(root, searchRoot *TreeNode, k int) bool { if root == nil { return false } found := findNode(searchRoot, k-root.Val) if found != nil && found != root { return true } return dfs(root.Left, searchRoot, k) || dfs(root.Right, searchRoot, k) } func findNode(root *TreeNode, target int) *TreeNode { if root == nil { return nil } if root.Val == target { return root } if root.Val 0 { node := queue[len(queue)-1] queue = queue[:len(queue)-1] if _, ok := m[k-node.Val]; ok { return true } if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } m[node.Val] = 1 } return false } # var arr []int func findTarget(root *TreeNode, k int) bool { if root == nil { return false } arr = make([]int, 0) dfs(root) i := 0 j := len(arr) - 1 for i k { j-- } else { i++ } } return false } func dfs(node *TreeNode) { if node == nil { return } dfs(node.Left) arr = append(arr, node.Val) dfs(node.Right) } 657.机器人能否返回原点(2) 题目 在二维平面上，有一个机器人从原点 (0, 0) 开始。 给出它的移动顺序，判断这个机器人在完成移动后是否在 (0, 0) 处结束。 移动顺序由字符串表示。字符 move[i] 表示其第 i 次移动。 机器人的有效动作有 R（右），L（左），U（上）和 D（下）。 如果机器人在完成所有动作后返回原点，则返回 true。否则，返回 false。 注意：机器人“面朝”的方向无关紧要。 “R” 将始终使机器人向右移动一次，“L” 将始终向左移动等。 此外，假设每次移动机器人的移动幅度相同。 示例 1:输入: \"UD\" 出: true 解释：机器人向上移动一次，然后向下移动一次。 所有动作都具有相同的幅度，因此它最终回到它开始的原点。因此，我们返回 true。 示例 2:输入: \"LL\"输出: false 解释：机器人向左移动两次。它最终位于原点的左侧，距原点有两次 “移动” 的距离。 我们返回 false，因为它在移动结束时没有返回原点。 解题思路 No. 思路 时间复杂度 空间复杂度 01 内置函数-字符统计 O(n) O(1) 02 模拟 O(n) O(1) func judgeCircle(moves string) bool { return strings.Count(moves, \"U\") == strings.Count(moves, \"D\") && strings.Count(moves, \"L\") == strings.Count(moves, \"R\") } # func judgeCircle(moves string) bool { x, y := 0, 0 for i := range moves { switch i { case 'U': y = y + 1 case 'D': y = y - 1 case 'L': x = x - 1 case 'R': x = x + 1 } } return x == 0 && y == 0 } 661.图片平滑器(2) 题目 包含整数的二维矩阵 M 表示一个图片的灰度。你需要设计一个平滑器来让每一个单元的灰度成为平均灰度 (向下舍入) ， 平均灰度的计算是周围的8个单元和它本身的值求平均，如果周围的单元格不足八个，则尽可能多的利用它们。 示例 1: 输入: [[1,1,1], [1,0,1], [1,1,1]] 输出: [[0, 0, 0], [0, 0, 0], [0, 0, 0]] 解释: 对于点 (0,0), (0,2), (2,0), (2,2): 平均(3/4) = 平均(0.75) = 0 对于点 (0,1), (1,0), (1,2), (2,1): 平均(5/6) = 平均(0.83333333) = 0 对于点 (1,1): 平均(8/9) = 平均(0.88888889) = 0 注意: 给定矩阵中的整数范围为 [0, 255]。 矩阵的长和宽的范围均为 [1, 150]。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n^2) O(n^2) 02 遍历 O(n^2) O(n^2) func imageSmoother(M [][]int) [][]int { res := make([][]int, len(M)) for i := range res { res[i] = make([]int, len(M[0])) for j := range res[i] { res[i][j] = getValue(M, i, j) } } return res } func getValue(M [][]int, r, c int) int { value, count := 0, 0 for i := r - 1; i 665.非递减数列(3) 题目 给你一个长度为 n 的整数数组，请你判断在 最多 改变 1 个元素的情况下，该数组能否变成一个非递减数列。 我们是这样定义一个非递减数列的： 对于数组中所有的 i (1 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法 O(n^2) O(n) 02 遍历修改前后 O(n) O(n) 03 遍历 O(n) ) func checkPossibility(nums []int) bool { for i := 0; i nums[i+1] { return false } } return true } # func checkPossibility(nums []int) bool { for i := 1; i nums[i]{ pre := deepCopy(nums) pre[i-1] = pre[i] next := deepCopy(nums) next[i] = next[i-1] return sort.IsSorted(sort.IntSlice(pre)) || sort.IsSorted(sort.IntSlice(next)) } } return true } func deepCopy(nums []int) []int { res := make([]int, len(nums)) copy(res,nums) return res } # func checkPossibility(nums []int) bool { count := 0 for i := 0; i nums[i+1] { if count == 1 { return false } else if i == 0 { // 4 2 3 => 2 2 3 nums[i] = nums[i+1] count++ } else if nums[i-1] > nums[i+1] { // 3 4 2 => 3 4 4 nums[i+1] = nums[i] count++ } else { // 1 4 2 => 1 2 2 nums[i] = nums[i+1] count++ } } } return true } 669.修剪二叉搜索树(2) 题目 给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。 通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R>=L) 。 你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。 示例 1: 输入: 1 / \\ 0 2 L = 1 R = 2 输出: 1 \\ 2 示例 2: 输入: 3 / \\ 0 4 \\ 2 / 1 L = 1 R = 3 输出: 3 / 2 / 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 迭代 O(n) O(n) func trimBST(root *TreeNode, L int, R int) *TreeNode { if root == nil { return nil } if root.Val R { if root.Val 0 { cur = stack[len(stack)-1] stack = stack[:len(stack)-1] if cur.Left != nil { if cur.Left.Val >= L { // 左节点>=L，继续向左 stack = append(stack, cur.Left) } else { // 在当前左节点，向它的右节点找到满足 R { temp = temp.Left } cur.Right = temp if temp != nil { stack = append(stack, temp) } } } } return root } 671.二叉树中第二小的节点(3) 题目 给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。 如果一个节点有两个子节点的话，那么这个节点的值不大于它的子节点的值。 给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。 示例 1: 输入: 2 / \\ 2 5 / \\ 5 7 输出: 5 说明: 最小的值是 2 ，第二小的值是 5 。 示例 2: 输入: 2 / \\ 2 2 输出: -1 说明: 最小的值是 2, 但是不存在第二小的值。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归+数组辅助 O(n) O(n) 02 递归 O(n) O(log(n)) 03 迭代 O(n) O(n) var arr []int func findSecondMinimumValue(root *TreeNode) int { arr = make([]int, 0) dfs(root) min, second := math.MaxInt32, math.MaxInt32 flag := 0 for i := 0; i val { return root.Val } left := dfs(root.Left, val) right := dfs(root.Right, val) if left == -1 { return right } if right == -1 { return left } return min(left, right) } func min(a, b int) int { if a > b { return b } return a } # func findSecondMinimumValue(root *TreeNode) int { min, second := root.Val, math.MaxInt32 queue := make([]*TreeNode, 0) queue = append(queue, root) flag := 0 for len(queue) > 0 { node := queue[len(queue)-1] queue = queue[:len(queue)-1] if node.Val 674.最长连续递增序列(3) 题目 给定一个未经排序的整数数组，找到最长且连续的的递增序列。 示例 1:输入: [1,3,5,4,7] 输出: 3 解释: 最长连续递增序列是 [1,3,5], 长度为3。 尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。 示例 2:输入: [2,2,2,2,2] 输出: 1 解释: 最长连续递增序列是 [2], 长度为1。 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n) O(1) 02 动态规划 O(n) O(n) 03 遍历 O(n) O(1) func findLengthOfLCIS(nums []int) int { if len(nums) == 0 { return 0 } res := 1 i, j := 0, 1 for j res{ res = dp[i] } } return res } 680.验证回文字符串 Ⅱ(2) 题目 给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。 示例 1:输入: \"aba\" 输出: True 示例 2:输入: \"abca\"输出: True 解释: 你可以删除c字符。 注意: 字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n) O(1) 02 递归 O(n) O(n) func validPalindrome(s string) bool { i := 0 j := len(s) - 1 for i 682.棒球比赛(1) 题目 你现在是棒球比赛记录员。 给定一个字符串列表，每个字符串可以是以下四种类型之一： 1.整数（一轮的得分）：直接表示您在本轮中获得的积分数。 2. \"+\"（一轮的得分）：表示本轮获得的得分是前两轮有效 回合得分的总和。 3. \"D\"（一轮的得分）：表示本轮获得的得分是前一轮有效 回合得分的两倍。 4. \"C\"（一个操作，这不是一个回合的分数）：表示您获得的最后一个有效 回合的分数是无效的，应该被移除。 每一轮的操作都是永久性的，可能会对前一轮和后一轮产生影响。 你需要返回你在所有回合中得分的总和。 示例 1:输入: [\"5\",\"2\",\"C\",\"D\",\"+\"] 输出: 30 解释: 第1轮：你可以得到5分。总和是：5。 第2轮：你可以得到2分。总和是：7。 操作1：第2轮的数据无效。总和是：5。 第3轮：你可以得到10分（第2轮的数据已被删除）。总数是：15。 第4轮：你可以得到5 + 10 = 15分。总数是：30。 示例 2:输入: [\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"] 输出: 27 解释: 第1轮：你可以得到5分。总和是：5。 第2轮：你可以得到-2分。总数是：3。 第3轮：你可以得到4分。总和是：7。 操作1：第3轮的数据无效。总数是：3。 第4轮：你可以得到-4分（第三轮的数据已被删除）。总和是：-1。 第5轮：你可以得到9分。总数是：8。 第6轮：你可以得到-4 + 9 = 5分。总数是13。 第7轮：你可以得到9 + 5 = 14分。总数是27。 注意： 输入列表的大小将介于1和1000之间。 列表中的每个整数都将介于-30000和30000之间。 解题思路 No. 思路 时间复杂度 空间复杂度 01 模拟-栈辅助 O(n) O(n) func calPoints(ops []string) int { stacks := make([]int, 0) for i := range ops { switch ops[i] { case \"+\": r1 := stacks[len(stacks)-1] r2 := stacks[len(stacks)-2] stacks = append(stacks, r1+r2) case \"D\": r1 := stacks[len(stacks)-1] stacks = append(stacks, 2*r1) case \"C\": stacks = stacks[:len(stacks)-1] default: tempInt, _ := strconv.Atoi(ops[i]) stacks = append(stacks, tempInt) } } res := 0 for _, value := range stacks { res = res + value } return res } 686.重复叠加字符串匹配(2) 题目 给定两个字符串 A 和 B, 寻找重复叠加字符串A的最小次数， 使得字符串B成为叠加后的字符串A的子串，如果不存在则返回 -1。 举个例子，A = \"abcd\"，B = \"cdabcdab\"。 答案为 3， 因为 A 重复叠加三遍后为 “abcdabcdabcd”， 此时 B 是其子串；A 重复叠加两遍后为\"abcdabcd\"，B 并不是其子串。 注意: A 与 B 字符串的长度在1和10000区间范围内。 解题思路 No. 思路 时间复杂度 空间复杂度 01 内置函数 O(n) O(n) 02 遍历 O(n) O(n) func repeatedStringMatch(A string, B string) int { times := len(B) / len(A) // 要确保B是A的子串，就要最少重复len(B)/len(A)次A次，最多len(B)/len(A)+2次 // 如长度为 len(B) = 6, len(A) = 3,至少重复2次 // 长度为len(B) = 7, len(A) = 3, 至少重复3次 // 另外如B=\"cabcabca\", A=\"abc\",需要重复4次 for i := times; i 687.最长同值路径(3) 题目 给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。 注意：两个节点之间的路径长度由它们之间的边数表示。 示例 1: 输入: 5 / \\ 4 5 / \\ \\ 1 1 5 输出:2 示例 2: 输入: 1 / \\ 4 5 / \\ \\ 4 4 5 输出:2 注意: 给定的二叉树不超过10000个结点。 树的高度不超过1000。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 递归 O(n) O(log(n)) 03 迭代+栈辅助 O(n) O(n) var maxLen int func longestUnivaluePath(root *TreeNode) int { maxLen = 0 dfs(root) return maxLen } func dfs(root *TreeNode) int { if root == nil { return 0 } left := dfs(root.Left) right := dfs(root.Right) l, r := 0, 0 if root.Left != nil && root.Val == root.Left.Val { l = left + 1 } if root.Right != nil && root.Val == root.Right.Val { r = right + 1 } if l+r > maxLen { maxLen = l + r } return max(l, r) } func max(a, b int) int { if a > b { return a } return b } # var maxLen int func longestUnivaluePath(root *TreeNode) int { maxLen = 0 if root == nil { return 0 } dfs(root, root.Val) return maxLen } func dfs(root *TreeNode, val int) int { if root == nil { return 0 } left := dfs(root.Left, root.Val) right := dfs(root.Right, root.Val) if left+right > maxLen { maxLen = left + right } if root.Val == val { return max(left, right) + 1 } return 0 } func max(a, b int) int { if a > b { return a } return b } # 参考543.二叉树的直径做法 func longestUnivaluePath(root *TreeNode) int { res := 0 stack := make([]*TreeNode, 0) m := make(map[*TreeNode]int) cur := root var prev *TreeNode for cur != nil || len(stack) != 0 { for cur != nil { stack = append(stack, cur) cur = cur.Left } cur = stack[len(stack)-1] if cur.Right == nil || cur.Right == prev { cur = stack[len(stack)-1] stack = stack[:len(stack)-1] leftLen := 0 rightLen := 0 if v, ok := m[cur.Left]; ok { leftLen = v } if v, ok := m[cur.Right]; ok { rightLen = v } var left, right int if cur.Left != nil && cur.Val == cur.Left.Val { left = leftLen + 1 } if cur.Right != nil && cur.Val == cur.Right.Val { right = rightLen + 1 } if left+right > res { res = left + right } if left > right { m[cur] = left } else { m[cur] = right } prev = cur cur = nil } else { cur = cur.Right } } return res } 690.员工的重要性(2) 题目 给定一个保存员工信息的数据结构，它包含了员工唯一的id，重要度 和 直系下属的id。 比如，员工1是员工2的领导，员工2是员工3的领导。他们相应的重要度为15, 10, 5。 那么员工1的数据结构是[1, 15, [2]]，员工2的数据结构是[2, 10, [3]]，员工3的数据结构是[3, 5, []]。 注意虽然员工3也是员工1的一个下属，但是由于并不是直系下属，因此没有体现在员工1的数据结构中。 现在输入一个公司的所有员工信息，以及单个员工id，返回这个员工和他所有下属的重要度之和。 示例 1:输入: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1 输出: 11 解释: 员工1自身的重要度是5，他有两个直系下属2和3，而且2和3的重要度均为3。因此员工1的总重要度是 5 + 3 + 3 = 11。 注意: 一个员工最多有一个直系领导，但是可以有多个直系下属 员工数量不超过2000。 解题思路 No. 思路 时间复杂度 空间复杂度 01 深度优先搜索-递归 O(n) O(log(n)) 02 广度优先搜索-迭代 O(n) O(n) func getImportance(employees []*Employee, id int) int { if len(employees) == 0 { return 0 } var root *Employee for i := 0; i 0 { node := list[0] list = list[1:] res = res + node.Importance for i := range node.Subordinates { if value, ok := m[node.Subordinates[i]]; ok { list = append(list, value) } } } return res } 693.交替位二进制数(4) 题目 给定一个正整数，检查他是否为交替位二进制数：换句话说，就是他的二进制数相邻的两个位数永不相等。 示例 1: 输入: 5 输出: True 解释:5的二进制数是: 101 示例 2:输入: 7 输出: False 解释: 7的二进制数是: 111 示例 3:输入: 11 输出: False 解释: 11的二进制数是: 1011 示例 4:输入: 10 输出: True 解释: 10的二进制数是: 1010 解题思路 No. 思路 时间复杂度 空间复杂度 01 转字符串+遍历 O(1) O(1) 02 位运算 O(1) O(1) 03 位运算 O(1) O(1) 04 遍历 O(1) O(1) func hasAlternatingBits(n int) bool { str := strconv.FormatInt(int64(n), 2) for i := 1; i >1=101 3. n=n^(n>>1)=1010^101=1111 4. n&(n+1)=1111&(10000)=0 示例2: 1. n=101 2. n>>1=10 3. n=n^(n>>1)=101^10=111 4. n&(n+1)=111&(1000)=0 */ func hasAlternatingBits(n int) bool { n = n ^ (n >> 1) return n&(n+1) == 0 } # // n (10|01)&3(11)=10|01 func hasAlternatingBits(n int) bool { temp := n & 3 if temp != 1 && temp != 2 { return false } for n > 0 { if n&3 != temp { return false } n = n >> 2 } return true } # // n (10|01)&3(11)=10|01 func hasAlternatingBits(n int) bool { temp := n & 3 if temp != 1 && temp != 2 { return false } for n > 0 { if n&3 != temp { return false } n = n >> 2 } return true } # func hasAlternatingBits(n int) bool { pre := n & 1 n = n >> 1 for n > 0 { if n&1 == pre { return false } pre = n & 1 n = n >> 1 } return true } 696.计数二进制子串(3) 题目 给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量， 并且这些子字符串中的所有0和所有1都是组合在一起的。 重复出现的子串要计算它们出现的次数。 示例 1 :输入: \"00110011\" 输出: 6 解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。 请注意，一些重复出现的子串要计算它们出现的次数。 另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。 示例 2 :输入: \"10101\"输出: 4 解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。 注意： s.length 在1到50,000之间。 s 只包含“0”或“1”字符。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 遍历 O(n) O(n) 03 暴力法 O(n^2) O(1) func countBinarySubstrings(s string) int { res := 0 cur := 1 pre := 0 for i := 0; i cur { res = res + cur } else { res = res + pre } pre = cur cur = 1 } } if pre > cur { return res + cur } return res + pre } # func countBinarySubstrings(s string) int { res := 0 arr := make([]int, 0) arr = append(arr, 1) for i := 1; i arr[i+1] { res = res + arr[i+1] } else { res = res + arr[i] } } return res } # var count int func countBinarySubstrings(s string) int { count = 0 for i := 1; i = 0 && right 697.数组的度(3) 题目 给定一个非空且只包含非负数的整数数组 nums, 数组的度的定义是指数组里任一元素出现频数的最大值。 你的任务是找到与 nums 拥有相同大小的度的最短连续子数组，返回其长度。 示例 1:输入: [1, 2, 2, 3, 1]输出: 2 解释: 输入数组的度是2，因为元素1和2的出现频数最大，均为2. 连续子数组里面拥有相同度的有如下所示: [1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2] 最短连续子数组[2, 2]的长度为2，所以返回2. 示例 2:输入: [1,2,2,3,1,4,2] 输出: 6 注意: nums.length 在1到50,000区间范围内。 nums[i] 是一个在0到49,999范围内的整数。 解题思路 No. 思路 时间复杂度 空间复杂度 01 自定义结构体+遍历 O(n) O(n) 02 哈希辅助 O(n) O(n) 03 哈希辅助 O(n) O(n) type node struct { count int left int right int } func findShortestSubArray(nums []int) int { m := make(map[int]*node, 0) for k, v := range nums { if nd, ok := m[v]; ok { nd.count = nd.count + 1 nd.right = k } else { m[v] = &node{ count: 1, left: k, right: k, } } } maxNode := new(node) for _, v := range m { if v.count > maxNode.count { maxNode = v } else if v.count == maxNode.count && v.right-v.left length) { maxCount = count[n] minLen = length } } } if len(count) == size { return 1 } return minLen } # func findShortestSubArray(nums []int) int { size := len(nums) if size maxLen { maxLen = len(v) res = v[len(v)-1] - v[0] + 1 } else if len(v) == maxLen && v[len(v)-1]-v[0]+1 700.二叉搜索树中的搜索(2) 题目 给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。 例如， 给定二叉搜索树: 4 / \\ 2 7 / \\ 1 3 和值: 2 你应该返回如下子树: 2 / \\ 1 3 在上述示例中，如果要找的值是 5，但因为没有节点值为 5，我们应该返回 NULL。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 迭代 O(n) O(n) func searchBST(root *TreeNode, val int) *TreeNode { if root == nil { return nil } if root.Val val { return searchBST(root.Left, val) } return root } # func searchBST(root *TreeNode, val int) *TreeNode { if root == nil { return nil } stack := make([]*TreeNode, 0) if root.Val == val { return root } else if root.Val > val && root.Left != nil { stack = append(stack, root.Left) } else if root.Val 0 { node := stack[len(stack)-1] stack = stack[:len(stack)-1] if node.Val == val { return node } else if node.Val > val && node.Left != nil { stack = append(stack, node.Left) } else if node.Val 0601-0700-Medium 621.任务调度器(2) 题目 给定一个用字符数组表示的 CPU 需要执行的任务列表。 其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。 任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。 CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。 然而，两个相同种类的任务之间必须有长度为 n 的冷却时间， 因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。 你需要计算完成所有任务所需要的最短时间。 示例 ：输入：tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2 输出：8 解释：A -> B -> (待命) -> A -> B -> (待命) -> A -> B. 在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间， 而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。 提示： 任务的总个数为 [1, 10000]。 n 的取值范围为 [0, 100]。 解题思路 No. 思路 时间复杂度 空间复杂度 01 贪心-数组辅助 O(n) O(1) 02 排序模拟 O(n) O(1) func leastInterval(tasks []byte, n int) int { arr := [26]int{} maxValue := 0 for i := 0; i maxValue { maxValue = arr[tasks[i]-'A'] } } res := (maxValue - 1) * (n + 1) // 完成所有任务至少需要(max-1)*(n+1)+1 for i := 0; i b { return a } return b } # 2 func leastInterval(tasks []byte, n int) int { arr := make([]int, 26) for i := 0; i 0 { i := 0 for i 0 { arr[25-i]-- } res++ i++ } sort.Ints(arr) } return res } 622.设计循环队列(2) 题目 设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。 它也被称为“环形缓冲器”。 循环队列的一个好处是我们可以利用这个队列之前用过的空间。 在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。 但是使用循环队列，我们能使用这些空间去存储新的值。 你的实现应该支持如下操作： MyCircularQueue(k): 构造器，设置队列长度为 k 。 Front: 从队首获取元素。如果队列为空，返回 -1 。 Rear: 获取队尾元素。如果队列为空，返回 -1 。 enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。 deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。 isEmpty(): 检查循环队列是否为空。 isFull(): 检查循环队列是否已满。 示例： MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3 circularQueue.enQueue(1); // 返回 true circularQueue.enQueue(2); // 返回 true circularQueue.enQueue(3); // 返回 true circularQueue.enQueue(4); // 返回 false，队列已满 circularQueue.Rear(); // 返回 3 circularQueue.isFull(); // 返回 true circularQueue.deQueue(); // 返回 true circularQueue.enQueue(4); // 返回 true circularQueue.Rear(); // 返回 4 提示： 所有的值都在 0 至 1000 的范围内； 操作数将在 1 至 1000 的范围内； 请不要使用内置的队列库。 解题思路 No. 思路 时间复杂度 空间复杂度 01 切片 O(1) O(n) 02 循环队列 O(1) O(n) type MyCircularQueue struct { queue []int k int } func Constructor(k int) MyCircularQueue { return MyCircularQueue{ queue: make([]int, 0), k: k, } } func (this *MyCircularQueue) EnQueue(value int) bool { if len(this.queue) == this.k { return false } this.queue = append(this.queue, value) return true } func (this *MyCircularQueue) DeQueue() bool { if len(this.queue) == 0 { return false } this.queue = this.queue[1:] return true } func (this *MyCircularQueue) Front() int { if len(this.queue) == 0 { return -1 } return this.queue[0] } func (this *MyCircularQueue) Rear() int { if len(this.queue) == 0 { return -1 } return this.queue[len(this.queue)-1] } func (this *MyCircularQueue) IsEmpty() bool { return len(this.queue) == 0 } func (this *MyCircularQueue) IsFull() bool { return len(this.queue) == this.k } # 2 type MyCircularQueue struct { queue []int k int front int // 队首 rear int // 队尾 } func Constructor(k int) MyCircularQueue { return MyCircularQueue{ queue: make([]int, k+1), k: k + 1, front: 0, rear: 0, } } func (this *MyCircularQueue) EnQueue(value int) bool { if this.IsFull() { return false } // 队尾入队 this.queue[this.rear] = value this.rear++ if this.rear == this.k { this.rear = 0 } return true } func (this *MyCircularQueue) DeQueue() bool { if this.IsEmpty() { return false } // 队尾出队 this.front++ if this.front == this.k { this.front = 0 } return true } func (this *MyCircularQueue) Front() int { if this.IsEmpty() { return -1 } return this.queue[this.front] } func (this *MyCircularQueue) Rear() int { if this.IsEmpty() { return -1 } prev := this.rear - 1 if prev 647.回文子串(5) 题目 给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。 具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。 示例 1：输入：\"abc\" 输出：3 解释：三个回文子串: \"a\", \"b\", \"c\" 示例 2：输入：\"aaa\" 输出：6 解释：6个回文子串: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\" 提示：输入的字符串长度不会超过 1000 。 解题思路 No. 思路 时间复杂度 空间复杂度 01 中心扩展 O(n^2) O(1) 02 Manacher算法 O(n^2) O(1) 03 Manacher算法 O(n) O(n) 04 动态规划 O(n^2) O(n^2) 05 暴力法 O(n^3) O(1) func countSubstrings(s string) int { n := len(s) res := 0 for i := 0; i = 0 && j rightMax { leftMax = i rightMax = i + arr[i] - 1 } result = result + arr[i]/2 } return result } func min(a, b int) int { if a > b { return b } return a } # 4 func countSubstrings(s string) int { if len(s) 695.岛屿的最大面积(2) 题目 给定一个包含了一些 0 和 1 的非空二维数组 grid 。 一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。 你可以假设 grid 的四个边缘都被 0（代表水）包围着。 找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。) 示例 1: [[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]] 对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。 示例 2:[[0,0,0,0,0,0,0,0]] 对于上面这个给定的矩阵, 返回 0。 注意: 给定的矩阵grid 的长度和宽度都不超过 50。 解题思路 No. 思路 时间复杂度 空间复杂度 01 深度优先搜索 O(n^2) O(n) 02 深度优先搜索 O(n^2) O(n) func maxAreaOfIsland(grid [][]int) int { maxArea := 0 for i := range grid { for j := range grid[i] { maxArea = max(maxArea, getArea(grid, i, j)) } } return maxArea } func getArea(grid [][]int, i, j int) int { if grid[i][j] == 0 { return 0 } grid[i][j] = 0 area := 1 if i != 0 { area = area + getArea(grid, i-1, j) } if j != 0 { area = area + getArea(grid, i, j-1) } if i != len(grid)-1 { area = area + getArea(grid, i+1, j) } if j != len(grid[0])-1 { area = area + getArea(grid, i, j+1) } return area } func max(a, b int) int { if a > b { return a } return b } # 2 func maxAreaOfIsland(grid [][]int) int { res := 0 for i := 0; i res { res = value } } } } return res } func dfs(grid [][]int, i, j int) int { if i = len(grid) || j >= len(grid[0]) || grid[i][j] == 0 { return 0 } grid[i][j] = 0 res := 1 res = res + dfs(grid, i+1, j) res = res + dfs(grid, i-1, j) res = res + dfs(grid, i, j+1) res = res + dfs(grid, i, j-1) return res } Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 10:35:58 "},"docs/source/question/0701-0800.html":{"url":"docs/source/question/0701-0800.html","title":"0701-0800","keywords":"","body":"0701-0800-Easy 0701-0800-Easy 703.数据流中的第K大元素(2) 704.二分查找(3) 705.设计哈希集合(2) 706.设计哈希映射(2) 709.转换成小写字母(2) 717.1比特与2比特字符(3) 720.词典中最长的单词(2) 724.寻找数组的中心索引(2) 728.自除数(2) 733.图像渲染(2) 744.寻找比目标字母大的最小字母(3) 746.使用最小花费爬楼梯(3) 747.至少是其他数字两倍的最大数(3) 748.最短完整词(3) 762.二进制表示中质数个计算置位(2) 766.托普利茨矩阵(2) 771.宝石与石头(3) 783.二叉搜索树节点最小距离(3) 784.字母大小写全排列(4) 788.旋转数字(4) 796.旋转字符串(2) 0701-0800-Medium 714.买卖股票的最佳时机含手续费(2) 718.最长重复子数组(3) 739.每日温度(3) 752.打开转盘锁(1) 779.第K个语法符号(3) 703.数据流中的第K大元素(2) 题目 设计一个找到数据流中第K大元素的类（class）。注意是排序后的第K大元素，不是第K个不同的元素。 你的 KthLargest 类需要一个同时接收整数 k 和整数数组nums 的构造器，它包含数据流中的初始元素。 每次调用 KthLargest.add，返回当前数据流中第K大的元素。 示例: int k = 3; int[] arr = [4,5,8,2]; KthLargest kthLargest = new KthLargest(3, arr); kthLargest.add(3); // returns 4 kthLargest.add(5); // returns 5 kthLargest.add(10); // returns 5 kthLargest.add(9); // returns 8 kthLargest.add(4); // returns 8 说明: 你可以假设 nums 的长度≥ k-1 且k ≥ 1。 解题思路 No. 思路 时间复杂度 空间复杂度 01 最小堆+内置heap O(nlog(n)) O(n) 02 小根堆 O(nlog(n)) O(n) type KthLargest struct { k int heap intHeap } func Constructor(k int, nums []int) KthLargest { h := intHeap(nums) heap.Init(&h) for len(h) > k { heap.Pop(&h) } return KthLargest{ k: k, heap: h, } } func (k *KthLargest) Add(val int) int { heap.Push(&k.heap, val) if len(k.heap) > k.k { heap.Pop(&k.heap) } return k.heap[0] } // 内置heap，实现接口 /* type Interface interface { sort.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // remove and return element Len() - 1. } */ type intHeap []int func (h intHeap) Len() int { return len(h) } func (h intHeap) Less(i, j int) bool { return h[i] len(k.nums) { k.nums = append(k.nums, val) Up(k.nums) } else { if val > k.nums[0] { // 在堆顶，向下调整 k.nums[0] = val Down(k.nums, 0) } } return k.nums[0] } func Down(nums []int, index int) { length := len(nums) minIndex := index for { left := 2*index + 1 right := 2*index + 2 if left = 0; i-- { minIndex := i left := 2*i + 1 right := 2*i + 2 if left 704.二分查找(3) 题目 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ， 写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例 1:输入: nums = [-1,0,3,5,9,12], target = 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 示例 2:输入: nums = [-1,0,3,5,9,12], target = 2 输出: -1 解释: 2 不存在 nums 中因此返回 -1 提示： 你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间。 解题思路 No. 思路 时间复杂度 空间复杂度 01 二分查找 O(log(n)) O(1) 02 遍历 O(n) O(1) 03 递归 O(log(n)) O(log(n)) func search(nums []int, target int) int { left, right:= 0, len(nums)-1 for left target: right = mid - 1 default: return mid } } return -1 } # func search(nums []int, target int) int { if nums[0] > target || nums[len(nums)-1] target { return -1 } } return -1 } # func search(nums []int, target int) int { if len(nums) == 0 { return -1 } mid := len(nums) / 2 if nums[mid] == target { return mid } else if nums[mid] > target { return search(nums[:mid], target) } else { result := search(nums[mid+1:], target) if result == -1 { return result } return mid + 1 + result } } 705.设计哈希集合(2) 题目 不使用任何内建的哈希表库设计一个哈希集合 具体地说，你的设计应该包含以下的功能 add(value)：向哈希集合中插入一个值。 contains(value) ：返回哈希集合中是否存在这个值。 remove(value)：将给定值从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。 示例: MyHashSet hashSet = new MyHashSet(); hashSet.add(1); hashSet.add(2); hashSet.contains(1); // 返回 true hashSet.contains(3); // 返回 false (未找到) hashSet.add(2); hashSet.contains(2); // 返回 true hashSet.remove(2); hashSet.contains(2); // 返回 false (已经被删除) 注意： 所有的值都在 [0, 1000000]的范围内。 操作的总数目在[1, 10000]范围内。 不要使用内建的哈希集合库。 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组实现 O(1) O(n) 02 数组实现 O(n^1/2) ) type MyHashSet struct { table []bool } func Constructor() MyHashSet { return MyHashSet{ table: make([]bool, 1000001), } } func (m *MyHashSet) Add(key int) { m.table[key] = true } func (m *MyHashSet) Remove(key int) { m.table[key] = false } func (m *MyHashSet) Contains(key int) bool { return m.table[key] } # type MyHashSet struct { table [10000][]int } func Constructor() MyHashSet { return MyHashSet{ table: [10000][]int{}, } } func (m *MyHashSet) Add(key int) { for _, v := range m.table[key%10000] { if v == key { return } } m.table[key%10000] = append(m.table[key%10000], key) } func (m *MyHashSet) Remove(key int) { for k, v := range m.table[key%10000] { if v == key { m.table[key%10000] = append(m.table[key%10000][:k], m.table[key%10000][k+1:]...) } } } func (m *MyHashSet) Contains(key int) bool { for _, v := range m.table[key%10000] { if v == key { return true } } return false } 706.设计哈希映射(2) 题目 具体地说，你的设计应该包含以下的功能 put(key, value)：向哈希映射中插入(键,值)的数值对。如果键对应的值已经存在，更新这个值。 get(key)：返回给定的键所对应的值，如果映射中不包含这个键，返回-1。 remove(key)：如果映射中存在这个键，删除这个数值对。 示例： MyHashMap hashMap = new MyHashMap(); hashMap.put(1, 1); hashMap.put(2, 2); hashMap.get(1); // 返回 1 hashMap.get(3); // 返回 -1 (未找到) hashMap.put(2, 1); // 更新已有的值 hashMap.get(2); // 返回 1 hashMap.remove(2); // 删除键为2的数据 hashMap.get(2); // 返回 -1 (未找到) 注意： 所有的值都在 [0, 1000000]的范围内。 操作的总数目在[1, 10000]范围内。 不要使用内建的哈希库。 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组实现 O(1) O(n) 02 数组实现 O(n^1/2) O(n^1/2) type MyHashMap struct { table []int } func Constructor() MyHashMap { return MyHashMap{ table: make([]int, 1000001), } } func (this *MyHashMap) Put(key int, value int) { this.table[key] = value + 1 } func (this *MyHashMap) Get(key int) int { return this.table[key] - 1 } func (this *MyHashMap) Remove(key int) { this.table[key] = 0 } # type MyHashMap struct { keys [10000][]int value [10000][]int } func Constructor() MyHashMap { return MyHashMap{ keys: [10000][]int{}, value: [10000][]int{}, } } func (m *MyHashMap) Put(key int, value int) { for k, v := range m.keys[key%10000] { if v == key { m.value[key%10000][k] = value return } } m.keys[key%10000] = append(m.keys[key%10000], key) m.value[key%10000] = append(m.value[key%10000], value) } func (m *MyHashMap) Get(key int) int { for k, v := range m.keys[key%10000] { if v == key { return m.value[key%10000][k] } } return -1 } func (m *MyHashMap) Remove(key int) { for k, v := range m.keys[key%10000] { if v == key { m.keys[key%10000] = append(m.keys[key%10000][:k], m.keys[key%10000][k+1:]...) m.value[key%10000] = append(m.value[key%10000][:k], m.value[key%10000][k+1:]...) } } } 709.转换成小写字母(2) 题目 实现函数 ToLowerCase()，该函数接收一个字符串参数 str， 并将该字符串中的大写字母转换成小写字母，之后返回新的字符串。 示例 1：输入: \"Hello\" 输出: \"hello\" 示例 2：输入: \"here\" 输出: \"here\" 示例 3：输入: \"LOVELY\" 输出: \"lovely\" 解题思路 No. 思路 时间复杂度 空间复杂度 01 内置函数 O(n) O(n) 02 遍历 O(n) O(n) func toLowerCase(str string) string { return strings.ToLower(str) } # func toLowerCase(str string) string { arr := []byte(str) for i := 0; i ='A' && arr[i] 717.1比特与2比特字符(3) 题目 现给一个由若干比特组成的字符串。问最后一个字符是否必定为一个一比特字符。给定的字符串总是由0结束。 示例 1:输入: bits = [1, 0, 0] 输出: True 解释: 唯一的编码方式是一个两比特字符和一个一比特字符。所以最后一个字符是一比特字符。 示例 2:输入: bits = [1, 1, 1, 0] 输出: False 解释: 唯一的编码方式是两比特字符和两比特字符。所以最后一个字符不是一比特字符。 注意: 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 遍历 O(n) O(1) 03 递归 O(n) O(n) func isOneBitCharacter(bits []int) bool { n := len(bits) i := 0 for i = 0; i-- { if bits[i] == 0 { break } else { count++ } } // return count & 1 == 0 return count%2 == 0 } # func isOneBitCharacter(bits []int) bool { return helper(bits, 0) } func helper(bits []int, left int) bool { if left == len(bits)-1 { return bits[left] == 0 } if left 720.词典中最长的单词(2) 题目 给出一个字符串数组words组成的一本英语词典。 从中找出最长的一个单词，该单词是由words词典中其他单词逐步添加一个字母组成。 若其中有多个可行的答案，则返回答案中字典序最小的单词。 若无答案，则返回空字符串。 示例 1:输入: words = [\"w\",\"wo\",\"wor\",\"worl\", \"world\"] 输出: \"world\" 解释: 单词\"world\"可由\"w\", \"wo\", \"wor\", 和 \"worl\"添加一个字母组成。 示例 2:输入: words = [\"a\", \"banana\", \"app\", \"appl\", \"ap\", \"apply\", \"apple\"] 输出: \"apple\" 解释: \"apply\"和\"apple\"都能由词典中的单词组成。但是\"apple\"得字典序小于\"apply\"。 注意: 所有输入的字符串都只包含小写字母。 words数组长度范围为[1,1000]。 words[i]的长度范围为[1,30]。 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序+遍历 O(nlog(n)) O(n) 02 trie树 O(n) O(n) func longestWord(words []string) string { if len(words) == 0 { return \"\" } else if len(words) == 1 && len(words[0]) > 1 { return \"\" } sort.Strings(words) m := make(map[string]bool) res := words[0] for _, w := range words { n := len(w) if n == 1 { m[w] = true } else if m[w[:n-1]] { m[w] = true if len(res) 0 { node := stack[len(stack)-1] stack = stack[:len(stack)-1] if node.index > 0 || node == t { if node != t { word := words[node.index-1] if len(word) > len(res) || (len(word) == len(res) && word 724.寻找数组的中心索引(2) 题目 给定一个整数类型的数组 nums，请编写一个能够返回数组“中心索引”的方法。 我们是这样定义数组中心索引的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。 如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。 示例 1:输入: nums = [1, 7, 3, 6, 5, 6] 输出: 3 解释: 索引3 (nums[3] = 6) 的左侧数之和(1 + 7 + 3 = 11)，与右侧数之和(5 + 6 = 11)相等。 同时, 3 也是第一个符合要求的中心索引。 示例 2:输入: nums = [1, 2, 3] 输出: -1 解释: 数组中不存在满足此条件的中心索引。 说明: nums 的长度范围为 [0, 10000]。 任何一个 nums[i] 将会是一个范围在 [-1000, 1000]的整数。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 遍历 O(n) O(n) func pivotIndex(nums []int) int { sum := 0 for i := range nums { sum = sum + nums[i] } left := 0 for i := range nums { if left*2+nums[i] == sum { return i } left = left + nums[i] } return -1 } # func pivotIndex(nums []int) int { if len(nums) == 0 { return -1 } arr := make([]int, len(nums)) arr[0] = nums[0] for i := 1; i len(nums)-1 { right = 0 } else { right = arr[len(nums)-1] - arr[i] } if left == right { return i } } return -1 } 728.自除数(2) 题目 自除数 是指可以被它包含的每一位数除尽的数。 例如，128 是一个自除数，因为 128 % 1 == 0，128 % 2 == 0，128 % 8 == 0。 还有，自除数不允许包含 0 。 给定上边界和下边界数字，输出一个列表，列表的元素是边界（含边界）内所有的自除数。 示例 1：输入： 上边界left = 1, 下边界right = 22 输出： [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22] 注意： 每个输入参数的边界满足 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(n) 02 遍历 O(n) O(n) func selfDividingNumbers(left int, right int) []int { res := make([]int, 0) for i := left; i 0 { d := temp % 10 temp = temp / 10 if d == 0 || n%d != 0 { return false } } return true } # func selfDividingNumbers(left int, right int) []int { res := make([]int, 0) for i := left; i 733.图像渲染(2) 题目 有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。 给你一个坐标 (sr, sc) 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 newColor，让你重新上色这幅图像。 为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点， 接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。 将所有有记录的像素点的颜色值改为新的颜色值。 最后返回经过上色渲染后的图像。 示例 1:输入: image = [[1,1,1],[1,1,0],[1,0,1]] sr = 1, sc = 1, newColor = 2 输出: [[2,2,2],[2,2,0],[2,0,1]] 解析: 在图像的正中间，(坐标(sr,sc)=(1,1)), 在路径上所有符合条件的像素点的颜色都被更改成2。 注意，右下角的像素没有更改为2， 因为它不是在上下左右四个方向上与初始点相连的像素点。 注意: image 和 image[0] 的长度在范围 [1, 50] 内。 给出的初始点将满足 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 广度优先搜索 O(n^2) O(n^2) 02 深度优先搜索 O(n^2) O(n^2) var dx = []int{-1, 1, 0, 0} var dy = []int{0, 0, -1, 1} func floodFill(image [][]int, sr int, sc int, newColor int) [][]int { oldColor := image[sr][sc] if oldColor == newColor { return image } m, n := len(image), len(image[0]) list := make([][]int, 1) list[0] = []int{sr, sc} for len(list) > 0 { node := list[0] list = list[1:] image[node[0]][node[1]] = newColor for i := 0; i = len(image) || sc >= len(image[sr]) || image[sr][sc] == newColor { return image } oldColor := image[sr][sc] image[sr][sc] = newColor for i := 0; i 744.寻找比目标字母大的最小字母(3) 题目 给你一个排序后的字符列表 letters ，列表中只包含小写英文字母。 另给出一个目标字母 target，请你寻找在这一有序列表里比目标字母大的最小字母。 在比较时，字母是依序循环出现的。举个例子： 如果目标字母 target = 'z' 并且字符列表为 letters = ['a', 'b']，则答案返回 'a' 示例： 输入:letters = [\"c\", \"f\", \"j\"] target = \"a\" 输出: \"c\" 输入:letters = [\"c\", \"f\", \"j\"] target = \"c\" 输出: \"f\" 输入:letters = [\"c\", \"f\", \"j\"] target = \"d\" 输出: \"f\" 输入:letters = [\"c\", \"f\", \"j\"] target = \"g\" 输出: \"j\" 输入:letters = [\"c\", \"f\", \"j\"] target = \"j\" 输出: \"c\" 输入:letters = [\"c\", \"f\", \"j\"] target = \"k\" 输出: \"c\" 提示： letters长度范围在[2, 10000]区间内。 letters 仅由小写字母组成，最少包含两个不同的字母。 目标字母target 是一个小写字母。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 内置函数 O(n) O(1) 03 二分查找 O(log(n)) O(1) func nextGreatestLetter(letters []byte, target byte) byte { for i := 0; i target { return letters[i] } } return letters[0] } # func nextGreatestLetter(letters []byte, target byte) byte { n := len(letters) i := sort.Search(n, func(i int) bool { return target 746.使用最小花费爬楼梯(3) 题目 数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost[i](索引从0开始)。 每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。 您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。 示例 1:输入: cost = [10, 15, 20] 输出: 15 解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。 示例 2:输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]输出: 6 解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。 注意： cost 的长度将会在 [2, 1000]。 每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划-一维数组 O(n) O(n) 02 动态规划 O(n) O(1) 03 递归 O(n) O(n) /* 用dp[i]表示爬i个台阶所需要的成本，所以dp[0]=0，dp[1]=0 每次爬i个楼梯，计算的都是从倒数第一个结束，还是从倒数第二个结束 动态转移方程为: dp[i] = min{dp[i-2]+cost[i-2] , dp[i-1]+cost[i-1]}; */ func minCostClimbingStairs(cost []int) int { n := len(cost) dp := make([]int, n+1) dp[0] = 0 dp[1] = 0 for i := 2; i 747.至少是其他数字两倍的最大数(3) 题目 在一个给定的数组nums中，总是存在一个最大元素 。 查找数组中的最大元素是否至少是数组中每个其他数字的两倍。 如果是，则返回最大元素的索引，否则返回-1。 示例 1:输入: nums = [3, 6, 1, 0] 输出: 1 解释: 6是最大的整数, 对于数组中的其他整数,6大于数组中其他元素的两倍。 6的索引是1, 所以我们返回1. 示例 2:输入: nums = [1, 2, 3, 4] 输出: -1 解释: 4没有超过3的两倍大, 所以我们返回 -1. 提示: nums 的长度范围在[1, 50]. 每个 nums[i] 的整数范围在 [0, 100]. 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 遍历 O(n) O(1) 03 排序 O(nlog(n)) P func dominantIndex(nums []int) int { n := len(nums) if n == 1 { return 0 } maxIndex, secondMaxIndex := 0, 1 if nums[maxIndex] = 2*nums[secondMaxIndex] { return maxIndex } return -1 } # func dominantIndex(nums []int) int { n := len(nums) if n == 1 { return 0 } maxValue := nums[0] index := 0 for i := 1; i maxValue { maxValue = nums[i] index = i } } for i := 0; i maxValue { return -1 } } return index } # func dominantIndex(nums []int) int { n := len(nums) if n == 1 { return 0 } temp := make([]int, len(nums)) copy(temp, nums) sort.Ints(temp) maxValue := temp[len(temp)-1] if maxValue 748.最短完整词(3) 题目 如果单词列表（words）中的一个单词包含牌照（licensePlate）中所有的字母，那么我们称之为完整词。 在所有完整词中，最短的单词我们称之为最短完整词。 单词在匹配牌照中的字母时不区分大小写，比如牌照中的 \"P\" 依然可以匹配单词中的 \"p\" 字母。 我们保证一定存在一个最短完整词。当有多个单词都符合最短完整词的匹配条件时取单词列表中最靠前的一个。 牌照中可能包含多个相同的字符，比如说：对于牌照 \"PP\"，单词 \"pair\" 无法匹配，但是 \"supper\" 可以匹配。 示例 1：输入：licensePlate = \"1s3 PSt\", words = [\"step\", \"steps\", \"stripe\", \"stepple\"] 输出：\"steps\" 说明：最短完整词应该包括 \"s\"、\"p\"、\"s\" 以及 \"t\"。 对于 \"step\" 它只包含一个 \"s\" 所以它不符合条件。同时在匹配过程中我们忽略牌照中的大小写。 示例 2：输入：licensePlate = \"1s3 456\", words = [\"looks\", \"pest\", \"stew\", \"show\"] 输出：\"pest\" 说明：存在 3 个包含字母 \"s\" 且有着最短长度的完整词，但我们返回最先出现的完整词。 注意: 牌照（licensePlate）的长度在区域[1, 7]中。 牌照（licensePlate）将会包含数字、空格、或者字母（大写和小写）。 单词列表（words）长度在区间 [10, 1000] 中。 每一个单词 words[i] 都是小写，并且长度在区间 [1, 15] 中。 解题思路 No. 思路 时间复杂度 空间复杂度 01 双哈希遍历 O(n) O(1) 02 双数组遍历 O(n) O(1) 03 排序+遍历 O(n) O(n) func shortestCompletingWord(licensePlate string, words []string) string { m := make(map[byte]int) licensePlate = strings.ToLower(licensePlate) for i := 0; i = 'a' && licensePlate[i] = len(res) && res != \"\" { continue } tempM := make(map[byte]int) for j := 0; j = 'a' && licensePlate[i] = len(res) && res != \"\" { continue } tempM := make([]int, 26) for j := 0; j = 'a' && licensePlate[i] 762.二进制表示中质数个计算置位(2) 题目 给定两个整数 L 和 R ，找到闭区间 [L, R] 范围内，计算置位位数为质数的整数个数。 （注意，计算置位代表二进制表示中1的个数。例如 21 的二进制表示 10101 有 3 个计算置位。还有，1 不是质数。） 示例 1: 输入: L = 6, R = 10 输出: 4 解释: 6 -> 110 (2 个计算置位，2 是质数) 7 -> 111 (3 个计算置位，3 是质数) 9 -> 1001 (2 个计算置位，2 是质数) 10-> 1010 (2 个计算置位，2 是质数) 示例 2: 输入: L = 10, R = 15 输出: 5 解释: 10 -> 1010 (2 个计算置位, 2 是质数) 11 -> 1011 (3 个计算置位, 3 是质数) 12 -> 1100 (2 个计算置位, 2 是质数) 13 -> 1101 (3 个计算置位, 3 是质数) 14 -> 1110 (3 个计算置位, 3 是质数) 15 -> 1111 (4 个计算置位, 4 不是质数) 注意: L, R 是 L 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 遍历+内置函数 O(n) O(1) func countPrimeSetBits(L int, R int) int { primes := [...]int{ 2: 1, 3: 1, 5: 1, 7: 1, 11: 1, 13: 1, 17: 1, 19: 1, 23: 1, 29: 1, 31: 1, } res := 0 for i := L; i 0; n >>= 1 { // bits = bits + n & 1 bits = bits + n % 2 } res = res + primes[bits] } return res } 766.托普利茨矩阵(2) 题目 如果一个矩阵的每一方向由左上到右下的对角线上具有相同元素，那么这个矩阵是托普利茨矩阵。 给定一个 M x N 的矩阵，当且仅当它是托普利茨矩阵时返回 True。 示例 1:输入: matrix = [ [1,2,3,4], [5,1,2,3], [9,5,1,2] ] 输出: True 解释: 在上述矩阵中, 其对角线为:\"[9]\", \"[5, 5]\", \"[1, 1, 1]\", \"[2, 2, 2]\", \"[3, 3]\", \"[4]\"。 各条对角线上的所有元素均相同, 因此答案是True。 示例 2:输入: matrix = [ [1,2], [2,2] ] 输出: False 解释: 对角线\"[1, 2]\"上的元素不同。 说明: matrix 是一个包含整数的二维数组。 matrix 的行数和列数均在 [1, 20]范围内。 matrix[i][j] 包含的整数在 [0, 99]范围内。 进阶: 如果矩阵存储在磁盘上，并且磁盘内存是有限的，因此一次最多只能将一行矩阵加载到内存中，该怎么办？ 如果矩阵太大以至于只能一次将部分行加载到内存中，该怎么办？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n^2) O(1) 02 哈希辅助 O(n^2) O(n) func isToeplitzMatrix(matrix [][]int) bool { m, n := len(matrix), len(matrix[0]) for i := 0; i 771.宝石与石头(3) 题目 给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。 J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此\"a\"和\"A\"是不同类型的石头。 示例 1:输入: J = \"aA\", S = \"aAAbbbb\"输出: 3 示例 2:输入: J = \"z\", S = \"ZZ\"输出: 0 注意: S 和 J 最多含有50个字母。 J 中的字符不重复。 解题思路 No. 思路 时间复杂度 空间复杂度 01 内置函数+遍历 O(n^2) O(1) 02 哈希辅助+遍历 O(n) O(n) 03 遍历 O(n^2) O(1) func numJewelsInStones(J string, S string) int { res := 0 for _, v := range J { res = res + strings.Count(S, string(v)) } return res } # func numJewelsInStones(J string, S string) int { m := make(map[byte]bool) for i := range J { m[J[i]] = true } res := 0 for i := range S { if m[S[i]] { res++ } } return res } # func numJewelsInStones(J string, S string) int { res := 0 for _, v := range J { for _, s := range S { if v == s { res++ } } } return res } 783.二叉搜索树节点最小距离(3) 题目 给定一个二叉搜索树的根节点 root，返回树中任意两节点的差的最小值。 示例：输入: root = [4,2,6,1,3,null,null] 输出: 1 解释:注意，root是树节点对象(TreeNode object)，而不是数组。 给定的树 [4,2,6,1,3,null,null] 可表示为下图: 4 / \\ 2 6 / \\ 1 3 最小的差值是 1, 它是节点1和节点2的差值, 也是节点3和节点2的差值。 注意： 二叉树的大小范围在 2 到 100。 二叉树总是有效的，每个节点的值都是整数，且不重复。 本题与 530：https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/ 相同 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归+中序遍历 O(n) O(log(n)) 02 递归+遍历 O(n) O(n) 03 迭代 O(n) O(n) var minDiff, previous int func minDiffInBST(root *TreeNode) int { minDiff, previous = math.MaxInt32, math.MaxInt32 dfs(root) return minDiff } func dfs(root *TreeNode) { if root == nil { return } dfs(root.Left) newDiff := diff(previous, root.Val) if minDiff > newDiff { minDiff = newDiff } previous = root.Val dfs(root.Right) } func diff(a, b int) int { if a > b { return a - b } return b - a } # func minDiffInBST(root *TreeNode) int { arr := make([]int, 0) dfs(root, &arr) min := arr[1] - arr[0] for i := 2; i arr[i]-arr[i-1] { min = arr[i] - arr[i-1] } } return min } func dfs(root *TreeNode, arr *[]int) { if root == nil { return } dfs(root.Left, arr) *arr = append(*arr, root.Val) dfs(root.Right, arr) } # func minDiffInBST(root *TreeNode) int { arr := make([]int, 0) stack := make([]*TreeNode, 0) min := math.MaxInt32 for root != nil || len(stack) > 0 { for root != nil { stack = append(stack, root) root = root.Left } node := stack[len(stack)-1] stack = stack[:len(stack)-1] arr = append(arr, node.Val) if len(arr) > 1 { temp := node.Val - arr[len(arr)-2] if min > temp { min = temp } } root = node.Right } return min } 784.字母大小写全排列(4) 题目 给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。 返回所有可能得到的字符串集合。 示例: 输入: S = \"a1b2\" 输出: [\"a1b2\", \"a1B2\", \"A1b2\", \"A1B2\"] 输入: S = \"3z4\" 输出: [\"3z4\", \"3Z4\"] 输入: S = \"12345\" 输出: [\"12345\"] 注意： S 的长度不超过12。 S 仅由数字和字母组成。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历-逐位添加 O(n*2^n) O(n*2^n) 02 递归 O(n*2^n) O(n*2^n) 03 遍历-遇字母翻倍 O(n*2^n) O(n*2^n) 04 回溯-递归 O(n*2^n) O(n*2^n) func letterCasePermutation(S string) []string { res := make([]string, 1) for i := 0; i = \"0\" && string(S[i]) = 'a' { n := len(res) for j := 0; j = 'a' && arr[level] = 'A' && arr[level] 788.旋转数字(4) 题目 我们称一个数 X 为好数, 如果它的每位数字逐个地被旋转 180 度后， 我们仍可以得到一个有效的，且和 X 不同的数。要求每位数字都要被旋转。 如果一个数的每位数字被旋转以后仍然还是一个数字， 则这个数是有效的。0, 1, 和 8 被旋转后仍然是它们自己； 2 和 5 可以互相旋转成对方（在这种情况下，它们以不同的方向旋转，换句话说，2 和 5 互为镜像）； 6 和 9 同理，除了这些以外其他的数字旋转以后都不再是有效的数字。 现在我们有一个正整数 N, 计算从 1 到 N 中有多少个数 X 是好数？ 示例：输入: 10 输出: 4 解释: 在[1, 10]中有四个好数： 2, 5, 6, 9。注意 1 和 10 不是好数, 因为他们在旋转之后不变。 提示：N 的取值范围是 [1, 10000]。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(nlog(n)) O(1) 02 遍历+递归 O(nlog(n)) O(log(n)) 03 遍历+转字符串 O(nlog(n)) O(log(n)) 04 动态规划 O(n) O(n) func rotatedDigits(N int) int { count := 0 for i := 2; i 0 { switch n % 10 { case 2, 5, 6, 9: valid = true case 3, 4, 7: return false } n = n / 10 } return valid } # func rotatedDigits(N int) int { count := 0 for i := 2; i = 10 { dp = append(dp, make([]int, N-9)...) } res := 0 for i := 0; i 796.旋转字符串(2) 题目 给定两个字符串, A 和 B。 A 的旋转操作就是将 A 最左边的字符移动到最右边。 例如, 若 A = 'abcde'，在移动一次之后结果就是'bcdea' 。 如果在若干次旋转操作之后，A 能变成B，那么返回True。 示例 1: 输入: A = 'abcde', B = 'cdeab' 输出: true 示例 2:输入: A = 'abcde', B = 'abced' 输出: false 注意：A 和 B 长度不超过 100。 解题思路 No. 思路 时间复杂度 空间复杂度 01 内置函数 O(n) O(1) 02 遍历 O(n) O(1) func rotateString(A string, B string) bool { return len(A) == len(B) && strings.Contains(A+A, B) } # func rotateString(A string, B string) bool { if A == B { return true } if len(A) != len(B) { return false } for i := 0; i 0701-0800-Medium 714.买卖股票的最佳时机含手续费(2) 题目 给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ； 非负整数 fee 代表了交易股票的手续费用。 你可以无限次地完成交易，但是你每笔交易都需要付手续费。 如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。 返回获得利润的最大值。 注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。 示例 1:输入: prices = [1, 3, 2, 8, 4, 9], fee = 2 输出: 8 解释: 能够达到的最大利润: 在此处买入 prices[0] = 1 在此处卖出 prices[3] = 8 在此处买入 prices[4] = 4 在此处卖出 prices[5] = 9 总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8. 注意: 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n) O(1) 02 动态规划-二维 O(n) O(n) func maxProfit(prices []int, fee int) int { dp0, dp1 := 0, math.MinInt32 for i := 0; i b { return a } return b } # 2 func maxProfit(prices []int, fee int) int { dp := make([][2]int, len(prices)) dp[0][0] = 0 dp[0][1] = -prices[0] for i := 1; i b { return a } return b } 718.最长重复子数组(3) 题目 给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。 示例：输入：A: [1,2,3,2,1] B: [3,2,1,4,7] 输出：3 解释：长度最长的公共子数组是 [3, 2, 1] 。 提示：1 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n^2) O(n^2) 02 动态规划 O(n^2) O(n) 03 滑动窗口 O(n^2) O(1) func findLength(A []int, B []int) int { n, m := len(A), len(B) dp := make([][]int, n+1) for i := 0; i res { res = dp[i][j] } } } return res } # 2 func findLength(A []int, B []int) int { n, m := len(A), len(B) dp := make([]int, m+1) res := math.MinInt32 for i := 1; i = 1; j-- { if A[i-1] == B[j-1] { dp[j] = dp[j-1] + 1 } else { dp[j] = 0 // 需要清0 } if dp[j] > res { res = dp[j] } } } return res } # 3 func findLength(A []int, B []int) int { n, m := len(A), len(B) res := math.MinInt32 for i := 0; i b { return a } return b } func min(a, b int) int { if a > b { return b } return a } 739.每日温度(3) 题目 请根据每日 气温 列表，重新生成一个列表。 对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。 如果气温在这之后都不会升高，请在该位置用 0 来代替。 例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]， 你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。 提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。 解题思路 No. 思路 时间复杂度 空间复杂度 01 栈辅助 O(n) O(n) 02 数组辅助 O(n) O(1) 03 暴力法 O(n^2) O(1) func dailyTemperatures(T []int) []int { res := make([]int, len(T)) stack := make([]int, 0) // 栈保存递减数据的下标 for i := 0; i 0 && T[i] > T[stack[len(stack)-1]] { last := stack[len(stack)-1] stack = stack[:len(stack)-1] res[last] = i - last } stack = append(stack, i) } return res } # 2 func dailyTemperatures(T []int) []int { res := make([]int, len(T)) arr := make([]int, 101) for i := 0; i = 0; i-- { temp := math.MaxInt64 for t := T[i] + 1; t T[i] { T[i] = j - i break } } if j == len(T) { T[i] = 0 } } return T } 752.打开转盘锁(1) 题目 你有一个带有四个圆形拨轮的转盘锁。 每个拨轮都有10个数字： '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' 。 每个拨轮可以自由旋转：例如把 '9' 变为 '0'，'0' 变为 '9' 。每次旋转都只能旋转一个拨轮的一位数字。 锁的初始数字为 '0000' ，一个代表四个拨轮的数字的字符串。 列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同， 这个锁将会被永久锁定，无法再被旋转。 字符串 target 代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1。 示例 1:输入：deadends = [\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"], target = \"0202\" 输出：6 解释：可能的移动序列为 \"0000\" -> \"1000\" -> \"1100\" -> \"1200\" -> \"1201\" -> \"1202\" -> \"0202\"。 注意 \"0000\" -> \"0001\" -> \"0002\" -> \"0102\" -> \"0202\" 这样的序列是不能解锁的， 因为当拨动到 \"0102\" 时这个锁就会被锁定。 示例 2:输入: deadends = [\"8888\"], target = \"0009\" 输出：1 解释： 把最后一位反向旋转一次即可 \"0000\" -> \"0009\"。 示例 3:输入: deadends = [\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9888\"], target = \"8888\" 输出：-1 解释：无法旋转到目标数字且不被锁定。 示例 4:输入: deadends = [\"0000\"], target = \"8888\" 输出：-1 提示： 死亡列表 deadends 的长度范围为 [1, 500]。 目标数字 target 不会在 deadends 之中。 每个 deadends 和 target 中的字符串的数字会在 10,000 个可能的情况 '0000' 到 '9999' 中产生。 解题思路 No. 思路 时间复杂度 空间复杂度 01 广度优先搜索 O(n) O(n) func openLock(deadends []string, target string) int { m := make(map[string]int) m[\"0000\"] = 0 for i := 0; i 0 { res++ length := len(queue) for i := 0; i 779.第K个语法符号(3) 题目 在第一行我们写上一个 0。接下来的每一行，将前一行中的0替换为01，1替换为10。 给定行数 N 和序数 K，返回第 N 行中第 K个字符。（K从1开始） 例子:输入: N = 1, K = 1 输出: 0 输入: N = 2, K = 1 输出: 0 输入: N = 2, K = 2 输出: 1 输入: N = 4, K = 5 输出: 1 解释: 第一行: 0 第二行: 01 第三行: 0110 第四行: 01101001 注意： N 的范围 [1, 30]. K 的范围 [1, 2^(N-1)]. 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(n) 02 递归 O(n) O(1) 03 位运算 O(log(n)) O(1) func kthGrammar(N int, K int) int { if K == 1 { return 0 } // N行K的数是由N-1行(K+1)/2的数来的 temp := kthGrammar(N-1, (K+1)/2) if K%2 == 1 { return temp } return 1 - temp } # 2 func kthGrammar(N int, K int) int { if K == 1 { return 0 } total := int(math.Pow(2, float64(N-1))) half := total / 2 if K Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 10:39:41 "},"docs/source/question/0801-0900.html":{"url":"docs/source/question/0801-0900.html","title":"0801-0900","keywords":"","body":"0801-0900-Easy 0801-0900-Easy 804.唯一摩尔斯密码词(1) 806.写字符串需要的行数(1) 811.子域名访问计数(2) 812.最大三角形面积(2) 819.最常见的单词(2) 821.字符的最短距离(3) 824.山羊拉丁文(2) 830.较大分组的位置(2) 832.翻转图像(2) 836.矩形重叠(3) 840.矩阵中的幻方(2) 844.比较含退格的字符串(2) 849.到最近的人的最大距离(4) 852.山脉数组的峰顶索引(2) 859.亲密字符串(2) 860.柠檬水找零(1) 867.转置矩阵(1) 868.二进制间距(3) 872.叶子相似的树(2) 874.模拟行走机器人(2) 876.链表的中间结点(3) 883.三维形体投影面积(2) 884.两句话中的不常见单词(2) 888.公平的糖果交换(2) 892.三维形体的表面积(2) 893.特殊等价字符串组(2) 896.单调数列(3) 897.递增顺序查找树(3) 0801-0900-Medium 820.单词的压缩编码(3) 841.钥匙和房间(2) 877.石子游戏(3) 0801-0900-Hard 887.鸡蛋掉落 题目 解题思路 804.唯一摩尔斯密码词(1) 题目 国际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串， 比如: \"a\" 对应 \".-\", \"b\" 对应 \"-...\", \"c\" 对应 \"-.-.\", 等等。 为了方便，所有26个英文字母对应摩尔斯密码表如下： [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\", \"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"] 给定一个单词列表，每个单词可以写成每个字母对应摩尔斯密码的组合。 例如，\"cab\" 可以写成 \"-.-..--...\"，(即 \"-.-.\" + \"-...\" + \".-\"字符串的结合)。 我们将这样一个连接过程称作单词翻译。 返回我们可以获得所有词不同单词翻译的数量。 例如: 输入: words = [\"gin\", \"zen\", \"gig\", \"msg\"] 输出: 2 解释: 各单词翻译如下: \"gin\" -> \"--...-.\" \"zen\" -> \"--...-.\" \"gig\" -> \"--...--.\" \"msg\" -> \"--...--.\" 共有 2 种不同翻译, \"--...-.\" 和 \"--...--.\". 注意: 单词列表words 的长度不会超过 100。 每个单词 words[i]的长度范围为 [1, 12]。 每个单词 words[i]只包含小写字母。 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(n) var table = []string{ \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\", } func uniqueMorseRepresentations(words []string) int { res := make(map[string]bool) for _, w := range words { b := \"\" for i := 0; i 806.写字符串需要的行数(1) 题目 我们要把给定的字符串 S 从左到右写到每一行上，每一行的最大宽度为100个单位， 如果我们在写某个字母的时候会使这行超过了100 个单位，那么我们应该把这个字母写到下一行。 我们给定了一个数组 widths ，这个数组 widths[0] 代表 'a' 需要的单位， widths[1] 代表 'b' 需要的单位，...， widths[25] 代表 'z' 需要的单位。 现在回答两个问题：至少多少行能放下S，以及最后一行使用的宽度是多少个单位？ 将你的答案作为长度为2的整数列表返回。 示例 1:输入: widths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10] S = \"abcdefghijklmnopqrstuvwxyz\" 输出: [3, 60] 解释: 所有的字符拥有相同的占用单位10。所以书写所有的26个字母， 我们需要2个整行和占用60个单位的一行。 示例 2:输入: widths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10] S = \"bbbcccdddaaa\" 输出: [2, 4] 解释: 除去字母'a'所有的字符都是相同的单位10，并且字符串 \"bbbcccdddaa\" 将会覆盖 9 * 10 + 2 * 4 = 98 个单位. 最后一个字母 'a' 将会被写到第二行，因为第一行只剩下2个单位了。 所以，这个答案是2行，第二行有4个单位宽度。 注: 字符串 S 的长度在 [1, 1000] 的范围。 S 只包含小写字母。 widths 是长度为 26的数组。 widths[i] 值的范围在 [2, 10]。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历-模拟 O(n) O(1) func numberOfLines(widths []int, S string) []int { res := []int{0, 0} if len(S) == 0 { return res } res[0] = 1 for i := 0; i 100 { res[0]++ res[1] = widths[S[i]-'a'] } else { res[1] = res[1] + widths[S[i]-'a'] } } return res } 811.子域名访问计数(2) 题目 一个网站域名，如\"discuss.leetcode.com\"，包含了多个子域名。 作为顶级域名，常用的有\"com\"，下一级则有\"leetcode.com\"，最低的一级为\"discuss.leetcode.com\"。 当我们访问域名\"discuss.leetcode.com\"时，也同时访问了其父域名\"leetcode.com\"以及顶级域名 \"com\"。 给定一个带访问次数和域名的组合，要求分别计算每个域名被访问的次数。 其格式为访问次数+空格+地址，例如：\"9001 discuss.leetcode.com\"。 接下来会给出一组访问次数和域名组合的列表cpdomains 。 要求解析出所有域名的访问次数，输出格式和输入格式相同，不限定先后顺序。 示例 1:输入: [\"9001 discuss.leetcode.com\"] 输出: [\"9001 discuss.leetcode.com\", \"9001 leetcode.com\", \"9001 com\"] 说明: 例子中仅包含一个网站域名：\"discuss.leetcode.com\"。 按照前文假设，子域名\"leetcode.com\"和\"com\"都会被访问，所以它们都被访问了9001次。 示例 2输入: [\"900 google.mail.com\", \"50 yahoo.com\", \"1 intel.mail.com\", \"5 wiki.org\"] 输出: [\"901 mail.com\",\"50 yahoo.com\",\"900 google.mail.com\",\"5 wiki.org\",\"5 org\", \"1 intel.mail.com\",\"951 com\"] 说明: 按照假设，会访问\"google.mail.com\" 900次，\"yahoo.com\" 50次， \"intel.mail.com\" 1次，\"wiki.org\" 5次。 而对于父域名，会访问\"mail.com\" 900+1 = 901次，\"com\" 900 + 50 + 1 = 951次，和 \"org\" 5 次。 注意事项： cpdomains 的长度小于 100。 每个域名的长度小于100。 每个域名地址包含一个或两个\".\"符号。 输入中任意一个域名的访问次数都小于10000。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历-哈希辅助 O(n) O(n) 02 遍历-哈希辅助 O(n) O(n) func subdomainVisits(cpdomains []string) []string { m := make(map[string]int) for _, domains := range cpdomains { domain, count := parse(domains) isNew := true for isNew { m[domain] = m[domain] + count domain, isNew = cut(domain) } } return getResult(m) } func parse(s string) (string, int) { ss := strings.Split(s, \" \") count, _ := strconv.Atoi(ss[0]) return ss[1], count } func cut(s string) (string, bool) { index := strings.Index(s, \".\") if index == -1 { return \"\", false } return s[index+1:], true } func getResult(m map[string]int) []string { res := make([]string, 0, len(m)) for k, v := range m { res = append(res, fmt.Sprintf(\"%d %s\", v, k)) } return res } # func subdomainVisits(cpdomains []string) []string { m := make(map[string]int) for _, domains := range cpdomains { arr := strings.Split(domains, \" \") count, _ := strconv.Atoi(arr[0]) tempArr := getSubdomains(arr[1]) for i := 0; i = 0; i-- { if s[i] == '.' { res = append(res, s[i+1:]) } } res = append(res, s) return res } 812.最大三角形面积(2) 题目 给定包含多个点的集合，从其中取三个点组成三角形，返回能组成的最大三角形的面积。 示例:输入: points = [[0,0],[0,1],[1,0],[0,2],[2,0]] 输出: 2 解释: 这五个点如下图所示。组成的橙色三角形是最大的，面积为2。 注意: 3 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法-鞋带公式 O(n^3) O(1) 02 暴力法-海伦公式 O(n^3) O(1) func largestTriangleArea(points [][]int) float64 { maxArea := 0.0 n := len(points) for i := 0; i maxArea { maxArea = area(points[i], points[j], points[k]) } } } } return maxArea } // 三角形面积=|(x1 * y2 + x2 * y3 + x3 * y1 - y1 * x2 - y2 * x3 - y3 * x1)|/2 func area(p1, p2, p3 []int) float64 { return abs( p1[0]*p2[1]+p2[0]*p3[1]+p3[0]*p1[1]- p1[0]*p3[1]-p2[0]*p1[1]-p3[0]*p2[1]) / 2 } func abs(num int) float64 { if num maxArea { maxArea = area } } } } return maxArea } // 求两点距离 func length(p1, p2 []int) float64 { l := (p1[0]-p2[0])*(p1[0]-p2[0]) + (p1[1]-p2[1])*(p1[1]-p2[1]) return math.Sqrt(float64(l)) } 819.最常见的单词(2) 题目 给定一个段落 (paragraph) 和一个禁用单词列表 (banned)。返回出现次数最多，同时不在禁用列表中的单词。 题目保证至少有一个词不在禁用列表中，而且答案唯一。 禁用列表中的单词用小写字母表示，不含标点符号。段落中的单词不区分大小写。答案都是小写字母。 示例：输入: paragraph = \"Bob hit a ball, the hit BALL flew far after it was hit.\" banned = [\"hit\"] 输出: \"ball\" 解释: \"hit\" 出现了3次，但它是一个禁用的单词。 \"ball\" 出现了2次 (同时没有其他单词出现2次)，所以它是段落里出现次数最多的，且不在禁用列表中的单词。 注意，所有这些单词在段落里不区分大小写，标点符号需要忽略（即使是紧挨着单词也忽略， 比如 \"ball,\"）， \"hit\"不是最终的答案，虽然它出现次数更多，但它在禁用单词列表中。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助遍历+内置函数 O(n) O(n) 02 哈希辅助遍历 O(n) O(n) func mostCommonWord(paragraph string, banned []string) string { isBanned := make(map[string]bool) for _, b := range banned { isBanned[b] = true } chars := []string{\"!\", \"?\", \",\", \"'\", \";\", \".\"} for _, c := range chars { paragraph = strings.Replace(paragraph, c, \" \", -1) } p := strings.ToLower(paragraph) ss := strings.Fields(p) count := make(map[string]int) for _, v := range ss { if isBanned[v] { continue } count[v]++ } res := \"\" max := 0 for s, c := range count { if max = 'A' && paragraph[j] = 'a' && b = 'A' && b 821.字符的最短距离(3) 题目 给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。 示例 1:输入: S = \"loveleetcode\", C = 'e' 输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0] 说明: 字符串 S 的长度范围为 [1, 10000]。 C 是一个单字符，且保证是字符串 S 里的字符。 S 和 C 中的所有字母均为小写字母。 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针遍历 O(n) O(1) 02 遍历-往两边找 O(n^2) O(1) 03 遍历-数组辅助 O(n^2) O(n) func shortestToChar(S string, C byte) []int { n := len(S) res := make([]int, n) for i := range res { res[i] = 100001 } left, right := -n, 2*n for i := 0; i n-1 跟左边的C比较得到最近的距离 // j从n-1->0 跟右边的C比较得到最近的距离 res[i] = min(res[i], dist(i, left)) res[j] = min(res[j], dist(j, right)) } return res } func min(a, b int) int { if a j { return i - j } return j - i } # func shortestToChar(S string, C byte) []int { n := len(S) res := make([]int, n) for i := 0; i j-i { min = j - i } break } } for j := i - 1; j >= 0; j-- { if S[j] == C { if min > i-j { min = i - j } break } } res[i] = min } return res } # func shortestToChar(S string, C byte) []int { n := len(S) res := make([]int, n) arr := make([]int, 0) for i := 0; i dist(i, value) { min = dist(i, value) } } res[i] = min } return res } func dist(i, j int) int { if i > j { return i - j } return j - i } 824.山羊拉丁文(2) 题目 给定一个由空格分割单词的句子 S。每个单词只包含大写或小写字母。 我们要将句子转换为 “Goat Latin”（一种类似于 猪拉丁文 - Pig Latin 的虚构语言）。 山羊拉丁文的规则如下： 如果单词以元音开头（a, e, i, o, u），在单词后添加\"ma\"。 例如，单词\"apple\"变为\"applema\"。 如果单词以辅音字母开头（即非元音字母），移除第一个字符并将它放到末尾，之后再添加\"ma\"。 例如，单词\"goat\"变为\"oatgma\"。 根据单词在句子中的索引，在单词最后添加与索引相同数量的字母'a'，索引从1开始。 例如，在第一个单词后添加\"a\"，在第二个单词后添加\"aa\"，以此类推。 返回将 S 转换为山羊拉丁文后的句子。 示例 1:输入: \"I speak Goat Latin\" 输出: \"Imaa peaksmaaa oatGmaaaa atinLmaaaaa\" 示例 2:输入: \"The quick brown fox jumped over the lazy dog\" 输出: \"heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa\" 说明: S 中仅包含大小写字母和空格。单词间有且仅有一个空格。 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 内置函数 O(n) O(n) 02 遍历 O(n) O(n) func toGoatLatin(S string) string { ss := strings.Split(S, \" \") for i := range ss { ss[i] = handle(ss[i], i) } return strings.Join(ss, \" \") } func handle(s string, i int) string { postfix := \"ma\" + strings.Repeat(\"a\", i+1) if isBeginWithVowel(s) { return s + postfix } return s[1:] + s[0:1] + postfix } func isBeginWithVowel(s string) bool { switch s[0] { case 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U': return true default: return false } } # func toGoatLatin(S string) string { res := \"\" begin := 1 count := 1 temp := \"\" for i := 0; i 830.较大分组的位置(2) 题目 在一个由小写字母构成的字符串 S 中，包含由一些连续的相同字符所构成的分组。 例如，在字符串 S = \"abbxxxxzyy\" 中，就含有 \"a\", \"bb\", \"xxxx\", \"z\" 和 \"yy\" 这样的一些分组。 我们称所有包含大于或等于三个连续字符的分组为较大分组。找到每一个较大分组的起始和终止位置。 最终结果按照字典顺序输出。 示例 1:输入: \"abbxxxxzzy\"输出: [[3,6]] 解释: \"xxxx\" 是一个起始于 3 且终止于 6 的较大分组。 示例 2:输入: \"abc\"输出: [] 解释: \"a\",\"b\" 和 \"c\" 均不是符合要求的较大分组。 示例 3:输入: \"abcdddeeeeaabbbcd\"输出: [[3,5],[6,9],[12,14]] 说明: 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n) O(1) 02 双指针 O(n) O(1) func largeGroupPositions(S string) [][]int { res := make([][]int, 0, len(S)/3) left := 0 for right := 0; right = 3 { res = append(res, []int{left, right}) } left = right + 1 } } return res } # func largeGroupPositions(S string) [][]int { res := make([][]int, 0, len(S)/3) left, right := 0, 1 for ; right 3 { res[len(res)-1][1] = right } } return res } 832.翻转图像(2) 题目 给定一个二进制矩阵 A，我们想先水平翻转图像，然后反转图像并返回结果。 水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 [1, 1, 0] 的结果是 [0, 1, 1]。 反转图片的意思是图片中的 0 全部被 1 替换， 1 全部被 0 替换。例如，反转 [0, 1, 1] 的结果是 [1, 0, 0]。 示例 1: 输入: [[1,1,0],[1,0,1],[0,0,0]] 输出: [[1,0,0],[0,1,0],[1,1,1]] 解释: 首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]； 然后反转图片: [[1,0,0],[0,1,0],[1,1,1]] 示例 2: 输入: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]] 输出: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] 解释: 首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]； 然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] 说明: 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历+双指针 O(n^2) O(1) 02 遍历 O(n^2) O(1) func flipAndInvertImage(A [][]int) [][]int { for k := 0; k 836.矩形重叠(3) 题目 矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。 如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。 给出两个矩形，判断它们是否重叠并返回结果。 示例 1：输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3] 输出：true 示例 2：输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1] 输出：false 提示： 两个矩形 rec1 和 rec2 都以含有四个整数的列表的形式给出。 矩形中的所有坐标都处于 -10^9 和 10^9 之间。 x 轴默认指向右，y 轴默认指向上。 你可以仅考虑矩形是正放的情况。 解题思路 No. 思路 时间复杂度 空间复杂度 01 正面条件判断 O(1) O(1) 02 不满足条件判断 O(1) O(1) 03 投影 O(1) O(1) func isRectangleOverlap(rec1 []int, rec2 []int) bool { // 满足条件 if rec1[1] = rec2[2] // 上方：rec1[1] >= rec2[3] // 下方：rec1[3] = rec2[2] || rec1[1] >= rec2[3] { return false } return true } # func isRectangleOverlap(rec1 []int, rec2 []int) bool { return min(rec1[2], rec2[2]) > max(rec1[0], rec2[0]) && min(rec1[3], rec2[3]) > max(rec1[1], rec2[1]) } func max(a, b int) int { if a > b { return a } return b } func min(a, b int) int { if a > b { return b } return a } 840.矩阵中的幻方(2) 题目 3 x 3 的幻方是一个填充有从 1 到 9 的不同数字的 3 x 3 矩阵， 其中每行，每列以及两条对角线上的各数之和都相等。 给定一个由整数组成的 grid，其中有多少个 3 × 3 的 “幻方” 子矩阵？（每个子矩阵都是连续的）。 示例：输入: [[4,3,8,4], [9,5,1,9], [2,7,6,2]] 输出: 1 解释: 下面的子矩阵是一个 3 x 3 的幻方： 438 951 276 而这一个不是： 384 519 762 总的来说，在本示例所给定的矩阵中只有一个 3 x 3 的幻方子矩阵。 提示: 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法 O(n^2) O(1) 02 暴力法-打表 O(n^2) O(1) func numMagicSquaresInside(grid [][]int) int { m, n := len(grid), len(grid[0]) res := 0 for i := 0; i+2 844.比较含退格的字符串(2) 题目 给定 S 和 T 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 # 代表退格字符。 注意：如果对空文本输入退格字符，文本继续为空。 示例 1：输入：S = \"ab#c\", T = \"ad#c\"输出：true 解释：S 和 T 都会变成 “ac”。 示例 2：输入：S = \"ab##\", T = \"c#d#\"输出：true 解释：S 和 T 都会变成 “”。 示例 3：输入：S = \"a##c\", T = \"#a#c\"输出：true 解释：S 和 T 都会变成 “c”。 示例 4：输入：S = \"a#c\", T = \"b\" 输出：false 解释：S 会变成 “c”，但 T 仍然是 “b”。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历-数组模拟栈操作 O(n) O(n) 02 遍历-从后往前 O(n) O(n) func backspaceCompare(S string, T string) bool { return check(S) == check(T) } func check(str string) string { res := make([]string, 0) for _, v := range str { if string(v) == \"#\" { if len(res) != 0 { res = res[:len(res)-1] } } else { res = append(res, string(v)) } } return strings.Join(res, \"\") } # func backspaceCompare(S string, T string) bool { return check(S) == check(T) } func check(S string) string { str := \"\" count := 0 for i := len(S) - 1; i >= 0; i-- { if S[i] == '#' { count++ } else { if count != 0 { count-- continue } str = string(S[i]) + str } } return str } 849.到最近的人的最大距离(4) 题目 在一排座位（ seats）中，1 代表有人坐在座位上，0 代表座位上是空的。 至少有一个空座位，且至少有一人坐在座位上。 亚历克斯希望坐在一个能够使他与离他最近的人之间的距离达到最大化的座位上。 返回他到离他最近的人的最大距离。 示例 1：输入：[1,0,0,0,1,0,1]输出：2 解释：如果亚历克斯坐在第二个空位（seats[2]）上，他到离他最近的人的距离为 2 。 如果亚历克斯坐在其它任何一个空位上，他到离他最近的人的距离为 1 。 因此，他到离他最近的人的最大距离是 2 。 示例 2：输入：[1,0,0,0]输出：3 解释： 如果亚历克斯坐在最后一个座位上，他离最近的人有 3 个座位远。 这是可能的最大距离，所以答案是 3 。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历-数组辅助 O(n) O(n) 02 遍历-双指针 O(n) I 03 遍历 O(n) O(n) 04 遍历 O(n) O(1) func maxDistToClosest(seats []int) int { n := len(seats) left := make([]int, n) right := make([]int, n) for i := 0; i 0 { left[i] = left[i-1] + 1 } } for i := n - 1; i >= 0; i-- { if seats[i] == 1 { right[i] = 0 } else if seats[i] != 1 && i res { res = min(left[i], right[i]) } } } return res } func min(a, b int) int { if a > b { return b } return a } # func maxDistToClosest(seats []int) int { n := len(seats) res := 0 left := -1 right := 0 for i := 0; i res { res = min(leftLen, rightLen) } } } return res } func min(a, b int) int { if a > b { return b } return a } # func maxDistToClosest(seats []int) int { n := len(seats) var arr []int for i := 0; i max { max = arr[i+1] - arr[i] } } max = max / 2 // 判断首尾 if arr[0] > max { max = arr[0] } if n-arr[len(arr)-1]-1 > max { max = n - arr[len(arr)-1] - 1 } return max } # func maxDistToClosest(seats []int) int { res := 0 count := 0 for i := 0; i b { return a } return b } 852.山脉数组的峰顶索引(2) 题目 我们把符合下列属性的数组 A 称作山脉： A.length >= 3 存在 0 A[i+1] > ... > A[A.length - 1] 给定一个确定为山脉的数组，返回任何满足 A[0] A[i+1] > ... > A[A.length - 1] 的 i 的值。 示例 1：输入：[0,1,0]输出：1 示例 2：输入：[0,2,1,0]输出：1 提示： 3 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 二分查找 O(log(n)) O(1) func peakIndexInMountainArray(A []int) int { n := len(A) for i := 0; i A[i+1] { return i } } return 0 } # func peakIndexInMountainArray(A []int) int { left, right := 0, len(A)-1 for { mid := left + (right-left)/2 if A[mid] > A[mid+1] && A[mid] > A[mid-1] { return mid } if A[mid] > A[mid-1] { left = mid + 1 } else { right = mid - 1 } } } 859.亲密字符串(2) 题目 给定两个由小写字母构成的字符串 A 和 B ，只要我们可以通过交换 A 中的两个字母得到与 B 相等的结果， 就返回 true ；否则返回 false 。 示例 1： 输入： A = \"ab\", B = \"ba\" 输出： true 示例 2： 输入： A = \"ab\", B = \"ab\"输出： false 示例 3: 输入： A = \"aa\", B = \"aa\" 输出： true 示例 4： 输入： A = \"aaaaaaabc\", B = \"aaaaaaacb\" 输出： true 示例 5： 输入： A = \"\", B = \"aa\" 输出： false 提示： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 遍历 O(n) O(1) func buddyStrings(A string, B string) bool { if len(A) != len(B) { return false } if A == B { return hasDouble(A) } count := 2 strA, strB := \"\", \"\" i := 0 for ; count > 0 && i = 1 { return true } seen[b] = 1 } return false } 860.柠檬水找零(1) 题目 在柠檬水摊上，每一杯柠檬水的售价为 5 美元。 顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。 每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。 你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。 注意，一开始你手头没有任何零钱。 如果你能给每位顾客正确找零，返回 true ，否则返回 false 。 示例 1：输入：[5,5,5,10,20] 输出：true 解释： 前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。 第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。 第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。 由于所有客户都得到了正确的找零，所以我们输出 true。 示例 2：输入：[5,5,10] 输出：true 示例 3：输入：[10,10] 输出：false 示例 4：输入：[5,5,10,10,20] 输出：false 解释： 前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。 对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。 对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。 由于不是每位顾客都得到了正确的找零，所以答案是 false。 提示： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历+模拟 O(n) O(1) func lemonadeChange(bills []int) bool { fives, tens := 0, 0 for _, b := range bills { switch b { case 5: fives++ case 10: fives-- tens++ case 20: if tens > 0 { tens-- fives-- } else { fives = fives - 3 } } if fives 867.转置矩阵(1) 题目 给定一个矩阵 A， 返回 A 的转置矩阵。 矩阵的转置是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。 示例 1：输入：[[1,2,3],[4,5,6],[7,8,9]]输出：[[1,4,7],[2,5,8],[3,6,9]] 示例 2：输入：[[1,2,3],[4,5,6]]输出：[[1,4],[2,5],[3,6]] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n^2) O(n^2) func transpose(A [][]int) [][]int { m, n := len(A), len(A[0]) res := make([][]int, n) for i := 0; i 868.二进制间距(3) 题目 给定一个正整数 N，找到并返回 N 的二进制表示中两个连续的 1 之间的最长距离。 如果没有两个连续的 1，返回 0 。 示例 1：输入：22 输出：2 解释：22 的二进制是 0b10110 。 在 22 的二进制表示中，有三个 1，组成两对连续的 1 。 第一对连续的 1 中，两个 1 之间的距离为 2 。 第二对连续的 1 中，两个 1 之间的距离为 1 。 答案取两个距离之中最大的，也就是 2 。 示例 2：输入：5 输出：2 解释：5 的二进制是 0b101 。 示例 3：输入：6 输出：1 解释： 6 的二进制是 0b110 。 示例 4：输入：8 输出：0 解释： 8 的二进制是 0b1000 。 在 8 的二进制表示中没有连续的 1，所以返回 0 。 提示：1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历-数组辅助 O(log(n)) O(log(n)) 02 遍历 O(log(n)) O(1) 03 遍历-内置函数 O(log(n)) O(log(n)) func binaryGap(N int) int { arr := make([]int, 0) index := 0 for N > 0 { if N%2 == 1 { arr = append(arr, index) } index++ N = N / 2 } res := 0 for i := 0; i res { res = arr[i+1] - arr[i] } } return res } # func binaryGap(N int) int { res := 0 count := 0 for N > 0 { if N%2 == 1 { if count > res { res = count } count = 1 } else if count > 0 { count++ } N = N / 2 } return res } # func binaryGap(N int) int { res := 0 str := strconv.FormatInt(int64(N), 2) j := -1 for i := 0; i res { res = i - j } j = i } } } return res } 872.叶子相似的树(2) 题目 请考虑一颗二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个叶值序列 。 举个例子，如上图所示，给定一颗叶值序列为 (6, 7, 4, 9, 8) 的树。 如果有两颗二叉树的叶值序列是相同，那么我们就认为它们是 叶相似 的。 如果给定的两个头结点分别为 root1 和 root2 的树是叶相似的，则返回 true；否则返回 false 。 提示： 给定的两颗树可能会有 1 到 200 个结点。 给定的两颗树上的值介于 0 到 200 之间。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 迭代 O(n) O(n) var a1, a2 []int func leafSimilar(root1 *TreeNode, root2 *TreeNode) bool { a1 = make([]int, 0) a2 = make([]int, 0) dfs(root1, &a1) dfs(root2, &a2) if len(a1) != len(a2) { return false } for i := 0; i 0 { node := stack[len(stack)-1] stack = stack[:len(stack)-1] if node.Left == nil && node.Right == nil { *arr = append(*arr, node.Val) } if node.Right != nil { stack = append(stack, node.Right) } if node.Left != nil { stack = append(stack, node.Left) } } } 874.模拟行走机器人(2) 题目 机器人在一个无限大小的网格上行走，从点 (0, 0) 处开始出发，面向北方。该机器人可以接收以下三种类型的命令： -2：向左转 90 度 -1：向右转 90 度 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历-模拟 O(n) O(n) 02 遍历-模拟 O(n) O(n) // 上、右、下、左 var dx = []int{0, 1, 0, -1} var dy = []int{1, 0, -1, 0} func robotSim(commands []int, obstacles [][]int) int { i := 0 // 方向， 0上， 1右， 2下， 3左 x := 0 y := 0 res := 0 m := map[string]bool{} for _, v := range obstacles { str := strconv.Itoa(v[0]) + \",\" + strconv.Itoa(v[1]) m[str] = true } for _, v := range commands { if v == -2 { i = (i + 3) % 4 // 左转 } else if v == -1 { i = (i + 1) % 4 // 右转 } else { for v > 0 { ddx := x + dx[i] ddy := y + dy[i] tp := strconv.Itoa(ddx) + \",\" + strconv.Itoa(ddy) if _, ok := m[tp]; ok { // 有障碍物，停止 break } else { x = ddx y = ddy if x*x+y*y > res { res = x*x + y*y } } v-- } } } return res } # var dx = []int{0, 1, 0, -1} var dy = []int{1, 0, -1, 0} func robotSim(commands []int, obstacles [][]int) int { m := make(map[string]bool, 10000) for _, o := range obstacles { i, j := o[0], o[1] m[encode(i, j)] = true } x, y, res := 0, 0, 0 index := 0 for _, c := range commands { index = (index + 4) % 4 switch { case c == -2: index-- case c == -1: index++ default: dx1, dy1 := dx[index], dy[index] for c > 0 && !m[encode(x+dx1, y+dy1)] { c-- x = x + dx1 y = y + dy1 } if x*x+y*y > res { res = x*x + y*y } } } return res } func encode(x, y int) string { return strconv.Itoa(x) + \",\" + strconv.Itoa(y) } 876.链表的中间结点(3) 题目 给定一个带有头结点 head 的非空单链表，返回链表的中间结点。 如果有两个中间结点，则返回第二个中间结点。 示例 1：输入：[1,2,3,4,5] 输出：此列表中的结点 3 (序列化形式：[3,4,5]) 返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。 注意，我们返回了一个 ListNode 类型的对象 ans，这样： ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL. 示例 2：输入：[1,2,3,4,5,6] 输出：此列表中的结点 4 (序列化形式：[4,5,6]) 由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。 提示： 给定链表的结点数介于 1 和 100 之间。 解题思路 No. 思路 时间复杂度 空间复杂度 01 快慢指针 O(n) O(1) 02 数组辅助 O(n) O(n) 03 遍历统计 O(n) O(1) func middleNode(head *ListNode) *ListNode { slow, fast := head, head for fast != nil && fast.Next != nil { slow = slow.Next fast = fast.Next.Next } return slow } # func middleNode(head *ListNode) *ListNode { res := make([]*ListNode, 0) for head != nil { res = append(res, head) head = head.Next } return res[len(res)/2] } # func middleNode(head *ListNode) *ListNode { count := 0 temp := head for temp != nil { count++ temp = temp.Next } mid := count / 2 for head != nil { if mid == 0 { return head } head = head.Next mid-- } return head } 883.三维形体投影面积(2) 题目 在 N * N 的网格中，我们放置了一些与 x，y，z 三轴对齐的 1 * 1 * 1 立方体。 每个值 v = grid[i][j] 表示 v 个正方体叠放在单元格 (i, j) 上。 现在，我们查看这些立方体在 xy、yz 和 zx 平面上的投影。 投影就像影子，将三维形体映射到一个二维平面上。 在这里，从顶部、前面和侧面看立方体时，我们会看到“影子”。 返回所有三个投影的总面积。 示例 1：输入：[[2]] 输出：5 示例 2：输入：[[1,2],[3,4]] 输出：17 解释： 这里有该形体在三个轴对齐平面上的三个投影(“阴影部分”)。 示例 3：输入：[[1,0],[0,2]] 输出：8 示例 4：输入：[[1,1,1],[1,0,1],[1,1,1]] 输出：14 示例 5：输入：[[2,2,2],[2,1,2],[2,2,2]] 输出：21 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n^2) O(1) 02 遍历 O(n^2) O(1) // 1.xy面，grid[i][j]>0的个数累加 // 2.xz面, 行的最大值累加 // 3.yz面, 列的最大值累加 func projectionArea(grid [][]int) int { yz := [51]int{} xz := [51]int{} res := 0 for i, line := range grid { for j, k := range line { if k == 0 { continue } res++ yz[i] = max(yz[i], k) xz[j] = max(xz[j], k) } } for i := range yz { res = res + yz[i] + xz[i] } return res } func max(a, b int) int { if a > b { return a } return b } # func projectionArea(grid [][]int) int { res := 0 for i := 0; i 0 { res++ } if yz 884.两句话中的不常见单词(2) 题目 给定两个句子 A 和 B 。 （句子是一串由空格分隔的单词。每个单词仅由小写字母组成。） 如果一个单词在其中一个句子中只出现一次，在另一个句子中却没有出现，那么这个单词就是不常见的。 返回所有不常用单词的列表。 您可以按任何顺序返回列表。 示例 1：输入：A = \"this apple is sweet\", B = \"this apple is sour\"输出：[\"sweet\",\"sour\"] 示例 2：输入：A = \"apple apple\", B = \"banana\"输出：[\"banana\"] 提示： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助+内置函数 O(n) O(n) 02 哈希辅助+遍历 O(n) O(n) func uncommonFromSentences(A string, B string) []string { m := map[string]int{} arrA := strings.Fields(A) arrB := strings.Fields(B) for _, v := range arrA { m[v]++ } for _, v := range arrB { m[v]++ } res := make([]string, 0) for k, v := range m { if v == 1 { res = append(res, k) } } return res } # func uncommonFromSentences(A string, B string) []string { m := map[string]int{} A = A + \" \" + B + \" \" j := 0 for i := 0; i 888.公平的糖果交换(2) 题目 爱丽丝和鲍勃有不同大小的糖果棒：A[i] 是爱丽丝拥有的第 i 块糖的大小，B[j] 是鲍勃拥有的第 j 块糖的大小。 因为他们是朋友，所以他们想交换一个糖果棒，这样交换后，他们都有相同的糖果总量。 （一个人拥有的糖果总量是他们拥有的糖果棒大小的总和。） 返回一个整数数组 ans，其中 ans[0] 是爱丽丝必须交换的糖果棒的大小，ans[1] 是 Bob 必须交换的糖果棒的大小。 如果有多个答案，你可以返回其中任何一个。保证答案存在。 示例 1：输入：A = [1,1], B = [2,2] 输出：[1,2] 示例 2：输入：A = [1,2], B = [2,3] 输出：[1,2] 示例 3：输入：A = [2], B = [1,3] 输出：[2,3] 示例 4：输入：A = [1,2,5], B = [2,4] 输出：[5,4] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历+哈希辅助 O(n) O(n) 02 暴力法 O(n^2) O(1) func fairCandySwap(A []int, B []int) []int { m := make(map[int]bool) sumA := 0 sumB := 0 for _, v := range A { sumA = sumA + v m[v] = true } for _, v := range B { sumB = sumB + v } half := (sumA - sumB) / 2 a, b := 0, 0 // sumA-A[i]+B[j] == sumB-B[j]+A[i] // sumA-sumB=2(A[i]-B[j]) // (sumA-sumB)/2 = A[i]-B[j] for _, b = range B { a = b + half if m[a] == true { return []int{a, b} } } return nil } # func fairCandySwap(A []int, B []int) []int { sumA := 0 sumB := 0 for _, v := range A { sumA = sumA + v } for _, v := range B { sumB = sumB + v } for i := 0; i 892.三维形体的表面积(2) 题目 在 N * N 的网格上，我们放置一些 1 * 1 * 1 的立方体。 每个值 v = grid[i][j] 表示 v 个正方体叠放在对应单元格 (i, j) 上。 请你返回最终形体的表面积。 示例 1：输入：[[2]] 输出：10 示例 2：输入：[[1,2],[3,4]] 输出：34 示例 3：输入：[[1,0],[0,2]] 输出：16 示例 4：输入：[[1,1,1],[1,0,1],[1,1,1]] 输出：32 示例 5：输入：[[2,2,2],[2,1,2],[2,2,2]]输出：46 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n^2) O(1) 02 遍历 O(n^2) O(1) // 第1步：总表面积是个数*6 // 第2步：同一位置，从2层以上开始，每升高一层，减少2个面 // 第3步：左右位置，每相邻一个，减少2个面 // 第4步：前后位置，每相邻一个，减少2个面 func surfaceArea(grid [][]int) int { sum := 0 for i, rows := range grid { for j, _ := range rows { sum = sum + grid[i][j]*6 if grid[i][j] > 1 { sum = sum - (grid[i][j]-1)*2 } if j > 0 { sum = sum - min(grid[i][j], grid[i][j-1])*2 } if i > 0 { sum = sum - min(grid[i][j], grid[i-1][j])*2 } } } return sum } func min(a, b int) int { if a > b { return b } return a } # // 上、右、下、左 var dx = []int{0, 1, 0, -1} var dy = []int{1, 0, -1, 0} func surfaceArea(grid [][]int) int { sum := 0 for i, rows := range grid { for j, _ := range rows { sum = sum + grid[i][j]*6 if grid[i][j] > 1 { sum = sum - (grid[i][j]-1)*2 } for k := 0; k = 0 && x = 0 && y b { return b } return a } 893.特殊等价字符串组(2) 题目 你将得到一个字符串数组 A。 如果经过任意次数的移动，S == T，那么两个字符串 S 和 T 是特殊等价的。 一次移动包括选择两个索引 i 和 j，且 i ％ 2 == j ％ 2，交换 S[j] 和 S [i]。 现在规定，A 中的特殊等价字符串组是 A 的非空子集 S， 这样不在 S 中的任何字符串与 S 中的任何字符串都不是特殊等价的。 返回 A 中特殊等价字符串组的数量。 示例 1：输入：[\"a\",\"b\",\"c\",\"a\",\"c\",\"c\"] 输出：3 解释：3 组 [\"a\",\"a\"]，[\"b\"]，[\"c\",\"c\",\"c\"] 示例 2：输入：[\"aa\",\"bb\",\"ab\",\"ba\"] 输出：4 解释：4 组 [\"aa\"]，[\"bb\"]，[\"ab\"]，[\"ba\"] 示例 3：输入：[\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"] 输出：3 解释：3 组 [\"abc\",\"cba\"]，[\"acb\",\"bca\"]，[\"bac\",\"cab\"] 示例 4：输入：[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] 输出：1 解释：1 组 [\"abcd\",\"cdab\",\"adcb\",\"cbad\"] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历+哈希辅助 O(n) O(n) 02 遍历+哈希辅助 O(n) O(n) func numSpecialEquivGroups(A []string) int { groups := make(map[[26]int]bool) for _, a := range A { count := [26]int{} i := 0 for i = 0; i 896.单调数列(3) 题目 如果数组是单调递增或单调递减的，那么它是单调的。 如果对于所有 i = A[j]，那么数组 A 是单调递减的。 当给定的数组 A 是单调数组时返回 true，否则返回 false。 示例 1：输入：[1,2,2,3]输出：true 示例 2：输入：[6,5,4,4]输出：true 示例 3：输入：[1,3,2]输出：false 示例 4：输入：[1,2,4,5]输出：true 示例 5：输入：[1,1,1]输出：true 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 遍历 O(n) O(1) 03 遍历 O(n) O(1) func isMonotonic(A []int) bool { toEnd := true toFirst := true for i := 0; i A[i+1] { toEnd = false } if A[i] A[i+1] { return false } } return true } func desc(A []int) bool { for i := 0; i 0 && A[i] > A[i+1] { return false } else if temp 897.递增顺序查找树(3) 题目 给你一个树，请你 按中序遍历 重新排列树，使树中最左边的结点现在是树的根， 并且每个结点没有左子结点，只有一个右子结点。 示例 ：输入：[5,3,6,2,4,null,8,1,null,null,null,7,9] 5 / \\ 3 6 / \\ \\ 2 4 8 / / \\ 1 7 9 输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9] 1 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6 \\ 7 \\ 8 \\ 9 提示： 给定树中的结点数介于 1 和 100 之间。 每个结点都有一个从 0 到 1000 范围内的唯一整数值。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归-数组辅助 O(n) O(n) 02 递归 O(n) O(log(n)) 03 迭代 O(n) O(n) func increasingBST(root *TreeNode) *TreeNode { arr := make([]int, 0) dfs(root, &arr) if len(arr) == 0 { return root } newRoot := &TreeNode{Val: arr[0]} cur := newRoot for i := 1; i 0 { node := stack[len(stack)-1] if node.Right != nil { stack = append(stack, node.Right) node.Right = nil continue } stack = stack[:len(stack)-1] node.Right = newRoot.Right newRoot.Right = node if node.Left != nil { stack = append(stack, node.Left) node.Left = nil } } return newRoot.Right } 0801-0900-Medium 820.单词的压缩编码(3) 题目 给定一个单词列表，我们将这个列表编码成一个索引字符串 S 与一个索引列表 A。 例如，如果这个列表是 [\"time\", \"me\", \"bell\"]， 我们就可以将其表示为 S = \"time#bell#\" 和 indexes = [0, 2, 5]。 对于每一个索引，我们可以通过从字符串 S 中索引的位置开始读取字符串，直到 \"#\" 结束， 来恢复我们之前的单词列表。 那么成功对给定单词列表进行编码的最小字符串长度是多少呢？ 示例：输入: words = [\"time\", \"me\", \"bell\"] 输出: 10 说明: S = \"time#bell#\" ， indexes = [0, 2, 5] 。 提示：1 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n^2) O(n) 02 排序遍历 O(n^2) O(n) 03 逆置排序 O(nlog(n)) O(n) func minimumLengthEncoding(words []string) int { res := 0 m := make(map[string]bool) for i := 0; i = 0; i-- { if m[words[i]] == false { continue } for j := i - 1; j >= 0; j-- { if strings.HasSuffix(words[i], words[j]) == true { m[words[j]] = false } } } for k := range m { if m[k] == true { res = res + len(k) + 1 } } return res } # 3 func minimumLengthEncoding(words []string) int { res := 0 arr := make([]string, 0) for k := range words { arr = append(arr, reverse(words[k])) } sort.Strings(arr) for i := 0; i = 0; i-- { res = append(res, str[i]) } return string(res) } 841.钥匙和房间(2) 题目 有 N 个房间，开始时你位于 0 号房间。每个房间有不同的号码：0，1，2，...，N-1， 并且房间里可能有一些钥匙能使你进入下一个房间。 在形式上，对于每个房间 i 都有一个钥匙列表 rooms[i]， 每个钥匙 rooms[i][j] 由 [0,1，...，N-1] 中的一个整数表示，其中 N = rooms.length。 钥匙 rooms[i][j] = v 可以打开编号为 v 的房间。 最初，除 0 号房间外的其余所有房间都被锁住。 你可以自由地在房间之间来回走动。 如果能进入每个房间返回 true，否则返回 false。 示例 1：输入: [[1],[2],[3],[]]输出: true 解释: 我们从 0 号房间开始，拿到钥匙 1。 之后我们去 1 号房间，拿到钥匙 2。 然后我们去 2 号房间，拿到钥匙 3。 最后我们去了 3 号房间。 由于我们能够进入每个房间，我们返回 true。 示例 2：输入：[[1,3],[3,0,1],[2],[0]] 输出：false 解释：我们不能进入 2 号房间。 提示：1 解题思路 No. 思路 时间复杂度 空间复杂度 01 深度优先搜索 O(n) O(n) 02 广度优先搜索 O(n) O(n) var visited []bool var total int func canVisitAllRooms(rooms [][]int) bool { n := len(rooms) total = 0 visited = make([]bool, n) dfs(rooms, 0) return total == n } func dfs(rooms [][]int, start int) { visited[start] = true total++ for _, room := range rooms[start] { if visited[room] == false { dfs(rooms, room) } } } # 2 func canVisitAllRooms(rooms [][]int) bool { n := len(rooms) total := 0 visited := make([]bool, n) visited[0] = true queue := make([]int, 0) queue = append(queue, 0) for len(queue) > 0 { start := queue[0] queue = queue[1:] total++ for _, room := range rooms[start] { if visited[room] == false { visited[room] = true queue = append(queue, room) } } } return total == n } 877.石子游戏(3) 题目 亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。 游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。 亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。 假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。 示例：输入：[5,3,4,5] 输出：true 解释：亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。 假设他取了前 5 颗，这一行就变成了 [3,4,5] 。 如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。 如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。 这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。 提示：2 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划-一维 O(n^2) O(n) 02 动态规划-二维 O(n^2) O(n^2) 03 数学 O(1) O(1) func stoneGame(piles []int) bool { dp := make([]int, len(piles)) for i := 0; i = 0; i-- { for j := i + 1; j = 0 } func max(a, b int) int { if a > b { return a } return b } # 2 func stoneGame(piles []int) bool { n := len(piles) dp := make([][]int, n) for i := 0; i = 0; i-- { for j := i + 1; j = 0 } func max(a, b int) int { if a > b { return a } return b } # 3 func stoneGame(piles []int) bool { return true } 0801-0900-Hard 887.鸡蛋掉落 题目 你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N 共有 N 层楼的建筑。 每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。 你知道存在楼层 F ，满足 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n^2) O(n^2) 02 动态规划 func superEggDrop(K int, N int) int { dp := make([][]int, K+1) for i := 0; i = N { return j } } } return N } Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 10:40:12 "},"docs/source/question/0901-1000.html":{"url":"docs/source/question/0901-1000.html","title":"0901-1000","keywords":"","body":"0901-1000-Easy 0901-1000-Easy 905.按奇偶排序数组(4) 908.最小差值I(2) 914.卡牌分组 917.仅仅反转字母(4) 922.按奇偶排序数组 II(3) 925.长按键入(2) 929.独特的电子邮件地址(2) 933.最近的请求次数(2) 937.重新排列日志文件(2) 938.二叉搜索树的范围和(2) 941.有效的山脉数组(2) 942.增减字符串匹配(1) 944.删列造序(1) 949.给定数字能组成的最大时间(2) 953.验证外星语词典(2) 961.重复 N 次的元素(5) 965.单值二叉树(4) 970.强整数(2) 976.三角形的最大周长(2) 977.有序数组的平方(3) 985.查询后的偶数和(1) 989.数组形式的整数加法(4) 993.二叉树的堂兄弟节点(2) 997.找到小镇的法官(2) 999.可以被一步捕获的棋子数(2) 0901-1000-Medium 901.股票价格跨度(1) 912.排序数组(7) 921.使括号有效的最少添加(3) 945.使数组唯一的最小增量(3) 946.验证栈序列(2) 974.和可被K整除的子数组(2) 983.最低票价(3) 994.腐烂的橘子(2) 0901-1000-Hard 956.最高的广告牌(5) 905.按奇偶排序数组(4) 题目 给定一个非负整数数组 A，返回一个数组，在该数组中， A 的所有偶数元素之后跟着所有奇数元素。 你可以返回满足此条件的任何数组作为答案。 示例：输入：[3,1,2,4] 输出：[2,4,3,1] 输出 [4,2,3,1]，[2,4,1,3] 和 [4,2,1,3] 也会被接受。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n) O(1) 02 双指针 O(n) O(1) 03 遍历 O(n) O(n) 04 遍历 O(n) O(1) func sortArrayByParity(A []int) []int { i := 0 j := len(A)-1 for i 908.最小差值I(2) 题目 给你一个整数数组 A，对于每个整数 A[i]，我们可以选择处于区间 [-K, K] 中的任意数 x ， 将 x 与 A[i] 相加，结果存入 A[i] 。 在此过程之后，我们得到一些数组 B。 返回 B 的最大值和 B 的最小值之间可能存在的最小差值。 示例 1：输入：A = [1], K = 0 输出：0 解释：B = [1] 示例 2：输入：A = [0,10], K = 2 输出：6 解释：B = [2,8] 示例 3：输入：A = [1,3,6], K = 3 输出：0 解释：B = [3,3,3] 或 B = [4,4,4] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序 O(nlog(n)) O(1) 02 遍历 O(n) O(1) func smallestRangeI(A []int, K int) int { if len(A) == 1 { return 0 } sort.Ints(A) if A[len(A)-1]-A[0] > 2*K { return A[len(A)-1] - A[0] - 2*K } return 0 } # func smallestRangeI(A []int, K int) int { if len(A) == 1 { return 0 } min := A[0] max := A[0] for i := 0; i max { max = A[i] } if A[i] 2*K { return max - min - 2*K } return 0 } 914.卡牌分组 题目 给定一副牌，每张牌上都写着一个整数。 此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组： 每组都有 X 张牌。 组内所有的牌上都写着相同的整数。 仅当你可选的 X >= 2 时返回 true。 示例 1：输入：[1,2,3,4,4,3,2,1] 输出：true 解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4] 示例 2：输入：[1,1,1,2,2,2,3,3] 输出：false 解释：没有满足要求的分组。 示例 3：输入：[1] 输出：false 解释：没有满足要求的分组。 示例 4：输入：[1,1] 输出：true 解释：可行的分组是 [1,1] 示例 5：输入：[1,1,2,2,2,2] 输出：true 解释：可行的分组是 [1,1]，[2,2]，[2,2] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助+求公约数 O(nlog(n)) O(n) 02 暴力法 O(n^2) O(n) func hasGroupsSizeX(deck []int) bool { if len(deck) 0 { return gcd(y, a) } return y } # func hasGroupsSizeX(deck []int) bool { if len(deck) 917.仅仅反转字母(4) 题目 给定一个字符串 S，返回 “反转后的” 字符串，其中不是字母的字符都保留在原地，而所有字母的位置发生反转。 示例 1：输入：\"ab-cd\" 输出：\"dc-ba\" 示例 2：输入：\"a-bC-dEf-ghIj\" 输出：\"j-Ih-gfE-dCba\" 示例 3：输入：\"Test1ng-Leet=code-Q!\" 输出：\"Qedo1ct-eeLg=ntse-T!\" 提示： S.length 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n) O(n) 02 双指针 O(n) O(n) 03 双指针-内置函数 O(n) O(n) 04 栈辅助 O(n) O(n) func reverseOnlyLetters(S string) string { i := 0 j := len(S) - 1 arr := []byte(S) for i = 'a' && b = 'A' && b = 'a' && b = 'A' && b 922.按奇偶排序数组 II(3) 题目 给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。 对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。 你可以返回任何满足上述条件的数组作为答案。 示例：输入：[4,2,5,7]输出：[4,5,2,7] 解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。 提示： 2 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n) O(1) 02 双指针 O(n) O(1) 03 数组辅助 O(n) O(n) func sortArrayByParityII(A []int) []int { i := 0 j := 1 for i = len(A) || j >= len(A) { break } A[i], A[j] = A[j], A[i] } return A } # func sortArrayByParityII(A []int) []int { i := 0 j := 1 for i 925.长按键入(2) 题目 你的朋友正在使用键盘输入他的名字 name。偶尔，在键入字符 c 时，按键可能会被长按， 而字符可能被输入 1 次或多次。 你将会检查键盘输入的字符 typed。 如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回 True。 示例 1： 输入：name = \"alex\", typed = \"aaleex\" 输出：true 解释：'alex' 中的 'a' 和 'e' 被长按。 示例 2： 输入：name = \"saeed\", typed = \"ssaaedd\" 输出：false 解释：'e' 一定需要被键入两次，但在 typed 的输出中不是这样。 示例 3： 输入：name = \"leelee\", typed = \"lleeelee\" 输出：true 示例 4： 输入：name = \"laiden\", typed = \"laiden\" 输出：true 解释：长按名字中的字符并不是必要的。 提示： name.length 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n) O(1) 02 遍历统计比较 O(n) O(1) func isLongPressedName(name string, typed string) bool { i := 0 j := 0 for j 929.独特的电子邮件地址(2) 题目 每封电子邮件都由一个本地名称和一个域名组成，以 @ 符号分隔。 例如，在 alice@leetcode.com中， alice 是本地名称，而 leetcode.com 是域名。 除了小写字母，这些电子邮件还可能包含 '.' 或 '+'。 如果在电子邮件地址的本地名称部分中的某些字符之间添加句点（'.'）， 则发往那里的邮件将会转发到本地名称中没有点的同一地址。 例如，\"alice.z@leetcode.com” 和 “alicez@leetcode.com” 会转发到同一电子邮件地址。 （请注意，此规则不适用于域名。） 如果在本地名称中添加加号（'+'），则会忽略第一个加号后面的所有内容。 这允许过滤某些电子邮件，例如 m.y+name@email.com 将转发到 my@email.com。 （同样，此规则不适用于域名。） 可以同时使用这两个规则。 给定电子邮件列表 emails，我们会向列表中的每个地址发送一封电子邮件。实际收到邮件的不同地址有多少？ 示例： 输入：[\"test.email+alex@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\", \"testemail+david@lee.tcode.com\"] 输出：2 解释：实际收到邮件的是 \"testemail@leetcode.com\" 和 \"testemail@lee.tcode.com\"。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助+内置函数 O(n^2) O(n) 02 哈希辅助 O(n^2) O(n) func numUniqueEmails(emails []string) int { m := make(map[string]bool) for i := 0; i 933.最近的请求次数(2) 题目 写一个 RecentCounter 类来计算最近的请求。 它只有一个方法：ping(int t)，其中 t 代表以毫秒为单位的某个时间。 返回从 3000 毫秒前到现在的 ping 数。 任何处于 [t - 3000, t] 时间范围之内的 ping 都将会被计算在内，包括当前（指 t 时刻）的 ping。 保证每次对 ping 的调用都使用比之前更大的 t 值。 示例： 输入：inputs = [\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\"], inputs = [[],[1],[100],[3001],[3002]] 输出：[null,1,2,3,3] 提示： 每个测试用例最多调用 10000 次 ping。 每个测试用例会使用严格递增的 t 值来调用 ping。 每次调用 ping 都有 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组操作 O(n) O(1) 02 数组操作 O(n) O(1) type RecentCounter struct { arr []int } func Constructor() RecentCounter { return RecentCounter{ arr: make([]int, 0), } } func (r *RecentCounter) Ping(t int) int { r.arr = append(r.arr, t) res := 1 for i := len(r.arr) - 2; i >= 0; i-- { if t-r.arr[i] 0 && r.arr[0] 937.重新排列日志文件(2) 题目 你有一个日志数组 logs。每条日志都是以空格分隔的字串。 对于每条日志，其第一个字为字母与数字混合的 标识符。 除标识符之外，所有字均由小写字母组成的，称为 字母日志 除标识符之外，所有字均由数字组成的，称为 数字日志 题目所用数据保证每个日志在其标识符后面至少有一个字。 请按下述规则将日志重新排序： 所有 字母日志 都排在 数字日志 之前。 字母日志 在内容不同时，忽略标识符后，按内容字母顺序排序；在内容相同时，按标识符排序； 数字日志 应该按原来的顺序排列。 返回日志的最终顺序。 示例 ： 输入：[\"a1 9 2 3 1\",\"g1 act car\",\"zo4 4 7\",\"ab1 off key dog\",\"a8 act zoo\"] 输出：[\"g1 act car\",\"a8 act zoo\",\"ab1 off key dog\",\"a1 9 2 3 1\",\"zo4 4 7\"] 提示： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 先分类后排序 O(nlog(n)) O(n) 02 先分类后自定义排序 O(nlog(n)) O(n) func reorderLogFiles(logs []string) []string { numLogs := make([]string, 0) wordLogs := make([]string, 0) for key := range logs { for i := 0; i 938.二叉搜索树的范围和(2) 题目 给定二叉搜索树的根结点 root，返回 L 和 R（含）之间的所有结点的值的和。 二叉搜索树保证具有唯一的值。 示例 1：输入：root = [10,5,15,3,7,null,18], L = 7, R = 15 输出：32 示例 2：输入：root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10 输出：23 提示： 树中的结点数量最多为 10000 个。 最终的答案保证小于 2^31。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 迭代 O(n) O(n) func rangeSumBST(root *TreeNode, L int, R int) int { if root == nil { return 0 } if root.Val R { return rangeSumBST(root.Left, L, R) } return root.Val + rangeSumBST(root.Right, L, R) + rangeSumBST(root.Left, L, R) } # func rangeSumBST(root *TreeNode, L int, R int) int { if root == nil { return 0 } stack := make([]*TreeNode, 0) if root.Val > R && root.Left != nil { stack = append(stack, root.Left) } else if root.Val 0 { node := stack[len(stack)-1] stack = stack[:len(stack)-1] if node.Val = L { if node.Left != nil { stack = append(stack, node.Left) } if node.Right != nil { stack = append(stack, node.Right) } res = res + node.Val } else if node.Val > R && node.Left != nil { stack = append(stack, node.Left) } else if node.Val 941.有效的山脉数组(2) 题目 定一个整数数组 A，如果它是有效的山脉数组就返回 true，否则返回 false。 让我们回顾一下，如果 A 满足下述条件，那么它是一个山脉数组： A.length >= 3 在 0 A[i+1] > ... > A[A.length - 1] 示例 1：输入：[2,1] 输出：false 示例 2：输入：[3,5,5] 输出：false 示例 3：输入：[0,3,2,1] 输出：true 提示： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 遍历-双指针 O(n) O(1) func validMountainArray(A []int) bool { if len(A) = len(A) || i == 1 { return false } for ; i A[i] { pre = A[i] } else if pre == A[i] { return false } else { return false } } return true } # func validMountainArray(A []int) bool { if len(A) 942.增减字符串匹配(1) 题目 给定只含 \"I\"（增大）或 \"D\"（减小）的字符串 S ，令 N = S.length。 返回 [0, 1, ..., N] 的任意排列 A 使得对于所有 i = 0, ..., N-1，都有： 如果 S[i] == \"I\"，那么 A[i] A[i+1] 示例 1：输出：\"IDID\" 输出：[0,4,1,3,2] 示例 2：输出：\"III\" 输出：[0,1,2,3] 示例 3：输出：\"DDI\" 输出：[3,2,0,1] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历-双指针 O(n) O(n) func diStringMatch(S string) []int { res := make([]int, len(S)+1) left := 0 right := len(S) for i := 0; i 944.删列造序(1) 题目 给定由 N 个小写字母字符串组成的数组 A，其中每个字符串长度相等。 你需要选出一组要删掉的列 D，对 A 执行删除操作，使 A 中剩余的每一列都是 非降序 排列的， 然后请你返回 D.length 的最小可能值。 删除 操作的定义是：选出一组要删掉的列，删去 A 中对应列中的所有字符， 形式上，第 n 列为 [A[0][n], A[1][n], ..., A[A.length-1][n]]）。（可以参见 删除操作范例） 示例 1：输入：[\"cba\", \"daf\", \"ghi\"] 输出：1 解释： 当选择 D = {1}，删除后 A 的列为：[\"c\",\"d\",\"g\"] 和 [\"a\",\"f\",\"i\"]，均为非降序排列。 若选择 D = {}，那么 A 的列 [\"b\",\"a\",\"h\"] 就不是非降序排列了。 示例 2：输入：[\"a\", \"b\"] 输出：0 解释：D = {} 示例 3：输入：[\"zyx\", \"wvu\", \"tsr\"] 输出：3 解释：D = {0, 1, 2} 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n^2) O(1) func minDeletionSize(A []string) int { res := 0 if len(A) == 1 { return res } for i := 0; i 949.给定数字能组成的最大时间(2) 题目 给定一个由 4 位数字组成的数组，返回可以设置的符合 24 小时制的最大时间。 最小的 24 小时制时间是 00:00，而最大的是 23:59。从 00:00 （午夜）开始算起，过得越久，时间越大。 以长度为 5 的字符串返回答案。如果不能确定有效时间，则返回空字符串。 示例 1：输入：[1,2,3,4] 输出：\"23:41\" 示例 2：输入：[5,5,5,5] 输出：\"\" 提示： A.length == 4 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法 O(1) O(1) 02 全排列 O(1) O(1) func largestTimeFromDigits(A []int) string { res := \"\" for i := 0; i res && res != \"\" { res = ans } else if res == \"\" { res = ans } } } } } } } return res } # var arr []string func largestTimeFromDigits(A []int) string { res := \"\" arr = make([]string, 0) dfs(A, 0, len(A)-1) for i := range arr { if (arr[i] > res && res != \"\") || (res == \"\") { res = arr[i] } } return res } func dfs(A []int, start, length int) { if start == length { hour := A[0]*10 + A[1] minute := A[2]*10 + A[3] if hour 953.验证外星语词典(2) 题目 某种外星语也使用英文小写字母，但可能顺序 order 不同。字母表的顺序（order）是一些小写字母的排列。 给定一组用外星语书写的单词 words，以及其字母表的顺序 order，只有当给定的单词在这种外星语中按字典序排列时， 返回 true；否则，返回 false。 示例 1： 输入：words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\" 输出：true 解释：在该语言的字母表中，'h' 位于 'l' 之前，所以单词序列是按字典序排列的。 示例 2： 输入：words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\" 输出：false 解释：在该语言的字母表中，'d' 位于 'l' 之后，那么 words[0] > words[1]，因此单词序列不是按字典序排列的。 示例 3： 输入：words = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\" 输出：false 解释：当前三个字符 \"app\" 匹配时，第二个字符串相对短一些，然后根据词典编纂规则 \"apple\" > \"app\"，因为 'l' > '∅'，其中 '∅' 是空白字符，定义为比任何其他字符都小（更多信息）。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助-替换 O(n) O(n) 02 遍历比较 O(n) O(1) func isAlienSorted(words []string, order string) bool { newWords := make([]string, len(words)) m := make(map[byte]int) for i := 0; i newWords[i+1] { return false } } return true } # func isAlienSorted(words []string, order string) bool { m := make(map[byte]int) for i := 0; i m[words[i+1][j]] { return false } if j == length-1 { if len(words[i]) > len(words[i+1]) { return false } } } } return true } 961.重复 N 次的元素(5) 题目 在大小为 2N 的数组 A 中有 N+1 个不同的元素，其中有一个元素重复了 N 次。 返回重复了 N 次的那个元素。 示例 1：输入：[1,2,3,3] 输出：3 示例 2：输入：[2,1,2,5,3,2] 输出：2 示例 3：输入：[5,1,5,2,5,3,5,4] 输出：5 提示： 4 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(n) 02 排序 O(nlog(n)) O(1) 03 哈希统计 O(n) O(n) 04 遍历 O(n) O(1) 05 暴力法 O(n^2) O(1) func repeatedNTimes(A []int) int { m := make(map[int]int) for i := 0; i 965.单值二叉树(4) 题目 如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。 只有给定的树是单值二叉树时，才返回 true；否则返回 false。 示例 1：输入：[1,1,1,1,1,null,1] 输出：true 示例 2：输入：[2,2,2,5,2] 输出：false 提示： 给定树的节点数范围是 [1, 100]。 每个节点的值都是整数，范围为 [0, 99] 。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归-数组辅助 O(n) O(n) 02 递归 O(n) O(log(n)) 03 递归 O(n) O(log(n)) 04 迭代 O(n) O(n) var arr []int func isUnivalTree(root *TreeNode) bool { if root == nil { return true } arr = make([]int, 0) dfs(root) for i := 1; i 0 { node := queue[len(queue)-1] queue = queue[:len(queue)-1] if node.Val != value { return false } if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } return true } 970.强整数(2) 题目 给定两个正整数 x 和 y，如果某一整数等于 x^i + y^j，其中整数 i >= 0 且 j >= 0， 那么我们认为该整数是一个强整数。 返回值小于或等于 bound 的所有强整数组成的列表。 你可以按任何顺序返回答案。在你的回答中，每个值最多出现一次。 示例 1：输入：x = 2, y = 3, bound = 10 输出：[2,3,4,5,7,9,10] 解释： 2 = 2^0 + 3^0 3 = 2^1 + 3^0 4 = 2^0 + 3^1 5 = 2^1 + 3^1 7 = 2^2 + 3^1 9 = 2^3 + 3^0 10 = 2^0 + 3^2 示例 2：输入：x = 3, y = 5, bound = 15 输出：[2,4,6,8,10,14] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(log(n)) O(log(n)^2) 02 遍历 O(log(n)) O(log(n)^2) func powerfulIntegers(x int, y int, bound int) []int { res := make([]int, 0) m := make(map[int]int) if bound 976.三角形的最大周长(2) 题目 给定由一些正数（代表长度）组成的数组 A，返回由其中三个长度组成的、面积不为零的三角形的最大周长。 如果不能形成任何面积不为零的三角形，返回 0。 示例 1：输入：[2,1,2] 输出：5 示例 2：输入：[1,2,1] 输出：0 示例 3：输入：[3,2,3,4] 输出：10 示例 4：输入：[3,6,2,3] 输出：8 提示： 3 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序 O(nlog(n)) O(1) 02 冒泡排序 O(n^2) O(1) func largestPerimeter(A []int) int { sort.Ints(A) for i := len(A) - 3; i >= 0; i-- { if A[i]+A[i+1] > A[i+2] { return A[i] + A[i+1] + A[i+2] } } return 0 } # func largestPerimeter(A []int) int { if len(A) A[j+1] { A[j], A[j+1] = A[j+1], A[j] } } if i >= 2 { index := len(A) - 1 - i if A[index]+A[index+1] > A[index+2] { return A[index] + A[index+1] + A[index+2] } } } if A[0]+A[1] > A[2] { return A[0] + A[1] + A[2] } return 0 } 977.有序数组的平方(3) 题目 给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。 示例 1：输入：[-4,-1,0,3,10] 输出：[0,1,9,16,100] 示例 2：输入：[-7,-3,2,3,11] 输出：[4,9,9,49,121] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n) O(n) 02 排序 O(nlog(n)) O(n) 03 直接插入排序 O(n^2) O(n) func sortedSquares(A []int) []int { res := make([]int, len(A)) i := 0 j := len(A) - 1 index := len(A) - 1 for i = 0; j-- { if value 985.查询后的偶数和(1) 题目 给出一个整数数组 A 和一个查询数组 queries。 对于第 i 次查询，有 val = queries[i][0], index = queries[i][1]， 我们会把 val 加到 A[index] 上。然后，第 i 次查询的答案是 A 中偶数值的和。 （此处给定的 index = queries[i][1] 是从 0 开始的索引，每次查询都会永久修改数组 A。） 返回所有查询的答案。你的答案应当以数组 answer 给出，answer[i] 为第 i 次查询的答案。 示例：输入：A = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]] 输出：[8,6,2,4] 解释：开始时，数组为 [1,2,3,4]。 将 1 加到 A[0] 上之后，数组为 [2,2,3,4]，偶数值之和为 2 + 2 + 4 = 8。 将 -3 加到 A[1] 上之后，数组为 [2,-1,3,4]，偶数值之和为 2 + 4 = 6。 将 -4 加到 A[0] 上之后，数组为 [-2,-1,3,4]，偶数值之和为 -2 + 4 = 2。 将 2 加到 A[3] 上之后，数组为 [-2,-1,3,6]，偶数值之和为 -2 + 6 = 4。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历模拟 O(n) O(n) func sumEvenAfterQueries(A []int, queries [][]int) []int { res := make([]int, 0) sum := 0 for _, value := range A { if value%2 == 0 { sum = sum + value } } for i := 0; i 989.数组形式的整数加法(4) 题目 对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。 例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。 给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。 示例 1：输入：A = [1,2,0,0], K = 34 输出：[1,2,3,4] 解释：1200 + 34 = 1234 示例 2： 输入：A = [2,7,4], K = 181 输出：[4,5,5] 解释：274 + 181 = 455 示例 3： 输入：A = [2,1,5], K = 806 输出：[1,0,2,1] 解释：215 + 806 = 1021 示例 4： 输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1 输出：[1,0,0,0,0,0,0,0,0,0,0] 解释：9999999999 + 1 = 10000000000 提示： 1 1，那么 A[0] != 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组辅助 O(n) O(n) 02 遍历 O(n) O(1) 03 遍历 O(n) O(n) 04 遍历 O(n) O(n) func addToArrayForm(A []int, K int) []int { B := make([]int, 0) for K > 0 { B = append([]int{K % 10}, B...) K = K / 10 } length := len(A) if len(B) > len(A) { length = len(B) } res := make([]int, length) flag := 0 i := len(A) - 1 j := len(B) - 1 count := 0 for i >= 0 && j >= 0 { sum := A[i] + B[j] + flag if sum >= 10 { sum = sum - 10 flag = 1 } else { flag = 0 } res[length-1-count] = sum i-- j-- count++ } for i >= 0 { sum := A[i] + flag if sum >= 10 { sum = sum - 10 flag = 1 } else { flag = 0 } res[length-1-count] = sum i-- count++ } for j >= 0 { sum := B[j] + flag if sum >= 10 { sum = sum - 10 flag = 1 } else { flag = 0 } res[length-1-count] = sum j-- count++ } if flag == 1 { return append([]int{1}, res...) } return res } # func addToArrayForm(A []int, K int) []int { A[len(A)-1] = A[len(A)-1] + K carry := 0 for i := len(A) - 1; i >= 0; i-- { carry = A[i] / 10 A[i] = A[i] % 10 if i > 0 { A[i-1] = A[i-1] + carry } } for carry > 0 { A = append([]int{carry % 10}, A...) carry = carry / 10 } return A } # func addToArrayForm(A []int, K int) []int { i := len(A) - 1 res := make([]int, 0) for i >= 0 || K > 0 { if i >= 0 { K = K + A[i] } res = append(res, K%10) K = K / 10 i-- } for i := 0; i = 0 || K > 0 { if i >= 0 { K = K + A[i] } res = append([]int{K % 10}, res...) K = K / 10 i-- } return res } 993.二叉树的堂兄弟节点(2) 题目 在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。 如果二叉树的两个节点深度相同，但父节点不同，则它们是一对堂兄弟节点。 我们给出了具有唯一值的二叉树的根节点 root，以及树中两个不同节点的值 x 和 y。 只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true。否则，返回 false。 示例 1：输入：root = [1,2,3,4], x = 4, y = 3 输出：false 示例 2：输入：root = [1,2,3,null,4,null,5], x = 5, y = 4 输出：true 示例 3：输入：root = [1,2,3,null,4], x = 2, y = 3 输出：false 提示： 二叉树的节点数介于 2 到 100 之间。 每个节点的值都是唯一的、范围为 1 到 100 的整数。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 迭代 O(n) O(n) 03 递归 O(n) O(n) func isCousins(root *TreeNode, x int, y int) bool { xNode, xDepth := dfs(root, x, 0) yNode, yDepth := dfs(root, y, 0) return xDepth == yDepth && xNode != yNode } func dfs(root *TreeNode, value int, level int) (*TreeNode, int) { if root == nil { return nil, -1 } if root.Val == value { return nil, 0 } if (root.Left != nil && root.Left.Val == value) || (root.Right != nil && root.Right.Val == value) { return root, level + 1 } leftNode, leftLevel := dfs(root.Left, value, level+1) if leftNode != nil { return leftNode, leftLevel } return dfs(root.Right, value, level+1) } # func isCousins(root *TreeNode, x int, y int) bool { if root == nil { return true } fatherM := make(map[int]int) levelM := make(map[int]int) queue := make([]*TreeNode, 0) queue = append(queue, root) level := 0 for len(queue) > 0 { length := len(queue) for i := 0; i 997.找到小镇的法官(2) 题目 在一个小镇里，按从 1 到 N 标记了 N 个人。传言称，这些人中有一个是小镇上的秘密法官。 如果小镇的法官真的存在，那么： 小镇的法官不相信任何人。 每个人（除了小镇法官外）都信任小镇的法官。 只有一个人同时满足属性 1 和属性 2 。 给定数组 trust，该数组由信任对 trust[i] = [a, b] 组成，表示标记为 a 的人信任标记为 b 的人。 如果小镇存在秘密法官并且可以确定他的身份，请返回该法官的标记。否则，返回 -1。 示例 1：输入：N = 2, trust = [[1,2]] 输出：2 示例 2：输入：N = 3, trust = [[1,3],[2,3]] 输出：3 示例 3：输入：N = 3, trust = [[1,3],[2,3],[3,1]] 输出：-1 示例 4：输入：N = 3, trust = [[1,2],[2,3]] 输出：-1 示例 5：输入：N = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]] 输出：3 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历-数组辅助 O(n) O(n) 02 遍历-双数组辅助 O(n) O(n) func findJudge(N int, trust [][]int) int { arr := make([]int, N+1) for i := range trust { arr[trust[i][0]] = -1 if arr[trust[i][1]] == -1 { continue } arr[trust[i][1]]++ } for i := 1; i 999.可以被一步捕获的棋子数(2) 题目 在一个 8 x 8 的棋盘上，有一个白色的车（Rook），用字符 'R' 表示。棋盘上还可能存在空方块， 白色的象（Bishop）以及黑色的卒（pawn），分别用字符 '.'，'B' 和 'p' 表示。 不难看出，大写字符表示的是白棋，小写字符表示的是黑棋。 车按国际象棋中的规则移动。东，西，南，北四个基本方向任选其一，然后一直向选定的方向移动， 直到满足下列四个条件之一： 棋手选择主动停下来。 棋子因到达棋盘的边缘而停下。 棋子移动到某一方格来捕获位于该方格上敌方（黑色）的卒，停在该方格内。 车不能进入/越过已经放有其他友方棋子（白色的象）的方格，停在友方棋子前。 你现在可以控制车移动一次，请你统计有多少敌方的卒处于你的捕获范围内（即，可以被一步捕获的棋子数）。 示例 1：输入： [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"], [\".\",\".\",\".\",\"R\",\".\",\".\",\".\",\"p\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"], [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"], [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]] 输出：3 解释：在本例中，车能够捕获所有的卒。 示例 2：输入： [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"p\",\"p\",\"p\",\"p\",\"p\",\".\",\".\"], [\".\",\"p\",\"p\",\"B\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"B\",\"R\",\"B\",\"p\",\".\",\".\"], [\".\",\"p\",\"p\",\"B\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"p\",\"p\",\"p\",\".\",\".\"], [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]] 输出：0 解释：象阻止了车捕获任何卒。 示例 3：输入： [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"], [\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\"p\",\"p\",\".\",\"R\",\".\",\"p\",\"B\",\".\"], [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"], [\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]] 输出：3 解释： 车可以捕获位置 b5，d6 和 f5 的卒。 提示： board.length == board[i].length == 8 board[i][j] 可以是 'R'，'.'，'B' 或 'p' 只有一个格子上存在 board[i][j] == 'R' 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(1) O(1) 02 遍历 O(1) O(1) func numRookCaptures(board [][]byte) int { res := 0 var x, y int for i := 0; i = 0 && board[x][i] != 'B'; i-- { if board[x][i] == 'p' { res++ break } } // 向下 for i := x; i = 0 && board[i][y] != 'B'; i-- { if board[i][y] == 'p' { res++ break } } return res } # func numRookCaptures(board [][]byte) int { res := 0 var x, y int var dx = []int{-1, 1, 0, 0} var dy = []int{0, 0, -1, 1} for i := 0; i = 0 && newX = 0 && newY 0901-1000-Medium 901.股票价格跨度(1) 题目 编写一个 StockSpanner 类，它收集某些股票的每日报价，并返回该股票当日价格的跨度。 今天股票价格的跨度被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。 例如，如果未来7天股票的价格是 [100, 80, 60, 70, 60, 75, 85]， 那么股票跨度将是 [1, 1, 1, 2, 1, 4, 6]。 示例： 输入：[\"StockSpanner\",\"next\",\"next\",\"next\",\"next\",\"next\",\"next\",\"next\"], [[],[100],[80],[60],[70],[60],[75],[85]] 输出：[null,1,1,1,2,1,4,6] 解释：首先，初始化 S = StockSpanner()，然后： S.next(100) 被调用并返回 1， S.next(80) 被调用并返回 1， S.next(60) 被调用并返回 1， S.next(70) 被调用并返回 2， S.next(60) 被调用并返回 1， S.next(75) 被调用并返回 4， S.next(85) 被调用并返回 6。 注意 (例如) S.next(75) 返回 4，因为截至今天的最后 4 个价格 (包括今天的价格 75) 小于或等于今天的价格。 提示： 调用 StockSpanner.next(int price) 时，将有 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 单调栈 O(n) O(n) type StockSpanner struct { prices []int count []int } func Constructor() StockSpanner { return StockSpanner{ prices: make([]int, 0), count: make([]int, 0), } } func (this *StockSpanner) Next(price int) int { res := 1 for len(this.prices) > 0 && this.prices[len(this.prices)-1] 912.排序数组(7) 题目 给你一个整数数组 nums，请你将该数组升序排列。 示例 1：输入：nums = [5,2,3,1] 输出：[1,2,3,5] 示例 2：输入：nums = [5,1,1,2,0,0] 输出：[0,0,1,1,2,5] 提示：1 解题思路 No. 思路 时间复杂度 空间复杂度 01 内置函数 O(nlog(n)) O(1) 02 插入排序 O(n^2) O(1) 03 希尔排序 O(n^1.3) O(1) 04 归并排序 O(nlog(n)) O(n) 05 快速排序 O(nlog(n)) O(log(n)) 06 堆排序-内置heap O(nlog(n)) O(n) 07 堆排序 O(nlog(n)) O(log(n)) func sortArray(nums []int) []int { sort.Ints(nums) return nums } # 2 func sortArray(nums []int) []int { for i := 1; i = 0 && nums[pos] > cur { nums[pos+1] = nums[pos] // 后移 pos-- } nums[pos+1] = cur } return nums } # 3 func sortArray(nums []int) []int { n := len(nums) for gap := n / 2; gap > 0; gap = gap / 2 { for i := gap; i = 0 && cur 0 && len(right) > 0 { if left[0] 0 { res = append(res, left...) } if len(right) > 0 { res = append(res, right...) } return res } # 5 func sortArray(nums []int) []int { quick(nums, 0, len(nums)-1) return nums } func quick(arr []int, left, right int) { if left >= right { return } index := partition(arr, left, right) quick(arr, left, index-1) quick(arr, index+1, right) } func partition(arr []int, left, right int) int { baseValue := arr[left] // 基准值 for left func (h IntHeap) Less(i, j int) bool { return h[i] 0; i-- { nums[0], nums[i] = nums[i], nums[0] heapModify(nums, 0, i-1) } return nums } func buildHeap(arr []int, length int) { for i := len(arr)/2 - 1; i >= 0; i-- { heapModify(arr, i, length-1) } } func heapModify(arr []int, start, end int) { temp := arr[start] for left := 2*start + 1; left 921.使括号有效的最少添加(3) 题目 给定一个由 '(' 和 ')' 括号组成的字符串 S，我们需要添加最少的括号（ '(' 或是 ')'，可以在任何位置）， 以使得到的括号字符串有效。 从形式上讲，只有满足下面几点之一，括号字符串才是有效的： 它是一个空字符串，或者 它可以被写成 AB （A 与 B 连接）, 其中 A 和 B 都是有效字符串，或者 它可以被写作 (A)，其中 A 是有效字符串。 给定一个括号字符串，返回为使结果字符串有效而必须添加的最少括号数。 示例 1：输入：\"())\" 输出：1 示例 2：输入：\"(((\" 输出：3 示例 3：输入：\"()\" 输出：0 示例 4：输入：\"()))((\" 输出：4 提示：S.length 解题思路 No. 思路 时间复杂度 空间复杂度 01 栈辅助 O(n) O(n) 02 遍历 O(n) O(1) 03 内置函数 O(n) O(1) func minAddToMakeValid(S string) int { stack := make([]byte,0) res := 0 for i := 0; i 0 { left-- } else { right++ } } } return left + right } # 3 func minAddToMakeValid(S string) int { for strings.Contains(S, \"()\") == true { S = strings.ReplaceAll(S, \"()\", \"\") } return len(S) } 945.使数组唯一的最小增量(3) 题目 给定整数数组 A，每次 move 操作将会选择任意 A[i]，并将其递增 1。 返回使 A 中的每个值都是唯一的最少操作次数。 示例 1:输入：[1,2,2] 输出：1 解释：经过一次 move 操作，数组将变为 [1, 2, 3]。 示例 2:输入：[3,2,1,2,1,7] 输出：6 解释：经过 6 次 move 操作，数组将变为 [3, 4, 1, 2, 5, 7]。 可以看出 5 次或 5 次以下的 move 操作是不能让数组的每个值唯一的。 提示： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序遍历 O(nlog(n)) O(1) 02 计数 O(n) O(n) 03 状态探测-递归 O(n) O(n) func minIncrementForUnique(A []int) int { res := 0 sort.Ints(A) for i := 0; i = A[i+1] { value := A[i] - A[i+1] + 1 res = res + value A[i+1] = A[i+1] + value } } return res } # 2 func minIncrementForUnique(A []int) int { res := 0 arr := make([]int, 80001) for i := 0; i = 2 { sum = sum + arr[i] - 1 res = res - i*(arr[i]-1) } else if arr[i] == 0 && sum > 0 { sum-- res = res + i } } return res } # 3 var arr []int func minIncrementForUnique(A []int) int { res := 0 arr = make([]int, 21) for i := 0; i 946.验证栈序列(2) 题目 给定 pushed 和 popped 两个序列，每个序列中的 值都不重复， 只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false 。 示例 1：输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1] 输出：true 解释：我们可以按以下顺序执行： push(1), push(2), push(3), push(4), pop() -> 4, push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1 示例 2：输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2] 输出：false 解释：1 不能在 2 之前弹出。 提示： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 栈辅助 O(n) O(n) 02 栈辅助 O(n) O(n) func validateStackSequences(pushed []int, popped []int) bool { stack := make([]int, 0) j := 0 for i := 0; i 0 && stack[len(stack)-1] == popped[j] { stack = stack[:len(stack)-1] j++ } } if len(stack) == 0 { return true } return false } # 2 func validateStackSequences(pushed []int, popped []int) bool { stack := make([]int, 0) res := false i := 0 j := 0 for j 974.和可被K整除的子数组(2) 题目 给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。 示例：输入：A = [4,5,0,-2,-3,1], K = 5 输出：7 解释： 有 7 个子数组满足其元素之和可被 K = 5 整除： [4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 前缀和-哈希辅助 O(n) O(n) 02 前缀和-哈希辅助 O(n) O(n) func subarraysDivByK(A []int, K int) int { m := make(map[int]int) m[0] = 1 sum := 0 res := 0 for i := 0; i 983.最低票价(3) 题目 在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。 在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。 火车票有三种不同的销售方式： 一张为期一天的通行证售价为 costs[0] 美元； 一张为期七天的通行证售价为 costs[1] 美元； 一张为期三十天的通行证售价为 costs[2] 美元。 通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证， 那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。 返回你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费。 示例 1：输入：days = [1,4,6,7,8,20], costs = [2,7,15] 输出：11 解释： 例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划： 在第 1 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 1 天生效。 在第 3 天，你花了 costs[1] = $7 买了一张为期 7 天的通行证，它将在第 3, 4, ..., 9 天生效。 在第 20 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 20 天生效。 你总共花了 $11，并完成了你计划的每一天旅行。 示例 2：输入：days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15] 输出：17 解释： 例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划： 在第 1 天，你花了 costs[2] = $15 买了一张为期 30 天的通行证，它将在第 1, 2, ..., 30 天生效。 在第 31 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 31 天生效。 你总共花了 $17，并完成了你计划的每一天旅行。 提示：1 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划-递归 O(n) O(n) 02 动态规划 O(n) O(n) 03 动态规划 O(n) O(n) var dp [366]int var m map[int]bool func mincostTickets(days []int, costs []int) int { dp = [366]int{} m = make(map[int]bool) for i := 0; i 365 { return 0 } if dp[day] > 0 { return dp[day] } if m[day] == true { dp[day] = min(min(dfs(day+1, costs)+costs[0], dfs(day+7, costs)+costs[1]), dfs(day+30, costs)+costs[2]) } else { dp[day] = dfs(day+1, costs) } return dp[day] } func min(a, b int) int { if a > b { return b } return a } # 2 var dp [366]int var duration = []int{1, 7, 30} func mincostTickets(days []int, costs []int) int { dp = [366]int{} return dfs(0, costs, days) } func dfs(day int, costs []int, days []int) int { if day >= len(days) { return 0 } if dp[day] > 0 { return dp[day] } dp[day] = math.MaxInt32 j := day for i := 0; i b { return b } return a } # 3 func mincostTickets(days []int, costs []int) int { n := days[len(days)-1] + 1 dp := make([]int, n) for i := 0; i 0 { dp[i] = min(dp[i-1]+costs[0], min(dp[max(i-7, 0)]+costs[1], dp[max(i-30, 0)]+costs[2])) } else { dp[i] = dp[i-1] } } return dp[n-1] } func max(a, b int) int { if a > b { return a } return b } func min(a, b int) int { if a > b { return b } return a } 994.腐烂的橘子(2) 题目 在给定的网格中，每个单元格可以有以下三个值之一： 值 0 代表空单元格； 值 1 代表新鲜橘子； 值 2 代表腐烂的橘子。 每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。 返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。 示例 1：输入：[[2,1,1],[1,1,0],[0,1,1]] 输出：4 示例 2：输入：[[2,1,1],[0,1,1],[1,0,1]] 输出：-1 解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。 示例 3：输入：[[0,2]] 输出：0 解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 广度优先搜索 O(n^2) O(n^2) 02 广度优先搜索 O(n^2) O(n^2) // 上、右、下、左 var dx = []int{0, 1, 0, -1} var dy = []int{1, 0, -1, 0} func orangesRotting(grid [][]int) int { queue := make([][]int, 0) count := 0 times := 0 for i := 0; i 0 && count > 0 { times++ length := len(queue) for i := 0; i = 0 && x = 0 && y 0 { return -1 } return times } # 2 // 上、右、下、左 var dx = []int{0, 1, 0, -1} var dy = []int{1, 0, -1, 0} func orangesRotting(grid [][]int) int { queue := make([][]int, 0) count := 0 times := 0 for i := 0; i 0 { times++ length := len(queue) for i := 0; i = 0 && x = 0 && y 0 { return -1 } return times } 0901-1000-Hard 956.最高的广告牌(5) 题目 你正在安装一个广告牌，并希望它高度最大。这块广告牌将有两个钢制支架，两边各一个。每个钢支架的高度必须相等。 你有一堆可以焊接在一起的钢筋 rods。 举个例子，如果钢筋的长度为 1、2 和 3，则可以将它们焊接在一起形成长度为 6 的支架。 返回广告牌的最大可能安装高度。如果没法安装广告牌，请返回 0。 示例 1：输入：[1,2,3,6] 输出：6 解释：我们有两个不相交的子集 {1,2,3} 和 {6}，它们具有相同的和 sum = 6。 示例 2：输入：[1,2,3,4,5,6] 输出：10 解释：我们有两个不相交的子集 {2,3,5} 和 {4,6}，它们具有相同的和 sum = 10。 示例 3：输入：[1,2] 输出：0 解释：没法安装广告牌，所以返回 0。 提示：0 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划-递归 O(3^n) O(n^2) 02 动态规划 O(3^n) O(n) 03 动态规划 O(3^n) O(n) 04 动态规划 O(3^n) O(n^2) 05 折半搜索 O(3^(n/2)) O(3^(n/2)) const MinValue = math.MinInt32 / 100 // 官方题解(从后往前比较难理解) // dp[i][s] 表示当我们可以使用 rods[j] (j >= i) 时能得到的最大 score // dp[i][s] = max(dp[i+1][s], dp[i+1][s-rods[i]], rods[i] + dp[i+1][s+rods[i]]) // 例如:rods=[1,2,3,6],可以有dp[1][1]=5, // 在写下1之后,可以写下+2,+3,-6使得剩下的rods[i:]获得score为5 var dp [][]int func tallestBillboard(rods []int) int { dp = make([][]int, len(rods)) for i := 0; i b { return a } return b } # 2 func tallestBillboard(rods []int) int { dp := make(map[int]int) // 保存和为i中正整数的和 dp[0] = 0 // 每个rods[i]有3个选择，+rods[i]、-rods[i]、0 for i := 0; i 0，是正整数，需要加上 temp[k] = max(temp[k], v) temp[k-value] = max(temp[k-value], v) // -value b { return a } return b } # 3 func tallestBillboard(rods []int) int { dp := make(map[int]int) // 保存高度差为i时最低一边的高度 dp[0] = 0 // 每个rods[i]有3个选择，+rods[i]、-rods[i]、0 for i := 0; i = 0 { return a } return -a } func min(a, b int) int { if a > b { return b } return a } func max(a, b int) int { if a > b { return a } return b } # 4 // dp[i][s] 表示当我们可以使用 rods[j] (j >= i) 时能得到的最大 score // dp[i][s] = max(dp[i+1][s], dp[i+1][s-rods[i]], rods[i] + dp[i+1][s+rods[i]]) // 例如:rods=[1,2,3,6],可以有dp[1][1]=5, // 在写下1之后,可以写下+2,+3,-6使得剩下的rods[i:]获得score为5 const MinValue = math.MinInt32 / 100 func tallestBillboard(rods []int) int { dp := make([][]int, len(rods)+1) for i := 0; i = 0; i-- { for s := rods[i]; s b { return a } return b } # 5 func tallestBillboard(rods []int) int { leftM := makeM(rods, 0, len(rods)/2) rightM := makeM(rods, len(rods)/2, len(rods)) res := 0 for k := range leftM { if rightM[k] > 0 { res = max(res, leftM[k]+rightM[-k]) } } return res } func makeM(rods []int, left, right int) map[int]int { dp := make([][2]int, 100001) dp[0] = [2]int{0, 0} count := 1 for i := left; i b { return a } return b } Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 10:43:32 "},"docs/source/question/1001-1100.html":{"url":"docs/source/question/1001-1100.html","title":"1001-1100","keywords":"","body":"1001-1100-Easy 1001-1100-Easy 1002.查找常用字符(2) 1005.K次取反后最大化的数组和(4) 1009.十进制整数的反码(3) 1010.总持续时间可被60整除的歌曲(2) 1013.将数组分成和相等的三个部分(2) 1018.可被5整除的二进制前缀(1) 1021.删除最外层的括号(3) 1022.从根到叶的二进制数之和(2) 1025.除数博弈(2) 1029.两地调度(2) 1030.距离顺序排列矩阵单元格(3) 1033.移动石子直到连续(2) 1037.有效的回旋镖(3) 1042.不邻接植花(1) 1046.最后一块石头的重量(2) 1047.删除字符串中的所有相邻重复项(2) 1051.高度检查器(2) 1071.字符串的最大公因子(2) 1078.Bigram 分词(1) 1089.复写零(3) 1001-1100-Medium 1014.最佳观光组合(1) 1035.不相交的线(3) 1081.不同字符的最小子序列(2) 1002.查找常用字符(2) 题目 给定仅有小写字母组成的字符串数组 A，返回列表中的每个字符串中都显示的全部字符（包括重复字符）组成的列表。 例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。 你可以按任意顺序返回答案。 示例 1：输入：[\"bella\",\"label\",\"roller\"] 输出：[\"e\",\"l\",\"l\"] 示例 2：输入：[\"cool\",\"lock\",\"cook\"] 输出：[\"c\",\"o\"] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历-数组辅助 O(n) O(n) 02 遍历-数组辅助 O(n) O(n) func commonChars(A []string) []string { arr := [26]int{} for _, v := range A[0] { arr[v-'a']++ } for i := 1; i 0 { for j := 0; j b { return b } return a } # func commonChars(A []string) []string { arr := make([][26]int, len(A)) for i := 0; i 0 { res = append(res, string(j+'a')) minValue-- } } return res } func min(a, b int) int { if a > b { return b } return a } 1005.K次取反后最大化的数组和(4) 题目 给定一个整数数组 A，我们只能用以下方法修改该数组： 我们选择某个个索引 i 并将 A[i] 替换为 -A[i]，然后总共重复这个过程 K 次。 （我们可以多次选择同一个索引 i。） 以这种方式修改数组后，返回数组可能的最大和。 示例 1：输入：A = [4,2,3], K = 1 输出：5 解释：选择索引 (1,) ，然后 A 变为 [4,-2,3]。 示例 2：输入：A = [3,-1,0,2], K = 3 输出：6 解释：选择索引 (1, 2, 2) ，然后 A 变为 [3,1,0,2]。 示例 3：输入：A = [2,-3,-1,5,-4], K = 2 输出：13 解释：选择索引 (1, 4) ，然后 A 变为 [2,3,-1,5,4]。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序+贪心 O(nlog(n)) O(1) 02 排序+贪心 O(nlog(n)) O(1) 03 数组辅助 O(n) O(1) 04 遍历-找最小 O(n^2) O(1) func largestSumAfterKNegations(A []int, K int) int { sort.Ints(A) i := 0 for i 0 { if A[i] 0 { A[i] = -A[i] if A[i] > 0 && A[i] > A[i+1] { i++ } K-- } return sum(A) } func sum(A []int) int { res := 0 for i := 0; i 0 { for arr[i] == 0 { i++ } if i > 100 { break } arr[i]-- arr[200-i]++ K-- } if K%2 == 1 && i != 100 { for j := i; j 0 { arr[j]-- arr[200-j]++ break } } } res := 0 for i := 0; i 0 { minIndex, minValue := findMin(A) if minValue > 0 { break } A[minIndex] = -A[minIndex] K-- } if K%2 == 1 { minIndex, _ := findMin(A) A[minIndex] = -A[minIndex] } res := 0 for i := 0; i A[i] { res = A[i] index = i } } return index, res } 1009.十进制整数的反码(3) 题目 每个非负整数 N 都有其二进制表示。例如， 5 可以被表示为二进制 \"101\"，11 可以用二进制 \"1011\" 表示， 依此类推。注意，除 N = 0 外，任何二进制表示中都不含前导零。 二进制的反码表示是将每个 1 改为 0 且每个 0 变为 1。例如，二进制数 \"101\" 的二进制反码为 \"010\"。 给你一个十进制数 N，请你返回其二进制表示的反码所对应的十进制整数。 示例 1：输入：5 输出：2 解释：5 的二进制表示为 \"101\"，其二进制反码为 \"010\"，也就是十进制中的 2 。 示例 2：输入：7 输出：0 解释：7 的二进制表示为 \"111\"，其二进制反码为 \"000\"，也就是十进制中的 0 。 示例 3：输入：10 输出：5 解释：10 的二进制表示为 \"1010\"，其二进制反码为 \"0101\"，也就是十进制中的 5 。 提示： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 位运算 O(log(n)) O(1) 02 位运算 O(log(n)) O(1) 03 遍历 O(log(n)) O(1) /* 101+010=1000=111+1 */ func bitwiseComplement(N int) int { temp := 2 for N >= temp { temp = temp 1 { temp = temp >> 1 res = res 0 { if N%2 == 0 { res = res + exp } exp = exp * 2 N = N / 2 } return res } 1010.总持续时间可被60整除的歌曲(2) 题目 在歌曲列表中，第 i 首歌曲的持续时间为 time[i] 秒。 返回其总持续时间（以秒为单位）可被 60 整除的歌曲对的数量。 形式上，我们希望索引的数字 i 和 j 满足 i 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(1) 02 数组辅助 O(n) O(1) func numPairsDivisibleBy60(time []int) int { m := make(map[int]int) for i := 0; i 0 { res = res + v*value m[key] = 0 m[60-key] = 0 } } } return res } # func numPairsDivisibleBy60(time []int) int { res := 0 arr := make([]int,60) for i := range time{ if time[i] % 60 == 0{ res = res + arr[0] }else { res = res + arr[60-time[i]%60] } arr[time[i]%60]++ } return res } 1013.将数组分成和相等的三个部分(2) 题目 给你一个整数数组 A，只有可以将其划分为三个和相等的非空部分时才返回 true，否则返回 false。 形式上，如果可以找出索引 i+1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 双指针 O(n) O(1) func canThreePartsEqualSum(A []int) bool { length := len(A) if length = 3 { return true } return false } # func canThreePartsEqualSum(A []int) bool { length := len(A) if length 1018.可被5整除的二进制前缀(1) 题目 给定由若干 0 和 1 组成的数组 A。我们定义 N_i： 从 A[0] 到 A[i] 的第 i 个子数组被解释为一个二进制数（从最高有效位到最低有效位）。 返回布尔值列表 answer，只有当 N_i 可以被 5 整除时，答案 answer[i] 为 true，否则为 false。 示例 1：输入：[0,1,1] 输出：[true,false,false] 解释： 输入数字为 0, 01, 011；也就是十进制中的 0, 1, 3 。只有第一个数可以被 5 整除，因此 answer[0] 为真。 示例 2：输入：[1,1,1] 输出：[false,false,false] 示例 3：输入：[0,1,1,1,1,1] 输出：[true,false,false,false,true,false] 示例 4：输入：[1,1,1,0,1] 输出：[false,false,false,false,false] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历-求余 O(n) O(n) func prefixesDivBy5(A []int) []bool { res := make([]bool, len(A)) temp := 0 for i := 0; i 1021.删除最外层的括号(3) 题目 有效括号字符串为空 (\"\")、\"(\" + A + \")\" 或 A + B，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。 例如，\"\"，\"()\"，\"(())()\" 和 \"(()(()))\" 都是有效的括号字符串。 如果有效字符串 S 非空，且不存在将其拆分为 S = A+B 的方法，我们称其为原语（primitive）， 其中 A 和 B 都是非空有效括号字符串。 给出一个非空有效字符串 S，考虑将其进行原语化分解， 使得：S = P_1 + P_2 + ... + P_k，其中 P_i 是有效括号字符串原语。 对 S 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 S 。 示例 1：输入：\"(()())(())\" 输出：\"()()()\" 解释： 输入字符串为 \"(()())(())\"，原语化分解得到 \"(()())\" + \"(())\"， 删除每个部分中的最外层括号后得到 \"()()\" + \"()\" = \"()()()\"。 示例 2：输入：\"(()())(())(()(()))\" 输出：\"()()()()(())\" 解释： 输入字符串为 \"(()())(())(()(()))\"，原语化分解得到 \"(()())\" + \"(())\" + \"(()(()))\"， 删除每个部分中的最外层括号后得到 \"()()\" + \"()\" + \"()(())\" = \"()()()()(())\"。 示例 3：输入：\"()()\" 输出：\"\" 解释： 输入字符串为 \"()()\"，原语化分解得到 \"()\" + \"()\"， 删除每个部分中的最外层括号后得到 \"\" + \"\" = \"\"。 提示： S.length 解题思路 No. 思路 时间复杂度 空间复杂度 01 栈 O(n) O(n) 02 遍历 O(n) O(1) 03 栈 O(n) O(n) func removeOuterParentheses(S string) string { if len(S) == 0 { return \"\" } res := \"\" stack := make([]byte, 0) stack = append(stack, S[0]) last := 0 for i := 1; i 0 && S[i] == ')' && stack[len(stack)-1] == '(' { stack = stack[:len(stack)-1] if len(stack) == 0 { res = res + S[last+1:i] last = i + 1 } } else { stack = append(stack, S[i]) } } return res } # func removeOuterParentheses(S string) string { res := \"\" count := 0 last := 0 for i := 0; i 0 { res = res + string(S[i]) } if S[i] == '(' { stack = append(stack, S[i]) } } return res } 1022.从根到叶的二进制数之和(2) 题目 给出一棵二叉树，其上每个结点的值都是 0 或 1 。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。 例如，如果路径为 0 -> 1 -> 1 -> 0 -> 1，那么它表示二进制数 01101，也就是 13 。 对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。 以 10^9 + 7 为模，返回这些数字之和。 示例：输入：[1,0,1,0,1,0,1] 输出：22 解释：(100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22 提示： 树中的结点数介于 1 和 1000 之间。 node.val 为 0 或 1 。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 迭代 O(n) O(n) var res int func sumRootToLeaf(root *TreeNode) int { res = 0 dfs(root, 0) return res } func dfs(root *TreeNode, sum int) { if root == nil { return } sum = sum*2 + root.Val if root.Left == nil && root.Right == nil { res = (res + sum) % 1000000007 } dfs(root.Left, sum) dfs(root.Right, sum) } # type Node struct { node *TreeNode sum int } func sumRootToLeaf(root *TreeNode) int { res := 0 stack := make([]Node, 0) stack = append(stack, Node{ node: root, sum: 0, }) for len(stack) > 0 { node, sum := stack[len(stack)-1].node, stack[len(stack)-1].sum stack = stack[:len(stack)-1] sum = sum*2 + node.Val if node.Left == nil && node.Right == nil { res = (res + sum) % 1000000007 } if node.Left != nil { stack = append(stack, Node{ node: node.Left, sum: sum, }) } if node.Right != nil { stack = append(stack, Node{ node: node.Right, sum: sum, }) } } return res } 1025.除数博弈(2) 题目 爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。 最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作： 选出任一 x，满足 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 找规律 O(1) O(1) 02 动态规划 O(n^2) O(n) func divisorGame(N int) bool { return N % 2 == 0 } # func divisorGame(N int) bool { dp := make([]bool, N+1) dp[1] = false // 1的时候爱丽丝没有选择，失败 for i := 2; i 1029.两地调度(2) 题目 公司计划面试 2N 人。第 i 人飞往 A 市的费用为 costs[i][0]，飞往 B 市的费用为 costs[i][1]。 返回将每个人都飞到某座城市的最低费用，要求每个城市都有 N 人抵达。 示例：输入：[[10,20],[30,200],[400,50],[30,20]] 输出：110 解释： 第一个人去 A 市，费用为 10。 第二个人去 A 市，费用为 30。 第三个人去 B 市，费用为 50。 第四个人去 B 市，费用为 20。 最低总费用为 10 + 30 + 50 + 20 = 110，每个城市都有一半的人在面试。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序 O(nlog(n)) O(1) 02 动态规划 O(n^2) O(n^2) func twoCitySchedCost(costs [][]int) int { sort.Slice(costs, func(i, j int) bool { return costs[i][0]-costs[i][1] i的情况，比如i=3, j=4 // 因为不存在3个人飞往A市次数为4次的情况 dp[i][j] = 100000000 } } for i := 1; i b { return b } return a } 1030.距离顺序排列矩阵单元格(3) 题目 给出 R 行 C 列的矩阵，其中的单元格的整数坐标为 (r, c)，满足 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 广度优先搜索 O(n^2) O(n^2) 02 排序 O(nlog(n)) O(n^2) 03 哈希辅助 O(n^2) I var dx = []int{-1, 1, 0, 0} var dy = []int{0, 0, -1, 1} func allCellsDistOrder(R int, C int, r0 int, c0 int) [][]int { res := make([][]int, 0) visited := make([][]bool, R) for i := 0; i 0 { x1, y1 := list[0][0], list[0][1] res = append(res, []int{x1, y1}) list = list[1:] for i := 0; i b { return a - b } return b - a } # func allCellsDistOrder(R int, C int, r0 int, c0 int) [][]int { res := make([][]int, 0) m := make(map[int][][]int) max := 0 for i := 0; i max { max = length } } } for i := 0; i b { return a - b } return b - a } 1033.移动石子直到连续(2) 题目 三枚石子放置在数轴上，位置分别为 a，b，c。 每一回合，我们假设这三枚石子当前分别位于位置 x, y, z 且 x 解题思路 No. 思路 时间复杂度 空间复杂度 01 找规律 O(1) O(1) 02 找规律 O(1) O(1) func numMovesStones(a int, b int, c int) []int { arr := []int{a, b, c} sort.Ints(arr) a, b, c = arr[0], arr[1], arr[2] if a 2 && c-b > 2 { return []int{2, c - a - 2} } else { return []int{1, c - a - 2} } } return []int{0, 0} } # func numMovesStones(a int, b int, c int) []int { if a > b { a, b = b, a } if b > c { b, c = c, b } if a > b { a, b = b, a } if a 2 && c-b > 2 { return []int{2, c - a - 2} } else { return []int{1, c - a - 2} } } return []int{0, 0} } 1037.有效的回旋镖(3) 题目 回旋镖定义为一组三个点，这些点各不相同且不在一条直线上。 给出平面上三个点组成的列表，判断这些点是否可以构成回旋镖。 示例 1：输入：[[1,1],[2,3],[3,2]] 输出：true 示例 2：输入：[[1,1],[2,2],[3,3]] 输出：false 提示： points.length == 3 points[i].length == 2 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 斜率公式 O(1) O(1) 02 鞋带公式 O(1) O(1) 03 判断是否组成三角形 O(1) O(1) // k1=(y1-y0)/(x1-x0) = k2 = (y2-y1)/(x2-x1) // (x1-x0)*(y2-y1) = (x2-x1)*(y1-y0) func isBoomerang(points [][]int) bool { return (points[1][0]-points[0][0])*(points[2][1]-points[1][1]) != (points[2][0]-points[1][0])*(points[1][1]-points[0][1]) } # // 鞋带公式 // S=|(x1 * y2 + x2 * y3 + x3 * y1 - y1 * x2 - y2 * x3 - y3 * x1)|/2 // S!=0组成三角形 func isBoomerang(points [][]int) bool { return points[0][0]*points[1][1]+points[1][0]*points[2][1]+points[2][0]*points[0][1] != points[0][1]*points[1][0]+points[1][1]*points[2][0]+points[2][1]*points[0][0] } # func isBoomerang(points [][]int) bool { side1 := side(points[0], points[1]) side2 := side(points[1], points[2]) side3 := side(points[0], points[2]) return side1+side2 > side3 && side2+side3 > side1 && side1+side3 > side2 } func side(arr1, arr2 []int) float64 { res := (arr1[0]-arr2[0])*(arr1[0]-arr2[0]) + (arr1[1]-arr2[1])*(arr1[1]-arr2[1]) return math.Sqrt(float64(res)) } 1042.不邻接植花(1) 题目 有 N 个花园，按从 1 到 N 标记。在每个花园中，你打算种下四种花之一。 paths[i] = [x, y] 描述了花园 x 到花园 y 的双向路径。 另外，没有花园有 3 条以上的路径可以进入或者离开。 你需要为每个花园选择一种花，使得通过路径相连的任何两个花园中的花的种类互不相同。 以数组形式返回选择的方案作为答案 answer，其中 answer[i] 为在第 (i+1) 个花园中种植的花的种类。 花的种类用 1, 2, 3, 4 表示。保证存在答案。 示例 1：输入：N = 3, paths = [[1,2],[2,3],[3,1]] 输出：[1,2,3] 示例 2：输入：N = 4, paths = [[1,2],[3,4]] 输出：[1,2,1,2] 示例 3：输入：N = 4, paths = [[1,2],[2,3],[3,4],[4,1],[1,3],[2,4]] 输出：[1,2,3,4] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 邻接表 O(n^2) O(n) func gardenNoAdj(N int, paths [][]int) []int { res := make([]int, N+1) arr := make([][]int, N+1) for i := 0; i 0 { delete(m, res[arr[i][j]]) } } for k := range m { res[i] = k break } } return res[1:] } 1046.最后一块石头的重量(2) 题目 有一堆石头，每块石头的重量都是正整数。 每一回合，从中选出两块 最重的 石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x 解题思路 No. 思路 时间复杂度 空间复杂度 01 内置堆 O(nlog(n)) O(n) 02 排序 O(n^2*log(n)) O(1) type IntHeap []int func (h IntHeap) Len() int { return len(h) } // 小根堆 func (h IntHeap) Less(i, j int) bool { return h[i] > h[j] } func (h IntHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] } func (h *IntHeap) Push(x interface{}) { *h = append(*h, x.(int)) } func (h *IntHeap) Pop() interface{} { value := (*h)[len(*h)-1] *h = (*h)[:len(*h)-1] return value } func lastStoneWeight(stones []int) int { intHeap := make(IntHeap, 0) heap.Init(&intHeap) for i := 0; i 1 { a := heap.Pop(&intHeap).(int) b := heap.Pop(&intHeap).(int) if a > b { heap.Push(&intHeap, a-b) } } if intHeap.Len() > 0 { res := heap.Pop(&intHeap).(int) return res } return 0 } # func lastStoneWeight(stones []int) int { length := len(stones) if length == 1 { return stones[0] } sort.Ints(stones) for stones[length-2] != 0 { stones[length-1] = stones[length-1] - stones[length-2] stones[length-2] = 0 sort.Ints(stones) } return stones[length-1] } 1047.删除字符串中的所有相邻重复项(2) 题目 给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。 在 S 上反复执行重复项删除操作，直到无法继续删除。 在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。 示例：输入：\"abbaca\" 输出：\"ca\" 解释：例如，在 \"abbaca\" 中，我们可以删除 \"bb\" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。 之后我们得到字符串 \"aaca\"，其中又只有 \"aa\" 可以执行重复项删除操作，所以最后的字符串为 \"ca\"。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 栈 O(n) O(n) 02 遍历 O(n) O(n) func removeDuplicates(S string) string { stack := make([]int32, 0) for _, v := range S { stack = append(stack, v) for len(stack) > 1 && stack[len(stack)-1] == stack[len(stack)-2] { stack = stack[:len(stack)-2] } } return string(stack) } # func removeDuplicates(S string) string { arr := []byte(S) for { flag := false for i := 0; i 1051.高度检查器(2) 题目 学校在拍年度纪念照时，一般要求学生按照 非递减 的高度顺序排列。 请你返回能让所有学生以 非递减 高度排列的最小必要移动人数。 注意，当一组学生被选中时，他们之间可以以任何可能的方式重新排序，而未被选中的学生应该保持不动。 示例：输入：heights = [1,1,4,2,1,3] 输出：3 解释：当前数组：[1,1,4,2,1,3] 目标数组：[1,1,1,2,3,4] 在下标 2 处（从 0 开始计数）出现 4 vs 1 ，所以我们必须移动这名学生。 在下标 4 处（从 0 开始计数）出现 1 vs 3 ，所以我们必须移动这名学生。 在下标 5 处（从 0 开始计数）出现 3 vs 4 ，所以我们必须移动这名学生。 示例 2：输入：heights = [5,1,2,3,4] 输出：5 示例 3：输入：heights = [1,2,3,4,5] 输出：0 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序 O(nlog(n)) O(n) 02 数组辅助 O(n) O(1) func heightChecker(heights []int) int { temp := make([]int, len(heights)) copy(temp, heights) sort.Ints(temp) res := 0 for i := 0; i 0 { if heights[j] != i { res++ } arr[i]-- j++ } } return res } 1071.字符串的最大公因子(2) 题目 对于字符串 S 和 T，只有在 S = T + ... + T（T 与自身连接 1 次或多次）时，我们才认定 “T 能除尽 S”。 返回最长字符串 X，要求满足 X 能除尽 str1 且 X 能除尽 str2。 示例 1：输入：str1 = \"ABCABC\", str2 = \"ABC\" 输出：\"ABC\" 示例 2：输入：str1 = \"ABABAB\", str2 = \"ABAB\" 输出：\"AB\" 示例 3：输入：str1 = \"LEET\", str2 = \"CODE\" 输出：\"\" 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 辗转相除法 O(n) O(n) 02 遍历 O(n^2) O(n) func gcdOfStrings(str1 string, str2 string) string { if str1+str2 != str2+str1 { return \"\" } if str1 > str2 { str1, str2 = str2, str1 } return str1[:gcd(len(str2), len(str1))] } func gcd(a, b int) int { if b == 0 { return a } return gcd(b, a%b) } # func gcdOfStrings(str1 string, str2 string) string { min := len(str1) if min > len(str2) { min = len(str2) } for i := len(str2); i >= 1; i-- { if len(str1)%i == 0 && len(str2)%i == 0 && str1[:i] == str2[:i] { a := strings.Repeat(str1[:i], len(str1)/i) b := strings.Repeat(str2[:i], len(str2)/i) if a == str1 && b == str2 { return str1[:i] } } } return \"\" } 1078.Bigram 分词(1) 题目 给出第一个词 first 和第二个词 second， 考虑在某些文本 text 中可能以 \"first second third\" 形式出现的情况， 其中 second 紧随 first 出现，third 紧随 second 出现。 对于每种这样的情况，将第三个词 \"third\" 添加到答案中，并返回答案。 示例 1： 输入：text = \"alice is a good girl she is a good student\", first = \"a\", second = \"good\" 输出：[\"girl\",\"student\"] 示例 2： 输入：text = \"we will we will rock you\", first = \"we\", second = \"will\" 输出：[\"we\",\"rock\"] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(n) func findOcurrences(text string, first string, second string) []string { arr := strings.Fields(text) res := make([]string, 0) for i := 0; i 1089.复写零(3) 题目 给你一个长度固定的整数数组 arr，请你将该数组中出现的每个零都复写一遍，并将其余的元素向右平移。 注意：请不要在超过该数组长度的位置写入元素。 要求：请对输入的数组 就地 进行上述修改，不要从函数返回任何东西。 示例 1：输入：[1,0,2,3,0,4,5,0] 输出：null 解释：调用函数后，输入的数组将被修改为：[1,0,0,2,3,0,0,4] 示例 2：输入：[1,2,3] 输出：null 解释：调用函数后，输入的数组将被修改为：[1,2,3] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 遍历后移 O(n^2) O(1) 03 数组辅助 O(n) O(n) func duplicateZeros(arr []int) { count := 0 for i := 0; i = 0; i-- { if arr[i] == 0 { count-- if i+count i; j-- { arr[j] = arr[j-1] } i++ } } } # func duplicateZeros(arr []int) { newArr := make([]int, 0) for i := 0; i 1001-1100-Medium 1014.最佳观光组合(1) 题目 给定正整数数组 A，A[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的距离为 j - i。 一对景点（i 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) func maxScoreSightseeingPair(A []int) int { res := 0 maxValue := A[0] + 0 // A[i]+A[j]+i-j=> max(A[i]+i)+(A[j]-j) (i b { return a } return b } 1035.不相交的线(3) 题目 我们在两条独立的水平线上按给定的顺序写下 A 和 B 中的整数。 现在，我们可以绘制一些连接两个数字 A[i] 和 B[j] 的直线，只要 A[i] == B[j]， 且我们绘制的直线不与任何其他连线（非水平线）相交。 以这种方法绘制线条，并返回我们可以绘制的最大连线数。 示例 1：输入：A = [1,4,2], B = [1,2,4] 输出：2 解释：我们可以画出两条不交叉的线，如上图所示。 我们无法画出第三条不相交的直线，因为从 A[1]=4 到 B[2]=4 的直线将与从 A[2]=2 到 B[1]=2 的直线相交。 示例 2：输入：A = [2,5,1,2,5], B = [10,5,2,1,5,2] 输出：3 示例 3：输入：A = [1,3,7,1,7,5], B = [1,9,2,5,1] 输出：2 提示：1 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划-二维 O(n^2) O(n^2) 02 动态规划-一维 O(n^2) O(n) 03 动态规划-一维 O(n^2) O(n) func maxUncrossedLines(A []int, B []int) int { n, m := len(A), len(B) dp := make([][]int, n+1) for i := 0; i b { return a } return b } # 2 func maxUncrossedLines(A []int, B []int) int { n, m := len(A), len(B) prev := make([]int, m+1) cur := make([]int, m+1) for i := 1; i b { return a } return b } # 3 func maxUncrossedLines(A []int, B []int) int { n, m := len(A), len(B) cur := make([]int, m+1) for i := 1; i b { return a } return b } 1081.不同字符的最小子序列(2) 题目 返回字符串 text 中按字典序排列最小的子序列，该子序列包含 text 中所有不同字符一次。 示例 1：输入：\"cdadabcc\" 输出：\"adbc\" 示例 2：输入：\"abcd\" 输出：\"abcd\" 示例 3：输入：\"ecbacba\" 输出：\"eacb\" 示例 4：输入：\"leetcode\" 输出：\"letcod\" 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 单调栈 O(n) O(n) 02 递归 O(n) O(n) func smallestSubsequence(text string) string { stack := make([]byte, 0) arr := [256]byte{} m := make(map[byte]bool) for i := 0; i s[i]:说明字典序不满足 for len(stack) > 0 && stack[len(stack)-1] > text[i] && arr[stack[len(stack)-1]] > 0 { m[stack[len(stack)-1]] = false stack = stack[:len(stack)-1] } stack = append(stack, text[i]) arr[text[i]]-- m[text[i]] = true } return string(stack) } # 2 func smallestSubsequence(text string) string { arr := [26]int{} pos := 0 for i := 0; i Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 10:44:00 "},"docs/source/question/1101-1200.html":{"url":"docs/source/question/1101-1200.html","title":"1101-1200","keywords":"","body":"1101-1200-Easy 1101-1200-Easy 1103.分糖果 II(3) 1108.IP地址无效化(2) 1122.数组的相对排序(3) 1128.等价多米诺骨牌对的数量(2) 1137.第N个泰波那契数(3) 1154.一年中的第几天(2) 1160.拼写单词(3) 1170.比较字符串最小字母出现频次(2) 1175.质数排列(1) 1184.公交站间的距离(2) 1185.一周中的第几天(3) 1189.“气球”的最大数量(3) 1200.最小绝对差(2) 1101-1200-Medium 1111.有效括号的嵌套深度(3) 1143.最长公共子序列(3) 1162.地图分析(2) 1191.K次串联后最大子数组之和 题目 解题思路 1103.分糖果 II(3) 题目 排排坐，分糖果。 我们买了一些糖果 candies，打算把它们分给排好队的 n = num_people 个小朋友。 给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 n 颗糖果。 然后，我们再回到队伍的起点，给第一个小朋友 n + 1 颗糖果，第二个小朋友 n + 2 颗， 依此类推，直到给最后一个小朋友 2 * n 颗糖果。 重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。 注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。 返回一个长度为 num_people、元素之和为 candies 的数组， 以表示糖果的最终分发情况（即 ans[i] 表示第 i 个小朋友分到的糖果数）。 示例 1：输入：candies = 7, num_people = 4 输出：[1,2,3,1] 解释： 第一次，ans[0] += 1，数组变为 [1,0,0,0]。 第二次，ans[1] += 2，数组变为 [1,2,0,0]。 第三次，ans[2] += 3，数组变为 [1,2,3,0]。 第四次，ans[3] += 1（因为此时只剩下 1 颗糖果），最终数组变为 [1,2,3,1]。 示例 2：输入：candies = 10, num_people = 3 输出：[5,2,3] 解释： 第一次，ans[0] += 1，数组变为 [1,0,0]。 第二次，ans[1] += 2，数组变为 [1,2,0]。 第三次，ans[2] += 3，数组变为 [1,2,3]。 第四次，ans[0] += 4，最终数组变为 [5,2,3]。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法 O(n^(1/2)) O(n) 02 暴力法 O(n^(1/2)) O(n) 03 等差数列求和公式 O(n^(1/2)) O(n) func distributeCandies(candies int, num_people int) []int { res := make([]int, num_people) i := 0 count := 0 for candies > 0 { count++ if candies >= count { res[i%num_people] += count } else { res[i%num_people] += candies } i++ candies = candies - count } return res } # func distributeCandies(candies int, num_people int) []int { res := make([]int, num_people) count := 1 for candies > 0 { for i := 0; i = count { res[i] = res[i] + count candies = candies - count } else { res[i] = res[i] + candies candies = 0 } count++ } } return res } # func distributeCandies(candies int, num_people int) []int { res := make([]int, num_people) times := 1 for times*(times+1)/2 i { n = n + 1 } // 等差数列{an}的通项公式为：an=a1+(n-1)d。 // 前n项和公式为：Sn=n*a1+n(n-1)d/2或Sn=n(a1+an)/2 // Sn=n(a1+a1+(n-1)d)/2=n(2a1+(n-1)d)/2 // (i+1)为首项，num_people为公差，n为数列长度，的等差数列的和 res[i] = n * (2*(i+1) + (n-1)*num_people) / 2 if times%num_people == i { res[i] = res[i] + last } } return res } 1108.IP地址无效化(2) 题目 给你一个有效的 IPv4 地址 address，返回这个 IP 地址的无效化版本。 所谓无效化 IP 地址，其实就是用 \"[.]\" 代替了每个 \".\"。 示例 1：输入：address = \"1.1.1.1\" 输出：\"1[.]1[.]1[.]1\" 示例 2：输入：address = \"255.100.50.0\" 输出：\"255[.]100[.]50[.]0\" 提示： 给出的 address 是一个有效的 IPv4 地址 解题思路 No. 思路 时间复杂度 空间复杂度 01 内置函数 O(n) O(n) 02 遍历 O(n) O(n) func defangIPaddr(address string) string { return strings.ReplaceAll(address, \".\", \"[.]\") } # func defangIPaddr(address string) string { res := \"\" for i := range address { if address[i] == '.' { res = res + \"[.]\" } else { res = res + string(address[i]) } } return res } 1122.数组的相对排序(3) 题目 给你两个数组，arr1 和 arr2， arr2 中的元素各不相同 arr2 中的每个元素都出现在 arr1 中 对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。 未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。 示例： 输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6] 输出：[2,2,2,1,4,3,3,9,6,7,19] 提示： arr1.length, arr2.length 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(nlog(n)) O(n) 02 暴力法 O(n^2) I 03 数组辅助 O(n) O(1) func relativeSortArray(arr1 []int, arr2 []int) []int { if len(arr2) == 0 { sort.Ints(arr1) return arr1 } res := make([]int, 0) m := make(map[int]int) for i := range arr1 { m[arr1[i]]++ } for i := 0; i 0 { tempArr = append(tempArr, key) value-- } } sort.Ints(tempArr) res = append(res, tempArr...) return res } # func relativeSortArray(arr1 []int, arr2 []int) []int { count := 0 for i := 0; i 0 { arr1[count] = arr2[i] temp[arr2[i]]-- count++ } } for i := 0; i 0 { arr1[count] = i temp[i]-- count++ } } return arr1 } 1128.等价多米诺骨牌对的数量(2) 题目 给你一个由一些多米诺骨牌组成的列表 dominoes。 如果其中某一张多米诺骨牌可以通过旋转 0 度或 180 度得到另一张多米诺骨牌，我们就认为这两张牌是等价的。 形式上，dominoes[i] = [a, b] 和 dominoes[j] = [c, d] 等价的前提是 a==c 且 b==d，或是 a==d 且 b==c。 在 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(1) 02 数组辅助 O(n) O(1) func numEquivDominoPairs(dominoes [][]int) int { m := make(map[string]int) for i := 0; i b { a, b = b, a } m[fmt.Sprintf(\"%d,%d\", a, b)]++ } res := 0 for _, v := range m { res = res + v*(v-1)/2 } return res } # func numEquivDominoPairs(dominoes [][]int) int { res := 0 arr := make([]int, 101) for i := 0; i b { a, b = b, a } res = res + arr[a*10+b] arr[a*10+b]++ } return res } 1137.第N个泰波那契数(3) 题目 泰波那契序列 Tn 定义如下： T0 = 0, T1 = 1, T2 = 1, 且在 n >= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2 给你整数 n，请返回第 n 个泰波那契数 Tn 的值。 示例 1：输入：n = 4 输出：4 解释： T_3 = 0 + 1 + 1 = 2 T_4 = 1 + 1 + 2 = 4 示例 2： 输入：n = 25 输出：1389537 提示： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n) O(n) 02 递推 O(n) O(1) 03 递归 O(n) O(n) func tribonacci(n int) int { arr := make([]int, n+3) arr[0] = 0 arr[1] = 1 arr[2] = 1 for i := 3; i 1154.一年中的第几天(2) 题目 给你一个按 YYYY-MM-DD 格式表示日期的字符串 date，请你计算并返回该日期是当年的第几天。 通常情况下，我们认为 1 月 1 日是每年的第 1 天，1 月 2 日是每年的第 2 天，依此类推。 每个月的天数与现行公元纪年法（格里高利历）一致。 示例 1：输入：date = \"2019-01-09\" 输出：9 示例 2：输入：date = \"2019-02-10\" 输出：41 示例 3：输入：date = \"2003-03-01\" 输出：60 示例 4：输入：date = \"2004-03-01\" 输出：61 提示： date.length == 10 date[4] == date[7] == '-'，其他的 date[i] 都是数字。 date 表示的范围从 1900 年 1 月 1 日至 2019 年 12 月 31 日。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(1) O(1) 02 内置函数 O(1) O(1) func dayOfYear(date string) int { arr := strings.Split(date, \"-\") year, _ := strconv.Atoi(arr[0]) month, _ := strconv.Atoi(arr[1]) day, _ := strconv.Atoi(arr[2]) res := 0 for i := 0; i 1160.拼写单词(3) 题目 给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。 假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串）， 那么我们就认为你掌握了这个单词。 注意：每次拼写（指拼写词汇表中的一个单词）时，chars 中的每个字母都只能用一次。 返回词汇表 words 中你掌握的所有单词的 长度之和。 示例 1：输入：words = [\"cat\",\"bt\",\"hat\",\"tree\"], chars = \"atach\" 输出：6 解释： 可以形成字符串 \"cat\" 和 \"hat\"，所以答案是 3 + 3 = 6。 示例 2：输入：words = [\"hello\",\"world\",\"leetcode\"], chars = \"welldonehoneyr\" 输出：10 解释： 可以形成字符串 \"hello\" 和 \"world\"，所以答案是 5 + 5 = 10。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n^2) O(1) 02 遍历-内置函数 O(n^2) O(1) 03 数组辅助 O(n^2) O(1) func countCharacters(words []string, chars string) int { m := make(map[byte]int) for i := range chars { m[chars[i]]++ } res := 0 for i := 0; i len(m) { continue } for k, v := range temp { if v > m[k] { flag = false break } } if flag == true { res = res + len(words[i]) } } return res } # func countCharacters(words []string, chars string) int { res := 0 for i := 0; i strings.Count(chars, string(v)) { flag = false continue } } if flag == true { res = res + len(words[i]) } } return res } # func countCharacters(words []string, chars string) int { m := make([]int, 26) for i := range chars { m[chars[i]-'a']++ } res := 0 for i := 0; i len(m) { continue } for k, v := range temp { if v > m[k] { flag = false break } } if flag == true { res = res + len(words[i]) } } return res } 1170.比较字符串最小字母出现频次(2) 题目 我们来定义一个函数 f(s)，其中传入参数 s 是一个非空字符串； 该函数的功能是统计 s 中（按字典序比较）最小字母的出现频次。 例如，若 s = \"dcce\"，那么 f(s) = 2，因为最小的字母是 \"c\"，它出现了 2 次。 现在，给你两个字符串数组待查表 queries 和词汇表 words，请你返回一个整数数组 answer 作为答案， 其中每个 answer[i] 是满足 f(queries[i]) f(\"cc\")。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组辅助 O(n^2) O(n) 02 排序+二分查找 O(nlog(n)) O(n) func numSmallerByFrequency(queries []string, words []string) []int { queriesArr := make([]int, len(queries)) wordsArr := make([]int, len(words)) res := make([]int, 0) for i := 0; i value { right = mid } else { left = mid + 1 } } if target[left] 1175.质数排列(1) 题目 请你帮忙给从 1 到 n 的数设计排列方案，使得所有的「质数」都应该被放在「质数索引」（索引从 1 开始）上； 你需要返回可能的方案总数。 让我们一起来回顾一下「质数」：质数一定是大于 1 的，并且不能用两个小于它的正整数的乘积来表示。 由于答案可能会很大，所以请你返回答案 模 mod 10^9 + 7 之后的结果即可。 示例 1：输入：n = 5 输出：12 解释：举个例子，[1,2,5,4,3] 是一个有效的排列，但 [5,2,3,4,1] 不是， 因为在第二种情况里质数 5 被错误地放在索引为 1 的位置上。 示例 2：输入：n = 100 输出：682289015 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历-全排列 O(n^3/2) O(1) func numPrimeArrangements(n int) int { primeNum := 0 for i := 2; i 1184.公交站间的距离(2) 题目 环形公交路线上有 n 个站，按次序从 0 到 n - 1 进行编号。 我们已知每一对相邻公交站之间的距离， distance[i] 表示编号为 i 的车站和编号为 (i + 1) % n 的车站之间的距离。 环线上的公交车都可以按顺时针和逆时针的方向行驶。 返回乘客从出发点 start 到目的地 destination 之间的最短距离。 示例 1：输入：distance = [1,2,3,4], start = 0, destination = 1 输出：1 解释：公交站 0 和 1 之间的距离是 1 或 9，最小值是 1。 示例 2：输入：distance = [1,2,3,4], start = 0, destination = 2 输出：3 解释：公交站 0 和 2 之间的距离是 3 或 7，最小值是 3。 示例 3：输入：distance = [1,2,3,4], start = 0, destination = 3 输出：4 解释：公交站 0 和 3 之间的距离是 6 或 4，最小值是 4。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 遍历 O(n) O(1) func distanceBetweenBusStops(distance []int, start int, destination int) int { x := 0 y := 0 for i := start; i != destination; i = (i + 1) % len(distance) { x = x + distance[i] } for i := destination; i != start; i = (i + 1) % len(distance) { y = y + distance[i] } if x > y { return y } return x } # func distanceBetweenBusStops(distance []int, start int, destination int) int { x := 0 sum := 0 for i := 0; i = start && i = destination && i x { return x } return sum - x } 1185.一周中的第几天(3) 题目 给你一个日期，请你设计一个算法来判断它是对应一周中的哪一天。 输入为三个整数：day、month 和 year，分别表示日、月、年。 您返回的结果必须是这几个值中的一个 {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"}。 示例 1：输入：day = 31, month = 8, year = 2019 输出：\"Saturday\" 示例 2：输入：day = 18, month = 7, year = 1999 输出：\"Sunday\" 示例 3：输入：day = 15, month = 8, year = 1993 输出：\"Sunday\" 提示： 给出的日期一定是在 1971 到 2100 年之间的有效日期。 解题思路 No. 思路 时间复杂度 空间复杂度 01 内置函数 O(1) O(1) 02 公式 O(1) O(1) 03 遍历 O(1) O(1) func dayOfTheWeek(day int, month int, year int) string { t, _ := time.Parse(\"2006-01-02\", fmt.Sprintf(\"%04d-%02d-%02d\", year, month, day)) return t.Weekday().String() } # // 蔡勒公式 // 基姆拉尔森计算公式 // https://baike.baidu.com/item/%E8%94%A1%E5%8B%92%E5%85%AC%E5%BC%8F // https://www.cnblogs.com/SeekHit/p/7498408.html // Week = (y+y/4-y/100+y/400+2*m+3*(m+1)/5+d) mod 7； func dayOfTheWeek(day int, month int, year int) string { arr := []string{\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"} if month == 1 || month == 2 { month = month + 12 year-- } week := (year + year/4 - year/100 + year/400 + 2*month + 3*(month+1)/5 + day) % 7 return arr[week] } # var arr = []string{\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"} var monthDate = []int{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31} func dayOfTheWeek(day int, month int, year int) string { day1 := totalDay(1993, 8, 15) day2 := totalDay(year, month, day) diff := 6 - day1%7 return arr[(day2+diff)%7] } func totalDay(year, month, day int) int { total := 0 for i := 1971; i 1189.“气球”的最大数量(3) 题目 给你一个字符串 text，你需要使用 text 中的字母来拼凑尽可能多的单词 \"balloon\"（气球）。 字符串 text 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词 \"balloon\"。 示例 1：输入：text = \"nlaebolko\" 输出：1 示例 2：输入：text = \"loonbalxballpoon\" 输出：2 示例 3：输入：text = \"leetcode\" 输出：0 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历-数组辅助 O(n) O(1) 02 遍历-数组辅助 O(n) O(1) 03 内置函数 O(n) O(1) func maxNumberOfBalloons(text string) int { m := make([]int, 26) str := \"ablon\" for i := 0; i 0 { m[text[i]-'a']++ } } min := math.MaxInt32 for k, v := range m { if v == 0 { continue } if k+'a' == 'l' || k+'a' == 'o' { v = (v - 1) / 2 } else { v = v - 1 } if v 1200.最小绝对差(2) 题目 给你个整数数组 arr，其中每个元素都 不相同。 请你找到所有具有最小绝对差的元素对，并且按升序的顺序返回。 示例 1：输入：arr = [4,2,1,3] 输出：[[1,2],[2,3],[3,4]] 示例 2：输入：arr = [1,3,6,10,15] 输出：[[1,3]] 示例 3：输入：arr = [3,8,-10,23,19,-4,-14,27] 输出：[[-14,-10],[19,23],[23,27]] 提示： 2 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序-遍历 O(nlog(n)) O(n) 02 排序-遍历 O(nlog(n)) O(n) func minimumAbsDifference(arr []int) [][]int { sort.Ints(arr) result := make([][]int, 0) min := arr[1] - arr[0] result = append(result, []int{arr[0], arr[1]}) for i := 2; i arr[i]-arr[i-1] { min = arr[i] - arr[i-1] } } for i := 1; i 1101-1200-Medium 1111.有效括号的嵌套深度(3) 题目 有效括号字符串 定义：对于每个左括号，都能找到与之对应的右括号，反之亦然。 详情参见题末「有效括号字符串」部分。 嵌套深度 depth 定义：即有效括号字符串嵌套的层数，depth(A) 表示有效括号字符串 A 的嵌套深度。 详情参见题末「嵌套深度」部分。 有效括号字符串类型与对应的嵌套深度计算方法如下图所示： 给你一个「有效括号字符串」 seq，请你将其分成两个不相交的有效括号字符串，A 和 B， 并使这两个字符串的深度最小。 不相交：每个 seq[i] 只能分给 A 和 B 二者中的一个，不能既属于 A 也属于 B 。 A 或 B 中的元素在原字符串中可以不连续。 A.length + B.length = seq.length 深度最小：max(depth(A), depth(B)) 的可能取值最小。 划分方案用一个长度为 seq.length 的答案数组 answer 表示，编码规则如下： answer[i] = 0，seq[i] 分给 A 。 answer[i] = 1，seq[i] 分给 B 。 如果存在多个满足要求的答案，只需返回其中任意 一个 即可。 示例 1：输入：seq = \"(()())\" 输出：[0,1,1,1,1,0] 示例 2：输入：seq = \"()(())()\" 输出：[0,0,0,1,1,0,1,1] 解释：本示例答案不唯一。 按此输出 A = \"()()\", B = \"()()\", max(depth(A), depth(B)) = 1，它们的深度最小。 像 [1,1,1,0,0,1,1,1]，也是正确结果，其中 A = \"()()()\", B = \"()\", max(depth(A), depth(B)) = 1 。 提示：1 解题思路 No. 思路 时间复杂度 空间复杂度 01 统计 O(n) O(n) 02 找规律 O(n) O(n) 03 找规律 O(n) O(n) func maxDepthAfterSplit(seq string) []int { res := make([]int, 0) level := 0 for i := 0; i b { a-- res = append(res, 0) } else { b-- res = append(res, 1) } } } return res } 1143.最长公共子序列(3) 题目 给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。 一个字符串的 子序列 是指这样一个新的字符串： 它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。 例如，\"ace\" 是 \"abcde\" 的子序列，但 \"aec\" 不是 \"abcde\" 的子序列。 两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。 若这两个字符串没有公共子序列，则返回 0。 示例 1:输入：text1 = \"abcde\", text2 = \"ace\" 输出：3 解释：最长公共子序列是 \"ace\"，它的长度为 3。 示例 2:输入：text1 = \"abc\", text2 = \"abc\" 输出：3 解释：最长公共子序列是 \"abc\"，它的长度为 3。 示例 3:输入：text1 = \"abc\", text2 = \"def\" 输出：0 解释：两个字符串没有公共子序列，返回 0。 提示: 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划-二维 O(n^2) O(n^2) 02 动态规划-一维 O(n^2) O(n) 03 动态规划-一维 O(n^2) O(n) func longestCommonSubsequence(text1 string, text2 string) int { n, m := len(text1), len(text2) dp := make([][]int, n+1) for i := 0; i b { return a } return b } # 2 func longestCommonSubsequence(text1 string, text2 string) int { n, m := len(text1), len(text2) prev := make([]int, m+1) cur := make([]int, m+1) for i := 1; i b { return a } return b } # 3 func longestCommonSubsequence(text1 string, text2 string) int { n, m := len(text1), len(text2) cur := make([]int, m+1) for i := 1; i b { return a } return b } 1162.地图分析(2) 题目 你现在手里有一份大小为 N x N 的 网格 grid，上面的每个 单元格 都用 0 和 1 标记好了。 其中 0 代表海洋，1 代表陆地，请你找出一个海洋单元格，这个海洋单元格到离它最近的陆地单元格的距离是最大的。 我们这里说的距离是「曼哈顿距离」（ Manhattan Distance）： (x0, y0) 和 (x1, y1) 这两个单元格之间的距离是 |x0 - x1| + |y0 - y1| 。 如果网格上只有陆地或者海洋，请返回 -1。 示例 1：输入：[[1,0,1],[0,0,0],[1,0,1]] 输出：2 解释：海洋单元格 (1, 1) 和所有陆地单元格之间的距离都达到最大，最大距离为 2。 示例 2：输入：[[1,0,0],[0,0,0],[0,0,0]] 输出：4 解释： 海洋单元格 (2, 2) 和所有陆地单元格之间的距离都达到最大，最大距离为 4。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 广度优先搜索 O(n^2) O(n^2) 02 动态规划 O(n^2) O(n^2) var dx = []int{-1, 1, 0, 0} var dy = []int{0, 0, -1, 1} func maxDistance(grid [][]int) int { queue := make([][2]int, 0) for i := 0; i 0 { res++ length := len(queue) for i := 0; i = 1 { dp[i][j] = min(dp[i][j], dp[i-1][j]+1) } if j >= 1 { dp[i][j] = min(dp[i][j], dp[i][j-1]+1) } } } // 从下往上 for i := n - 1; i >= 0; i-- { for j := m - 1; j >= 0; j-- { if grid[i][j] == 1 { continue } if i b { return a } return b } func min(a, b int) int { if a > b { return b } return a } 1191.K次串联后最大子数组之和 题目 给你一个整数数组 arr 和一个整数 k。 首先，我们要对该数组进行修改，即把原数组 arr 重复 k 次。 举个例子，如果 arr = [1, 2] 且 k = 3，那么修改后的数组就是 [1, 2, 1, 2, 1, 2]。 然后，请你返回修改后的数组中的最大的子数组之和。 注意，子数组长度可以是 0，在这种情况下它的总和也是 0。 由于 结果可能会很大，所以需要 模（mod） 10^9 + 7 后再返回。 示例 1：输入：arr = [1,2], k = 3 输出：9 示例 2：输入：arr = [1,-2,1], k = 5 输出：2 示例 3：输入：arr = [-1,-2], k = 7 输出：0 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 广度优先搜索 O(n^2) O(n^2) Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 10:45:26 "},"docs/source/question/1201-1300.html":{"url":"docs/source/question/1201-1300.html","title":"1201-1300","keywords":"","body":"1201-1300-Easy 1201-1300-Easy 1207.独一无二的出现次数(2) 1217.玩筹码(1) 1221.分割平衡字符串(3) 1232.缀点成线(3) 1237.找出给定方程的正整数解(3) 1252.奇数值单元格的数目(3) 1260.二维网格迁移(2) 1266.访问所有点的最小时间(1) 1275.找出井字棋的获胜者(2) 1281.整数的各位积和之差(2) 1287.有序数组中出现次数超过25%的元素(4) 1290.二进制链表转整数(3) 1295.统计位数为偶数的数字(2) 1299.将每个元素替换为右侧最大元素(3) 1201-1300-Medium 1248.统计「优美子数组」(4) 1207.独一无二的出现次数(2) 题目 给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。 如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。 示例 1：输入：arr = [1,2,2,1,1,3] 输出：true 解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。 示例 2：输入：arr = [1,2] 输出：false 示例 3：输入：arr = [-3,0,1,-3,1,1,1,-3,10,0] 输出：true 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(1) 02 数组辅助 O(n) O(1) func uniqueOccurrences(arr []int) bool { m := make(map[int]int) for _, v := range arr { m[v]++ } temp := make(map[int]bool) for _, v := range m { if temp[v] == true { return false } temp[v] = true } return true } # func uniqueOccurrences(arr []int) bool { tempArr := make([]int,2001) for _, v := range arr { tempArr[v+1000]++ } temp := make(map[int]bool) for _, v := range tempArr { if v == 0{ continue } if temp[v] == true { return false } temp[v] = true } return true } 1217.玩筹码(1) 题目 数轴上放置了一些筹码，每个筹码的位置存在数组 chips 当中。 你可以对 任何筹码 执行下面两种操作之一（不限操作次数，0 次也可以）： 将第 i 个筹码向左或者右移动 2 个单位，代价为 0。 将第 i 个筹码向左或者右移动 1 个单位，代价为 1。 最开始的时候，同一位置上也可能放着两个或者更多的筹码。 返回将所有筹码移动到同一位置（任意位置）上所需要的最小代价。 示例 1：输入：chips = [1,2,3] 输出：1 解释：第二个筹码移动到位置三的代价是 1，第一个筹码移动到位置三的代价是 0，总代价为 1。 示例 2：输入：chips = [2,2,2,3,3] 输出：2 解释：第四和第五个筹码移动到位置二的代价都是 1，所以最小总代价为 2。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 奇偶计数 O(n) O(1) /* 1、所有偶数移动到同一偶数位置，花费0 2、所有奇数移动到同一奇数位置，花费0 3、将较小移动到较多的位置。 */ func minCostToMoveChips(chips []int) int { odd := 0 even := 0 for i := 0; i even { return even } return odd } 1221.分割平衡字符串(3) 题目 在一个「平衡字符串」中，'L' 和 'R' 字符的数量是相同的。 给出一个平衡字符串 s，请你将它分割成尽可能多的平衡字符串。 返回可以通过分割得到的平衡字符串的最大数量。 示例 1：输入：s = \"RLRRLLRLRL\" 输出：4 解释：s 可以分割为 \"RL\", \"RRLL\", \"RL\", \"RL\", 每个子字符串中都包含相同数量的 'L' 和 'R'。 示例 2：输入：s = \"RLLLLRRRLR\" 输出：3 解释：s 可以分割为 \"RL\", \"LLLRRR\", \"LR\", 每个子字符串中都包含相同数量的 'L' 和 'R'。 示例 3：输入：s = \"LLLLRRRR\" 输出：1 解释：s 只能保持原样 \"LLLLRRRR\". 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 栈辅助 O(n) O(n) 02 遍历 O(n) O(1) 03 遍历 O(n) O(1) func balancedStringSplit(s string) int { res := 0 if len(s) == 0 { return res } stack := make([]byte, 0) stack = append(stack, s[0]) for i := 1; i 0 && ((s[i] == 'L' && stack[len(stack)-1] == 'R') || (s[i] == 'R' && stack[len(stack)-1] == 'L')) { stack = stack[:len(stack)-1] if len(stack) == 0 { res++ } } else { stack = append(stack, s[i]) } } return res } # func balancedStringSplit(s string) int { res := 0 if len(s) == 0 { return res } count := 0 if s[0] == 'L' { count++ } else { count-- } for i := 1; i 1232.缀点成线(3) 题目 在一个 XY 坐标系中有一些点，我们用数组 coordinates 来分别记录它们的坐标， 其中 coordinates[i] = [x, y] 表示横坐标为 x、纵坐标为 y 的点。 请你来判断，这些点是否在该坐标系中属于同一条直线上，是则返回 true，否则请返回 false。 示例 1：输入：coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]] 输出：true 示例 2：输入：coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]] 输出：false 提示： 2 解题思路 No. 思路 时间复杂度 空间复杂度 01 斜率公式 O(n) O(1) 02 鞋带公式 O(n) O(1) 03 判断三边长 O(n) O(1) // k=y/x k1=y1/x1 => xy1=x1y func checkStraightLine(coordinates [][]int) bool { x, y := coordinates[1][0]-coordinates[0][0], coordinates[1][1]-coordinates[0][1] for i := 2; i 0.00000005 || arr[2]-arr[1]-arr[0] 1237.找出给定方程的正整数解(3) 题目 给出一个函数 f(x, y) 和一个目标结果 z，请你计算方程 f(x,y) == z 所有可能的正整数 数对 x 和 y。 给定函数是严格单调的，也就是说： f(x, y) 解题思路 No. 思路 时间复杂度 空间复杂度 01 二分查找 O(nlog(n)) O(n) 02 双指针 O(n) O(n) 03 暴力法 O(n^2) O(n) func findSolution(customFunction func(int, int) int, z int) [][]int { res := make([][]int, 0) for i := 1; i v2 { continue } for left v { left = mid + 1 } else { right = mid - 1 } } } return res } # func findSolution(customFunction func(int, int) int, z int) [][]int { res := make([][]int, 0) i := 1 j := 1000 for i = 1 { if customFunction(i, j) == z { res = append(res, []int{i, j}) i++ j-- } else if customFunction(i, j) > z { j-- } else { i++ } } return res } # func findSolution(customFunction func(int, int) int, z int) [][]int { res := make([][]int, 0) for i := 1; i 1252.奇数值单元格的数目(3) 题目 给你一个 n 行 m 列的矩阵，最开始的时候，每个单元格中的值都是 0。 另有一个索引数组 indices，indices[i] = [ri, ci] 中的 ri 和 ci 分别表示指定的行和列（从 0 开始编号）。 你需要将每对 [ri, ci] 指定的行和列上的所有单元格的值加 1。 请你在执行完所有 indices 指定的增量操作后，返回矩阵中 「奇数值单元格」 的数目。 示例 1：输入：n = 2, m = 3, indices = [[0,1],[1,1]] 输出：6 解释：最开始的矩阵是 [[0,0,0],[0,0,0]]。 第一次增量操作后得到 [[1,2,1],[0,1,0]]。 最后的矩阵是 [[1,3,1],[1,3,1]]，里面有 6 个奇数。 示例 2：输入：n = 2, m = 2, indices = [[1,1],[0,0]] 输出：0 解释：最后的矩阵是 [[2,2],[2,2]]，里面没有奇数。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历模拟 O(n^2) O(n^2) 02 统计行列 O(n) O(n) 03 统计行列-遍历 O(n^2) O(n) func oddCells(n int, m int, indices [][]int) int { arr := make([][]int, n) for i := 0; i 1260.二维网格迁移(2) 题目 给你一个 m 行 n 列的二维网格 grid 和一个整数 k。你需要将 grid 迁移 k 次。 每次「迁移」操作将会引发下述活动： 位于 grid[i][j] 的元素将会移动到 grid[i][j + 1]。 位于 grid[i][n - 1] 的元素将会移动到 grid[i + 1][0]。 位于 grid[m - 1][n - 1] 的元素将会移动到 grid[0][0]。 请你返回 k 次迁移操作后最终得到的 二维网格。 示例 1：输入：grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1 输出：[[9,1,2],[3,4,5],[6,7,8]] 示例 2：输入：grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4 输出：[[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]] 示例 3：输入：grid = [[1,2,3],[4,5,6],[7,8,9]], k = 9 输出：[[1,2,3],[4,5,6],[7,8,9]] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历模拟 O(n^2) O(n^2) 02 计算下标 O(n^2) O(n^2) func shiftGrid(grid [][]int, k int) [][]int { for i := 0; i 1266.访问所有点的最小时间(1) 题目 平面上有 n 个点，点的位置用整数坐标表示 points[i] = [xi, yi]。 请你计算访问所有这些点需要的最小时间（以秒为单位）。 你可以按照下面的规则在平面上移动： 每一秒沿水平或者竖直方向移动一个单位长度， 或者跨过对角线（可以看作在一秒内向水平和竖直方向各移动一个单位长度）。 必须按照数组中出现的顺序来访问这些点。 示例 1：输入：points = [[1,1],[3,4],[-1,0]] 输出：7 解释：一条最佳的访问路径是： [1,1] -> [2,2] -> [3,3] -> [3,4] -> [2,3] -> [1,2] -> [0,1] -> [-1,0] 从 [1,1] 到 [3,4] 需要 3 秒 从 [3,4] 到 [-1,0] 需要 4 秒 一共需要 7 秒 示例 2：输入：points = [[3,2],[-2,2]] 输出：5 提示： points.length == n 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) func minTimeToVisitAllPoints(points [][]int) int { res := 0 for i := 1; i y { res = res + x } else { res = res + y } } return res } func length(a, b int) int { if a > b { return a - b } return b - a } 1275.找出井字棋的获胜者(2) 题目 A 和 B 在一个 3 x 3 的网格上玩井字棋。 井字棋游戏的规则如下： 玩家轮流将棋子放在空方格 (\" \") 上。 第一个玩家 A 总是用 \"X\" 作为棋子，而第二个玩家 B 总是用 \"O\" 作为棋子。 \"X\" 和 \"O\" 只能放在空方格中，而不能放在已经被占用的方格上。 只要有 3 个相同的（非空）棋子排成一条直线（行、列、对角线）时，游戏结束。 如果所有方块都放满棋子（不为空），游戏也会结束。 游戏结束后，棋子无法再进行任何移动。 给你一个数组 moves，其中每个元素是大小为 2 的另一个数组（元素分别对应网格的行和列）， 它按照 A 和 B 的行动顺序（先 A 后 B）记录了两人各自的棋子位置。 如果游戏存在获胜者（A 或 B），就返回该游戏的获胜者； 如果游戏以平局结束，则返回 \"Draw\"；如果仍会有行动（游戏未结束），则返回 \"Pending\"。 你可以假设 moves 都 有效（遵循井字棋规则），网格最初是空的，A 将先行动。 示例 1：输入：moves = [[0,0],[2,0],[1,1],[2,1],[2,2]] 输出：\"A\" 解释：\"A\" 获胜，他总是先走。 \"X \" \"X \" \"X \" \"X \" \"X \" \" \" -> \" \" -> \" X \" -> \" X \" -> \" X \" \" \" \"O \" \"O \" \"OO \" \"OOX\" 示例 2：输入：moves = [[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]] 输出：\"B\" 解释：\"B\" 获胜。 \"X \" \"X \" \"XX \" \"XXO\" \"XXO\" \"XXO\" \" \" -> \" O \" -> \" O \" -> \" O \" -> \"XO \" -> \"XO \" \" \" \" \" \" \" \" \" \" \" \"O \" 示例 3：输入：moves = [[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]] 输出：\"Draw\" 输出：由于没有办法再行动，游戏以平局结束。 \"XXO\" \"OOX\" \"XOX\" 示例 4：输入：moves = [[0,0],[1,1]] 输出：\"Pending\" 解释：游戏还没有结束。 \"X \" \" O \" \" \" 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历模拟 O(1) O(1) 02 遍历模拟 O(1) O(1) func tictactoe(moves [][]int) string { arrA := make([]int, 0) arrB := make([]int, 0) for i := 0; i 1281.整数的各位积和之差(2) 题目 给你一个整数 n，请你帮忙计算并返回该整数「各位数字之积」与「各位数字之和」的差。 示例 1：输入：n = 234 输出：15 解释： 各位数之积 = 2 * 3 * 4 = 24 各位数之和 = 2 + 3 + 4 = 9 结果 = 24 - 9 = 15 示例 2：输入：n = 4421 输出：21 解释： 各位数之积 = 4 * 4 * 2 * 1 = 32 各位数之和 = 4 + 4 + 2 + 1 = 11 结果 = 32 - 11 = 21 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(log(n)) O(1) 02 转字符串遍历 O(log(n)) O(1) func subtractProductAndSum(n int) int { sum := 0 mul := 1 for n > 0 { value := n % 10 n = n / 10 sum = sum + value mul = mul * value } return mul - sum } func subtractProductAndSum(n int) int { sum := 0 mul := 1 str := strconv.Itoa(n) for i := 0; i 1287.有序数组中出现次数超过25%的元素(4) 题目 给你一个非递减的 有序 整数数组，已知这个数组中恰好有一个整数，它的出现次数超过数组元素总数的 25%。 请你找到并返回这个整数 示例：输入：arr = [1,2,2,6,6,6,6,7,10] 输出：6 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历统计 O(n) O(1) 02 遍历 O(n) O(1) 03 二分查找 O(log(n)) O(1) 04 遍历 O(n) O(1) func findSpecialInteger(arr []int) int { count := 1 res := arr[0] for i := 1; i len(arr)/4 { return arr[i] } } else { res = arr[i] count = 1 } } return res } # func findSpecialInteger(arr []int) int { step := len(arr) / 4 for i := 0; i length { return value } } return arr[3*length] } func leftSearch(arr []int, value int) int { left := 0 right := len(arr) for left = value { right = mid } else { left = mid + 1 } } return left } func rightSearch(arr []int, value int) int { left := 0 right := len(arr) for left value { right = mid } else { left = mid + 1 } } return right - 1 } # func findSpecialInteger(arr []int) int { length := len(arr) / 4 for i := 1; i 0 { if arr[left] == arr[left-1] { left-- } else { break } } right := length * i for right length { return value } } return arr[3*length] } 1290.二进制链表转整数(3) 题目 给你一个单链表的引用结点 head。链表中每个结点的值不是 0 就是 1。 已知此链表是一个整数数字的二进制表示形式。 请你返回该链表所表示数字的 十进制值 。 示例 1：输入：head = [1,0,1] 输出：5 解释：二进制数 (101) 转化为十进制数 (5) 示例 2：输入：head = [0] 输出：0 示例 3：输入：head = [1] 输出：1 示例 4：输入：head = [1,0,0,1,0,0,1,1,1,0,0,0,0,0,0] 输出：18880 示例 5：输入：head = [0,0] 输出：0 提示： 链表不为空。 链表的结点总数不超过 30。 每个结点的值不是 0 就是 1。 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组辅助 O(n) O(n) 02 遍历 O(n) O(1) 03 递归 O(n) O(n) func getDecimalValue(head *ListNode) int { arr := make([]int, 0) for head != nil { arr = append(arr, head.Val) head = head.Next } res := 0 for i := 0; i 1295.统计位数为偶数的数字(2) 题目 给你一个整数数组 nums，请你返回其中位数为 偶数 的数字的个数。 示例 1：输入：nums = [12,345,2,6,7896] 输出：2 解释： 12 是 2 位数字（位数为偶数） 345 是 3 位数字（位数为奇数） 2 是 1 位数字（位数为奇数） 6 是 1 位数字 位数为奇数） 7896 是 4 位数字（位数为偶数） 因此只有 12 和 7896 是位数为偶数的数字 示例 2：输入：nums = [555,901,482,1771]输出：1 解释： 只有 1771 是位数为偶数的数字。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 转字符串 O(n) O(1) func findNumbers(nums []int) int { res := 0 for i := 0; i 0 { value = value / 10 count++ } if count%2 == 0 { res++ } } return res } # func findNumbers(nums []int) int { res := 0 for i := 0; i 1299.将每个元素替换为右侧最大元素(3) 题目 给你一个数组 arr ，请你将每个元素用它右边最大的元素替换，如果是最后一个元素，用 -1 替换。 完成所有替换操作后，请你返回这个数组。 示例：输入：arr = [17,18,5,4,6,1] 输出：[18,6,6,6,1,-1] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 暴力法 O(n^2) O(1) 03 遍历-数组辅助 O(n) O(n) func replaceElements(arr []int) []int { max := -1 for i := len(arr) - 1; i >= 0; i-- { if arr[i] > max { arr[i], max = max, arr[i] } else { arr[i] = max } } return arr } # func replaceElements(arr []int) []int { for i := 0; i max { max = arr[j] } } arr[i] = max } return arr } # func replaceElements(arr []int) []int { res := make([]int, len(arr)) res[len(res)-1] = -1 for i := len(arr) - 2; i >= 0; i-- { if arr[i+1] > res[i+1] { res[i] = arr[i+1] } else { res[i] = res[i+1] } } return res } 1201-1300-Medium 1248.统计「优美子数组」(4) 题目 给你一个整数数组 nums 和一个整数 k。 如果某个 连续 子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。 请返回这个数组中「优美子数组」的数目。 示例 1：输入：nums = [1,1,2,1,1], k = 3 输出：2 解释：包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。 示例 2：输入：nums = [2,4,6], k = 1 输出：0 解释：数列中不包含任何奇数，所以不存在优美子数组。 示例 3：输入：nums = [2,2,2,1,2,2,1,2,2,2], k = 2 输出：16 提示：1 解题思路 No. 思路 时间复杂度 空间复杂度 01 统计奇数 O(n) O(n) 02 前缀和 O(n) O(n) 03 滑动窗口 O(n) O(1) 04 动态规划 O(n) O(n) func numberOfSubarrays(nums []int, k int) int { res := 0 arr := make([]int, 0) arr = append(arr, -1) for i := 0; i = k { res = res + arr[sum-k] } } return res } # 3 func numberOfSubarrays(nums []int, k int) int { res := 0 left, right := 0, 0 count := 0 for right = k { res = res + dp[len(dp)-k] } } return res } Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 10:47:31 "},"docs/source/question/1301-1400.html":{"url":"docs/source/question/1301-1400.html","title":"1301-1400","keywords":"","body":"1301-1400-Easy 1301-1400-Easy 1304.和为零的N个唯一整数(2) 1309.解码字母到整数映射(3) 1313.解压缩编码列表(1) 1317.将整数转换为两个无零整数的和(2) 1323.6和9组成的最大数字(3) 1331.数组序号转换(2) 1332.删除回文子序列(2) 1337.方阵中战斗力最弱的K行(2) 1342.将数字变成0的操作次数(3) 1346.检查整数及其两倍数是否存在(3) 1351.统计有序矩阵中的负数(4) 1356.根据数字二进制下1的数目排序(3) 1360.日期之间隔几天(2) 1365.有多少小于当前数字的数字(3) 1370.上升下降字符串(2) 1374.生成每种字符都是奇数个的字符串(2) 1380.矩阵中的幸运数(2) 1385.两个数组间的距离值(2) 1389.按既定顺序创建目标数组(3) 1394.找出数组中的幸运数(2) 1399.统计最大组的数目(2) 1301-1400-Medium 1306.跳跃游戏III(2) 1375.灯泡开关III(2) 1376.通知所有员工所需的时间(3) 1304.和为零的N个唯一整数(2) 题目 给你一个整数 n，请你返回 任意 一个由 n 个 各不相同 的整数组成的数组，并且这 n 个数相加和为 0 。 示例 1：输入：n = 5 输出：[-7,-1,1,3,4] 解释：这些数组也是正确的 [-5,-1,1,2,3]，[-3,-1,2,-2,4]。 示例 2：输入：n = 3 输出：[-1,0,1] 示例 3：输入：n = 1 输出：[0] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 1负N正 O(n) O(n) 02 半正半负 O(n) O(n) func sumZero(n int) []int { res := make([]int, n) sum := 0 for i := 0; i 1309.解码字母到整数映射(3) 题目 给你一个字符串 s，它由数字（'0' - '9'）和 '#' 组成。我们希望按下述规则将 s 映射为一些小写英文字符： 字符（'a' - 'i'）分别用（'1' - '9'）表示。 字符（'j' - 'z'）分别用（'10#' - '26#'）表示。 返回映射之后形成的新字符串。 题目数据保证映射始终唯一。 示例 1：输入：s = \"10#11#12\" 输出：\"jkab\" 解释：\"j\" -> \"10#\" , \"k\" -> \"11#\" , \"a\" -> \"1\" , \"b\" -> \"2\". 示例 2：输入：s = \"1326#\" 输出：\"acz\" 示例 3：输入：s = \"25#\" 输出：\"y\" 示例 4：输入：s = \"12345678910#11#12#13#14#15#16#17#18#19#20#21#22#23#24#25#26#\" 输出：\"abcdefghijklmnopqrstuvwxyz\" 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 反向遍历 O(n) O(n) 02 正向遍历 O(n) O(n) 03 内置函数 O(n) O(n) func freqAlphabets(s string) string { res := \"\" for i := len(s) - 1; i >= 0; { if s[i] == '#' { value, _ := strconv.Atoi(string(s[i-2 : i])) res = string('a'+value-1) + res i = i - 3 } else { value, _ := strconv.Atoi(string(s[i])) res = string('a'+value-1) + res i = i - 1 } } return res } # func freqAlphabets(s string) string { res := \"\" for i := 0; i 1313.解压缩编码列表(1) 题目 给你一个以行程长度编码压缩的整数列表 nums 。 考虑每对相邻的两个元素 [freq, val] = [nums[2*i], nums[2*i+1]] （其中 i >= 0 ）， 每一对都表示解压后子列表中有 freq 个值为 val 的元素，你需要从左到右连接所有子列表以生成解压后的列表。 请你返回解压后的列表。 示例：输入：nums = [1,2,3,4] 输出：[2,4,4,4] 解释：第一对 [1,2] 代表着 2 的出现频次为 1，所以生成数组 [2]。 第二对 [3,4] 代表着 4 的出现频次为 3，所以生成数组 [4,4,4]。 最后将它们串联到一起 [2] + [4,4,4] = [2,4,4,4]。 示例 2：输入：nums = [1,1,2,3] 输出：[1,3,3] 提示： 2 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n^2) O(n^2) func decompressRLElist(nums []int) []int { res := make([]int, 0) for i := 0; i 1317.将整数转换为两个无零整数的和(2) 题目 「无零整数」是十进制表示中 不含任何 0 的正整数。 给你一个整数 n，请你返回一个 由两个整数组成的列表 [A, B]，满足： A 和 B 都是无零整数 A + B = n 题目数据保证至少有一个有效的解决方案。 如果存在多个有效解决方案，你可以返回其中任意一个。 示例 1：输入：n = 2 输出：[1,1] 解释：A = 1, B = 1. A + B = n 并且 A 和 B 的十进制表示形式都不包含任何 0 。 示例 2：输入：n = 11 输出：[2,9] 示例 3：输入：n = 10000 输出：[1,9999] 示例 4：输入：n = 69 输出：[1,68] 示例 5：输入：n = 1010 输出：[11,999] 提示：2 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(nlog(n)) O(1) 02 遍历 O(nlog(n)) O(1) func getNoZeroIntegers(n int) []int { for i := 1; i 0 { if num%10 == 0 { return false } num = num / 10 } return true } 1323.6和9组成的最大数字(3) 题目 给你一个仅由数字 6 和 9 组成的正整数 num。 你最多只能翻转一位数字，将 6 变成 9，或者把 9 变成 6 。 请返回你可以得到的最大数字。 示例 1：输入：num = 9669 输出：9969 解释： 改变第一位数字可以得到 6669 。 改变第二位数字可以得到 9969 。 改变第三位数字可以得到 9699 。 改变第四位数字可以得到 9666 。 其中最大的数字是 9969 。 示例 2：输入：num = 9996 输出：9999 解释：将最后一位从 6 变到 9，其结果 9999 是最大的数。 示例 3：输入：num = 9999 输出：9999 解释：无需改变就已经是最大的数字了。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历-转字符串 O(log(n)) O(log(n)) 02 遍历-转数组 O(log(n)) O(log(n)) 03 内置函数 O(log(n)) O(log(n)) func maximum69Number(num int) int { arr := []byte(strconv.Itoa(num)) for i := 0; i 0 { arr = append(arr, num%10) num = num / 10 } res := 0 flag := true for i := len(arr) - 1; i >= 0; i-- { if arr[i] == 6 && flag == true { res = res*10 + 9 flag = false } else { res = res*10 + arr[i] } } return res } # func maximum69Number(num int) int { str := strconv.Itoa(num) str = strings.Replace(str, \"6\", \"9\", 1) res, _ := strconv.Atoi(string(str)) return res } 1331.数组序号转换(2) 题目 给你一个整数数组 arr ，请你将数组中的每个元素替换为它们排序后的序号。 序号代表了一个元素有多大。序号编号的规则如下： 序号从 1 开始编号。 一个元素越大，那么序号越大。如果两个元素相等，那么它们的序号相同。 每个数字的序号都应该尽可能地小。 示例 1：输入：arr = [40,10,20,30] 输出：[4,1,2,3] 解释：40 是最大的元素。 10 是最小的元素。 20 是第二小的数字。 30 是第三小的数字。 示例 2：输入：arr = [100,100,100] 输出：[1,1,1] 解释：所有元素有相同的序号。 示例 3：输入：arr = [37,12,28,9,100,56,80,5,12] 输出：[5,3,4,2,8,6,7,1,3] 提示： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历-哈希辅助 O(nlog(n)) O(n) 02 数组辅助 O(n) O(10^9) func arrayRankTransform(arr []int) []int { temp := make([]int, len(arr)) copy(temp, arr) sort.Ints(temp) m := make(map[int]int) count := 1 for i := 0; i 0 { continue } m[temp[i]] = count count++ } res := make([]int, len(arr)) for i := 0; i = max { max = arr[i] } } length := max - min + 1 temp := make([]int, length) for i := 0; i 1332.删除回文子序列(2) 题目 给你一个字符串 s，它仅由字母 'a' 和 'b' 组成。每一次删除操作都可以从 s 中删除一个回文子序列。 返回删除给定字符串中所有字符（字符串为空）的最小删除次数。 「子序列」定义：如果一个字符串可以通过删除原字符串某些字符而不改变原字符顺序得到， 那么这个字符串就是原字符串的一个子序列。 「回文」定义：如果一个字符串向后和向前读是一致的，那么这个字符串就是一个回文。 示例 1：输入：s = \"ababa\" 输出：1 解释：字符串本身就是回文序列，只需要删除一次。 示例 2：输入：s = \"abb\" 输出：2 解释：\"abb\" -> \"bb\" -> \"\". 先删除回文子序列 \"a\"，然后再删除 \"bb\"。 示例 3：输入：s = \"baabb\" 输出：2 解释：\"baabb\" -> \"b\" -> \"\". 先删除回文子序列 \"baab\"，然后再删除 \"b\"。 示例 4：输入：s = \"\" 输出：0 提示： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n) O(1) 02 反转 O(n) O(n) /* 1.长度为0，返回0 2.字符串为回文子序列，返回1 3.字符串不为回文子序列，返回2，因为可以把a或者b一次都去除，题目没有要求去除的是连续的 */ func removePalindromeSub(s string) int { if len(s) == 0 { return 0 } for i, j := 0, len(s)-1; i = 0; i-- { temp = temp + string(s[i]) } if temp == s { return 1 } return 2 } 1337.方阵中战斗力最弱的K行(2) 题目 给你一个大小为 m * n 的方阵 mat，方阵由若干军人和平民组成，分别用 1 和 0 表示。 请你返回方阵中战斗力最弱的 k 行的索引，按从最弱到最强排序。 如果第 i 行的军人数量少于第 j 行，或者两行军人数量相同但 i 小于 j， 那么我们认为第 i 行的战斗力比第 j 行弱。 军人 总是 排在一行中的靠前位置，也就是说 1 总是出现在 0 之前。 示例 1：输入：mat = [[1,1,0,0,0], [1,1,1,1,0], [1,0,0,0,0], [1,1,0,0,0], [1,1,1,1,1]], k = 3 输出：[2,0,3] 解释： 每行中的军人数目： 行 0 -> 2 行 1 -> 4 行 2 -> 1 行 3 -> 2 行 4 -> 5 从最弱到最强对这些行排序后得到 [2,0,3,1,4] 示例 2：输入：mat = [[1,0,0,0], [1,1,1,1], [1,0,0,0], [1,0,0,0]], k = 2 输出：[0,2] 解释： 每行中的军人数目： 行 0 -> 1 行 1 -> 4 行 2 -> 1 行 3 -> 1 从最弱到最强对这些行排序后得到 [0,2,3,1] 提示： m == mat.length n == mat[i].length 2 解题思路 No. 思路 时间复杂度 空间复杂度 01 加权排序 O(n^2) O(n) 02 自定义排序 O(n^2) O(n) func kWeakestRows(mat [][]int, k int) []int { arr := make([]int, 0) for i := 0; i 1342.将数字变成0的操作次数(3) 题目 给你一个非负整数 num ，请你返回将它变成 0 所需要的步数。 如果当前数字是偶数，你需要把它除以 2 ；否则，减去 1 。 示例 1：输入：num = 14 输出：6 解释： 步骤 1) 14 是偶数，除以 2 得到 7 。 步骤 2） 7 是奇数，减 1 得到 6 。 步骤 3） 6 是偶数，除以 2 得到 3 。 步骤 4） 3 是奇数，减 1 得到 2 。 步骤 5） 2 是偶数，除以 2 得到 1 。 步骤 6） 1 是奇数，减 1 得到 0 。 示例 2：输入：num = 8 输出：4 解释： 步骤 1） 8 是偶数，除以 2 得到 4 。 步骤 2） 4 是偶数，除以 2 得到 2 。 步骤 3） 2 是偶数，除以 2 得到 1 。 步骤 4） 1 是奇数，减 1 得到 0 。 示例 3：输入：num = 123 输出：12 提示： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历模拟 O(log(n)) O(1) 02 递归 O(log(n)) O(log(n)) 02 递归 O(log(n)) O(log(n)) func numberOfSteps(num int) int { res := 0 for num > 0 { if num%2 == 1 { num = num - 1 } else { num = num / 2 } res++ } return res } # var res int func numberOfSteps(num int) int { res = 0 dfs(num) return res } func dfs(num int) { if num != 0 { res++ if num%2 == 1 { dfs(num - 1) } else { dfs(num / 2) } } } # func numberOfSteps(num int) int { if num == 0 { return 0 } else if num%2 == 1 { return 1 + numberOfSteps(num-1) } return 1 + numberOfSteps(num/2) } 1346.检查整数及其两倍数是否存在(3) 题目 给你一个整数数组 arr，请你检查是否存在两个整数 N 和 M，满足 N 是 M 的两倍（即，N = 2 * M）。 更正式地，检查是否存在两个下标 i 和 j 满足： i != j 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法 O(n^2) O(1) 02 哈希辅助 O(n) O(n) 03 排序+二分查找 O(nlog(n)) O(1) func checkIfExist(arr []int) bool { for i := 0; i 0 || (i%2 == 0 && m[arr[i]/2] > 0) { return true } m[arr[i]] = 1 } return false } # func checkIfExist(arr []int) bool { var target int sort.Ints(arr) for i := 0; i = 0 { target = 2 * arr[i] } else { if arr[i]%2 == -1 { continue } target = arr[i] / 2 } for left target { right = mid - 1 } else { left = mid + 1 } } } return false } 1351.统计有序矩阵中的负数(4) 题目 给你一个 m * n 的矩阵 grid，矩阵中的元素无论是按行还是按列，都以非递增顺序排列。 请你统计并返回 grid 中 负数 的数目。 示例 1：输入：grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]] 输出：8 解释：矩阵中共有 8 个负数。 示例 2：输入：grid = [[3,2],[1,0]] 输出：0 示例 3：输入：grid = [[1,-1],[-1,-1]] 输出：3 示例 4：输入：grid = [[-1]] 输出：1 提示： m == grid.length n == grid[i].length 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法 O(n^2) O(1) 02 二分查找 O(nlog(n)) O(1) 03 遍历 O(n^2) O(1) 04 右上角 O(n) O(1) func countNegatives(grid [][]int) int { res := 0 for i := 0; i = 0 { left = mid + 1 } else { right = mid - 1 } } return left } # func countNegatives(grid [][]int) int { res := 0 for i := 0; i = -1; j-- { if j == -1 { res = res + len(grid[i]) break } if grid[i][j] >= 0 { count := len(grid[i]) - 1 - j res = res + count break } } } return res } # func countNegatives(grid [][]int) int { res := 0 i := 0 j := len(grid[0])-1 for i = 0 { if grid[i][j] >=0{ res = res + len(grid[0])-j-1 i++ }else { j-- } } if j 1356.根据数字二进制下1的数目排序(3) 题目 给你一个整数数组 arr 。请你将数组中的元素按照其二进制表示中数字 1 的数目升序排序。 如果存在多个数字二进制中 1 的数目相同，则必须将它们按照数值大小升序排列。 请你返回排序后的数组。 示例 1：输入：arr = [0,1,2,3,4,5,6,7,8] 输出：[0,1,2,4,8,3,5,6,7] 解释：[0] 是唯一一个有 0 个 1 的数。 [1,2,4,8] 都有 1 个 1 。 [3,5,6] 有 2 个 1 。 [7] 有 3 个 1 。 按照 1 的个数排序得到的结果数组为 [0,1,2,4,8,3,5,6,7] 示例 2：输入：arr = [1024,512,256,128,64,32,16,8,4,2,1] 输出：[1,2,4,8,16,32,64,128,256,512,1024] 解释：数组中所有整数二进制下都只有 1 个 1 ，所以你需要按照数值大小将它们排序。 示例 3：输入：arr = [10000,10000] 输出：[10000,10000] 示例 4：输入：arr = [2,3,5,7,11,13,17,19] 输出：[2,3,5,17,7,11,13,19] 示例 5：输入：arr = [10,100,1000,10000] 输出：[10,100,10000,1000] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 自定义排序 O(log(n)^2*n) O(1) 02 排序+分组 O(nlog(n)) O(n) 03 内置函数 O(log(n)^2*n) O(1) func sortByBits(arr []int) []int { sort.Slice(arr, func(i, j int) bool { if countBit(arr[i]) == countBit(arr[j]) { return arr[i] 0 { if num%2 == 1 { res++ } num = num / 2 } return res } # func sortByBits(arr []int) []int { sort.Ints(arr) m := make(map[int][]int, 0) for i := 0; i 0 { if num%2 == 1 { res++ } num = num / 2 } return res } # func sortByBits(arr []int) []int { sort.Slice(arr, func(i, j int) bool { if bits.OnesCount32(uint32(arr[i])) == bits.OnesCount32(uint32(arr[j])) { return arr[i] 1360.日期之间隔几天(2) 题目 请你编写一个程序来计算两个日期之间隔了多少天。 日期以字符串形式给出，格式为 YYYY-MM-DD，如示例所示。 示例 1：输入：date1 = \"2019-06-29\", date2 = \"2019-06-30\" 输出：1 示例 2：输入：date1 = \"2020-01-15\", date2 = \"2019-12-31\" 输出：15 提示： 给定的日期是 1971 年到 2100 年之间的有效日期。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(1) O(1) 02 内置函数 O(1) O(1) func daysBetweenDates(date1 string, date2 string) int { v1 := totalDay(date1) v2 := totalDay(date2) if v1 > v2 { return v1 - v2 } return v2 - v1 } var monthDate = []int{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31} func totalDay(date string) int { var year, month, day int arr := strings.Split(date, \"-\") year, _ = strconv.Atoi(arr[0]) month, _ = strconv.Atoi(arr[1]) day, _ = strconv.Atoi(arr[2]) total := 0 for i := 1971; i 0 { return value } return -value } 1365.有多少小于当前数字的数字(3) 题目 给你一个数组 nums，对于其中每个元素 nums[i]，请你统计数组中比它小的所有数字的数目。 换而言之，对于每个 nums[i] 你必须计算出有效的 j 的数量，其中 j 满足 j != i 且 nums[j] 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(n) 02 暴力法 O(n^2) O(n) 03 排序 O(nlog(n)) O(n) func smallerNumbersThanCurrent(nums []int) []int { arr := make([]int, 101) res := make([]int, len(nums)) for i := 0; i nums[j] { res[i]++ } } } return res } # func smallerNumbersThanCurrent(nums []int) []int { temp := make([]int, len(nums)) copy(temp, nums) sort.Ints(temp) m := make(map[int]int) count := 0 m[temp[0]] = count for i := 1; i 1370.上升下降字符串(2) 题目 给你一个字符串 s ，请你根据下面的算法重新构造字符串： 从 s 中选出 最小 的字符，将它 接在 结果字符串的后面。 从 s 剩余字符中选出 最小 的字符，且该字符比上一个添加的字符大，将它 接在 结果字符串后面。 重复步骤 2 ，直到你没法从 s 中选择字符。 从 s 中选出 最大 的字符，将它 接在 结果字符串的后面。 从 s 剩余字符中选出 最大 的字符，且该字符比上一个添加的字符小，将它 接在 结果字符串后面。 重复步骤 5 ，直到你没法从 s 中选择字符。 重复步骤 1 到 6 ，直到 s 中所有字符都已经被选过。 在任何一步中，如果最小或者最大字符不止一个 ，你可以选择其中任意一个，并将其添加到结果字符串。 请你返回将 s 中字符重新排序后的 结果字符串 。 示例 1：输入：s = \"aaaabbbbcccc\" 输出：\"abccbaabccba\" 解释：第一轮的步骤 1，2，3 后，结果字符串为 result = \"abc\" 第一轮的步骤 4，5，6 后，结果字符串为 result = \"abccba\" 第一轮结束，现在 s = \"aabbcc\" ，我们再次回到步骤 1 第二轮的步骤 1，2，3 后，结果字符串为 result = \"abccbaabc\" 第二轮的步骤 4，5，6 后，结果字符串为 result = \"abccbaabccba\" 示例 2：输入：s = \"rat\" 输出：\"art\" 解释：单词 \"rat\" 在上述算法重排序以后变成 \"art\" 示例 3：输入：s = \"leetcode\" 输出：\"cdelotee\" 示例 4：输入：s = \"ggggggg\" 输出：\"ggggggg\" 示例 5：输入：s = \"spo\" 输出：\"ops\" 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组辅助 O(n) O(n) 02 哈希辅助 O(n) O(n) func sortString(s string) string { arr := make([]int, 26) for i := 0; i 0 { res = res + string(i+'a') arr[i]-- } } for i := 25; i >= 0; i-- { if arr[i] > 0 { res = res + string(i+'a') arr[i]-- } } } return res } # func sortString(s string) string { m := make(map[int]int, 26) for i := 0; i 0 { res = res + string(i+'a') m[i]-- } } for i := 25; i >= 0; i-- { if m[i] > 0 { res = res + string(i+'a') m[i]-- } } } return res } 1374.生成每种字符都是奇数个的字符串(2) 题目 给你一个整数 n，请你返回一个含 n 个字符的字符串，其中每种字符在该字符串中都恰好出现 奇数次 。 返回的字符串必须只含小写英文字母。如果存在多个满足题目要求的字符串，则返回其中任意一个即可。 示例 1：输入：n = 4 输出：\"pppz\" 解释：\"pppz\" 是一个满足题目要求的字符串，因为 'p' 出现 3 次，且 'z' 出现 1 次。 当然，还有很多其他字符串也满足题目要求，比如：\"ohhh\" 和 \"love\"。 示例 2：输入：n = 2 输出：\"xy\" 解释：\"xy\" 是一个满足题目要求的字符串，因为 'x' 和 'y' 各出现 1 次。 当然，还有很多其他字符串也满足题目要求，比如：\"ag\" 和 \"ur\"。 示例 3：输入：n = 7 输出：\"holasss\" 提示：1 解题思路 No. 思路 时间复杂度 空间复杂度 01 奇1偶2 O(n) O(n) 02 奇1偶2 O(n) O(n) func generateTheString(n int) string { if n % 2 == 0 { return strings.Repeat(\"a\", n-1)+\"b\" } return strings.Repeat(\"a\", n) } # func generateTheString(n int) string { res := \"\" if n%2 == 0 { res = \"a\" for i := 0; i 1380.矩阵中的幸运数(2) 题目 给你一个 m * n 的矩阵，矩阵中的数字 各不相同 。请你按 任意 顺序返回矩阵中的所有幸运数。 幸运数是指矩阵中满足同时下列两个条件的元素： 在同一行的所有元素中最小 在同一列的所有元素中最大 示例 1：输入：matrix = [[3,7,8],[9,11,13],[15,16,17]] 输出：[15] 解释：15 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。 示例 2：输入：matrix = [[1,10,4,2],[9,3,8,7],[15,16,17,12]] 输出：[12] 解释：12 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。 示例 3：输入：matrix = [[7,8],[1,2]] 输出：[7] 提示： m == mat.length n == mat[i].length 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n^2) O(n) 02 遍历 O(n^2) O(n) func luckyNumbers(matrix [][]int) []int { res := make([]int, 0) for i := 0; i matrix[i][j] { min = matrix[i][j] minIndex = j } } flag := true for j := 0; j min { flag = false break } } if flag == true { res = append(res, min) } } return res } # func luckyNumbers(matrix [][]int) []int { res := make([]int, 0) minArr := make([]int, 0) maxArr := make([]int, 0) for i := 0; i matrix[i][j] { min = matrix[i][j] } } minArr = append(minArr, min) } for i := 0; i 1385.两个数组间的距离值(2) 题目 给你两个整数数组 arr1 ， arr2 和一个整数 d ，请你返回两个数组之间的 距离值 。 「距离值」 定义为符合此描述的元素数目： 对于元素 arr1[i] ，不存在任何元素 arr2[j] 满足 |arr1[i]-arr2[j]| d=2 |4-9|=5 > d=2 |4-1|=3 > d=2 |4-8|=4 > d=2 对于 arr1[1]=5 我们有： |5-10|=5 > d=2 |5-9|=4 > d=2 |5-1|=4 > d=2 |5-8|=3 > d=2 对于 arr1[2]=8 我们有： |8-10|=2 d=2 |8-8|=0 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n^2) O(1) 02 二分查找 O(nlog(n)) O(1) func findTheDistanceValue(arr1 []int, arr2 []int, d int) int { res := 0 for i := 0; i 1389.按既定顺序创建目标数组(3) 题目 给你两个整数数组 nums 和 index。你需要按照以下规则创建目标数组： 目标数组 target 最初为空。 按从左到右的顺序依次读取 nums[i] 和 index[i]， 在 target 数组中的下标 index[i] 处插入值 nums[i] 。 重复上一步，直到在 nums 和 index 中都没有要读取的元素。 请你返回目标数组。 题目保证数字插入位置总是存在。 示例 1：输入：nums = [0,1,2,3,4], index = [0,1,2,2,1] 输出：[0,4,1,3,2] 解释： nums index target 0 0 [0] 1 1 [0,1] 2 2 [0,1,2] 3 2 [0,1,3,2] 4 1 [0,4,1,3,2] 示例 2：输入：nums = [1,2,3,4,0], index = [0,1,2,3,0] 输出：[0,1,2,3,4] 解释： nums index target 1 0 [1] 2 1 [1,2] 3 2 [1,2,3] 4 3 [1,2,3,4] 0 0 [0,1,2,3,4] 示例 3：输入：nums = [1], index = [0] 输出：[1] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历模拟 O(n^2) O(n) 02 遍历-切片操作 O(n^2) O(n) 03 遍历-定位 O(n^2) O(n) func createTargetArray(nums []int, index []int) []int { res := make([]int, len(nums)) for i := 0; i index[i]; j-- { res[j] = res[j-1] } res[index[i]] = nums[i] } return res } # func createTargetArray(nums []int, index []int) []int { res := make([]int, len(nums)) for i := 0; i = index[i] { index[j]++ } } } for i := 0; i 1394.找出数组中的幸运数(2) 题目 在整数数组中，如果一个整数的出现频次和它的数值大小相等，我们就称这个整数为「幸运数」。 给你一个整数数组 arr，请你从中找出并返回一个幸运数。 如果数组中存在多个幸运数，只需返回 最大 的那个。 如果数组中不含幸运数，则返回 -1 。 示例 1：输入：arr = [2,2,3,4] 输出：2 解释：数组中唯一的幸运数是 2 ，因为数值 2 的出现频次也是 2 。 示例 2：输入：arr = [1,2,2,3,3,3] 输出：3 解释：1、2 以及 3 都是幸运数，只需要返回其中最大的 3 。 示例 3：输入：arr = [2,2,2,3,3] 输出：-1 解释：数组中不存在幸运数。 示例 4：输入：arr = [5] 输出：-1 示例 5：输入：arr = [7,7,7,7,7,7,7] 输出：7 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(n) 02 数组辅助 O(n) O(1) func findLucky(arr []int) int { m := make(map[int]int) for i := 0; i = 1; i-- { if res[i] == i { return i } } return -1 } 1399.统计最大组的数目(2) 题目 给你一个整数 n 。请你先求出从 1 到 n 的每个整数 10 进制表示下的数位和（每一位上的数字相加）， 然后把数位和相等的数字放到同一个组中。 请你统计每个组中的数字数目，并返回数字数目并列最多的组有多少个。 示例 1：输入：n = 13 输出：4 解释：总共有 9 个组，将 1 到 13 按数位求和后这些组分别是： [1,10]，[2,11]，[3,12]，[4,13]，[5]，[6]，[7]，[8]，[9]。总共有 4 个组拥有的数字并列最多。 示例 2：输入：n = 2 输出：2 解释：总共有 2 个大小为 1 的组 [1]，[2]。 示例 3：输入：n = 15 输出：6 示例 4：输入：n = 24 输出：5 提示：1 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(nlog(n)) O(1) 02 数组辅助 O(nlog(n)) O(1) func countLargestGroup(n int) int { if n max { max = m[value] } } res := 0 for i := range m { if m[i] == max { res++ } } return res } func sum(n int) int { res := 0 for n > 0 { res = res + n%10 n = n / 10 } return res } # func countLargestGroup(n int) int { if n max { max = arr[value] } } res := 0 for i := range arr { if arr[i] == max { res++ } } return res } func sum(n int) int { res := 0 for n > 0 { res = res + n%10 n = n / 10 } return res } 1301-1400-Medium 1306.跳跃游戏III(2) 题目 这里有一个非负整数数组 arr，你最开始位于该数组的起始下标 start 处。 当你位于下标 i 处时，你可以跳到 i + arr[i] 或者 i - arr[i]。 请你判断自己是否能够跳到对应元素值为 0 的 任一 下标处。 注意，不管是什么情况下，你都无法跳到数组之外。 示例 1：输入：arr = [4,2,3,0,3,1,2], start = 5 输出：true 解释：到达值为 0 的下标 3 有以下可能方案： 下标 5 -> 下标 4 -> 下标 1 -> 下标 3 下标 5 -> 下标 6 -> 下标 4 -> 下标 1 -> 下标 3 示例 2：输入：arr = [4,2,3,0,3,1,2], start = 0 输出：true 解释：到达值为 0 的下标 3 有以下可能方案： 下标 0 -> 下标 4 -> 下标 1 -> 下标 3 示例 3：输入：arr = [3,0,2,1,2], start = 2 输出：false 解释：无法到达值为 0 的下标 1 处。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 广度优先搜索 O(n) O(n) 02 深度优先搜索 O(n) O(n) func canReach(arr []int, start int) bool { m := make(map[int]bool) queue := make([]int, 0) queue = append(queue, start) for len(queue) > 0 { length := len(queue) for j := 0; j = 0 { if arr[i-arr[i]] == 0 { return true } queue = append(queue, i-arr[i]) } } } queue = queue[length:] } return false } # 2 var m map[int]bool func canReach(arr []int, start int) bool { m = make(map[int]bool) return dfs(arr, start) } func dfs(arr []int, i int) bool { if i len(arr)-1 || m[i] == true { return false } m[i] = true return arr[i] == 0 || dfs(arr, i+arr[i]) || dfs(arr, i-arr[i]) } 1375.灯泡开关III(2) 题目 房间中有 n 枚灯泡，编号从 1 到 n，自左向右排成一排。最初，所有的灯都是关着的。 在 k 时刻（ k 的取值范围是 0 到 n - 1），我们打开 light[k] 这个灯。 灯的颜色要想 变成蓝色 就必须同时满足下面两个条件： 灯处于打开状态。 排在它之前（左侧）的所有灯也都处于打开状态。 请返回能够让 所有开着的 灯都 变成蓝色 的时刻 数目 。 示例 1：输入：light = [2,1,3,5,4] 输出：3 解释：所有开着的灯都变蓝的时刻分别是 1，2 和 4 。 示例 2：输入：light = [3,2,4,1,5] 输出：2 解释：所有开着的灯都变蓝的时刻分别是 3 和 4（index-0）。 示例 3：输入：light = [4,1,2,3] 输出：1 解释：所有开着的灯都变蓝的时刻是 3（index-0）。 第 4 个灯在时刻 3 变蓝。 示例 4：输入：light = [2,1,4,3,6,5] 输出：3 示例 5：输入：light = [1,2,3,4,5,6] 输出：6 提示： n == light.length 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 数学 O(n) O(1) 02 遍历 O(n) O(1) func numTimesAllBlue(light []int) int { res := 0 sum := 0 for i := 0; i b { return a } return b } 1376.通知所有员工所需的时间(3) 题目 公司里有 n 名员工，每个员工的 ID 都是独一无二的，编号从 0 到 n - 1。 公司的总负责人通过 headID 进行标识。 在 manager 数组中，每个员工都有一个直属负责人，其中 manager[i] 是第 i 名员工的直属负责人。 对于总负责人，manager[headID] = -1。题目保证从属关系可以用树结构显示。 公司总负责人想要向公司所有员工通告一条紧急消息。 他将会首先通知他的直属下属们，然后由这些下属通知他们的下属，直到所有的员工都得知这条紧急消息。 第 i 名员工需要 informTime[i] 分钟来通知它的所有直属下属（也就是说在 informTime[i] 分钟后， 他的所有直属下属都可以开始传播这一消息）。 返回通知所有员工这一紧急消息所需要的 分钟数 。 示例 1：输入：n = 1, headID = 0, manager = [-1], informTime = [0] 输出：0 解释：公司总负责人是该公司的唯一一名员工。 示例 2：输入：n = 6, headID = 2, manager = [2,2,-1,2,2,2], informTime = [0,0,1,0,0,0] 输出：1 解释：id = 2 的员工是公司的总负责人，也是其他所有员工的直属负责人，他需要 1 分钟来通知所有员工。 上图显示了公司员工的树结构。 示例 3：输入：n = 7, headID = 6, manager = [1,2,3,4,5,6,-1], informTime = [0,6,5,4,3,2,1] 输出：21 解释：总负责人 id = 6。他将在 1 分钟内通知 id = 5 的员工。 id = 5 的员工将在 2 分钟内通知 id = 4 的员工。 id = 4 的员工将在 3 分钟内通知 id = 3 的员工。 id = 3 的员工将在 4 分钟内通知 id = 2 的员工。 id = 2 的员工将在 5 分钟内通知 id = 1 的员工。 id = 1 的员工将在 6 分钟内通知 id = 0 的员工。 所需时间 = 1 + 2 + 3 + 4 + 5 + 6 = 21 。 示例 4：输入：n = 15, headID = 0, manager = [-1,0,0,1,1,2,2,3,3,4,4,5,5,6,6], informTime = [1,1,1,1,1,1,1,0,0,0,0,0,0,0,0] 输出：3 解释：第一分钟总负责人通知员工 1 和 2 。 第二分钟他们将会通知员工 3, 4, 5 和 6 。 第三分钟他们将会通知剩下的员工。 示例 5：输入：n = 4, headID = 2, manager = [3,3,-1,2], informTime = [0,0,162,914] 输出：1076 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 深度优先搜索 O(n) O(n) 02 遍历 O(n) O(n) 03 广度优先搜索 O(n) O(n) var res int var m map[int][]int func numOfMinutes(n int, headID int, manager []int, informTime []int) int { m = make(map[int][]int) for i := 0; i res { res = cost } return } cost = cost + informTime[headID] for i := 0; i b { return a } return b } # 3 func numOfMinutes(n int, headID int, manager []int, informTime []int) int { res := 0 m := make(map[int][]int) for i := 0; i 0 { id := queue[0] queue = queue[1:] res = max(res, costM[id]) for i := 0; i b { return a } return b } Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 10:50:42 "},"docs/source/question/1401-1500.html":{"url":"docs/source/question/1401-1500.html","title":"1401-1500","keywords":"","body":"1401-1500-Easy 1401-1500-Easy 1403.非递增顺序的最小子序列(2) 1408.数组中的字符串匹配(3) 1413.逐步求和得到正数的最小值(2) 1417.重新格式化字符串(2) 1422.分割字符串的最大得分(3) 1431.拥有最多糖果的孩子(2) 1436.旅行终点站(4) 1441.用栈操作构建数组(2) 1446.连续字符(2) 1450.在既定时间做作业的学生人数(1) 1455.检查单词是否为句中其他单词的前缀(2) 1460.通过翻转子数组使两个数组相等(3) 1464.数组中两元素的最大乘积(3) 1470.重新排列数组(2) 1475.商品折扣后的最终价格(2) 1480.一维数组的动态和(2) 1486.数组异或操作(1) 1491.去掉最低工资和最高工资后的工资平均值(2) 1496.判断路径是否相交(1) 1401-1500-Medium 1418.点菜展示表(1) 1442.形成两个异或相等数组的三元组数目(3) 1487.保证文件名唯一(2) 1492.n的第k个因子(2) 1493.删掉一个元素以后全为 1 的最长子数组(3) 1403.非递增顺序的最小子序列(2) 题目 给你一个数组 nums，请你从中抽取一个子序列，满足该子序列的元素之和 严格 大于未包含在该子序列中的各元素之和。 如果存在多个解决方案，只需返回 长度最小 的子序列。如果仍然有多个解决方案，则返回 元素之和最大 的子序列。 与子数组不同的地方在于，「数组的子序列」不强调元素在原数组中的连续性， 也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。 注意，题目数据保证满足所有约束条件的解决方案是 唯一 的。同时，返回的答案应当按 非递增顺序 排列。 示例 1：输入：nums = [4,3,10,9,8] 输出：[10,9] 解释：子序列 [10,9] 和 [10,8] 是最小的、满足元素之和大于其他各元素之和的子序列。 但是 [10,9] 的元素之和最大。 示例 2：输入：nums = [4,4,7,6,7] 输出：[7,7,6] 解释：子序列 [7,7] 的和为 14 ，不严格大于剩下的其他元素之和（14 = 4 + 4 + 6）。 因此，[7,6,7] 是满足题意的最小子序列。注意，元素按非递增顺序返回。 示例 3：输入：nums = [6] 输出：[6] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序遍历 O(nlog(n)) O(n) 02 排序遍历 O(nlog(n)) O(1) func minSubsequence(nums []int) []int { sort.Ints(nums) sum := 0 for i := 0; i = 0; i-- { if sum nums[j] }) sum := 0 for i := 0; i target { return nums[:i+1] } } return nil } 1408.数组中的字符串匹配(3) 题目 给你一个字符串数组 words ，数组中的每个字符串都可以看作是一个单词。 请你按 任意 顺序返回 words 中是其他单词的子字符串的所有单词。 如果你可以删除 words[j] 最左侧和/或最右侧的若干字符得到 word[i] ， 那么字符串 words[i] 就是 words[j] 的一个子字符串。 示例 1：输入：words = [\"mass\",\"as\",\"hero\",\"superhero\"] 输出：[\"as\",\"hero\"] 解释：\"as\" 是 \"mass\" 的子字符串，\"hero\" 是 \"superhero\" 的子字符串。 [\"hero\",\"as\"] 也是有效的答案。 示例 2：输入：words = [\"leetcode\",\"et\",\"code\"] 输出：[\"et\",\"code\"] 解释：\"et\" 和 \"code\" 都是 \"leetcode\" 的子字符串。 示例 3：输入：words = [\"blue\",\"green\",\"bu\"] 输出：[] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历-内置函数 O(n^3) O(n) 02 遍历-内置函数 O(n^3) O(n) 03 排序 O(n^3) O(n) func stringMatching(words []string) []string { res := make([]string, 0) m := make(map[string]bool) for i := 0; i 1413.逐步求和得到正数的最小值(2) 题目 给你一个整数数组 nums 。你可以选定任意的 正数 startValue 作为初始值。 你需要从左到右遍历 nums 数组，并将 startValue 依次累加上 nums 数组中的值。 请你在确保累加和始终大于等于 1 的前提下，选出一个最小的 正数 作为 startValue 。 示例 1：输入：nums = [-3,2,-3,4,2] 输出：5 解释：如果你选择 startValue = 4，在第三次累加时，和小于 1 。 累加求和 startValue = 4 | startValue = 5 | nums (4 -3 ) = 1 | (5 -3 ) = 2 | -3 (1 +2 ) = 3 | (2 +2 ) = 4 | 2 (3 -3 ) = 0 | (4 -3 ) = 1 | -3 (0 +4 ) = 4 | (1 +4 ) = 5 | 4 (4 +2 ) = 6 | (5 +2 ) = 7 | 2 示例 2：输入：nums = [1,2] 输出：1 解释：最小的 startValue 需要是正数。 示例 3：输入：nums = [1,-2,-3] 输出：5 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 遍历 O(n) O(1) func minStartValue(nums []int) int { min := nums[0] sum := nums[0] for i := 1; i = 0 { return 1 } return 1 - min } # func minStartValue(nums []int) int { res := 1 sum := 0 for i := 0; i 1417.重新格式化字符串(2) 题目 给你一个混合了数字和字母的字符串 s，其中的字母均为小写英文字母。 请你将该字符串重新格式化，使得任意两个相邻字符的类型都不同。 也就是说，字母后面应该跟着数字，而数字后面应该跟着字母。 请你返回 重新格式化后 的字符串；如果无法按要求重新格式化，则返回一个 空字符串 。 示例 1：输入：s = \"a0b1c2\" 输出：\"0a1b2c\" 解释：\"0a1b2c\" 中任意两个相邻字符的类型都不同。 \"a0b1c2\", \"0a1b2c\", \"0c2a1b\" 也是满足题目要求的答案。 示例 2：输入：s = \"leetcode\" 输出：\"\" 解释：\"leetcode\" 中只有字母，所以无法满足重新格式化的条件。 示例 3：输入：s = \"1229857369\" 输出：\"\" 解释：\"1229857369\" 中只有数字，所以无法满足重新格式化的条件。 示例 4：输入：s = \"covid2019\" 输出：\"c2o0v1i9d\" 示例 5：输入：s = \"ab123\" 输出：\"1a2b3\" 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(n) 02 遍历 O(n) O(n) func reformat(s string) string { arr := make([]byte, 0) str := make([]byte, 0) res := \"\" for i := 0; i = '0' && s[i] 1 { return res } else { length := len(arr) if len(str) b { return a - b } return b - a } # func reformat(s string) string { res := make([]byte, 0) m1 := make([]byte, 0) m2 := make([]byte, 0) for i := range s { if s[i] >= '0' && s[i] 1422.分割字符串的最大得分(3) 题目 给你一个由若干 0 和 1 组成的字符串 s ， 请你计算并返回将该字符串分割成两个 非空 子字符串（即 左 子字符串和 右 子字符串）所能获得的最大得分。 「分割字符串的得分」为 左 子字符串中 0 的数量加上 右 子字符串中 1 的数量。 示例 1：输入：s = \"011101\" 输出：5 解释： 将字符串 s 划分为两个非空子字符串的可行方案有： 左子字符串 = \"0\" 且 右子字符串 = \"11101\"，得分 = 1 + 4 = 5 左子字符串 = \"01\" 且 右子字符串 = \"1101\"，得分 = 1 + 3 = 4 左子字符串 = \"011\" 且 右子字符串 = \"101\"，得分 = 1 + 2 = 3 左子字符串 = \"0111\" 且 右子字符串 = \"01\"，得分 = 1 + 1 = 2 左子字符串 = \"01110\" 且 右子字符串 = \"1\"，得分 = 2 + 1 = 3 示例 2：输入：s = \"00111\" 输出：5 解释：当 左子字符串 = \"00\" 且 右子字符串 = \"111\" 时，我们得到最大得分 = 2 + 3 = 5 示例 3：输入：s = \"1111\" 输出：3 提示： 2 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 暴力法 O(n^2) O(1) 03 数组辅助 O(n) O(n) func maxScore(s string) int { one := 0 for i := 0; i max { max = one + zero } } return max } # func maxScore(s string) int { max := 0 for i := 0; i max { max = zero + one } } return max } # func maxScore(s string) int { max := 0 arr := make([]int, len(s)+1) for i := 0; i max { max = v } } return max } 1431.拥有最多糖果的孩子(2) 题目 给你一个数组 candies 和一个整数 extraCandies ，其中 candies[i] 代表第 i 个孩子拥有的糖果数目。 对每一个孩子，检查是否存在一种方案，将额外的 extraCandies 个糖果分配给孩子们之后，此孩子有 最多 的糖果。 注意，允许有多个孩子同时拥有 最多 的糖果数目。 示例 1：输入：candies = [2,3,5,1,3], extraCandies = 3 输出：[true,true,true,false,true] 解释： 孩子 1 有 2 个糖果，如果他得到所有额外的糖果（3个），那么他总共有 5 个糖果，他将成为拥有最多糖果的孩子。 孩子 2 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。 孩子 3 有 5 个糖果，他已经是拥有最多糖果的孩子。 孩子 4 有 1 个糖果，即使他得到所有额外的糖果，他也只有 4 个糖果，无法成为拥有糖果最多的孩子。 孩子 5 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。 示例 2：输入：candies = [4,2,1,1,2], extraCandies = 1 输出：[true,false,false,false,false] 解释：只有 1 个额外糖果，所以不管额外糖果给谁，只有孩子 1 可以成为拥有糖果最多的孩子。 示例 3：输入：candies = [12,1,12], extraCandies = 10 输出：[true,false,true] 提示： 2 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历比较 O(n) O(n) 02 暴力法 O(n^2) O(n) func kidsWithCandies(candies []int, extraCandies int) []bool { res := make([]bool, len(candies)) max := 0 for i := 0; i max { max = candies[i] } } for i := 0; i = max { res[i] = true } } return res } # func kidsWithCandies(candies []int, extraCandies int) []bool { res := make([]bool, len(candies)) for i := 0; i 1436.旅行终点站(4) 题目 给你一份旅游线路图，该线路图中的旅行线路用数组 paths 表示， 其中 paths[i] = [cityAi, cityBi] 表示该线路将会从 cityAi 直接前往 cityBi 。 请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市。 题目数据保证线路图会形成一条不存在循环的线路，因此只会有一个旅行终点站。 示例 1： 输入：paths = [[\"London\",\"New York\"],[\"New York\",\"Lima\"],[\"Lima\",\"Sao Paulo\"]] 输出：\"Sao Paulo\" 解释：从 \"London\" 出发，最后抵达终点站 \"Sao Paulo\" 。 本次旅行的路线是 \"London\" -> \"New York\" -> \"Lima\" -> \"Sao Paulo\" 。 示例 2：输入：paths = [[\"B\",\"C\"],[\"D\",\"B\"],[\"C\",\"A\"]] 输出：\"A\" 解释：所有可能的线路是： \"D\" -> \"B\" -> \"C\" -> \"A\". \"B\" -> \"C\" -> \"A\". \"C\" -> \"A\". \"A\". 显然，旅行终点站是 \"A\" 。 示例 3：输入：paths = [[\"A\",\"Z\"]] 输出：\"Z\" 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(n) 02 哈希辅助 O(n) O(n) 03 出入度计算 O(n) O(n) 04 暴力法 O(n^2) O(1) func destCity(paths [][]string) string { m := make(map[string]string) for i := 0; i 1441.用栈操作构建数组(2) 题目 给你一个目标数组 target 和一个整数 n。每次迭代，需要从 list = {1,2,3..., n} 中依序读取一个数字。 请使用下述操作来构建目标数组 target ： Push：从 list 中读取一个新元素， 并将其推入数组中。 Pop：删除数组中的最后一个元素。 如果目标数组构建完成，就停止读取更多元素。 题目数据保证目标数组严格递增，并且只包含 1 到 n 之间的数字。 请返回构建目标数组所用的操作序列。 题目数据保证答案是唯一的。 示例 1：输入：target = [1,3], n = 3 输出：[\"Push\",\"Push\",\"Pop\",\"Push\"] 解释： 读取 1 并自动推入数组 -> [1] 读取 2 并自动推入数组，然后删除它 -> [1] 读取 3 并自动推入数组 -> [1,3] 示例 2：输入：target = [1,2,3], n = 3 输出：[\"Push\",\"Push\",\"Push\"] 示例 3：输入：target = [1,2], n = 4 输出：[\"Push\",\"Push\"] 解释：只需要读取前 2 个数字就可以停止。 示例 4：输入：target = [2,3,4], n = 4 输出：[\"Push\",\"Pop\",\"Push\",\"Push\",\"Push\"] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n) O(n) 02 双指针 O(n) O(n) func buildArray(target []int, n int) []string { res := make([]string, 0) j := 0 for i := 1; i = len(target) { break } if target[j] != i { res = append(res, \"Push\") res = append(res, \"Pop\") } else { res = append(res, \"Push\") j++ } } return res } # func buildArray(target []int, n int) []string { res := make([]string, 0) j := 1 for i := 0; i 1446.连续字符(2) 题目 给你一个字符串 s ，字符串的「能量」定义为：只包含一种字符的最长非空子字符串的长度。 请你返回字符串的能量。 示例 1：输入：s = \"leetcode\" 输出：2 解释：子字符串 \"ee\" 长度为 2 ，只包含字符 'e' 。 示例 2：输入：s = \"abbcccddddeeeeedcba\" 输出：5 解释：子字符串 \"eeeee\" 长度为 5 ，只包含字符 'e' 。 示例 3：输入：s = \"triplepillooooow\" 输出：5 示例 4：输入：s = \"hooraaaaaaaaaaay\" 输出：11 示例 5：输入：s = \"tourist\" 输出：1 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 双指针 O(n) O(1) func maxPower(s string) int { max := 1 count := 1 for i := 1; i max { max = count } } return max } # func maxPower(s string) int { max := 1 left := 0 right := 1 for right max { max = right - left } left = right } right++ } if right-left > max { return right - left } return max } 1450.在既定时间做作业的学生人数(1) 题目 给你两个整数数组 startTime（开始时间）和 endTime（结束时间），并指定一个整数 queryTime 作为查询时间。 已知，第 i 名学生在 startTime[i] 时开始写作业并于 endTime[i] 时完成作业。 请返回在查询时间 queryTime 时正在做作业的学生人数。 形式上，返回能够使 queryTime 处于区间 [startTime[i], endTime[i]]（含）的学生人数。 示例 1：输入：startTime = [1,2,3], endTime = [3,2,7], queryTime = 4 输出：1 解释：一共有 3 名学生。 第一名学生在时间 1 开始写作业，并于时间 3 完成作业，在时间 4 没有处于做作业的状态。 第二名学生在时间 2 开始写作业，并于时间 2 完成作业，在时间 4 没有处于做作业的状态。 第三名学生在时间 3 开始写作业，预计于时间 7 完成作业，这是是唯一一名在时间 4 时正在做作业的学生。 示例 2：输入：startTime = [4], endTime = [4], queryTime = 4 输出：1 解释：在查询时间只有一名学生在做作业。 示例 3：输入：startTime = [4], endTime = [4], queryTime = 5 输出：0 示例 4：输入：startTime = [1,1,1,1], endTime = [1,3,2,4], queryTime = 7 输出：0 示例 5：输入：startTime = [9,8,7,6,5,4,3,2,1], endTime = [10,10,10,10,10,10,10,10,10], queryTime = 5 输出：5 提示： startTime.length == endTime.length 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) func busyStudent(startTime []int, endTime []int, queryTime int) int { res := 0 for i := 0; i = startTime[i] && queryTime 1455.检查单词是否为句中其他单词的前缀(2) 题目 给你一个字符串 sentence 作为句子并指定检索词为 searchWord ，其中句子由若干用 单个空格 分隔的单词组成。 请你检查检索词 searchWord 是否为句子 sentence 中任意单词的前缀。 如果 searchWord 是某一个单词的前缀，则返回句子 sentence 中该单词所对应的下标（下标从 1 开始）。 如果 searchWord 是多个单词的前缀，则返回匹配的第一个单词的下标（最小下标）。 如果 searchWord 不是任何单词的前缀，则返回 -1 。 字符串 S 的 「前缀」是 S 的任何前导连续子字符串。 示例 1：输入：sentence = \"i love eating burger\", searchWord = \"burg\" 输出：4 解释：\"burg\" 是 \"burger\" 的前缀，而 \"burger\" 是句子中第 4 个单词。 示例 2：输入：sentence = \"this problem is an easy problem\", searchWord = \"pro\" 输出：2 解释：\"pro\" 是 \"problem\" 的前缀，而 \"problem\" 是句子中第 2 个也是第 6 个单词， 但是应该返回最小下标 2 。 示例 3：输入：sentence = \"i am tired\", searchWord = \"you\" 输出：-1 解释：\"you\" 不是句子中任何单词的前缀。 示例 4：输入：sentence = \"i use triple pillow\", searchWord = \"pill\" 输出：4 示例 5：输入：sentence = \"hello from the other side\", searchWord = \"they\" 输出：-1 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(n) 02 遍历 O(n) O(n) func isPrefixOfWord(sentence string, searchWord string) int { arr := strings.Split(sentence, \" \") for k, v := range arr { if strings.HasPrefix(v, searchWord) { return k + 1 } } return -1 } # func isPrefixOfWord(sentence string, searchWord string) int { arr := strings.Fields(sentence) for k, v := range arr { if len(v) >= len(searchWord) { if v[:len(searchWord)] == searchWord { return k + 1 } } } return -1 } 1460.通过翻转子数组使两个数组相等(3) 题目 给你两个长度相同的整数数组 target 和 arr 。 每一步中，你可以选择 arr 的任意 非空子数组 并将它翻转。你可以执行此过程任意次。 如果你能让 arr 变得与 target 相同，返回 True；否则，返回 False 。 示例 1：输入：target = [1,2,3,4], arr = [2,4,1,3] 输出：true 解释：你可以按照如下步骤使 arr 变成 target： 1- 翻转子数组 [2,4,1] ，arr 变成 [1,4,2,3] 2- 翻转子数组 [4,2] ，arr 变成 [1,2,4,3] 3- 翻转子数组 [4,3] ，arr 变成 [1,2,3,4] 上述方法并不是唯一的，还存在多种将 arr 变成 target 的方法。 示例 2：输入：target = [7], arr = [7] 输出：true 解释：arr 不需要做任何翻转已经与 target 相等。 示例 3：输入：target = [1,12], arr = [12,1] 输出：true 示例 4：输入：target = [3,7,9], arr = [3,7,11] 输出：false 解释：arr 没有数字 9 ，所以无论如何也无法变成 target 。 示例 5：输入：target = [1,1,1,1,1], arr = [1,1,1,1,1] 输出：true 提示： target.length == arr.length 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序遍历 O(nlog(n)) O(1) 02 数组辅助 O(n) O(1) 03 哈希辅助 O(n) O(1) func canBeEqual(target []int, arr []int) bool { sort.Ints(target) sort.Ints(arr) for i := 0; i 1464.数组中两元素的最大乘积(3) 题目 给你一个整数数组 nums，请你选择数组的两个不同下标 i 和 j，使 (nums[i]-1)*(nums[j]-1) 取得最大值。 请你计算并返回该式的最大值。 示例 1：输入：nums = [3,4,5,2] 输出：12 解释：如果选择下标 i=1 和 j=2（下标从 0 开始），则可以获得最大值， (nums[1]-1)*(nums[2]-1) = (4-1)*(5-1) = 3*4 = 12 。 示例 2：输入：nums = [1,5,4,5] 输出：16 解释：选择下标 i=1 和 j=3（下标从 0 开始），则可以获得最大值 (5-1)*(5-1) = 16 。 示例 3：输入：nums = [3,7] 输出：12 提示： 2 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序遍历 O(nlog(n)) O(1) 02 遍历 O(n) O(1) 03 暴力法 O(n^2) O(1) func maxProduct(nums []int) int { sort.Ints(nums) return (nums[len(nums)-1] - 1) * (nums[len(nums)-2] - 1) } # func maxProduct(nums []int) int { max := math.MinInt32 next := math.MinInt32 for i := 0; i max { next, max = max, nums[i] } else if nums[i] > next { next = nums[i] } } return (max - 1) * (next - 1) } # func maxProduct(nums []int) int { res := 0 for i := 0; i res { res = (nums[i] - 1) * (nums[j] - 1) } } } return res } 1470.重新排列数组(2) 题目 给你一个数组 nums ，数组中有 2n 个元素，按 [x1,x2,...,xn,y1,y2,...,yn] 的格式排列。 请你将数组按 [x1,y1,x2,y2,...,xn,yn] 格式重新排列，返回重排后的数组。 示例 1：输入：nums = [2,5,1,3,4,7], n = 3 输出：[2,3,5,4,1,7] 解释：由于 x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 ，所以答案为 [2,3,5,4,1,7] 示例 2：输入：nums = [1,2,3,4,4,3,2,1], n = 4 输出：[1,4,2,3,3,2,4,1] 示例 3：输入：nums = [1,1,2,2], n = 2 输出：[1,2,1,2] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组辅助 O(n) O(n) 02 前移遍历 O(n^1) O(1) func shuffle(nums []int, n int) []int { res := make([]int,0) for i := 0; i 1475.商品折扣后的最终价格(2) 题目 给你一个数组 prices ，其中 prices[i] 是商店里第 i 件商品的价格。 商店里正在进行促销活动，如果你要买第 i 件商品，那么你可以得到与 prices[j] 相等的折扣， 其中 j 是满足 j > i 且 prices[j] 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历模拟 O(n^2) O(1) 02 栈 O(n) O(n) func finalPrices(prices []int) []int { for i := 0; i 0 { index := stack[len(stack)-1] if prices[i] > prices[index] { break } prices[index] = prices[index] - prices[i] stack = stack[:len(stack)-1] } stack = append(stack, i) } return prices } 1480.一维数组的动态和(2) 题目 给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。 请返回 nums 的动态和。 示例 1：输入：nums = [1,2,3,4] 输出：[1,3,6,10] 解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。 示例 2：输入：nums = [1,1,1,1,1] 输出：[1,2,3,4,5] 解释：动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。 示例 3：输入：nums = [3,1,2,10,1] 输出：[3,4,6,16,17] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 数组辅助 O(n) O(n) func runningSum(nums []int) []int { for i := 1; i 1486.数组异或操作(1) 题目 给你两个整数，n 和 start 。 数组 nums 定义为：nums[i] = start + 2*i（下标从 0 开始）且 n == nums.length 。 请返回 nums 中所有元素按位异或（XOR）后得到的结果。 示例 1：输入：n = 5, start = 0 输出：8 解释：数组 nums 为 [0, 2, 4, 6, 8]，其中 (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8 。 \"^\" 为按位异或 XOR 运算符。 示例 2：输入：n = 4, start = 3 输出：8 解释：数组 nums 为 [3, 5, 7, 9]，其中 (3 ^ 5 ^ 7 ^ 9) = 8. 示例 3：输入：n = 1, start = 7 输出：7 示例 4：输入：n = 10, start = 5 输出：2 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) func xorOperation(n int, start int) int { res := 0 for i := 0; i 1491.去掉最低工资和最高工资后的工资平均值(2) 题目 给你一个整数数组 salary ，数组里每个数都是 唯一 的，其中 salary[i] 是第 i 个员工的工资。 请你返回去掉最低工资和最高工资以后，剩下员工工资的平均值。 示例 1：输入：salary = [4000,3000,1000,2000] 输出：2500.00000 解释：最低工资和最高工资分别是 1000 和 4000 。 去掉最低工资和最高工资以后的平均工资是 (2000+3000)/2= 2500 示例 2：输入：salary = [1000,2000,3000] 输出：2000.00000 解释：最低工资和最高工资分别是 1000 和 3000 。 去掉最低工资和最高工资以后的平均工资是 (2000)/1= 2000 示例 3：输入：salary = [6000,5000,4000,3000,2000,1000] 输出：3500.00000 示例 4：输入：salary = [8000,9000,2000,3000,6000,1000] 输出：4750.00000 提示： 3 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序遍历 O(nlog(n)) O(1) 02 遍历 O(n) O(1) func average(salary []int) float64 { sort.Ints(salary) sum := 0 for i := 1; i max { max = salary[i] } if salary[i] 1496.判断路径是否相交(1) 题目 给你一个字符串 path，其中 path[i] 的值可以是 'N'、'S'、'E' 或者 'W'， 分别表示向北、向南、向东、向西移动一个单位。 机器人从二维平面上的原点 (0, 0) 处开始出发，按 path 所指示的路径行走。 如果路径在任何位置上出现相交的情况，也就是走到之前已经走过的位置，请返回 True ；否则，返回 False 。 示例 1：输入：path = \"NES\" 输出：false 解释：该路径没有在任何位置相交。 示例 2：输入：path = \"NESWW\" 输出：true 解释：该路径经过原点两次。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(n) func isPathCrossing(path string) bool { m := make(map[string]bool) m[\"0,0\"] = true x := 0 y := 0 for i := 0; i 1401-1500-Medium 1418.点菜展示表(1) 题目 给你一个数组 orders，表示客户在餐厅中完成的订单，确切地说， orders[i]=[customerNamei,tableNumberi,foodItemi] ，其中 customerNamei 是客户的姓名， tableNumberi 是客户所在餐桌的桌号，而 foodItemi 是客户点的餐品名称。 请你返回该餐厅的 点菜展示表 。在这张表中，表中第一行为标题，其第一列为餐桌桌号 “Table” ， 后面每一列都是按字母顺序排列的餐品名称。 接下来每一行中的项则表示每张餐桌订购的相应餐品数量，第一列应当填对应的桌号，后面依次填写下单的餐品数量。 注意：客户姓名不是点菜展示表的一部分。此外，表中的数据行应该按餐桌桌号升序排列。 示例 1： 输入：orders = [[\"David\",\"3\",\"Ceviche\"],[\"Corina\",\"10\",\"Beef Burrito\"], [\"David\",\"3\",\"Fried Chicken\"],[\"Carla\",\"5\",\"Water\"], [\"Carla\",\"5\",\"Ceviche\"],[\"Rous\",\"3\",\"Ceviche\"]] 输出：[[\"Table\",\"Beef Burrito\",\"Ceviche\",\"Fried Chicken\",\"Water\"], [\"3\",\"0\",\"2\",\"1\",\"0\"],[\"5\",\"0\",\"1\",\"0\",\"1\"],[\"10\",\"1\",\"0\",\"0\",\"0\"]] 解释：点菜展示表如下所示： Table,Beef Burrito,Ceviche,Fried Chicken,Water 3 ,0 ,2 ,1 ,0 5 ,0 ,1 ,0 ,1 10 ,1 ,0 ,0 ,0 对于餐桌 3：David 点了 \"Ceviche\" 和 \"Fried Chicken\"，而 Rous 点了 \"Ceviche\" 而餐桌 5：Carla 点了 \"Water\" 和 \"Ceviche\" 餐桌 10：Corina 点了 \"Beef Burrito\" 示例 2：输入：orders = [[\"James\",\"12\",\"Fried Chicken\"],[\"Ratesh\",\"12\",\"Fried Chicken\"], [\"Amadeus\",\"12\",\"Fried Chicken\"],[\"Adam\",\"1\",\"Canadian Waffles\"], [\"Brianna\",\"1\",\"Canadian Waffles\"]] 输出：[[\"Table\",\"Canadian Waffles\",\"Fried Chicken\"],[\"1\",\"2\",\"0\"],[\"12\",\"0\",\"3\"]] 解释：对于餐桌 1：Adam 和 Brianna 都点了 \"Canadian Waffles\" 而餐桌 12：James, Ratesh 和 Amadeus 都点了 \"Fried Chicken\" 示例 3： 输入：orders = [[\"Laura\",\"2\",\"Bean Burrito\"],[\"Jhon\",\"2\",\"Beef Burrito\"],[\"Melissa\",\"2\",\"Soda\"]] 输出：[[\"Table\",\"Bean Burrito\",\"Beef Burrito\",\"Soda\"],[\"2\",\"1\",\"1\",\"1\"]] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(nlog(n)) O(n) func displayTable(orders [][]string) [][]string { res := make([][]string, 0) titles := make([]string, 0) idArr := make([]int, 0) m := make(map[string]bool) m2 := make(map[string]map[string]int) for i := 0; i 1442.形成两个异或相等数组的三元组数目(3) 题目 给你一个整数数组 arr 。 现需要从数组中取三个下标 i、j 和 k ，其中 (0 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法 O(n^3) O(1) 02 遍历 O(n^2) O(1) 03 哈希辅助 O(n) O(n) func countTriplets(arr []int) int { res := 0 for i := 1; i 0 { // 相同异或结果，分别出现在下标[a,b,c,d] // 则[a,d]有d-a-1个满足条件的 // sum = (d-a-1)+(d-b-1)+(d-c-1) // ==> nd - [(a+1) + (b+1) + (c+1)] // 同理得[a,b], [a,c] res = res + i*countM[temp] - sumM[temp] } countM[temp]++ sumM[temp] = sumM[temp] + (i + 1) } return res } 1487.保证文件名唯一(2) 题目 给你一个长度为 n 的字符串数组 names 。 你将会在文件系统中创建 n 个文件夹：在第 i 分钟，新建名为 names[i] 的文件夹。 由于两个文件 不能 共享相同的文件名，因此如果新建文件夹使用的文件名已经被占用， 系统会以 (k) 的形式为新文件夹的文件名添加后缀，其中 k 是能保证文件名唯一的 最小正整数 。 返回长度为 n 的字符串数组，其中 ans[i] 是创建第 i 个文件夹时系统分配给该文件夹的实际名称。 示例 1： 输入：names = [\"pes\",\"fifa\",\"gta\",\"pes(2019)\"] 输出：[\"pes\",\"fifa\",\"gta\",\"pes(2019)\"] 解释：文件系统将会这样创建文件名： \"pes\" --> 之前未分配，仍为 \"pes\" \"fifa\" --> 之前未分配，仍为 \"fifa\" \"gta\" --> 之前未分配，仍为 \"gta\" \"pes(2019)\" --> 之前未分配，仍为 \"pes(2019)\" 示例 2： 输入：names = [\"gta\",\"gta(1)\",\"gta\",\"avalon\"] 输出：[\"gta\",\"gta(1)\",\"gta(2)\",\"avalon\"] 解释：文件系统将会这样创建文件名： \"gta\" --> 之前未分配，仍为 \"gta\" \"gta(1)\" --> 之前未分配，仍为 \"gta(1)\" \"gta\" --> 文件名被占用，系统为该名称添加后缀 (k)，由于 \"gta(1)\" 也被占用，所以 k = 2 。 实际创建的文件名为 \"gta(2)\" 。 \"avalon\" --> 之前未分配，仍为 \"avalon\" 示例 3： 输入：names = [\"onepiece\",\"onepiece(1)\",\"onepiece(2)\",\"onepiece(3)\",\"onepiece\"] 输出：[\"onepiece\",\"onepiece(1)\",\"onepiece(2)\",\"onepiece(3)\",\"onepiece(4)\"] 解释：当创建最后一个文件夹时，最小的正有效 k 为 4 ，文件名变为 \"onepiece(4)\"。 示例 4： 输入：names = [\"wano\",\"wano\",\"wano\",\"wano\"] 输出：[\"wano\",\"wano(1)\",\"wano(2)\",\"wano(3)\"] 解释：每次创建文件夹 \"wano\" 时，只需增加后缀中 k 的值即可。 示例 5： 输入：names = [\"kaido\",\"kaido(1)\",\"kaido\",\"kaido(1)\"] 输出：[\"kaido\",\"kaido(1)\",\"kaido(2)\",\"kaido(1)(1)\"] 解释：注意，如果含后缀文件名被占用，那么系统也会按规则在名称后添加新的后缀 (k) 。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助-递归 O(n) O(n) 02 哈希辅助 O(n) O(n) func getFolderNames(names []string) []string { m := make(map[string]int) for i, name := range names { if value, ok := m[name]; ok { names[i] = getName(m, name, value) m[names[i]] = 1 } else { m[name] = 1 } } return names } func getName(m map[string]int, name string, n int) string { newName := name + fmt.Sprintf(\"(%d)\", n) if _, ok := m[newName]; ok { return getName(m, name, n+1) } m[name] = n + 1 return newName } # func getFolderNames(names []string) []string { m := make(map[string]int) res := make([]string, 0) for _, name := range names { if value, ok := m[name]; ok { for { newName := name + fmt.Sprintf(\"(%d)\", value) if _, ok2 := m[newName]; ok2 { value++ continue } res = append(res, newName) m[newName] = 1 m[name] = value break } } else { res = append(res, name) m[name] = 1 } } return res } 1492.n的第k个因子(2) 题目 给你两个正整数 n 和 k 。 如果正整数 i 满足 n % i == 0 ，那么我们就说正整数 i 是整数 n 的因子。 考虑整数 n 的所有因子，将它们 升序排列 。请你返回第 k 个因子。如果 n 的因子数少于 k ，请你返回 -1 。 示例 1：输入：n = 12, k = 3输出：3 解释：因子列表包括 [1, 2, 3, 4, 6, 12]，第 3 个因子是 3 。 示例 2：输入：n = 7, k = 2 输出：7 解释：因子列表包括 [1, 7] ，第 2 个因子是 7 。 示例 3：输入：n = 4, k = 4 输出：-1 解释：因子列表包括 [1, 2, 4] ，只有 3 个因子，所以我们应该返回 -1 。 示例 4：输入：n = 1, k = 1 输出：1 解释：因子列表包括 [1] ，第 1 个因子为 1 。 示例 5：输入：n = 1000, k = 3 输出：4 解释：因子列表包括 [1, 2, 4, 5, 8, 10, 20, 25, 40, 50, 100, 125, 200, 250, 500, 1000] 。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 遍历 O(n^1/2) O(1) func kthFactor(n int, k int) int { count := 0 for i := 1; i 0; i-- { if n%i == 0 { count++ if count == k { return n / i } } } return -1 } 1493.删掉一个元素以后全为 1 的最长子数组(3) 题目 给你一个二进制数组 nums ，你需要从中删掉一个元素。 请你在删掉元素的结果数组中，返回最长的且只包含 1 的非空子数组的长度。 如果不存在这样的子数组，请返回 0 。 提示 1：输入：nums = [1,1,0,1] 输出：3 解释：删掉位置 2 的数后，[1,1,1] 包含 3 个 1 。 示例 2：输入：nums = [0,1,1,1,0,1,1,0,1] 输出：5 解释：删掉位置 4 的数字后，[0,1,1,1,1,1,0,1] 的最长全 1 子数组为 [1,1,1,1,1] 。 示例 3：输入：nums = [1,1,1] 输出：2 解释：你必须要删除一个元素。 示例 4：输入：nums = [1,1,0,0,1,1,1,0,1] 输出：4 示例 5：输入：nums = [0,0,0] 输出：0 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组辅助 O(n) O(n) 02 遍历 O(n) O(1) 03 数组辅助 O(n) O(n) func longestSubarray(nums []int) int { n := len(nums) pre := make([]int, n) suf := make([]int, n) pre[0] = nums[0] for i := 1; i = 0; i-- { if nums[i] == 1 { suf[i] = suf[i+1] + 1 } else { suf[i] = 0 } } res := 0 for i := 0; i res { res = p + s } } return res } # func longestSubarray(nums []int) int { res := 0 p, q := 0, 0 // q=>中间有一个“非1”的和, p=>连续1的和 for i := 0; i res { res = q } } if res == len(nums) { return res - 1 } return res } # func longestSubarray(nums []int) int { arr := make([]int, 0) count := 0 for _, v := range nums { if v == 0 { arr = append(arr, count) count = 0 continue } count++ } arr = append(arr, count) if len(arr) == 1 { return arr[0] - 1 } res := 0 for i := 0; i res { res = arr[i] + arr[i+1] } } return res } Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 10:59:22 "},"docs/source/question/1501-1600.html":{"url":"docs/source/question/1501-1600.html","title":"1501-1600","keywords":"","body":"1501-1600-Easy 1501-1600-Easy 1502.判断能否形成等差数列(2) 1507.转变日期格式(1) 1512.好数对的数目(3) 1518.换酒问题(2) 1523.在区间范围内统计奇数数目(2) 1528.重新排列字符串(1) 1534.统计好三元组(2) 1539.第k个缺失的正整数(3) 1544.整理字符串(1) 1550.存在连续三个奇数的数组(2) 1556.千位分隔数(1) 1560.圆形赛道上经过次数最多的扇区(2) 1566.重复至少K次且长度为M的模式(2) 1572.矩阵对角线元素的和(2) 1576.替换所有的问号(1) 1501-1600-Medium 1503.所有蚂蚁掉下来前的最后一刻(2) 1508.子数组和排序后的区间和(1) 1509.三次操作后最大值与最小值的最小差(2) 1513.仅含1的子串数(2) 1514.概率最大的路径 题目 解题思路 1525.字符串的好分割数目(2) 1529.灯泡开关IV(2) 1541.平衡括号字符串的最少插入次数(2) 1545.找出第N个二进制字符串中的第K位(2) 1546.和为目标值的最大数目不重叠非空子数组数目(2) 1551.使数组中所有元素相等的最小操作数(3) 1552.两球之间的磁力(2) 1557.可以到达所有点的最少点数目(2) 1558.得到目标数组的最少函数调用次数(2) 1561.你可以获得的最大硬币数目(3) 1562.查找大小为M的最新分组(2) 1567.乘积为正数的最长子数组长度(2) 1568.使陆地分离的最少天数(1) 1573.分割字符串的方案数(2) 1574.删除最短的子数组使剩余数组有序(1) 1501-1600-Hard 1510.石子游戏IV(1) 1526.形成目标数组的子数组最少增加次数(1) 1553.吃掉N个橘子的最少天数(2) 1559.二维网格图中探测环(1) 1563.石子游戏V(2) 1502.判断能否形成等差数列(2) 题目 给你一个数字数组 arr 。 如果一个数列中，任意相邻两项的差总等于同一个常数，那么这个数列就称为 等差数列 。 如果可以重新排列数组形成等差数列，请返回 true ；否则，返回 false 。 示例 1：输入：arr = [3,5,1] 输出：true 解释：对数组重新排序得到 [1,3,5] 或者 [5,3,1] ，任意相邻两项的差分别为 2 或 -2 ，可以形成等差数列。 示例 2：输入：arr = [1,2,4] 输出：false 解释：无法通过重新排序得到等差数列。 提示： 2 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序遍历 O(nlog(n)) O(1) 02 哈希辅助 O(n) O(n) func canMakeArithmeticProgression(arr []int) bool { sort.Ints(arr) diff := arr[1] - arr[0] for i := 2; i = max { max = arr[i] } m[arr[i]] = true } diff := (max - min) / (len(arr) - 1) for i := 0; i 1507.转变日期格式(1) 题目 给你一个字符串 date ，它的格式为 Day Month Year ，其中： Day 是集合 {\"1st\", \"2nd\", \"3rd\", \"4th\", ..., \"30th\", \"31st\"} 中的一个元素。 Month 是集合 {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"} 中的一个元素。 Year 的范围在 [1900, 2100] 之间。 请你将字符串转变为 YYYY-MM-DD 的格式，其中： YYYY 表示 4 位的年份。 MM 表示 2 位的月份。 DD 表示 2 位的天数。 示例 1：输入：date = \"20th Oct 2052\" 输出：\"2052-10-20\" 示例 2：输入：date = \"6th Jun 1933\" 输出：\"1933-06-06\" 示例 3：输入：date = \"26th May 1960\" 输出：\"1960-05-26\" 提示： 给定日期保证是合法的，所以不需要处理异常输入。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历-内置函数 O(n) O(n) func reformatDate(date string) string { month := []string{\"\", \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"} arr := strings.Split(date, \" \") res := arr[2] + \"-\" for i := 1; i = '0' && arr[0][1] 1512.好数对的数目(3) 题目 给你一个整数数组 nums 。 如果一组数字 (i,j) 满足 nums[i] == nums[j] 且 i 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n^2) O(1) 02 数组辅助 O(n) O(1) 03 哈希辅助 O(n) O(1) func numIdenticalPairs(nums []int) int { res := 0 for i := 0; i 0 { res = res + v*(v-1)/2 } } return res } 1518.换酒问题(2) 题目 小区便利店正在促销，用 numExchange 个空酒瓶可以兑换一瓶新酒。你购入了 numBottles 瓶酒。 如果喝掉了酒瓶中的酒，那么酒瓶就会变成空的。 请你计算 最多 能喝到多少瓶酒。 示例 1：输入：numBottles = 9, numExchange = 3 输出：13 解释：你可以用 3 个空酒瓶兑换 1 瓶酒。 所以最多能喝到 9 + 3 + 1 = 13 瓶酒。 示例 2：输入：numBottles = 15, numExchange = 4 输出：19 解释：你可以用 4 个空酒瓶兑换 1 瓶酒。 所以最多能喝到 15 + 3 + 1 = 19 瓶酒。 示例 3：输入：numBottles = 5, numExchange = 5 输出：6 示例 4：输入：numBottles = 2, numExchange = 3 输出：2 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(log(n)) O(1) 02 计算 O(1) O(1) func numWaterBottles(numBottles int, numExchange int) int { res := numBottles for numBottles > 0 { times := numBottles / numExchange res = res + times numBottles = numBottles%numExchange + times if numBottles 1523.在区间范围内统计奇数数目(2) 题目 给你两个非负整数 low 和 high 。请你返回 low 和 high 之间（包括二者）奇数的数目。 示例 1：输入：low = 3, high = 7 输出：3 解释：3 到 7 之间奇数数字为 [3,5,7] 。 示例 2：输入：low = 8, high = 10输出：1 解释：8 到 10 之间奇数数字为 [9] 。 提示：0 解题思路 No. 思路 时间复杂度 空间复杂度 01 数学 O(1) O(1) 02 数学 O(1) O(1) func countOdds(low int, high int) int { if low%2 == 1 { low = low - 1 } if high%2 == 1 { high = high + 1 } return (high - low) / 2 } # func countOdds(low int, high int) int { if low%2 == 0 && high%2 == 0 { return (high - low) / 2 } return (high-low)/2 + 1 } 1528.重新排列字符串(1) 题目 给你一个字符串 s 和一个 长度相同 的整数数组 indices 。 请你重新排列字符串 s ，其中第 i 个字符需要移动到 indices[i] 指示的位置。 返回重新排列后的字符串。 示例 1：输入：s = \"codeleet\", indices = [4,5,6,7,0,2,1,3] 输出：\"leetcode\" 解释：如图所示，\"codeleet\" 重新排列后变为 \"leetcode\" 。 示例 2：输入：s = \"abc\", indices = [0,1,2] 输出：\"abc\" 解释：重新排列后，每个字符都还留在原来的位置上。 示例 3：输入：s = \"aiohn\", indices = [3,1,4,2,0] 输出：\"nihao\" 示例 4：输入：s = \"aaiougrt\", indices = [4,0,2,6,7,3,1,5]输出：\"arigatou\" 示例 5：输入：s = \"art\", indices = [1,0,2] 输出：\"rat\" 提示： s.length == indices.length == n 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(n) func restoreString(s string, indices []int) string { arr := []byte(s) res := make([]byte, len(s)) for i := 0; i 1534.统计好三元组(2) 题目 给你一个整数数组 arr ，以及 a、b 、c 三个整数。请你统计其中好三元组的数量。 如果三元组 (arr[i], arr[j], arr[k]) 满足下列全部条件，则认为它是一个 好三元组 。 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法 O(n^3) O(1) 02 遍历 O(n^3) O(1) func countGoodTriplets(arr []int, a int, b int, c int) int { res := 0 for i := 0; i b { return a - b } return b - a } # func countGoodTriplets(arr []int, a int, b int, c int) int { res := 0 for i := 0; i a { continue } for k := j + 1; k b { return a - b } return b - a } 1539.第k个缺失的正整数(3) 题目 给你一个 严格升序排列 的正整数数组 arr 和一个整数 k 。 请你找到这个数组里第 k 个缺失的正整数。 示例 1：输入：arr = [2,3,4,7,11], k = 5 输出：9 解释：缺失的正整数包括 [1,5,6,8,9,10,12,13,...] 。第 5 个缺失的正整数为 9 。 示例 2：输入：arr = [1,2,3,4], k = 2 输出：6 解释：缺失的正整数包括 [5,6,7,...] 。第 2 个缺失的正整数为 6 。 提示：1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 遍历 O(n) O(1) 03 二分查找 O(log(n)) O(1) func findKthPositive(arr []int, k int) int { start := 1 i := 0 for { if i = k { return k + i } } return k + len(arr) } # 3 func findKthPositive(arr []int, k int) int { left := 0 right := len(arr) for left = k { right = mid } else { left = mid + 1 } } return k + left } 1544.整理字符串(1) 题目 给你一个由大小写英文字母组成的字符串 s 。 一个整理好的字符串中，两个相邻字符 s[i] 和 s[i + 1] 不会同时满足下述条件： 0 \"aAcC\" --> \"cC\" --> \"\" \"abBAcC\" --> \"abBA\" --> \"aA\" --> \"\" 示例 3：输入：s = \"s\"输出：\"s\" 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 栈辅助 O(n) O(n) func makeGood(s string) string { if len(s) 1 { length := len(stack) if stack[length-1]-'A'+'a' == stack[length-2] || stack[length-1]-'a'+'A' == stack[length-2] { stack = stack[:length-2] } } } return string(stack) } 1550.存在连续三个奇数的数组(2) 题目 给你一个整数数组 arr，请你判断数组中是否存在连续三个元素都是奇数的情况： 如果存在，请返回 true ；否则，返回 false 。 示例 1：输入：arr = [2,6,4,1] 输出：false 解释：不存在连续三个元素都是奇数的情况。 示例 2：输入：arr = [1,2,34,3,4,5,7,23,12] 输出：true 解释：存在连续三个元素都是奇数的情况，即 [5,7,23] 。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法 O(n) O(1) 02 遍历 O(n) O(1) func threeConsecutiveOdds(arr []int) bool { for i := 0; i 1556.千位分隔数(1) 题目 给你一个整数 n，请你每隔三位添加点（即 \".\" 符号）作为千位分隔符，并将结果以字符串格式返回。 示例 1：输入：n = 987 输出：\"987\" 示例 2：输入：n = 1234 输出：\"1.234\" 示例 3：输入：n = 123456789 输出：\"123.456.789\" 示例 4：输入：n = 0 输出：\"0\" 提示： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) func thousandSeparator(n int) string { res := \"\" if n == 0 { return \"0\" } count := 0 for n != 0 { count++ value := n % 10 if count%3 == 1 { res = strconv.Itoa(value) + \".\" + res } else { res = strconv.Itoa(value) + res } n = n / 10 } return strings.Trim(res, \".\") } 1560.圆形赛道上经过次数最多的扇区(2) 题目 给你一个整数 n 和一个整数数组 rounds 。有一条圆形赛道由 n 个扇区组成，扇区编号从 1 到 n 。 现将在这条赛道上举办一场马拉松比赛，该马拉松全程由 m 个阶段组成。 其中，第 i 个阶段将会从扇区 rounds[i - 1] 开始，到扇区 rounds[i] 结束。 举例来说，第 1 阶段从 rounds[0] 开始，到 rounds[1] 结束。 请你以数组形式返回经过次数最多的那几个扇区，按扇区编号 升序 排列。 注意，赛道按扇区编号升序逆时针形成一个圆（请参见第一个示例）。 示例 1：输入：n = 4, rounds = [1,3,1,2] 输出：[1,2] 解释：本场马拉松比赛从扇区 1 开始。经过各个扇区的次序如下所示： 1 --> 2 --> 3（阶段 1 结束）--> 4 --> 1（阶段 2 结束）--> 2 （阶段 3 结束，即本场马拉松结束）其中，扇区 1 和 2 都经过了两次，它们是经过次数最多的两个扇区。 扇区 3 和 4 都只经过了一次。 示例 2：输入：n = 2, rounds = [2,1,2,1,2,1,2,1,2] 出：[2] 示例 3：输入：n = 7, rounds = [1,3,5,7] 出：[1,2,3,4,5,6,7] 提示： 2 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组模拟 O(n^2) O(n) 02 遍历 O(n) O(n) func mostVisited(n int, rounds []int) []int { arr := make([]int, n+1) res := make([]int, 0) max := 0 arr[rounds[0]]++ for i := 0; i max { max = arr[i] res = make([]int, 0) res = append(res, i) } else if arr[i] == max { res = append(res, i) } } return res } # 2 func mostVisited(n int, rounds []int) []int { res := make([]int, 0) start := rounds[0] end := rounds[len(rounds)-1] if start 1566.重复至少K次且长度为M的模式(2) 题目 给你一个正整数数组 arr，请你找出一个长度为 m 且在数组中至少重复 k 次的模式。 模式 是由一个或多个值组成的子数组（连续的子序列），连续 重复多次但 不重叠 。 模式由其长度和重复次数定义。 如果数组中存在至少重复 k 次且长度为 m 的模式，则返回 true ，否则返回 false 。 示例 1：输入：arr = [1,2,4,4,4,4], m = 1, k = 3 输出：true 解释：模式 (4) 的长度为 1 ，且连续重复 4 次。注意，模式可以重复 k 次或更多次，但不能少于 k 次。 示例 2：输入：arr = [1,2,1,2,1,1,1,3], m = 2, k = 2 输出：true 解释：模式 (1,2) 长度为 2 ，且连续重复 2 次。另一个符合题意的模式是 (2,1) ，同样重复 2 次。 示例 3：输入：arr = [1,2,1,2,1,3], m = 2, k = 3 输出：false 解释：模式 (1,2) 长度为 2 ，但是只连续重复 2 次。不存在长度为 2 且至少重复 3 次的模式。 示例 4：输入：arr = [1,2,3,1,2], m = 2, k = 2 输出：false 解释：模式 (1,2) 出现 2 次但并不连续，所以不能算作连续重复 2 次。 示例 5：输入：arr = [2,2,2,2], m = 2, k = 3 输出：false 解释：长度为 2 的模式只有 (2,2) ，但是只连续重复 2 次。注意，不能计算重叠的重复次数。 提示： 2 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n^2) O(1) 02 遍历 O(n^2) O(1) func containsPattern(arr []int, m int, k int) bool { for i := 0; i = k { return true } } return false } # 2 func containsPattern(arr []int, m int, k int) bool { n := len(arr) if n 1572.矩阵对角线元素的和(2) 题目 给你一个正方形矩阵 mat，请你返回矩阵对角线元素的和。 请你返回在矩阵主对角线上的元素和副对角线上且不在主对角线上元素的和。 示例 1：输入：mat = [[1,2,3], [4,5,6], [7,8,9]] 输出：25 解释：对角线的和为：1 + 5 + 9 + 3 + 7 = 25 请注意，元素 mat[1][1] = 5 只会被计算一次。 示例 2：输入：mat = [[1,1,1,1], [1,1,1,1], [1,1,1,1], [1,1,1,1]] 输出：8 示例 3：输入：mat = [[5]] 输出：5 提示： n == mat.length == mat[i].length 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 遍历 O(n) O(1) func diagonalSum(mat [][]int) int { res := 0 for i := 0; i 1576.替换所有的问号(1) 题目 给你一个仅包含小写英文字母和 '?' 字符的字符串 s， 请你将所有的 '?' 转换为若干小写字母，使最终的字符串不包含任何 连续重复 的字符。 注意：你 不能 修改非 '?' 字符。 题目测试用例保证 除 '?' 字符 之外，不存在连续重复的字符。 在完成所有转换（可能无需转换）后返回最终的字符串。 如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。 示例 1：输入：s = \"?zs\" 输出：\"azs\" 解释：该示例共有 25 种解决方案，从 \"azs\" 到 \"yzs\" 都是符合题目要求的。 只有 \"z\" 是无效的修改，因为字符串 \"zzs\" 中有连续重复的两个 'z' 。 示例 2：输入：s = \"ubv?w\"输出：\"ubvaw\" 解释：该示例共有 24 种解决方案，只有替换成 \"v\" 和 \"w\" 不符合题目要求。 因为 \"ubvvw\" 和 \"ubvww\" 都包含连续重复的字符。 示例 3：输入：s = \"j?qg??b\" 输出：\"jaqgacb\" 示例 4：输入：s = \"??yw?ipkj?\" 输出：\"acywaipkja\" 提示：1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) func modifyString(s string) string { res := []byte(s) for i := 0; i 1501-1600-Medium 1503.所有蚂蚁掉下来前的最后一刻(2) 题目 有一块木板，长度为 n 个 单位 。一些蚂蚁在木板上移动，每只蚂蚁都以 每秒一个单位 的速度移动。 其中，一部分蚂蚁向 左 移动，其他蚂蚁向 右 移动。 当两只向 不同 方向移动的蚂蚁在某个点相遇时，它们会同时改变移动方向并继续移动。 假设更改方向不会花费任何额外时间。 而当蚂蚁在某一时刻 t 到达木板的一端时，它立即从木板上掉下来。 给你一个整数 n 和两个整数数组 left 以及 right 。 两个数组分别标识向左或者向右移动的蚂蚁在 t = 0 时的位置。请你返回最后一只蚂蚁从木板上掉下来的时刻。 示例 1：输入：n = 4, left = [4,3], right = [0,1] 输出：4 解释：如上图所示： -下标 0 处的蚂蚁命名为 A 并向右移动。 -下标 1 处的蚂蚁命名为 B 并向右移动。 -下标 3 处的蚂蚁命名为 C 并向左移动。 -下标 4 处的蚂蚁命名为 D 并向左移动。 请注意，蚂蚁在木板上的最后时刻是 t = 4 秒，之后蚂蚁立即从木板上掉下来。 （也就是说在 t = 4.0000000001 时，木板上没有蚂蚁）。 示例 2：输入：n = 7, left = [], right = [0,1,2,3,4,5,6,7] 输出：7 解释：所有蚂蚁都向右移动，下标为 0 的蚂蚁需要 7 秒才能从木板上掉落。 示例 3：输入：n = 7, left = [0,1,2,3,4,5,6,7], right = [] 输出：7 解释：所有蚂蚁都向左移动，下标为 7 的蚂蚁需要 7 秒才能从木板上掉落。 示例 4：输入：n = 9, left = [5], right = [4] 输出：5 解释：t = 1 秒时，两只蚂蚁将回到初始位置，但移动方向与之前相反。 示例 5：输入：n = 6, left = [6], right = [0] 输出：6 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 排序 O(nlog(n)) O(1) // 2只蚂蚁相遇=>两只蚂蚁都不改变移动方向=>求离终点最远距离 func getLastMoment(n int, left []int, right []int) int { max := 0 for i := 0; i max { max = left[i] } } for i := 0; i max { max = n - right[i] } } return max } # 2 func getLastMoment(n int, left []int, right []int) int { sort.Ints(left) sort.Ints(right) if len(left) == 0 { return n - right[0] } if len(right) == 0 { return left[len(left)-1] } if n-right[0] > left[len(left)-1] { return n - right[0] } return left[len(left)-1] } 1508.子数组和排序后的区间和(1) 题目 给你一个数组 nums ，它包含 n 个正整数。你需要计算所有非空连续子数组的和，并将它们按升序排序， 得到一个新的包含 n * (n + 1) / 2 个数字的数组。 请你返回在新数组中下标为 left 到 right （下标从 1 开始）的所有数字和（包括左右端点）。 由于答案可能很大，请你将它对 10^9 + 7 取模后返回。 示例 1：输入：nums = [1,2,3,4], n = 4, left = 1, right = 5 输出：13 解释：所有的子数组和为 1, 3, 6, 10, 2, 5, 9, 3, 7, 4 。 将它们升序排序后，我们得到新的数组 [1, 2, 3, 3, 4, 5, 6, 7, 9, 10] 。 下标从 le = 1 到 ri = 5 的和为 1 + 2 + 3 + 3 + 4 = 13 。 示例 2：输入：nums = [1,2,3,4], n = 4, left = 3, right = 4 输出：6 解释：给定数组与示例 1 一样，所以新数组为 [1, 2, 3, 3, 4, 5, 6, 7, 9, 10] 。 下标从 le = 3 到 ri = 4 的和为 3 + 3 = 6 。 示例 3：输入：nums = [1,2,3,4], n = 4, left = 1, right = 10 输出：50 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法 O(n^2log(n)) O(n^2) func rangeSum(nums []int, n int, left int, right int) int { arr := make([]int, 0) for i := 0; i 1509.三次操作后最大值与最小值的最小差(2) 题目 给你一个数组 nums ，每次操作你可以选择 nums 中的任意一个元素并将它改成任意值。 请你返回三次操作后， nums 中最大值与最小值的差的最小值。 示例 1：输入：nums = [5,3,2,4] 输出：0 解释：将数组 [5,3,2,4] 变成 [2,2,2,2]. 最大值与最小值的差为 2-2 = 0 。 示例 2：输入：nums = [1,5,0,10,14] 输出：1 解释：将数组 [1,5,0,10,14] 变成 [1,1,0,1,1] 。 最大值与最小值的差为 1-0 = 1 。 示例 3：输入：nums = [6,6,0,1,1,4,6] 输出：2 示例 4：输入：nums = [1,5,6,14,15] 输出：1 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序 O(nlog(n)) O(1) 02 排序 O(nlog(n)) O(1) func minDifference(nums []int) int { if len(nums) 1513.仅含1的子串数(2) 题目 给你一个二进制字符串 s（仅由 '0' 和 '1' 组成的字符串）。 返回所有字符都为 1 的子字符串的数目。 由于答案可能很大，请你将它对 10^9 + 7 取模后返回。 示例 1：输入：s = \"0110111\" 输出：9 解释：共有 9 个子字符串仅由 '1' 组成 \"1\" -> 5 次 \"11\" -> 3 次 \"111\" -> 1 次 示例 2：输入：s = \"101\" 输出：2 解释：子字符串 \"1\" 在 s 中共出现 2 次 示例 3：输入：s = \"111111\" 输出：21 解释：每个子字符串都仅由 '1' 组成 示例 4：输入：s = \"000\" 输出：0 提示： s[i] == '0' 或 s[i] == '1' 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 遍历 O(n) O(1) func numSub(s string) int { res := 0 count := 0 for i := 0; i 0 { res = (res + (count+1)*count/2) % 1000000007 } return res } # func numSub(s string) int { res := 0 count := 0 for i := 0; i 1514.概率最大的路径 题目 解题思路 1525.字符串的好分割数目(2) 题目 给你一个字符串 s ，一个分割被称为 「好分割」 当它满足： 将 s 分割成 2 个字符串 p 和 q ，它们连接起来等于 s 且 p 和 q 中不同字符的数目相同。 请你返回 s 中好分割的数目。 示例 1：输入：s = \"aacaba\" 输出：2 解释：总共有 5 种分割字符串 \"aacaba\" 的方法，其中 2 种是好分割。 (\"a\", \"acaba\") 左边字符串和右边字符串分别包含 1 个和 3 个不同的字符。 (\"aa\", \"caba\") 左边字符串和右边字符串分别包含 1 个和 3 个不同的字符。 (\"aac\", \"aba\") 左边字符串和右边字符串分别包含 2 个和 2 个不同的字符。这是一个好分割。 (\"aaca\", \"ba\") 左边字符串和右边字符串分别包含 2 个和 2 个不同的字符。这是一个好分割。 (\"aacab\", \"a\") 左边字符串和右边字符串分别包含 3 个和 1 个不同的字符。 示例 2：输入：s = \"abcd\"输出：1 解释：好分割为将字符串分割成 (\"ab\", \"cd\") 。 示例 3：输入：s = \"aaaaa\"输出：4 解释：所有分割都是好分割。 示例 4：输入：s = \"acbadbaada\"输出：2 提示：s 只包含小写英文字母。 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(1) 02 数组辅助 O(n) O(1) func numSplits(s string) int { left := make(map[byte]int) right := make(map[byte]int) for i := 0; i 1529.灯泡开关IV(2) 题目 房间中有 n 个灯泡，编号从 0 到 n-1 ，自左向右排成一行。最开始的时候，所有的灯泡都是 关 着的。 请你设法使得灯泡的开关状态和 target 描述的状态一致，其中 target[i] 等于 1 第 i 个灯泡是开着的， 等于 0 意味着第 i 个灯是关着的。 有一个开关可以用于翻转灯泡的状态，翻转操作定义如下： 选择当前配置下的任意一个灯泡（下标为 i ） 翻转下标从 i 到 n-1 的每个灯泡 翻转时，如果灯泡的状态为 0 就变为 1，为 1 就变为 0 。 返回达成 target 描述的状态所需的 最少 翻转次数。 示例 1：输入：target = \"10111\" 输出：3 解释：初始配置 \"00000\". 从第 3 个灯泡（下标为 2）开始翻转 \"00000\" -> \"00111\" 从第 1 个灯泡（下标为 0）开始翻转 \"00111\" -> \"11000\" 从第 2 个灯泡（下标为 1）开始翻转 \"11000\" -> \"10111\" 至少需要翻转 3 次才能达成 target 描述的状态 示例 2：输入：target = \"101\" 输出：3 解释：\"000\" -> \"111\" -> \"100\" -> \"101\". 示例 3：输入：target = \"00000\" 输出：0 示例 4：输入：target = \"001011101\" 输出：5 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 遍历 O(n) O(1) func minFlips(target string) int { res := 0 prev := uint8('0') for i := 0; i 00000=>(1)1111=>(10)000=>(10111) if target[i] != target[i-1] { res++ } } return res } 1541.平衡括号字符串的最少插入次数(2) 题目 给你一个括号字符串 s ，它只包含字符 '(' 和 ')' 。一个括号字符串被称为平衡的当它满足： 任何左括号 '(' 必须对应两个连续的右括号 '))' 。 左括号 '(' 必须在对应的连续两个右括号 '))' 之前。 比方说 \"())\"， \"())(())))\" 和 \"(())())))\" 都是平衡的， \")()\"， \"()))\" 和 \"(()))\" 都是不平衡的。 你可以在任意位置插入字符 '(' 和 ')' 使字符串平衡。 请你返回让 s 平衡的最少插入次数。 示例 1：输入：s = \"(()))\" 输出：1 解释：第二个左括号有与之匹配的两个右括号，但是第一个左括号只有一个右括号。 我们需要在字符串结尾额外增加一个 ')' 使字符串变成平衡字符串 \"(())))\" 。 示例 2：输入：s = \"())\" 输出：0 解释：字符串已经平衡了。 示例 3：输入：s = \"))())(\" 输出：3 解释：添加 '(' 去匹配最开头的 '))' ，然后添加 '))' 去匹配最后一个 '(' 。 示例 4：输入：s = \"((((((\" 输出：12 解释：添加 12 个 ')' 得到平衡字符串。 示例 5：输入：s = \")))))))\" 输出：5 解释：在字符串开头添加 4 个 '(' 并在结尾添加 1 个 ')' ，字符串变成平衡字符串 \"(((())))))))\" 。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 栈辅助 O(n) O(n) func minInsertions(s string) int { res := 0 left := 0 for i := 0; i 0 { left-- } else { res++ // 左边无'('补一个 } } } res = res + left*2 return res } # 2 func minInsertions(s string) int { res := 0 stack := make([]byte, 0) for i := 0; i 1545.找出第N个二进制字符串中的第K位(2) 题目 给你两个正整数 n 和 k，二进制字符串 Sn 的形成规则如下： S1 = \"0\" 当 i > 1 时，Si = Si-1 + \"1\" + reverse(invert(Si-1)) 其中 + 表示串联操作，reverse(x) 返回反转 x 后得到的字符串， 而 invert(x) 则会翻转 x 中的每一位（0 变为 1，而 1 变为 0） 例如，符合上述描述的序列的前 4 个字符串依次是： S1 = \"0\" S2 = \"011\" S3 = \"0111001\" S4 = \"011100110110001\" 请你返回 Sn 的 第 k 位字符 ，题目数据保证 k 一定在 Sn 长度范围以内。 示例 1：输入：n = 3, k = 1 输出：\"0\" 解释：S3 为 \"0111001\"，其第 1 位为 \"0\" 。 示例 2：输入：n = 4, k = 11 输出：\"1\" 解释：S4 为 \"011100110110001\"，其第 11 位为 \"1\" 。 示例 3：输入：n = 1, k = 1 输出：\"0\" 示例 4：输入：n = 2, k = 3 输出：\"1\" 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(n) 02 暴力 O(2^n) O(2^n) 03 遍历 O(n) O(1) func findKthBit(n int, k int) byte { if n == 1 { return '0' } mid := 1 3,1(2^4-15=16-15=1) return change(findKthBit(n-1, (1 1 { if k == mid { if flag == true { return '0' } return '1' } else if k > mid { if flag == true { flag = false } else { flag = true } k = (mid > 1 } if flag == true { return '1' } return '0' } 1546.和为目标值的最大数目不重叠非空子数组数目(2) 题目 给你一个数组 nums 和一个整数 target 。 请你返回 非空不重叠 子数组的最大数目，且每个子数组中数字和都为 target 。 示例 1：输入：nums = [1,1,1,1,1], target = 2 输出：2 解释：总共有 2 个不重叠子数组（加粗数字表示） [1,1,1,1,1] ，它们的和为目标值 2 。 示例 2：输入：nums = [-1,3,5,1,4,2,-9], target = 6 输出：2 解释：总共有 3 个子数组和为 6 。([5,1], [4,2], [3,5,1,4,2,-9]) 但只有前 2 个是不重叠的。 示例 3：输入：nums = [-2,6,6,3,5,4,1,2,8], target = 10 输出：3 示例 4：输入：nums = [0,0,0], target = 0 输出：3 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 前缀和-哈希辅助 O(n) O(n) 02 前缀和-哈希辅助 O(n) O(n) func maxNonOverlapping(nums []int, target int) int { res := 0 m := make(map[int]int) m[0] = -1 sum := 0 prev := -1 for i := 0; i = prev { res++ prev = i } m[sum] = i } return res } # 2 func maxNonOverlapping(nums []int, target int) int { res := 0 m := make(map[int]int) m[0] = -1 sum := 0 for i := 0; i 1551.使数组中所有元素相等的最小操作数(3) 题目 存在一个长度为 n 的数组 arr ，其中 arr[i] = (2 * i) + 1 （ 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 数学 O(n) O(1) 02 数学 O(1) O(1) 03 数学 O(1) O(1) func minOperations(n int) int { res := 0 for i := 1; i 1552.两球之间的磁力(2) 题目 在代号为 C-137 的地球上，Rick 发现如果他将两个球放在他新发明的篮子里，它们之间会形成特殊形式的磁力 。Rick 有 n 个空的篮子，第 i 个篮子的位置在 position[i] ，Morty 想把 m 个球放到这些篮子里， 使得任意两球间 最小磁力 最大。 已知两个球如果分别位于 x 和 y ，那么它们之间的磁力为 |x - y| 。 给你一个整数数组 position 和一个整数 m ，请你返回最大化的最小磁力。 示例 1：输入：position = [1,2,3,4,7], m = 3 输出：3 解释：将 3 个球分别放入位于 1，4 和 7 的三个篮子，两球间的磁力分别为 [3, 3, 6]。最小磁力为 3 。 我们没办法让最小磁力大于 3 。 示例 2：输入：position = [5,4,3,2,1,1000000000], m = 2 输出：999999999 解释：我们使用位于 1 和 1000000000 的篮子时最小磁力最大。 提示：n == position.length 2 解题思路 No. 思路 时间复杂度 空间复杂度 01 二分查找 O(nlog(n)) O(1) 02 二分查找 O(nlog(n)) O(1) func maxDistance(position []int, m int) int { sort.Ints(position) n := len(position) maxValue := position[n-1] - position[0] // 最大值 minValue := position[n-1] // 求最小值 for i := 1; i position[i]-position[i-1] { minValue = position[i] - position[i-1] } } if m == 2 { return maxValue } left, right := minValue, maxValue for left = target { count++ target = arr[i] + value } } return count >= m } # 2 func maxDistance(position []int, m int) int { sort.Ints(position) n := len(position) maxValue := (position[n-1] - position[0]) / (m - 1) // 最大值 minValue := 1 // 最小值 left, right := minValue, maxValue res := 1 for left = value { count++ prev = i } } return count >= m } 1557.可以到达所有点的最少点数目(2) 题目 给你一个 有向无环图 ， n 个节点编号为 0 到 n-1 ，以及一个边数组 edges ， 其中 edges[i] = [fromi, toi] 表示一条从点 fromi 到点 toi 的有向边。 找到最小的点集使得从这些点出发能到达图中所有点。题目保证解存在且唯一。 你可以以任意顺序返回这些节点编号。 示例 1：输入：n = 6, edges = [[0,1],[0,2],[2,5],[3,4],[4,2]] 输出：[0,3] 解释：从单个节点出发无法到达所有节点。从 0 出发我们可以到达 [0,1,2,5] 。 从 3 出发我们可以到达 [3,4,2,5] 。所以我们输出 [0,3] 。 示例 2：输入：n = 5, edges = [[0,1],[2,1],[3,1],[1,4],[2,4]] 输出：[0,2,3] 解释：注意到节点 0，3 和 2 无法从其他节点到达，所以我们必须将它们包含在结果点集中， 这些点都能到达节点 1 和 4 。 提示： 2 解题思路 No. 思路 时间复杂度 空间复杂度 01 入度统计 O(n) O(n) 02 哈希辅助 O(n) O(n) func findSmallestSetOfVertices(n int, edges [][]int) []int { res := make([]int, 0) inEdges := make([]int, n) for i := 0; i b b := edges[i][1] inEdges[b]++ // 入度 } for i := 0; i 1558.得到目标数组的最少函数调用次数(2) 题目 给你一个与 nums 大小相同且初始值全为 0 的数组 arr ，请你调用以上函数得到整数数组 nums 。 请你返回将 arr 变成 nums 的最少函数调用次数。 答案保证在 32 位有符号整数以内。 示例 1：输入：nums = [1,5] 输出：5 解释：给第二个数加 1 ：[0, 0] 变成 [0, 1] （1 次操作）。 将所有数字乘以 2 ：[0, 1] -> [0, 2] -> [0, 4] （2 次操作）。 给两个数字都加 1 ：[0, 4] -> [1, 4] -> [1, 5] （2 次操作）。 总操作次数为：1 + 2 + 2 = 5 。 示例 2：输入：nums = [2,2] 输出：3 解释：给两个数字都加 1 ：[0, 0] -> [0, 1] -> [1, 1] （2 次操作）。 将所有数字乘以 2 ： [1, 1] -> [2, 2] （1 次操作）。 总操作次数为： 2 + 1 = 3 。 示例 3：输入：nums = [4,2,5] 输出：6 解释：（初始）[0,0,0] -> [1,0,0] -> [1,0,1] -> [2,0,2] -> [2,1,2] -> [4,2,4] -> [4,2,5] （nums 数组）。 示例 4：输入：nums = [3,2,2,4] 输出：7 示例 5：输入：nums = [2,4,8,16] 输出：8 提示：1 解题思路 No. 思路 时间复杂度 空间复杂度 01 模拟 O(n) O(1) 02 数学 O(n) O(1) func minOperations(nums []int) int { res := 0 for judge(nums) != true { res++ // 最后一次循环会多算一次,最后要减掉 res = res + div(nums) } return res - 1 } func judge(arr []int) bool { for i := 0; i b { return a } return b } 1561.你可以获得的最大硬币数目(3) 题目 有 3n 堆数目不一的硬币，你和你的朋友们打算按以下方式分硬币： 每一轮中，你将会选出 任意 3 堆硬币（不一定连续）。 Alice 将会取走硬币数量最多的那一堆。 你将会取走硬币数量第二多的那一堆。 Bob 将会取走最后一堆。 重复这个过程，直到没有更多硬币。 给你一个整数数组 piles ，其中 piles[i] 是第 i 堆中硬币的数目。 返回你可以获得的最大硬币数目。 示例 1：输入：piles = [2,4,1,2,7,8] 输出：9 解释：选出 (2, 7, 8) ，Alice 取走 8 枚硬币的那堆，你取走 7 枚硬币的那堆，Bob 取走最后一堆。 选出 (1, 2, 4) , Alice 取走 4 枚硬币的那堆，你取走 2 枚硬币的那堆，Bob 取走最后一堆。 你可以获得的最大硬币数目：7 + 2 = 9. 考虑另外一种情况，如果选出的是 (1, 2, 8) 和 (2, 4, 7) ，你就只能得到 2 + 4 = 6 枚硬币，这不是最优解。 示例 2：输入：piles = [2,4,5] 输出：4 示例 3：输入：piles = [9,8,7,6,5,1,2,3,4] 输出：18 提示： 3 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序 O(nlog(n)) O(1) 02 排序 O(nlog(n)) O(1) 03 排序 O(nlog(n)) O(1) func maxCoins(piles []int) int { res := 0 sort.Ints(piles) count := len(piles) / 3 for i := 0; i piles[j] }) for i := 0; i 1562.查找大小为M的最新分组(2) 题目 给你一个数组 arr ，该数组表示一个从 1 到 n 的数字排列。 有一个长度为 n 的二进制字符串，该字符串上的所有位最初都设置为 0 。 在从 1 到 n 的每个步骤 i 中（假设二进制字符串和 arr 都是从 1 开始索引的情况下）， 二进制字符串上位于位置 arr[i] 的位将会设为 1 。 给你一个整数 m ，请你找出二进制字符串上存在长度为 m 的一组 1 的最后步骤。 一组 1 是一个连续的、由 1 组成的子串，且左右两边不再有可以延伸的 1 。 返回存在长度 恰好 为 m 的 一组 1 的最后步骤。如果不存在这样的步骤，请返回 -1 。 示例 1：输入：arr = [3,5,1,2,4], m = 1 输出：4 解释：步骤 1：\"00100\"，由 1 构成的组：[\"1\"] 步骤 2：\"00101\"，由 1 构成的组：[\"1\", \"1\"] 步骤 3：\"10101\"，由 1 构成的组：[\"1\", \"1\", \"1\"] 步骤 4：\"11101\"，由 1 构成的组：[\"111\", \"1\"] 步骤 5：\"11111\"，由 1 构成的组：[\"11111\"] 存在长度为 1 的一组 1 的最后步骤是步骤 4 。 示例 2：输入：arr = [3,1,5,4,2], m = 2 输出：-1 解释：步骤 1：\"00100\"，由 1 构成的组：[\"1\"] 步骤 2：\"10100\"，由 1 构成的组：[\"1\", \"1\"] 步骤 3：\"10101\"，由 1 构成的组：[\"1\", \"1\", \"1\"] 步骤 4：\"10111\"，由 1 构成的组：[\"1\", \"111\"] 步骤 5：\"11111\"，由 1 构成的组：[\"11111\"] 不管是哪一步骤都无法形成长度为 2 的一组 1 。 示例 3：输入：arr = [1], m = 1 输出：1 示例 4：输入：arr = [2,1], m = 2 输出：2 提示：n == arr.length 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(n) 02 数组辅助 O(n) O(n) func findLatestStep(arr []int, m int) int { res := -1 temp := make([]int, len(arr)+2) M := make(map[int]bool) for i := 0; i 0 { res = i + 1 } } return res } # 2 func findLatestStep(arr []int, m int) int { if len(arr) == m { return len(arr) } res := -1 temp := make([]int, len(arr)+2) for i := 0; i 1567.乘积为正数的最长子数组长度(2) 题目 给你一个整数数组 nums ，请你求出乘积为正数的最长子数组的长度。 一个数组的子数组是由原数组中零个或者更多个连续数字组成的数组。 请你返回乘积为正数的最长子数组长度。 示例 1：输入：nums = [1,-2,-3,4] 输出：4 解释：数组本身乘积就是正数，值为 24 。 示例 2：输入：nums = [0,1,-2,-3,-4] 输出：3 解释：最长乘积为正数的子数组为 [1,-2,-3] ，乘积为 6 。 注意，我们不能把 0 也包括到子数组中，因为这样乘积为 0 ，不是正数。 示例 3：输入：nums = [-1,-2,-3,0,1] 输出：2 解释：乘积为正数的最长子数组是 [-1,-2] 或者 [-2,-3] 。 示例 4：输入：nums = [-1,2] 输出：1 示例 5：输入：nums = [1,2,3,5,-6,4,0,10] 输出：4 提示：1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历+贪心 O(n) O(n) 02 动态规划 O(n) O(n) func getMaxLen(nums []int) int { arr := make([][]int, 0) temp := make([]int, 0) res := 0 total := 1 for i := 0; i 0 { total = total * 1 } else if nums[i] 0 { temp = append(temp, 1) } else if nums[i] == 0 { if len(temp) > 0 { arr = append(arr, temp) temp = make([]int, 0) } total = 1 } else if total 0 { arr = append(arr, temp) } for i := 0; i b { return a } return b } # 2 func getMaxLen(nums []int) int { dp := make([][2]int, len(nums)+1) res := 0 for i := 1; i 0 { dp[i][0] = dp[i-1][0] + 1 if dp[i-1][1] != 0 { dp[i][1] = dp[i-1][1] + 1 } else { dp[i][1] = 0 } } else { if dp[i-1][1] != 0 { dp[i][0] = dp[i-1][1] + 1 } else { dp[i][0] = 0 } dp[i][1] = dp[i-1][0] + 1 } res = max(res, dp[i][0]) } return res } func max(a, b int) int { if a > b { return a } return b } 1568.使陆地分离的最少天数(1) 题目 给你一个由若干 0 和 1 组成的二维网格 grid ，其中 0 表示水，而 1 表示陆地。 岛屿由水平方向或竖直方向上相邻的 1 （陆地）连接形成。 如果 恰好只有一座岛屿 ，则认为陆地是 连通的 ；否则，陆地就是 分离的 。 一天内，可以将任何单个陆地单元（1）更改为水单元（0）。 返回使陆地分离的最少天数。 示例 1：输入：grid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]] 输出：2 解释：至少需要 2 天才能得到分离的陆地。 将陆地 grid[1][1] 和 grid[0][2] 更改为水，得到两个分离的岛屿。 示例 2：输入：grid = [[1,1]] 输出：2 解释：如果网格中都是水，也认为是分离的 ([[1,1]] -> [[0,0]])，0 岛屿。 示例 3：输入：grid = [[1,0,1,0]] 输出：0 示例 4：输入：grid = [[1,1,0,1,1], [1,1,1,1,1], [1,1,0,1,1], [1,1,0,1,1]] 输出：1 示例 5：输入：grid = [[1,1,0,1,1], [1,1,1,1,1], [1,1,0,1,1], [1,1,1,1,1]] 输出：2 提示：1 解题思路 No. 思路 时间复杂度 空间复杂度 01 深度优先搜索 O(n^4) O(n^2) func minDays(grid [][]int) int { temp := copyArr(grid) nums := numIslands(temp) if nums >= 2 { return 0 } for i := 0; i = len(grid) || j >= len(grid[0]) || grid[i][j] == 0 { return } grid[i][j] = 0 dfs(grid, i+1, j) dfs(grid, i-1, j) dfs(grid, i, j+1) dfs(grid, i, j-1) } func copyArr(grid [][]int) [][]int { temp := make([][]int, len(grid)) for i := 0; i 1573.分割字符串的方案数(2) 题目 给你一个二进制串 s （一个只包含 0 和 1 的字符串）， 我们可以将 s 分割成 3 个 非空 字符串 s1, s2, s3 （s1 + s2 + s3 = s）。 请你返回分割 s 的方案数，满足 s1，s2 和 s3 中字符 '1' 的数目相同。 由于答案可能很大，请将它对 10^9 + 7 取余后返回。 示例 1：输入：s = \"10101\" 输出：4 解释：总共有 4 种方法将 s 分割成含有 '1' 数目相同的三个子字符串。 \"1|010|1\" \"1|01|01\" \"10|10|1\" \"10|1|01\" 示例 2：输入：s = \"1001\" 输出：0 示例 3：输入：s = \"0000\" 输出：3 解释：总共有 3 种分割 s 的方法。 \"0|0|00\" \"0|00|0\" \"00|0|0\" 示例 4：输入：s = \"100100010100110\" 输出：12 提示： s[i] == '0' 或者 s[i] == '1' 3 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 遍历 O(n) O(n) func numWays(s string) int { total := 0 for i := 0; i 1574.删除最短的子数组使剩余数组有序(1) 题目 给你一个整数数组 arr ，请你删除一个子数组（可以为空），使得 arr 中剩下的元素是 非递减 的。 一个子数组指的是原数组中连续的一个子序列。 请你返回满足题目要求的最短子数组的长度。 示例 1：输入：arr = [1,2,3,10,4,2,3,5] 输出：3 解释：我们需要删除的最短子数组是 [10,4,2] ，长度为 3 。剩余元素形成非递减数组 [1,2,3,3,5] 。 另一个正确的解为删除子数组 [3,10,4] 。 示例 2：输入：arr = [5,4,3,2,1] 输出：4 解释：由于数组是严格递减的，我们只能保留一个元素。所以我们需要删除长度为 4 的子数组， 要么删除 [5,4,3,2]，要么删除 [4,3,2,1]。 示例 3：输入：arr = [1,2,3] 输出：0 解释：数组已经是非递减的了，我们不需要删除任何元素。 示例 4：输入：arr = [1] 输出：0 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) func findLengthOfShortestSubarray(arr []int) int { if len(arr) arr[i] { flag = false break } else { left = i } } if flag == true { return 0 } right := len(arr) - 1 for i := len(arr) - 1; i >= 1; i-- { if arr[i-1] = 0 && arr[i] > arr[right]; i-- { leftC++ } for i := right; i b { return a } return b } 1501-1600-Hard 1510.石子游戏IV(1) 题目 Alice 和 Bob 两个人轮流玩一个游戏，Alice 先手。 一开始，有 n 个石子堆在一起。每个人轮流操作，正在操作的玩家可以从石子堆里拿走 任意 非零 平方数 个石子。 如果石子堆里没有石子了，则无法操作的玩家输掉游戏。 给你正整数 n ，且已知两个人都采取最优策略。如果 Alice 会赢得比赛，那么返回 True ，否则返回 False 。 示例 1：输入：n = 1 输出：true 解释：Alice 拿走 1 个石子并赢得胜利，因为 Bob 无法进行任何操作。 示例 2：输入：n = 2 输出：false 解释：Alice 只能拿走 1 个石子，然后 Bob 拿走最后一个石子并赢得胜利（2 -> 1 -> 0）。 示例 3：输入：n = 4 输出：true 解释：n 已经是一个平方数，Alice 可以一次全拿掉 4 个石子并赢得胜利（4 -> 0）。 示例 4：输入：n = 7 输出：false 解释：当 Bob 采取最优策略时，Alice 无法赢得比赛。 如果 Alice 一开始拿走 4 个石子， Bob 会拿走 1 个石子，然后 Alice 只能拿走 1 个石子， Bob 拿走最后一个石子并赢得胜利（7 -> 3 -> 2 -> 1 -> 0）。 如果 Alice 一开始拿走 1 个石子， Bob 会拿走 4 个石子，然后 Alice 只能拿走 1 个石子， Bob 拿走最后一个石子并赢得胜利（7 -> 6 -> 2 -> 1 -> 0）。 示例 5：输入：n = 17 输出：false 解释：如果 Bob 采取最优策略，Alice 无法赢得胜利。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n^(3/2)) O(n) func winnerSquareGame(n int) bool { dp := make([]bool, n+1) count := 1 for i := 1; i 1526.形成目标数组的子数组最少增加次数(1) 题目 给你一个整数数组 target 和一个数组 initial ，initial 数组与 target 数组有同样的维度， 且一开始全部为 0 。 请你返回从 initial 得到 target 的最少操作次数，每次操作需遵循以下规则： 在 initial 中选择 任意 子数组，并将子数组中每个元素增加 1 。 答案保证在 32 位有符号整数以内。 示例 1：输入：target = [1,2,3,2,1] 输出：3 解释：我们需要至少 3 次操作从 intial 数组得到 target 数组。 [0,0,0,0,0] 将下标为 0 到 4 的元素（包含二者）加 1 。 [1,1,1,1,1] 将下标为 1 到 3 的元素（包含二者）加 1 。 [1,2,2,2,1] 将下表为 2 的元素增加 1 。 [1,2,3,2,1] 得到了目标数组。 示例 2：输入：target = [3,1,1,2] 输出：4 解释：(initial)[0,0,0,0] -> [1,1,1,1] -> [1,1,1,2] -> [2,1,1,2] -> [3,1,1,2] (target) 。 示例 3：输入：target = [3,1,5,4,2] 输出：7 解释：(initial)[0,0,0,0,0] -> [1,1,1,1,1] -> [2,1,1,1,1] -> [3,1,1,1,1] -> [3,1,2,2,2] -> [3,1,3,3,2] -> [3,1,4,4,2] -> [3,1,5,4,2] (target)。 示例 4：输入：target = [1,1,1,1] 输出：1 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) func minNumberOperations(target []int) int { res := target[0] for i := 1; i b { return a } return b } 1553.吃掉N个橘子的最少天数(2) 题目 厨房里总共有 n 个橘子，你决定每一天选择如下方式之一吃这些橘子： 吃掉一个橘子。 如果剩余橘子数 n 能被 2 整除，那么你可以吃掉 n/2 个橘子。 如果剩余橘子数 n 能被 3 整除，那么你可以吃掉 2*(n/3) 个橘子。 每天你只能从以上 3 种方案中选择一种方案。 请你返回吃掉所有 n 个橘子的最少天数。 示例 1：输入：n = 10 输出：4 解释：你总共有 10 个橘子。 第 1 天：吃 1 个橘子，剩余橘子数 10 - 1 = 9。 第 2 天：吃 6 个橘子，剩余橘子数 9 - 2*(9/3) = 9 - 6 = 3。（9 可以被 3 整除） 第 3 天：吃 2 个橘子，剩余橘子数 3 - 2*(3/3) = 3 - 2 = 1。 第 4 天：吃掉最后 1 个橘子，剩余橘子数 1 - 1 = 0。 你需要至少 4 天吃掉 10 个橘子。 示例 2：输入：n = 6 输出：3 解释：你总共有 6 个橘子。 第 1 天：吃 3 个橘子，剩余橘子数 6 - 6/2 = 6 - 3 = 3。（6 可以被 2 整除） 第 2 天：吃 2 个橘子，剩余橘子数 3 - 2*(3/3) = 3 - 2 = 1。（3 可以被 3 整除） 第 3 天：吃掉剩余 1 个橘子，剩余橘子数 1 - 1 = 0。 你至少需要 3 天吃掉 6 个橘子。 示例 3：输入：n = 1 输出：1 示例 4：输入：n = 56 输出：6 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划-递归 O(log(n)) O(log(n)) 02 广度优先搜索 O(log(n)) O(log(n)) var dp map[int]int func minDays(n int) int { dp = make(map[int]int) dp[0] = 0 dp[1] = 1 return dfs(n) } func dfs(n int) int { if value, ok := dp[n]; ok { return value } // 吃n/2的情况，先吃掉n%2，然后就剩下dfs(n/2)+1 // 吃n/3的情况，先吃点n%3, 然后就剩下dfs(n/3)+1 dp[n] = min(dfs(n/2)+n%2+1, dfs(n/3)+n%3+1) return dp[n] } func min(a, b int) int { if a > b { return b } return a } # 2 func minDays(n int) int { m := make(map[int]bool) queue := make([]int, 0) queue = append(queue, n) res := 0 for len(queue) > 0 { length := len(queue) for i := 0; i 1559.二维网格图中探测环(1) 题目 给你一个二维字符网格数组 grid ，大小为 m x n ，你需要检查 grid 中是否存在 相同值 形成的环。 一个环是一条开始和结束于同一个格子的长度 大于等于 4 的路径。对于一个给定的格子， 你可以移动到它上、下、左、右四个方向相邻的格子之一，可以移动的前提是这两个格子有 相同的值 。 同时，你也不能回到上一次移动时所在的格子。比方说，环 (1, 1) -> (1, 2) -> (1, 1) 是不合法的， 因为从 (1, 2) 移动到 (1, 1) 回到了上一次移动时的格子。 如果 grid 中有相同值形成的环，请你返回 true ，否则返回 false 。 示例 1： 输入：grid = [[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"b\",\"b\",\"a\"],[\"a\",\"b\",\"b\",\"a\"],[\"a\",\"a\",\"a\",\"a\"]] 输出：true 解释：如下图所示，有 2 个用不同颜色标出来的环： 示例 2： 输入：grid = [[\"c\",\"c\",\"c\",\"a\"],[\"c\",\"d\",\"c\",\"c\"],[\"c\",\"c\",\"e\",\"c\"],[\"f\",\"c\",\"c\",\"c\"]] 输出：true 解释：如下图所示，只有高亮所示的一个合法环： 示例 3：输入：grid = [[\"a\",\"b\",\"b\"],[\"b\",\"z\",\"b\"],[\"b\",\"b\",\"a\"]] 输出：false 提示： m == grid.length n == grid[i].length 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 深度优先搜索 O(n^2) O(n^2) var dx = []int{0, 1, 0, -1} var dy = []int{1, 0, -1, 0} var visited map[[2]int]bool func containsCycle(grid [][]byte) bool { n, m := len(grid), len(grid[0]) visited = make(map[[2]int]bool) for i := 0; i = len(grid) || newY = len(grid[0]) || (newX == pX && newY == pY) { continue } if start == grid[newX][newY] { if visited[[2]int{newX, newY}] == true { return true } result := dfs(grid, start, newX, newY, x, y) if result == true { return true } } } return false } 1563.石子游戏V(2) 题目 几块石子 排成一行 ，每块石子都有一个关联值，关联值为整数，由数组 stoneValue 给出。 游戏中的每一轮：Alice 会将这行石子分成两个 非空行（即，左侧行和右侧行）； Bob 负责计算每一行的值，即此行中所有石子的值的总和。 Bob 会丢弃值最大的行，Alice 的得分为剩下那行的值（每轮累加）。 如果两行的值相等，Bob 让 Alice 决定丢弃哪一行。下一轮从剩下的那一行开始。 只剩下一块石子 时，游戏结束。Alice 的分数最初为 0 。 返回 Alice 能够获得的最大分数 。 示例 1：输入：stoneValue = [6,2,3,4,5,5] 输出：18 解释：在第一轮中，Alice 将行划分为 [6，2，3]，[4，5，5] 。 左行的值是 11 ，右行的值是 14 。Bob 丢弃了右行，Alice 的分数现在是 11 。 在第二轮中，Alice 将行分成 [6]，[2，3] 。这一次 Bob 扔掉了左行，Alice 的分数变成了 16（11 + 5）。 最后一轮 Alice 只能将行分成 [2]，[3] 。Bob 扔掉右行，Alice 的分数现在是 18（16 + 2）。 游戏结束，因为这行只剩下一块石头了。 示例 2：输入：stoneValue = [7,7,7,7,7,7,7] 输出：28 示例 3：输入：stoneValue = [4] 输出：0 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划+前缀和 O(n^3) O(n^2) 02 递归+前缀和 O(n^3) O(n^2) func stoneGameV(stoneValue []int) int { n := len(stoneValue) sum := make([]int, n+1) sum[0] = stoneValue[0] for i := 1; i k || k+1 > j { continue } left := dp[i][k] right := dp[k+1][j] leftSum := sum[k] if i > 0 { leftSum = sum[k] - sum[i-1] } rightSum := sum[j] - sum[k] if leftSum == rightSum { dp[i][j] = max(dp[i][j], max(left, right)+leftSum) } else if leftSum > rightSum { dp[i][j] = max(dp[i][j], right+rightSum) } else if leftSum b { return a } return b } # 2 var dp [][]int var sum []int func stoneGameV(stoneValue []int) int { n := len(stoneValue) sum = make([]int, n+1) sum[0] = 0 for i := 0; i rightSum { value = max(value, rightSum+dfs(i+1, right)) } else { value = max(value, max(dfs(left, i), dfs(i+1, right))+leftSum) } } dp[left][right] = value } return dp[left][right] } func max(a, b int) int { if a > b { return a } return b } Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 11:00:36 "},"docs/source/question/lcp.html":{"url":"docs/source/question/lcp.html","title":"lcp","keywords":"","body":"LCP LCP LCP01.猜数字(2) LCP02.分式化简(2) LCP06.拿硬币(2) LCP07.传递信息(5) LCP11.期望个数统计(2) LCP01.猜数字(2) 题目 小A 和 小B 在玩猜数字。小B 每次从 1, 2, 3 中随机选择一个，小A 每次也从 1, 2, 3 中选择一个猜。 他们一共进行三次这个游戏，请返回 小A 猜对了几次？ 输入的guess数组为 小A 每次的猜测，answer数组为 小B 每次的选择。 guess和answer的长度都等于3。 示例 1：输入：guess = [1,2,3], answer = [1,2,3] 输出：3 解释：小A 每次都猜对了。 示例 2：输入：guess = [2,2,3], answer = [3,2,1] 输出：1 解释：小A 只猜对了第二次。 限制： guess的长度 = 3 answer的长度 = 3 guess的元素取值为 {1, 2, 3} 之一。 answer的元素取值为 {1, 2, 3} 之一。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(1) O(1) 02 位运算-异或 O(1) O(1) func game(guess []int, answer []int) int { res := 0 for i := 0; i LCP02.分式化简(2) 题目 有一个同学在学习分式。他需要将一个连分数化成最简分数，你能帮助他吗？ 连分数是形如上图的分式。在本题中，所有系数都是大于等于0的整数。 输入的cont代表连分数的系数（cont[0]代表上图的a0，以此类推）。 返回一个长度为2的数组[n, m]，使得连分数的值等于n / m，且n, m最大公约数为1。 示例 1：输入：cont = [3, 2, 0, 2] 输出：[13, 4] 解释：原连分数等价于3 + (1 / (2 + (1 / (0 + 1 / 2))))。注意[26, 8], [-13, -4]都不是正确答案。 示例 2：输入：cont = [0, 0, 3] 输出：[3, 1] 解释：如果答案是整数，令分母为1即可。 限制： cont[i] >= 0 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 递归 O(n) O(n) func fraction(cont []int) []int { n, m := 1, cont[len(cont)-1] for i := len(cont) - 2; i >= 0; i-- { n, m = m, cont[i]*m+n } return []int{m, n} } # func fraction(cont []int) []int { if len(cont) == 1 { return []int{cont[0], 1} } n := fraction(cont[1:]) m := cont[0] return []int{m*n[0] + n[1], n[0]} } LCP03.机器人大冒险(1) 题目 力扣团队买了一个可编程机器人，机器人初始位置在原点(0, 0)。 小伙伴事先给机器人输入一串指令command，机器人就会无限循环这条指令的步骤进行移动。指令有两种： U: 向y轴正方向移动一格 R: 向x轴正方向移动一格。 不幸的是，在 xy 平面上还有一些障碍物，他们的坐标用obstacles表示。机器人一旦碰到障碍物就会被损毁。 给定终点坐标(x, y)，返回机器人能否完好地到达终点。如果能，返回true；否则返回false。 示例 1：输入：command = \"URR\", obstacles = [], x = 3, y = 2 输出：true 解释：U(0, 1) -> R(1, 1) -> R(2, 1) -> U(2, 2) -> R(3, 2)。 示例 2：输入：command = \"URR\", obstacles = [[2, 2]], x = 3, y = 2 输出：false 解释：机器人在到达终点前会碰到(2, 2)的障碍物。 示例 3：输入：command = \"URR\", obstacles = [[4, 2]], x = 3, y = 2 输出：true 解释：到达终点后，再碰到障碍物也不影响返回结果。 限制： 2 解题思路 No. 思路 时间复杂度 空间复杂度 01 数学计算 O(n) O(1) func robot(command string, obstacles [][]int, x int, y int) bool { if judge(command, x, y) == false { return false } for _, node := range obstacles { if x >= node[0] && y >= node[1] && judge(command, node[0], node[1]) { return false } } return true } func judge(command string, x, y int) bool { u := strings.Count(command, \"U\") r := strings.Count(command, \"R\") times := (x + y) / len(command) last := command[:(x+y)%len(command)] uNum := u*times + strings.Count(last, \"U\") rNum := r*times + strings.Count(last, \"R\") if uNum == y && rNum == x { return true } return false } LCP06.拿硬币(2) 题目 桌上有 n 堆力扣币，每堆的数量保存在数组 coins 中。 我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。 示例 1：输入：[4,2,1]输出：4 解释：第一堆力扣币最少需要拿 2 次，第二堆最少需要拿 1 次，第三堆最少需要拿 1 次，总共 4 次即可拿完。 示例 2： 输入：[2,3,10]输出：8 限制： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 内置函数 O(n) O(1) func minCount(coins []int) int { res := 0 for i := 0; i LCP07.传递信息(5) 题目 小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下： 有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0 每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。 传信息的关系是单向的（比如 A 可以向 B 传信息，但 B 不能向 A 传信息）。 每轮信息必须需要传递给另一个人，且信息可重复经过同一个人 给定总玩家数 n，以及按 [玩家编号,对应可传递玩家编号] 关系组成的二维数组 relation。 返回信息从小 A (编号 0 ) 经过 k 轮传递到编号为 n-1 的小伙伴处的方案数；若不能到达，返回 0。 示例 1： 输入：n = 5, relation = [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k = 3 输出：3 解释：信息从小 A 编号 0 处开始，经 3 轮传递，到达编号 4。 共有 3 种方案，分别是 0->2->0->4， 0->2->1->4， 0->2->3->4。 示例 2： 输入：n = 3, relation = [[0,2],[2,1]], k = 2 输出：0 解释：信息不能从小 A 处经过 2 轮传递到编号 2 限制： 2 解题思路 No. 思路 时间复杂度 空间复杂度 01 深度优先搜索 O(n^k) O(n^2) 02 深度优先搜索 O(n^k) O(n) 03 广度优先搜索 O(n^k) O(n^k) 04 动态规划 O(n^2) O(n) 05 动态规划 O(n^2) O(n^2) var ways [][]bool func numWays(n int, relation [][]int, k int) int { ways = make([][]bool, n) for i := range ways { ways[i] = make([]bool, n) } sum := 0 for i := 0; i = n { return 0 } if k == 0 && i == n-1 { return 1 } else { for j := 0; j K { return } for i := 0; i LCP08.剧情触发时间(2) 题目 在战略游戏中，玩家往往需要发展自己的势力来触发各种新的剧情。一个势力的主要属性有三种， 分别是文明等级（C），资源储备（R）以及人口数量（H）。在游戏开始时（第 0 天），三种属性的值均为 0。 随着游戏进程的进行，每一天玩家的三种属性都会对应增加，我们用一个二维数组 increase 来表示每天的增加情况。 这个二维数组的每个元素是一个长度为 3 的一维数组， 例如 [[1,2,1],[3,4,2]] 表示第一天三种属性分别增加 1,2,1 而第二天分别增加 3,4,2。 所有剧情的触发条件也用一个二维数组 requirements 表示。 这个二维数组的每个元素是一个长度为 3 的一维数组，对于某个剧情的触发条件 c[i], r[i], h[i]， 如果当前 C >= c[i] 且 R >= r[i] 且 H >= h[i] ，则剧情会被触发。 根据所给信息，请计算每个剧情的触发时间，并以一个数组返回。 如果某个剧情不会被触发，则该剧情对应的触发时间为 -1 。 示例 1： 输入： increase = [[2,8,4],[2,5,0],[10,9,8]] requirements = [[2,11,3],[15,10,7],[9,17,12],[8,1,14]] 输出: [2,-1,3,-1] 解释： 初始时，C = 0，R = 0，H = 0 第 1 天，C = 2，R = 8，H = 4 第 2 天，C = 4，R = 13，H = 4，此时触发剧情 0 第 3 天，C = 14，R = 22，H = 12，此时触发剧情 2 剧情 1 和 3 无法触发。 示例 2： 输入： increase = [[0,4,5],[4,8,8],[8,6,1],[10,10,0]] requirements = [[12,11,16],[20,2,6],[9,2,6],[10,18,3],[8,14,9]] 输出: [-1,4,3,3,3] 示例 3：输入： increase = [[1,1,1]] requirements = [[0,0,0]] 输出: [0] 限制： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 二分查找 O(nlog(n)) O(n) 02 内置函数 O(nlog(n)) O(n) func getTriggerTime(increase [][]int, requirements [][]int) []int { for i := 1; i increase[len(increase)-1][0] || R > increase[len(increase)-1][1] || H > increase[len(increase)-1][2] { res[i] = -1 continue } left, right := 0, len(increase)-1 index := -1 for left = C && increase[mid][1] >= R && increase[mid][2] >= H { index = mid + 1 right = mid - 1 } else { left = mid + 1 } } res[i] = index } return res } # func getTriggerTime(increase [][]int, requirements [][]int) []int { for i := 1; i increase[len(increase)-1][0] || R > increase[len(increase)-1][1] || H > increase[len(increase)-1][2] { res[i] = -1 continue } index := sort.Search(len(increase), func(j int) bool { return increase[j][0] >= requirements[i][0] && increase[j][1] >= requirements[i][1] && increase[j][2] >= requirements[i][2] }) if index == len(increase) { index = -2 } res[i] = index + 1 } return res } LCP11.期望个数统计(2) 题目 某互联网公司一年一度的春招开始了，一共有 n 名面试者入选。 每名面试者都会提交一份简历，公司会根据提供的简历资料产生一个预估的能力值，数值越大代表越有可能通过面试。 小 A 和小 B 负责审核面试者，他们均有所有面试者的简历，并且将各自根据面试者能力值从大到小的顺序浏览。 由于简历事先被打乱过，能力值相同的简历的出现顺序是从它们的全排列中等可能地取一个。 现在给定 n 名面试者的能力值 scores， 设 X 代表小 A 和小 B 的浏览顺序中出现在同一位置的简历数，求 X 的期望。 提示：离散的非负随机变量的期望计算公式为 1。在本题中，由于 X 的取值为 0 到 n 之间，期望计算公式可以是 2。 示例 1： 输入：scores = [1,2,3] 输出：3 解释：由于面试者能力值互不相同，小 A 和小 B 的浏览顺序一定是相同的。X的期望是 3 。 示例 2：输入：scores = [1,1] 输出：1 解释：设两位面试者的编号为 0, 1。 由于他们的能力值都是 1，小 A 和小 B 的浏览顺序都为从全排列 [[0,1],[1,0]] 中等可能地取一个。 如果小 A 和小 B 的浏览顺序都是 [0,1] 或者 [1,0] ，那么出现在同一位置的简历数为 2 ，否则是 0 。 所以 X 的期望是 (2+0+2+0) * 1/4 = 1 示例 3：输入：scores = [1,1,2] 输出：2 限制： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(n) 02 排序遍历 O(nlog(n)) O(1) func expectNumber(scores []int) int { m := make(map[int]bool) for i := 0; i LCP12.小张刷题计划(2) 题目 为了提高自己的代码能力，小张制定了 LeetCode 刷题计划，他选中了 LeetCode 题库中的 n 道题， 编号从 0 到 n-1，并计划在 m 天内按照题目编号顺序刷完所有的题目（注意，小张不能用多天完成同一题）。 在小张刷题计划中，小张需要用 time[i] 的时间完成编号 i 的题目。此外，小张还可以使用场外求助功能， 通过询问他的好朋友小杨题目的解法，可以省去该题的做题时间。为了防止“小张刷题计划”变成“小杨刷题计划”， 小张每天最多使用一次求助。 我们定义 m 天中做题时间最多的一天耗时为 T（小杨完成的题目不计入做题总时间）。 请你帮小张求出最小的 T是多少。 示例 1： 输入：time = [1,2,3,3], m = 2 输出：3 解释：第一天小张完成前三题，其中第三题找小杨帮忙；第二天完成第四题，并且找小杨帮忙。 这样做题时间最多的一天花费了 3 的时间，并且这个值是最小的。 示例 2：输入：time = [999,999,999], m = 4 输出：0 解释：在前三天中，小张每天求助小杨一次，这样他可以在三天内完成所有的题目并不花任何时间。 限制： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 二分查找 O(nlog(n)) O(1) 02 二分查找 O(nlog(n)) O(1) func minTime(time []int, m int) int { left, right, mid := 0, 0, 0 for i := 0; i maxValue { maxValue = arr[i] } if sum-maxValue > mid { count++ if count >= m { return false } sum = arr[i] maxValue = arr[i] } } return true } # func minTime(time []int, m int) int { left, right, mid := 0, 0, 0 for i := 0; i maxValue { maxValue = arr[i] } if sum-maxValue > mid { sum = arr[i] maxValue = arr[i] res++ } } return res } Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 09:46:03 "},"docs/source/question/mysql.html":{"url":"docs/source/question/mysql.html","title":"mysql","keywords":"","body":"mysql mysql 175.组合两个表(2) 176.第二高的薪水(3) 181.超过经理收入的员工(3) 182.查找重复的电子邮箱(2) 183.从不订购的客户(3) 193.删除重复的电子邮箱(2) 197.上升的温度(4) 595.大的国(2) 596.超过5名学生的课(2) 620.有趣的电影(2) 627.交换工资(3) 1179.重新格式化部门表(2) 175.组合两个表(2) 题目 SQL架构 Create table Person (PersonId int, FirstName varchar(255), LastName varchar(255)) Create table Address (AddressId int, PersonId int, City varchar(255), State varchar(255)) Truncate table Person insert into Person (PersonId, LastName, FirstName) values ('1', 'Wang', 'Allen') Truncate table Address insert into Address (AddressId, PersonId, City, State) values ('1', '2', 'New York City', 'New York') 表1: Person +-------------+---------+ | 列名 | 类型 | +-------------+---------+ | PersonId | int | | FirstName | varchar | | LastName | varchar | +-------------+---------+ PersonId 是上表主键 表2: Address +-------------+---------+ | 列名 | 类型 | +-------------+---------+ | AddressId | int | | PersonId | int | | City | varchar | | State | varchar | +-------------+---------+ AddressId 是上表主键 编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息： FirstName, LastName, City, State 解题思路 No. 思路 01 考察join的基本使用 02 考察join的基本使用 select FirstName, LastName, City, State from Person left join Address on Person.PersonId = Address.PersonId # select A.FirstName, A.LastName, B.City, B.State from Person A left join (select distinct PersonId, City, State from Address) B on A.PersonId=B.PersonId; 176.第二高的薪水(3) 题目 SQL架构 Create table If Not Exists Employee (Id int, Salary int) Truncate table Employee insert into Employee (Id, Salary) values ('1', '100') insert into Employee (Id, Salary) values ('2', '200') insert into Employee (Id, Salary) values ('3', '300') 编写一个 SQL 查询，获取 Employee 表中第二高的薪水（Salary） 。 +----+--------+ | Id | Salary | +----+--------+ | 1 | 100 | | 2 | 200 | | 3 | 300 | +----+--------+ 例如上述 Employee 表，SQL查询应该返回 200 作为第二高的薪水。 如果不存在第二高的薪水，那么查询应返回 null。 +---------------------+ | SecondHighestSalary | +---------------------+ | 200 | +---------------------+ 解题思路 No. 思路 01 把select语句包起来，使空的时候为null 02 使用ifnull 03 先查出最大的，然后查出比最大小的 select( select distinct Salary from Employee order by Salary desc limit 1 offset 1 ) as SecondHighestSalary; # select ifnull( (select distinct Salary from Employee order by Salary desc limit 1 offset 1),null ) as SecondHighestSalary; # select max(Salary) as SecondHighestSalary from Employee where Salary 181.超过经理收入的员工(3) 题目 SQL架构 Create table If Not Exists Employee (Id int, Name varchar(255), Salary int, ManagerId int) Truncate table Employee insert into Employee (Id, Name, Salary, ManagerId) values ('1', 'Joe', '70000', '3') insert into Employee (Id, Name, Salary, ManagerId) values ('2', 'Henry', '80000', '4') insert into Employee (Id, Name, Salary, ManagerId) values ('3', 'Sam', '60000', 'None') insert into Employee (Id, Name, Salary, ManagerId) values ('4', 'Max', '90000', 'None') Employee 表包含所有员工，他们的经理也属于员工。 每个员工都有一个 Id，此外还有一列对应员工的经理的 Id。 +----+-------+--------+-----------+ | Id | Name | Salary | ManagerId | +----+-------+--------+-----------+ | 1 | Joe | 70000 | 3 | | 2 | Henry | 80000 | 4 | | 3 | Sam | 60000 | NULL | | 4 | Max | 90000 | NULL | +----+-------+--------+-----------+ 给定 Employee 表，编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名。 在上面的表格中，Joe 是唯一一个收入超过他的经理的员工。 +----------+ | Employee | +----------+ | Joe | +----------+ 解题思路 No. 思路 01 使用笛卡尔乘积，和方法2一样 02 使用内链接 03 子查询 SELECT a.Name AS 'Employee' FROM Employee AS a, Employee AS b WHERE a.ManagerId = b.Id AND a.Salary > b.Salary; # SELECT a.Name AS 'Employee' FROM Employee AS a join Employee AS b on a.ManagerId = b.Id AND a.Salary > b.Salary; # select name as Employee from employee a where salary > (select salary from employee where a.managerid = id); 182.查找重复的电子邮箱(2) 题目 SQL架构 Create table If Not Exists Person (Id int, Email varchar(255)) Truncate table Person insert into Person (Id, Email) values ('1', 'a@b.com') insert into Person (Id, Email) values ('2', 'c@d.com') insert into Person (Id, Email) values ('3', 'a@b.com') 编写一个 SQL 查询，查找 Person 表中所有重复的电子邮箱。 示例： +----+---------+ | Id | Email | +----+---------+ | 1 | a@b.com | | 2 | c@d.com | | 3 | a@b.com | +----+---------+ 根据以上输入，你的查询应返回以下结果： +---------+ | Email | +---------+ | a@b.com | +---------+ 说明：所有电子邮箱都是小写字母。 解题思路 No. 思路 01 使用临时表 02 使用having子句 select Email from ( select Email, count(Email) as num from Person Group by Email ) as temp_table where num > 1; // select Email from Person group by Email having count(Email) > 1; 183.从不订购的客户(3) 题目 SQL架构 Create table If Not Exists Customers (Id int, Name varchar(255)) Create table If Not Exists Orders (Id int, CustomerId int) Truncate table Customers insert into Customers (Id, Name) values ('1', 'Joe') insert into Customers (Id, Name) values ('2', 'Henry') insert into Customers (Id, Name) values ('3', 'Sam') insert into Customers (Id, Name) values ('4', 'Max') Truncate table Orders insert into Orders (Id, CustomerId) values ('1', '3') insert into Orders (Id, CustomerId) values ('2', '1') 某网站包含两个表，Customers 表和 Orders 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。 Customers 表： +----+-------+ | Id | Name | +----+-------+ | 1 | Joe | | 2 | Henry | | 3 | Sam | | 4 | Max | +----+-------+ Orders 表： +----+------------+ | Id | CustomerId | +----+------------+ | 1 | 3 | | 2 | 1 | +----+------------+ 例如给定上述表格，你的查询应返回： +-----------+ | Customers | +-----------+ | Henry | | Max | +-----------+ 解题思路 No. 思路 01 使用not in 02 左连接 03 使用not exists select Customers.Name as Customers from Customers where Customers.Id not in ( select CustomerId from Orders ); # select a.Name as Customers from Customers as a left join Orders as b on a.Id=b.CustomerId where b.CustomerId is null; # select name Customers from customers c where not exists ( select 1 from orders o where o.customerid=c.id ) 193.删除重复的电子邮箱(2) 题目 编写一个 SQL 查询，来删除 Person 表中所有重复的电子邮箱，重复的邮箱里只保留 Id 最小 的那个。 +----+------------------+ | Id | Email | +----+------------------+ | 1 | john@example.com | | 2 | bob@example.com | | 3 | john@example.com | +----+------------------+ Id 是这个表的主键。 例如，在运行你的查询语句之后，上面的 Person 表应返回以下几行: +----+------------------+ | Id | Email | +----+------------------+ | 1 | john@example.com | | 2 | bob@example.com | +----+------------------+ 提示： 执行 SQL 之后，输出是整个 Person 表。 使用 delete 语句。 解题思路 No. 思路 01 使用delete+自连接 02 使用delete，根据group by和min()查询出最小的id # delete p1 from Person p1, Person P2 where p1.Email = p2.Email and p1.Id > p2.Id # delete from Person where id not in ( select id from ( select min(id) as id from Person group by Email ) as temp_table ) 197.上升的温度(4) 题目 SQL架构 Create table If Not Exists Weather (Id int, RecordDate date, Temperature int) Truncate table Weather insert into Weather (Id, RecordDate, Temperature) values ('1', '2015-01-01', '10') insert into Weather (Id, RecordDate, Temperature) values ('2', '2015-01-02', '25') insert into Weather (Id, RecordDate, Temperature) values ('3', '2015-01-03', '20') insert into Weather (Id, RecordDate, Temperature) values ('4', '2015-01-04', '30') 给定一个 Weather 表，编写一个 SQL 查询，来查找与之前（昨天的）日期相比温度更高的所有日期的 Id。 +---------+------------------+------------------+ | Id(INT) | RecordDate(DATE) | Temperature(INT) | +---------+------------------+------------------+ | 1 | 2015-01-01 | 10 | | 2 | 2015-01-02 | 25 | | 3 | 2015-01-03 | 20 | | 4 | 2015-01-04 | 30 | +---------+------------------+------------------+ 例如，根据上述给定的 Weather 表格，返回如下 Id: +----+ | Id | +----+ | 2 | | 4 | +----+ 解题思路 No. 思路 01 自连接和datediff()的使用 02 自连接和adddate()的使用 03 自连接和unix_timestamp()的使用 04 自连接和subdate()的使用 # select A.Id as \"Id\" from Weather A join Weather B on datediff(A.RecordDate, B.RecordDate) = 1 and A.Temperature > B.Temperature # select A.Id as \"Id\" from Weather A join Weather B on A.Temperature > B.Temperature and A.RecordDate = adddate(B.RecordDate, 1) # select A.Id as \"Id\" from Weather A join Weather B on unix_timestamp(A.RecordDate) = unix_timestamp(B.RecordDate) + 86400 and A.Temperature > B.Temperature # select A.Id as \"Id\" from Weather A join Weather B on A.Temperature > B.Temperature and B.RecordDate = subdate(A.RecordDate, 1) 595.大的国(2) 题目 Create table If Not Exists World (name varchar(255), continent varchar(255), area int, population int, gdp int) Truncate table World insert into World (name, continent, area, population, gdp) values ('Afghanistan', 'Asia', '652230', '25500100', '20343000000') insert into World (name, continent, area, population, gdp) values ('Albania', 'Europe', '28748', '2831741', '12960000000') insert into World (name, continent, area, population, gdp) values ('Algeria', 'Africa', '2381741', '37100000', '188681000000') insert into World (name, continent, area, population, gdp) values ('Andorra', 'Europe', '468', '78115', '3712000000') insert into World (name, continent, area, population, gdp) values ('Angola', 'Africa', '1246700', '20609294', '100990000000') 这里有张 World 表 +-----------------+------------+------------+--------------+---------------+ | name | continent | area | population | gdp | +-----------------+------------+------------+--------------+---------------+ | Afghanistan | Asia | 652230 | 25500100 | 20343000 | | Albania | Europe | 28748 | 2831741 | 12960000 | | Algeria | Africa | 2381741 | 37100000 | 188681000 | | Andorra | Europe | 468 | 78115 | 3712000 | | Angola | Africa | 1246700 | 20609294 | 100990000 | +-----------------+------------+------------+--------------+---------------+ 如果一个国家的面积超过300万平方公里，或者人口超过2500万，那么这个国家就是大国家。 编写一个SQL查询，输出表中所有大国家的名称、人口和面积。 例如，根据上表，我们应该输出: +--------------+-------------+--------------+ | name | population | area | +--------------+-------------+--------------+ | Afghanistan | 25500100 | 652230 | | Algeria | 37100000 | 2381741 | +--------------+-------------+--------------+ 解题思路 No. 思路 01 or的使用 02 union的使用 select name, population, area from world where area > 3000000 or population > 25000000 # # or具有全表扫描机制 # union具有索引列查询速度快 # Union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序； # Union All：对两个结果集进行并集操作，包括重复行，不进行排序； select name, population, area from world where area > 3000000 union select name, population, area from world where population > 25000000 596.超过5名学生的课(2) 题目 Create table If Not Exists courses (student varchar(255), class varchar(255)) Truncate table courses insert into courses (student, class) values ('A', 'Math') insert into courses (student, class) values ('B', 'English') insert into courses (student, class) values ('C', 'Math') insert into courses (student, class) values ('D', 'Biology') insert into courses (student, class) values ('E', 'Math') insert into courses (student, class) values ('F', 'Computer') insert into courses (student, class) values ('G', 'Math') insert into courses (student, class) values ('H', 'Math') insert into courses (student, class) values ('I', 'Math') 有一个courses 表 ，有: student (学生) 和 class (课程)。 请列出所有超过或等于5名学生的课。 例如,表: +---------+------------+ | student | class | +---------+------------+ | A | Math | | B | English | | C | Math | | D | Biology | | E | Math | | F | Computer | | G | Math | | H | Math | | I | Math | +---------+------------+ 应该输出: +---------+ | class | +---------+ | Math | +---------+ Note: 学生在每个课中不应被重复计算。 解题思路 No. 思路 01 group by + having 02 group by + 临时表 select class from courses group by class having count(distinct student) >= 5 # select class from (select class, count(distinct student) as num from courses group by class) as temp_table where num >= 5 620.有趣的电影(2) 题目 Create table If Not Exists cinema (id int, movie varchar(255), description varchar(255), rating float(2, 1)) Truncate table cinema insert into cinema (id, movie, description, rating) values ('1', 'War', 'great 3D', '8.9') insert into cinema (id, movie, description, rating) values ('2', 'Science', 'fiction', '8.5') insert into cinema (id, movie, description, rating) values ('3', 'irish', 'boring', '6.2') insert into cinema (id, movie, description, rating) values ('4', 'Ice song', 'Fantacy', '8.6') insert into cinema (id, movie, description, rating) values ('5', 'House card', 'Interesting', '9.1') 某城市开了一家新的电影院，吸引了很多人过来看电影。 该电影院特别注意用户体验，专门有个 LED显示板做电影推荐，上面公布着影评和相关电影描述。 作为该电影院的信息部主管，您需要编写一个 SQL查询， 找出所有影片描述为非 boring (不无聊) 的并且 id 为奇数 的影片，结果请按等级 rating 排列。 例如，下表 cinema: +---------+-----------+--------------+-----------+ | id | movie | description | rating | +---------+-----------+--------------+-----------+ | 1 | War | great 3D | 8.9 | | 2 | Science | fiction | 8.5 | | 3 | irish | boring | 6.2 | | 4 | Ice song | Fantacy | 8.6 | | 5 | House card| Interesting| 9.1 | +---------+-----------+--------------+-----------+ 对于上面的例子，则正确的输出是为： +---------+-----------+--------------+-----------+ | id | movie | description | rating | +---------+-----------+--------------+-----------+ | 5 | House card| Interesting| 9.1 | | 1 | War | great 3D | 8.9 | +---------+-----------+--------------+-----------+ 解题思路 No. 思路 01 mod的使用 02 常用操作 select * from cinema where mod(id,2)=1 and description != 'boring' order by rating desc # select * from cinema where id%2=1 and description != 'boring' order by rating desc 627.交换工资(3) 题目 create table if not exists salary(id int, name varchar(100), sex char(1), salary int) Truncate table salary insert into salary (id, name, sex, salary) values ('1', 'A', 'm', '2500') insert into salary (id, name, sex, salary) values ('2', 'B', 'f', '1500') insert into salary (id, name, sex, salary) values ('3', 'C', 'm', '5500') insert into salary (id, name, sex, salary) values ('4', 'D', 'f', '500') 给定一个 salary 表，如下所示，有 m = 男性 和 f = 女性 的值。 交换所有的 f 和 m 值（例如，将所有 f 值更改为 m，反之亦然）。 要求只使用一个更新（Update）语句，并且没有中间的临时表。 注意，您必只能写一个 Update 语句，请不要编写任何 Select 语句。 例如： | id | name | sex | salary | |----|------|-----|--------| | 1 | A | m | 2500 | | 2 | B | f | 1500 | | 3 | C | m | 5500 | | 4 | D | f | 500 | 运行你所编写的更新语句之后，将会得到以下表: | id | name | sex | salary | |----|------|-----|--------| | 1 | A | f | 2500 | | 2 | B | m | 1500 | | 3 | C | f | 5500 | | 4 | D | m | 500 | 解题思路 No. 思路 01 update+case 02 update+if 03 update+ascii互转 update salary set sex= CASE sex when 'm' then 'f' else 'm' END # update salary set sex=if(sex='f','m','f') # update salary set sex=char(ascii('m')+ascii('f')-ascii(sex)) 1179.重新格式化部门表(2) 题目 部门表 Department： Create table If Not Exists Department (id int, revenue int, month varchar(5)) Truncate table Department insert into Department (id, revenue, month) values ('1', '8000', 'Jan') insert into Department (id, revenue, month) values ('2', '9000', 'Jan') insert into Department (id, revenue, month) values ('3', '10000', 'Feb') insert into Department (id, revenue, month) values ('1', '7000', 'Feb') insert into Department (id, revenue, month) values ('1', '6000', 'Mar') +---------------+---------+ | Column Name | Type | +---------------+---------+ | id | int | | revenue | int | | month | varchar | +---------------+---------+ (id, month) 是表的联合主键。 这个表格有关于每个部门每月收入的信息。 月份（month）可以取下列值 [\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"]。 编写一个 SQL 查询来重新格式化表，使得新的表中有一个部门 id 列和一些对应 每个月 的收入（revenue）列。 查询结果格式如下面的示例所示： Department 表： +------+---------+-------+ | id | revenue | month | +------+---------+-------+ | 1 | 8000 | Jan | | 2 | 9000 | Jan | | 3 | 10000 | Feb | | 1 | 7000 | Feb | | 1 | 6000 | Mar | +------+---------+-------+ 查询得到的结果表： +------+-------------+-------------+-------------+-----+-------------+ | id | Jan_Revenue | Feb_Revenue | Mar_Revenue | ... | Dec_Revenue | +------+-------------+-------------+-------------+-----+-------------+ | 1 | 8000 | 7000 | 6000 | ... | null | | 2 | 9000 | null | null | ... | null | | 3 | null | 10000 | null | ... | null | +------+-------------+-------------+-------------+-----+-------------+ 注意，结果表有 13 列 (1个部门 id 列 + 12个月份的收入列)。 解题思路 No. 思路 01 group by+case when then end+sum/max 02 group by+if+sum/max select id, sum(case month when 'Jan' then revenue end) Jan_Revenue, sum(case month when 'Feb' then revenue end) Feb_Revenue, sum(case month when 'Mar' then revenue end) Mar_Revenue, sum(case month when 'Apr' then revenue end) Apr_Revenue, sum(case month when 'May' then revenue end) May_Revenue, sum(case month when 'Jun' then revenue end) Jun_Revenue, sum(case month when 'Jul' then revenue end) Jul_Revenue, sum(case month when 'Aug' then revenue end) Aug_Revenue, sum(case month when 'Sep' then revenue end) Sep_Revenue, sum(case month when 'Oct' then revenue end) Oct_Revenue, sum(case month when 'Nov' then revenue end) Nov_Revenue, sum(case month when 'Dec' then revenue end) Dec_Revenue from department group by id; # select id, sum(if(`month` = 'Jan', revenue, null)) as \"Jan_Revenue\", sum(if(`month` = 'Feb', revenue, null)) as \"Feb_Revenue\", sum(if(`month` = 'Mar', revenue, null)) as \"Mar_Revenue\", sum(if(`month` = 'Apr', revenue, null)) as \"Apr_Revenue\", sum(if(`month` = 'May', revenue, null)) as \"May_Revenue\", sum(if(`month` = 'Jun', revenue, null)) as \"Jun_Revenue\", sum(if(`month` = 'Jul', revenue, null)) as \"Jul_Revenue\", sum(if(`month` = 'Aug', revenue, null)) as \"Aug_Revenue\", sum(if(`month` = 'Sep', revenue, null)) as \"Sep_Revenue\", sum(if(`month` = 'Oct', revenue, null)) as \"Oct_Revenue\", sum(if(`month` = 'Nov', revenue, null)) as \"Nov_Revenue\", sum(if(`month` = 'Dec', revenue, null)) as \"Dec_Revenue\" from Department group by id; Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 09:46:03 "},"docs/source/question/bash.html":{"url":"docs/source/question/bash.html","title":"bash","keywords":"","body":"Bash Bash 193.有效电话号码(4) 195. 第十行(4) 193.有效电话号码(4) 题目 给定一个包含电话号码列表（一行一个电话号码）的文本文件 file.txt， 写一个 bash 脚本输出所有有效的电话号码。 你可以假设一个有效的电话号码必须满足以下两种格式： (xxx) xxx-xxxx 或 xxx-xxx-xxxx。（x 表示一个数字） 你也可以假设每行前后没有多余的空格字符。 示例: 假设 file.txt 内容如下： 987-123-4567 123 456 7890 (123) 456-7890 你的脚本应当输出下列有效的电话号码： 987-123-4567 (123) 456-7890 解题思路分析 No. 思路 01 正则表达式_cat_grep 02 正则表达式_grep 03 正则表达式_awk 04 正则表达式_grep # 正则表达式_cat_grep # (xxx) xxx-xxxx 或 xxx-xxx-xxxx # ^\\([0-9]{3}\\) [0-9]{3}-[0-9]{4}$ (xxx) xxx-xxxx # ^[0-9]{3}-[0-9]{3}-[0-9]{4}$ xxx-xxx-xxxx # grep -P 匹配正则 cat file.txt | grep -P \"^\\([0-9]{3}\\) [0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}$\" # (xxx) xxx-xxxx 或 xxx-xxx-xxxx grep -P \"^([0-9]{3}-|\\([0-9]{3}\\) )[0-9]{3}-[0-9]{4}$\" file.txt grep -E \"^([0-9]{3}-|\\([0-9]{3}\\) )[0-9]{3}-[0-9]{4}$\" file.txt # awk \"/^([0-9]{3}-|\\([0-9]{3}\\) )[0-9]{3}-[0-9]{4}$/\" file.txt # grep -P \"^(\\d{3}-|\\(\\d{3}\\) )\\d{3}-\\d{4}$\" file.txt 195. 第十行(4) 题目 给定一个文本文件 file.txt，请只打印这个文件中的第十行。 示例: 假设 file.txt 有如下内容： Line 1 Line 2 Line 3 Line 4 Line 5 Line 6 Line 7 Line 8 Line 9 Line 10 你的脚本应当显示第十行： Line 10 说明: 1. 如果文件少于十行，你应当输出什么？ 2. 至少有三种不同的解法，请尝试尽可能多的方法来解题。 解题思路分析 No. 思路 01 awk NR 02 tail head 03 sed # awk 'NR==10' file.txt # tail -n +10 file.txt | head -1 # sed -n 10p file.txt Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 09:46:03 "},"docs/source/question/offer.html":{"url":"docs/source/question/offer.html","title":"剑指offer","keywords":"","body":"剑指offer 剑指offer 参考资料 面试题03.数组中重复的数字(6) 面试题04.二维数组中的查找(6) 面试题05.替换空格(2) 面试题06.从尾到头打印链表(5) 面试题07.重建二叉树(3) 面试题09.用两个栈实现队列(1) 面试题10- I.斐波那契数列(5) 面试题10-II.青蛙跳台阶问题(3) 面试题11.旋转数组的最小数字(4) 面试题12.矩阵中的路径(2) 面试题13.机器人的运动范围(3) 面试题14- I.剪绳子(2) 面试题14-II.剪绳子 II(2) 面试题15.二进制中1的个数(4) 面试题16.数值的整数次方(2) 面试题17.打印从1到最大的n位数(4) 面试题18.删除链表的节点(2) 面试题19.正则表达式匹配(2) 面试题20.表示数值的字符串(1) 面试题21.调整数组顺序使奇数位于偶数前面(4) 面试题22.链表中倒数第k个节点(5) 面试题24.反转链表(4) 面试题25.合并两个排序的链表(3) 面试题26.树的子结构(2) 面试题27.二叉树的镜像(2) 面试题28.对称的二叉树(2) 面试题29.顺时针打印矩阵(2) 面试题30.包含min函数的栈(2) 面试题31.栈的压入弹出序列(2) 面试题32-I.从上到下打印二叉树(2) 面试题32-II.从上到下打印二叉树II(2) 面试题32-III.从上到下打印二叉树III(2) 面试题33.二叉搜索树的后序遍历序列(3) 面试题34.二叉树中和为某一值的路径(2) 面试题35.复杂链表的复制(3) 面试题38.字符串的排列(2) 面试题39.数组中出现次数超过一半的数字(5) 面试题40.最小的k个数(4) 面试题41.数据流中的中位数(1) 面试题42.连续子数组的最大和(4) 面试题43.1～n整数中1出现的次数(3) 面试题44.数字序列中某一位的数字(2) 面试题45.把数组排成最小的数(3) 面试题46.把数字翻译成字符串(4) 面试题47.礼物的最大价值(2) 面试题48.最长不含重复字符的子字符串(4) 面试题49.丑数(1) 面试题50.第一个只出现一次的字符(3) 面试题51.数组中的逆序对(1) 面试题52.两个链表的第一个公共节点(4) 面试题53-I.在排序数组中查找数字I(5) 面试题53-II.0～n-1中缺失的数字(6) 面试题54.二叉搜索树的第k大节点(3) 面试题55-I.二叉树的深度(2) 面试题55-II.平衡二叉树(2) 面试题56-I.数组中数字出现的次数(5) 面试题56-II.数组中数字出现的次数II(5) 面试题57.和为s的两个数字(2) 面试题57-II.和为s的连续正数序列(4) 面试题58-I.翻转单词顺序(3) 面试题58-II.左旋转字符串(2) 面试题59-I.滑动窗口的最大值(4) 面试题59-II.队列的最大值(2) 面试题60.n个骰子的点数(2) 面试题61.扑克牌中的顺子(3) 面试题62.圆圈中最后剩下的数字(2) 面试题63.股票的最大利润(3) 面试题64.求1 2 … n(2) 面试题65.不用加减乘除做加法(2) 面试题66.构建乘积数组(2) 面试题67.把字符串转换成整数(2) 参考资料 leetcode专栏链接 https://leetcode-cn.com/problemset/lcof/ http://zhedahht.blog.163.com/ 《剑指Offer》第二版源代码 C++ https://github.com/zhedahht/CodingInterviewChinese2 面试题03.数组中重复的数字(6) 题目 找出数组中重复的数字。 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。 数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。 请找出数组中任意一个重复的数字。 示例 1：输入：[2, 3, 1, 0, 2, 5, 3] 输出：2 或 3 限制： 2 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(n) 02 排序遍历 O(nlog(n)) O(1) 03 暴力法 O(n^2) O(1) 04 遍历-置换 O(n) O(1) 05 遍历-置反 O(n) O(1) 06 遍历-置换(书上方法) O(n) O(1) func findRepeatNumber(nums []int) int { m := make(map[int]int) for i := 0; i 0 { return 0 } countZero++ continue } if value 面试题04.二维数组中的查找(6) 题目 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。 请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 示例: 现有矩阵 matrix 如下： [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] 给定 target = 5，返回 true。 给定 target = 20，返回 false。 限制： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法 O(n^2) O(1) 02 暴力法-优化 O(n^2) O(1) 03 二分查找 O(nlog(n)) O(1) 04 左下角查找 O(n) O(1) 05 右上角查找(书上方法) O(n) O(1) 06 内置函数 O(n^2) O(1) func findNumberIn2DArray(matrix [][]int, target int) bool { if len(matrix) == 0 { return false } if len(matrix[0]) == 0 { return false } for i := 0; i = target { for j := 0; j = target { res := binarySearch(matrix[i], target) if res == true { return true } } } return false } func binarySearch(arr []int, target int) bool { left := 0 right := len(arr) - 1 for left target { right = mid - 1 } else { left = mid + 1 } } return false } # 4 func findNumberIn2DArray(matrix [][]int, target int) bool { if len(matrix) == 0 { return false } if len(matrix[0]) == 0 { return false } i := len(matrix) - 1 j := 0 for i >= 0 && j target { i-- } else { j++ } } return false } # 5 func findNumberIn2DArray(matrix [][]int, target int) bool { if len(matrix) == 0 { return false } if len(matrix[0]) == 0 { return false } i := 0 j := len(matrix[0]) - 1 for j >= 0 && i target { j-- } else { i++ } } return false } # 6 func findNumberIn2DArray(matrix [][]int, target int) bool { if len(matrix) == 0 { return false } if len(matrix[0]) == 0 { return false } for i := 0; i 面试题05.替换空格(2) 题目 请实现一个函数，把字符串 s 中的每个空格替换成\"%20\"。 示例 1：输入：s = \"We are happy.\" 输出：\"We%20are%20happy.\" 限制：0 解题思路 No. 思路 时间复杂度 空间复杂度 01 内置函数 O(n) O(n) 02 遍历 O(n) O(n) func replaceSpace(s string) string { return strings.Replace(s,\" \",\"%20\",-1) // return strings.ReplaceAll(s, \" \", \"%20\") } # func replaceSpace(s string) string { res := \"\" for i := 0; i 面试题06.从尾到头打印链表(5) 题目 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 示例 1：输入：head = [1,3,2] 输出：[2,3,1] 限制：0 解题思路 No. 思路 时间复杂度 空间复杂度 01 反转数组 O(n) O(n) 02 递归(书上方法) O(n) O(n) 03 反转链表 O(n) O(n) 04 栈辅助(书上方法) O(n) O(n) 05 统计+遍历 O(n) O(n) func reversePrint(head *ListNode) []int { res := make([]int, 0) for head != nil { res = append(res, head.Val) head = head.Next } i := 0 for i 0{ node := stack[len(stack)-1] stack = stack[:len(stack)-1] res = append(res, node.Val) } return res } # 5 func reversePrint(head *ListNode) []int { cur := head count := 0 for head != nil { count++ head = head.Next } res := make([]int, count) for cur != nil { res[count-1] = cur.Val count-- cur = cur.Next } return res } 面试题07.重建二叉树(3) 题目 输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。 假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 例如，给出 前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树： 3 / \\ 9 20 / \\ 15 7 限制：0 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(n) 02 迭代 O(n) O(n) 03 递归(书上方法) O(n) O(n) func buildTree(preorder []int, inorder []int) *TreeNode { for k := range inorder { if inorder[k] == preorder[0] { return &TreeNode{ Val: preorder[0], Left: buildTree(preorder[1:k+1], inorder[0:k]), Right: buildTree(preorder[k+1:], inorder[k+1:]), } } } return nil } # func buildTree(preorder []int, inorder []int) *TreeNode { if preorder == nil || len(preorder) == 0 { return nil } root := &TreeNode{ Val: preorder[0], } length := len(preorder) stack := make([]*TreeNode, 0) stack = append(stack, root) index := 0 for i := 1; i 0 && stack[len(stack)-1].Val == inorder[index] { node = stack[len(stack)-1] stack = stack[:len(stack)-1] index++ } node.Right = &TreeNode{Val: value} stack = append(stack, node.Right) } } return root } # func buildTree(preorder []int, inorder []int) *TreeNode { if len(preorder) == 0 { return nil } return helper(preorder, inorder) } func helper(preorder []int, inorder []int) *TreeNode { var root *TreeNode for k := range inorder { if inorder[k] == preorder[0] { root = &TreeNode{Val: preorder[0]} root.Left = helper(preorder[1:k+1], inorder[0:k]) root.Right = helper(preorder[k+1:], inorder[k+1:]) } } return root } 面试题09.用两个栈实现队列(1) 题目 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ， 分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) 示例 1：输入： [\"CQueue\",\"appendTail\",\"deleteHead\",\"deleteHead\"] [[],[3],[],[]] 输出：[null,null,3,-1] 示例 2：输入： [\"CQueue\",\"deleteHead\",\"appendTail\",\"appendTail\",\"deleteHead\",\"deleteHead\"] [[],[],[5],[2],[],[]] 输出：[null,-1,null,null,5,2] 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 栈模拟队列 O(n) O(n) type stack []int func (s *stack) Push(value int) { *s = append(*s, value) } func (s *stack) Pop() int { value := (*s)[len(*s)-1] *s = (*s)[:len(*s)-1] return value } type CQueue struct { tail stack head stack } func Constructor() CQueue { return CQueue{} } // 1.入队，tail栈保存 // 2.出队, head不为空，出head；head为空，tail出到head里，最后出head func (this *CQueue) AppendTail(value int) { this.tail.Push(value) } func (this *CQueue) DeleteHead() int { if len(this.head) != 0 { return this.head.Pop() } else if len(this.tail) != 0 { for len(this.tail) > 0 { this.head.Push(this.tail.Pop()) } return this.head.Pop() } return -1 } 面试题10- I.斐波那契数列(5) 题目 写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下： F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), 其中 N > 1. 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例 1：输入：n = 2输出：1 示例 2：输入：n = 5输出：5 提示： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历(书上方法) O(n) O(1) 02 遍历+数组 O(n) O(n) 03 矩阵快速幂(书上方法) O(log(n)) O(1) 04 矩阵快速幂(书上方法) O(n) O(1) 05 递归 O(n) O(n) func fib(n int) int { if n == 0 { return 0 } if n == 1 { return 1 } n1, n2 := 0, 1 for i := 2; i 0{ if n % 2 == 1{ ans = multi(ans, m) } m = multi(m, m) n = n >> 1 } return ans.b } /* a b c d */ type matrix struct { a, b, c, d int } // 矩阵乘法 func multi(x, y matrix) matrix { newA := x.a*y.a + x.b*y.c newB := x.a*y.b + x.b*y.d newC := x.c*y.a + x.d*y.c newD := x.c*y.b + x.d*y.d return matrix{ a: newA% 1000000007, b: newB% 1000000007, c: newC% 1000000007, d: newD% 1000000007, } } # func fib(n int) int { if n == 0 { return 0 } /* ans = [Fn+1 Fn Fn Fn-1] = [ 1 0 0 1] */ ans := matrix{ a: 1, b: 0, c: 0, d: 1, } m := matrix{ a: 1, b: 1, c: 1, d: 0, } for n > 0 { if n%2 == 1 { ans = multi(ans, m) } m = multi(m, m) n = n >> 1 } return ans.b } /* a b c d */ type matrix struct { a, b, c, d int } // 矩阵乘法 func multi(x, y matrix) matrix { newA := x.a*y.a + x.b*y.c newB := x.a*y.b + x.b*y.d newC := x.c*y.a + x.d*y.c newD := x.c*y.b + x.d*y.d return matrix{ a: newA % 1000000007, b: newB % 1000000007, c: newC % 1000000007, d: newD % 1000000007, } } # 4 func fib(n int) int { if n == 0 { return 0 } /* ans = [Fn+1 Fn Fn Fn-1] = [ 1 0 0 1] */ ans := matrix{ a: 1, b: 0, c: 0, d: 1, } m := matrix{ a: 1, b: 1, c: 1, d: 0, } for n > 0 { ans = multi(ans, m) n-- } return ans.b } /* a b c d */ type matrix struct { a, b, c, d int } // 矩阵乘法 func multi(x, y matrix) matrix { newA := x.a*y.a + x.b*y.c newB := x.a*y.b + x.b*y.d newC := x.c*y.a + x.d*y.c newD := x.c*y.b + x.d*y.d return matrix{ a: newA % 1000000007, b: newB % 1000000007, c: newC % 1000000007, d: newD % 1000000007, } } # 5 var m = make(map[int]int) func fib(n int) int { if n == 0 { return 0 } if n == 1 { return 1 } if m[n] > 0 { return m[n] } m[n] = (fib(n-1) + fib(n-2)) % 1000000007 return m[n] } 面试题10-II.青蛙跳台阶问题(3) 题目 一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例 1：输入：n = 2输出：2 示例 2：输入：n = 7输出：21 提示： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n) O(n) 02 斐波那契 O(n) O(1) 03 递归 O(n) O(n) func numWays(n int) int { if n 0 { return m[n] } else { m[n] = (numWays(n-1) + numWays(n-2)) % 1000000007 } return m[n] } 面试题11.旋转数组的最小数字(4) 题目 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。 例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 示例 1：输入：[3,4,5,1,2]输出：1 示例 2：输入：[2,2,2,0,1]输出：0 注意：本题与主站 154 题相同： https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/ 解题思路 No. 思路 时间复杂度 空间复杂度 01 二分查找 O(log(n)) O(1) 02 排序 O(nlog(n)) O(1) 03 遍历 O(n) O(1) 04 二分查找(书上方法) O(log(n)) O(1) func minArray(numbers []int) int { left := 0 right := len(numbers) - 1 for left numbers[left] { left = mid + 1 } else if numbers[mid] = numbers[right] { if right-left == 1 { mid = right break } mid = (left + right) / 2 if numbers[left] == numbers[right] && numbers[mid] == numbers[left] { return minInorder(numbers, left, right) } if numbers[mid] >= numbers[left] { left = mid } else if numbers[mid] numbers[i] { result = numbers[i] } } return result } 面试题12.矩阵中的路径(2) 题目 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。 路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。 如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。 例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。 [[\"a\",\"b\",\"c\",\"e\"], [\"s\",\"f\",\"c\",\"s\"], [\"a\",\"d\",\"e\",\"e\"]] 但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后， 路径不能再次进入这个格子。 示例 1：输入：board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\" 输出：true 示例 2：输入：board = [[\"a\",\"b\"],[\"c\",\"d\"]], word = \"abcd\" 输出：false 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 深度优先搜索+回溯 O(n^2) O(n) 02 深度优先搜索+回溯+数组辅助(书上方法) O(n^2) O(n^2) func exist(board [][]byte, word string) bool { for i := 0; i = len(board) || j = len(board[0]) || board[i][j] != word[level] { return false } if level == len(word)-1 { return true } temp := board[i][j] board[i][j] = ' ' res := dfs(board, i+1, j, word, level+1) || dfs(board, i-1, j, word, level+1) || dfs(board, i, j+1, word, level+1) || dfs(board, i, j-1, word, level+1) board[i][j] = temp return res } # func exist(board [][]byte, word string) bool { visited := make([][]bool, len(board)) for i := 0; i = 0 && i = 0 && j 面试题13.机器人的运动范围(3) 题目 地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。 一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外）， 也不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。 但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？ 示例 1：输入：m = 2, n = 3, k = 1 输出：3 示例 2：输入：m = 3, n = 1, k = 0 输出：1 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 深度优先搜索(书上方法) O(n^2) O(n^2) 02 暴力法 O(n^2) O(n^2) 03 广度优先搜索 O(n^2) O(n^2) func movingCount(m int, n int, k int) int { if k = 0 && x = 0 && y 0 { sum = sum + num%10 num = num / 10 } return sum } # func movingCount(m int, n int, k int) int { if k = 0 && visited[i-1][j] == true) || (j-1 >= 0 && visited[i][j-1] == true) { value := getDigiSum(i) + getDigiSum(j) if value 0 { sum = sum + num%10 num = num / 10 } return sum } # func movingCount(m int, n int, k int) int { if k 0 { node := queue[0] queue = queue[1:] x := node[0] y := node[1] if getDigiSum(x)+getDigiSum(y) = 0 && getDigiSum(x-1)+getDigiSum(y) = 0 && getDigiSum(x)+getDigiSum(y-1) 0 { sum = sum + num%10 num = num / 10 } return sum } 面试题14- I.剪绳子(2) 题目 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1）， 每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？ 例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 示例 1： 输入: 2 输出: 1 解释: 2 = 1 + 1, 1 × 1 = 1 示例 2: 输入: 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36 提示：2 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划(书上方法) O(n^2) O(n) 02 贪心法 O(1) O(1) func cuttingRope(n int) int { if n max { max = length } dp[i] = max } } return dp[n] } # func cuttingRope(n int) int { if n 面试题14-II.剪绳子 II(2) 题目 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1）， 每段绳子的长度记为 k[0],k[1]...k[m] 。请问 k[0]*k[1]*...*k[m] 可能的最大乘积是多少？ 例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例 1：输入: 2 输出: 1 解释: 2 = 1 + 1, 1 × 1 = 1 示例 2:输入: 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36 提示：2 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n) O(n) 02 贪心法 O(n) O(1) func cuttingRope(n int) int { if n 面试题15.二进制中1的个数(4) 题目 请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。 例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。 示例 1： 输入：00000000000000000000000000001011 输出：3 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。 示例 2：输入：00000000000000000000000010000000 输出：1 解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。 示例 3：输入：11111111111111111111111111111101 输出：31 解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。 注意：本题与主站 191 题相同：https://leetcode-cn.com/problems/number-of-1-bits/ 解题思路 No. 思路 时间复杂度 空间复杂度 01 循环位计算 O(1) O(1) 02 位计算 n&(n-1)，会把该整数的最右边的1变成0(书上方法) O(1) O(1) 03 内置函数 O(1) O(1) 04 遍历(书上方法) O(1) O(1) func hammingWeight(num uint32) int { count := 0 for num != 0 { if num&1 == 1 { count++ } num = num >> 1 } return count } # func hammingWeight(num uint32) int { count := 0 for num != 0 { num = num & (num - 1) count++ } return count } # func hammingWeight(num uint32) int { return strings.Count(strconv.FormatInt(int64(num), 2), \"1\") // return strings.Count(fmt.Sprintf(\"%b\",num),\"1\") } # func hammingWeight(num uint32) int { count := 0 flag := uint32(1) for flag != 0{ if num & flag == flag{ count++ } flag = flag 面试题16.数值的整数次方(4) 题目 实现函数double Power(double base, int exponent)，求base的exponent次方。 不得使用库函数，同时不需要考虑大数问题。 示例 1:输入: 2.00000, 10 输出: 1024.00000 示例 2:输入: 2.10000, 3 输出: 9.26100 示例 3:输入: 2.00000, -2 输出: 0.25000 解释: 2-2 = 1/22 = 1/4 = 0.25 说明: -100.0 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归(书上方法) O(log(n)) O(log(n)) 02 迭代 O(log(n)) O(1) 03 计算 O(log(n)) O(1) 04 递归 O(log(n)) O(1) func myPow(x float64, n int) float64 { if n == 0 { return 1 } if n == 1 { return x } res := 1.0 if n > 0 { res = myPow(x, n/2) return res * res * myPow(x, n%2) } else { res = myPow(x, -n/2) res = res * res * myPow(x, -n%2) return 1 / res } } # func myPow(x float64, n int) float64 { if n == 0 { return 1 } if n == 1 { return x } res := 1.0 if n = 1 { if n%2 == 1 { res = res * x n-- } else { x = x * x n = n / 2 } } return res } # func myPow(x float64, n int) float64 { return math.Pow(x, float64(n)) } # func myPow(x float64, n int) float64 { if n == 0 { return 1 } if n 面试题17.打印从1到最大的n位数(4) 题目 输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。 比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。 示例 1: 输入: n = 1 输出: [1,2,3,4,5,6,7,8,9] 说明： 用返回一个整数列表来代替打印 n 为正整数 解题思路 No. 思路 时间复杂度 空间复杂度 01 求最大 O(10^n) O(10^n) 02 求最大 O(10^n) O(10^n) 03 递归+全排列(书上方法) O(10^n) O(10^n) 04 模拟进位(书上方法) O(10^n) O(10^n) func printNumbers(n int) []int { res := make([]int, 0) maxValue := 0 for n > 0 { maxValue = maxValue*10 + 9 n-- } for i := 1; i = 0; i-- { sum := int(arr[i]-'0') + nTakeOver if i == len(arr)-1 { sum++ } if sum >= 10 { if i == 0 { isOverflow = true } else { sum = sum - 10 nTakeOver = 1 arr[i] = rune('0' + sum) } } else { arr[i] = rune('0' + sum) break } } return isOverflow } func printNum(arr []rune) string { res := \"\" isBeginning := true for i := 0; i 面试题18.删除链表的节点(2) 题目 给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。 返回删除后的链表的头节点。 注意：此题对比原题有改动 示例 1:输入: head = [4,5,1,9], val = 5 输出: [4,1,9] 解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9. 示例 2:输入: head = [4,5,1,9], val = 1 输出: [4,5,9] 解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9. 说明： 题目保证链表中节点的值互不相同 若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点 解题思路 No. 思路 时间复杂度 空间复杂度 01 哨兵结点+链表遍历 O(n) O(1) 02 递归 O(n) O(n) func deleteNode(head *ListNode, val int) *ListNode { headPre := &ListNode{Next: head} temp := headPre for temp.Next != nil { if temp.Next.Val == val { temp.Next = temp.Next.Next break } else { temp = temp.Next } } return headPre.Next } # func deleteNode(head *ListNode, val int) *ListNode { if head == nil { return nil } head.Next = deleteNode(head.Next, val) if head.Val == val { return head.Next } return head } 面试题19.正则表达式匹配(3) 题目 请实现一个函数用来匹配包含'. '和'*'的正则表达式。模式中的字符'.'表示任意一个字符， 而'*'表示它前面的字符可以出现任意次（含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。 例如，字符串\"aaa\"与模式\"a.a\"和\"ab*ac*a\"匹配，但与\"aa.a\"和\"ab*a\"均不匹配。 示例 1:输入: s = \"aa\" p = \"a\" 输出: false 解释: \"a\" 无法匹配 \"aa\" 整个字符串。 示例 2:输入: s = \"aa\" p = \"a*\" 输出: true 解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。 因此，字符串 \"aa\" 可被视为 'a' 重复了一次。 示例 3:输入:s = \"ab\" p = \".*\" 输出: true 解释: \".*\" 表示可匹配零个或多个（'*'）任意字符（'.'）。 示例 4: 输入:s = \"aab\" p = \"c*a*b\" 输出: true 解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 \"aab\"。 示例 5: 输入: s = \"mississippi\" p = \"mis*is*p*.\" 输出: false s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母以及字符 . 和 *，无连续的 '*'。 注意：本题与主站 10 题相同： https://leetcode-cn.com/problems/regular-expression-matching/ 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归(书上方法) O(n) O(n) 02 动态规划 O(n^2) O(n^2) 03 递归 O(n) O(n) func isMatch(s string, p string) bool { return dfs(s, p, 0, 0) } func dfs(s string, p string, i, j int) bool { if i >= len(s) && j >= len(p) { return true } if i = len(p) { return false } if j+1 1 { if p[i-2] == s[j-1] || p[i-2] == '.' { dp[i][j] = dp[i][j-1] || dp[i-2][j-1] || dp[i-2][j] } else { dp[i][j] = dp[i-2][j] } } } } } return dp[len(p)][len(s)] } # 3 func isMatch(s string, p string) bool { if len(s) == 0 && len(p) == 0 { return true } else if len(p) == 0 { return false } match := false // 正常匹配条件=>相等，或者 p[0]等于.就不用管s[0] if len(s) > 0 && (s[0] == p[0] || p[0] == '.') { match = true } // 匹配多个 就把 s 往后移1位，注意p不移动 // 匹配0个 就把 p 往后移2位，相当于p的*当前作废 if len(p) > 1 && p[1] == '*' { return (match && isMatch(s[1:], p)) || isMatch(s, p[2:]) } // 匹配当前成功，同时往后移 return match && isMatch(s[1:], p[1:]) } 面试题20.表示数值的字符串(1) 题目 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串\"+100\"、\"5e2\"、\"-123\"、\"3.1416\"、\"0123\"都表示数值， 但\"12e\"、\"1a3.14\"、\"1.2.3\"、\"+-5\"、\"-1E-16\"及\"12e+5.4\"都不是。 注意：本题与主站 65 题相同：https://leetcode-cn.com/problems/valid-number/ 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历-找规律(书上方法) O(n) O(1) func isNumber(s string) bool { s = strings.Trim(s, \" \") if s == \"\" || len(s) == 0 || len(s) == 0 { return false } arr := []byte(s) i := 0 numeric := scanInteger(&arr, &i) if i '9' { break } *index++ } return j 面试题21.调整数组顺序使奇数位于偶数前面(4) 题目 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分， 所有偶数位于数组的后半部分。 示例：输入：nums = [1,2,3,4] 输出：[1,3,2,4] 注：[3,1,2,4] 也是正确的答案之一。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n) O(1) 02 双指针(书上方法) O(n) O(1) 03 遍历 O(n) O(n) 04 遍历 O(n) O(1) func exchange(nums []int) []int { i := 0 j := len(nums) - 1 for i 面试题22.链表中倒数第k个节点(5) 题目 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数， 即链表的尾节点是倒数第1个节点。 例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。 这个链表的倒数第3个节点是值为4的节点。 示例：给定一个链表: 1->2->3->4->5, 和 k = 2. 返回链表 4->5. 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组辅助 O(n) O(n) 02 快慢指针(书上方法) O(n) O(1) 03 统计+遍历 O(n) O(1) 04 递归 O(n) O(n) 05 递归 O(n) O(n) func getKthFromEnd(head *ListNode, k int) *ListNode { arr := make([]*ListNode, 0) for head != nil { arr = append(arr, head) head = head.Next } if len(arr) >= k { return arr[len(arr)-k] } return nil } # func getKthFromEnd(head *ListNode, k int) *ListNode { fast := head for k > 0 && head != nil { fast = fast.Next k-- } if k > 0 { return nil } slow := head for fast != nil { fast = fast.Next slow = slow.Next } return slow } # func getKthFromEnd(head *ListNode, k int) *ListNode { temp := head count := 0 for temp != nil { count++ temp = temp.Next } if count 0 { return nil } return res } func dfs(node *ListNode, k int) (*ListNode, int) { if node == nil { return node, k } next, nextValue := dfs(node.Next, k) if nextValue 面试题24.反转链表(4) 题目 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。 示例: 输入: 1->2->3->4->5->NULL 输出: 5->4->3->2->1->NULL 限制：0 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(n) 02 迭代(书上方法) O(n) O(1) 03 数组辅助 O(n) O(n) 04 迭代-新建节点 O(n) O(1) func reverseList(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } result := reverseList(head.Next) head.Next.Next = head head.Next = nil return result } # func reverseList(head *ListNode) *ListNode { var result *ListNode var temp *ListNode for head != nil { temp = head.Next head.Next = result result = head head = temp } return result } # func reverseList(head *ListNode) *ListNode { result := &ListNode{} arr := make([]*ListNode, 0) for head != nil { arr = append(arr, head) head = head.Next } temp := result for i := len(arr) - 1; i >= 0; i-- { arr[i].Next = nil temp.Next = arr[i] temp = temp.Next } return result.Next } # func reverseList(head *ListNode) *ListNode { var res *ListNode for { if head == nil { break } res = &ListNode{head.Val, res} head = head.Next } return res } 面试题25.合并两个排序的链表(3) 题目 输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。 示例1：输入：1->2->4, 1->3->4 输出：1->1->2->3->4->4 限制：0 解题思路 No. 思路 时间复杂度 空间复杂度 01 迭代遍历 O(n) O(1) 02 递归(书上方法) O(n) O(n) 03 迭代 O(n) O(1) func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode { if l1 == nil { return l2 } if l2 == nil { return l1 } var head, node *ListNode if l1.Val 面试题26.树的子结构(2) 题目 输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构) B是A的子结构， 即 A中有出现和B相同的结构和节点值。 例如:给定的树 A: 3 / \\ 4 5 / \\ 1 2 给定的树 B： 4 / 1 返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。 示例 1：输入：A = [1,2,3], B = [3,1]输出：false 示例 2：输入：A = [3,4,5,1,2], B = [4,1]输出：true 限制：0 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归(书上方法) O(n^2) O(log(n)) 02 迭代+递归 O(n^2) O(n) func isSubStructure(A *TreeNode, B *TreeNode) bool { if A == nil || B == nil { return false } return dfs(A, B) || isSubStructure(A.Left, B) || isSubStructure(A.Right, B) } func dfs(A *TreeNode, B *TreeNode) bool { if B == nil { return true } if A == nil { return false } return dfs(A.Left, B.Left) && dfs(A.Right, B.Right) && A.Val == B.Val } # func isSubStructure(A *TreeNode, B *TreeNode) bool { if A == nil || B == nil { return false } res := false list := make([]*TreeNode, 0) list = append(list, A) for len(list) > 0 { node := list[0] list = list[1:] if node.Val == B.Val { res = dfs(node, B) if res == true { return true } } if node.Left != nil { list = append(list, node.Left) } if node.Right != nil { list = append(list, node.Right) } } return res } func dfs(A *TreeNode, B *TreeNode) bool { fmt.Println(A, B) if B == nil { return true } if A == nil { return false } return dfs(A.Left, B.Left) && dfs(A.Right, B.Right) && A.Val == B.Val } 面试题27.二叉树的镜像(2) 题目 请完成一个函数，输入一个二叉树，该函数输出它的镜像。 例如输入： 4 / \\ 2 7 / \\ / \\ 1 3 6 9 镜像输出： 4 / \\ 7 2 / \\ / \\ 9 6 3 1 示例 1：输入：root = [4,2,7,1,3,6,9] 输出：[4,7,2,9,6,3,1] 限制：0 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归(书上方法) O(n) O(n) 02 迭代 O(n) O(n) func mirrorTree(root *TreeNode) *TreeNode { if root == nil || (root.Left == nil && root.Right == nil) { return root } root.Left, root.Right = mirrorTree(root.Right), mirrorTree(root.Left) return root } # func mirrorTree(root *TreeNode) *TreeNode { if root == nil { return root } var queue []*TreeNode queue = append(queue, root) for len(queue) > 0 { node := queue[0] queue = queue[1:] node.Left, node.Right = node.Right, node.Left if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } return root } 面试题28.对称的二叉树(2) 题目 请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 / \\ 2 2 / \\ / \\ 3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 1 / \\ 2 2 \\ \\ 3 3 示例 1：输入：root = [1,2,2,3,4,4,3] 输出：true 示例 2：输入：root = [1,2,2,null,3,null,3] 输出：false 限制：0 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归(书上方法) O(n) O(n) 02 迭代 O(n) O(n) func isSymmetric(root *TreeNode) bool { if root == nil { return true } return recur(root.Left, root.Right) } func recur(left, right *TreeNode) bool { if left == nil && right == nil { return true } if left == nil || right == nil { return false } return left.Val == right.Val && recur(left.Left, right.Right) && recur(left.Right, right.Left) } # func isSymmetric(root *TreeNode) bool { leftQ := make([]*TreeNode, 0) rightQ := make([]*TreeNode, 0) leftQ = append(leftQ, root) rightQ = append(rightQ, root) for len(leftQ) != 0 && len(rightQ) != 0 { leftCur, rightCur := leftQ[0], rightQ[0] leftQ, rightQ = leftQ[1:], rightQ[1:] if leftCur == nil && rightCur == nil { continue } else if leftCur != nil && rightCur != nil && leftCur.Val == rightCur.Val { leftQ = append(leftQ, leftCur.Left, leftCur.Right) rightQ = append(rightQ, rightCur.Right, rightCur.Left) } else { return false } } if len(leftQ) == 0 && len(rightQ) == 0 { return true } else { return false } } 面试题29.顺时针打印矩阵(2) 题目 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。 示例 1：输入：matrix = [[1,2,3],[4,5,6],[7,8,9]] 输出：[1,2,3,6,9,8,7,4,5] 示例 2：输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]] 输出：[1,2,3,4,8,12,11,10,9,5,6,7] 限制：0 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历(书上方法) O(n^2) O(n^2) 02 遍历 O(n^2) O(n^2) var res []int func spiralOrder(matrix [][]int) []int { res = make([]int, 0) rows := len(matrix) if rows == 0 { return res } cols := len(matrix[0]) if cols == 0 { return res } start := 0 for cols > start*2 && rows > start*2 { printCircle(matrix, cols, rows, start) start++ } return res } func printCircle(matrix [][]int, cols, rows, start int) { x := cols - 1 - start y := rows - 1 - start // 左到右 for i := start; i = start; i-- { res = append(res, matrix[y][i]) } } // 下到上 if start = start+1; i-- { res = append(res, matrix[i][start]) } } } # func spiralOrder(matrix [][]int) []int { res := make([]int, 0) rows := len(matrix) if rows == 0 { return res } cols := len(matrix[0]) if cols == 0 { return res } x1, x2, y1, y2 := 0, rows-1, 0, cols-1 direct := 0 for x1 = y1; i-- { res = append(res, matrix[x2][i]) } x2-- } else if direct == 3 { for i := x2; i >= x1; i-- { res = append(res, matrix[i][y1]) } y1++ } direct++ } return res } 面试题30.包含min函数的栈(2) 题目 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中， 调用 min、push 及 pop 的时间复杂度都是 O(1)。 示例: MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.min(); --> 返回 -3. minStack.pop(); minStack.top(); --> 返回 0. minStack.min(); --> 返回 -2. 提示： 各函数的调用总次数不超过 20000 次 注意：本题与主站 155 题相同：https://leetcode-cn.com/problems/min-stack/ 解题思路 No. 思路 时间复杂度 空间复杂度 01 使用数组模拟栈，保存数据的时候同时保存当前的最小值 O(1) O(n) 02 使用双栈(书上方法) O(1) O(n) type item struct { min, x int } type MinStack struct { stack []item } func Constructor() MinStack { return MinStack{} } func (m *MinStack) Push(x int) { min := x if len(m.stack) > 0 && m.Min() 面试题31.栈的压入弹出序列(2) 题目 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。 假设压入栈的所有数字均不相等。 例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列， 但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。 示例 1：输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1] 输出：true 解释：我们可以按以下顺序执行： push(1), push(2), push(3), push(4), pop() -> 4, push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1 示例 2：输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2] 输出：false 解释：1 不能在 2 之前弹出。 提示： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 栈辅助 O(n) O(n) 02 栈辅助(书上方法) O(n) O(n) func validateStackSequences(pushed []int, popped []int) bool { stack := make([]int, 0) j := 0 for i := 0; i 0 && stack[len(stack)-1] == popped[j] { stack = stack[:len(stack)-1] j++ } } if len(stack) == 0 { return true } return false } # func validateStackSequences(pushed []int, popped []int) bool { stack := make([]int, 0) res := false i := 0 j := 0 for j 面试题32-I.从上到下打印二叉树(2) 题目 从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。 例如:给定二叉树: [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 返回：[3,9,20,15,7] 提示：节点总数 解题思路 No. 思路 时间复杂度 空间复杂度 01 层序遍历(书上方法) O(n) O(n) 02 递归 O(n) O(n) func levelOrder(root *TreeNode) []int { res := make([]int, 0) if root == nil { return res } list := make([]*TreeNode, 0) list = append(list, root) for len(list) > 0 { length := len(list) for i := 0; i 面试题32-II.从上到下打印二叉树II(2) 题目 从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。 例如: 给定二叉树: [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 返回其层次遍历结果： [ [3], [9,20], [15,7] ] 提示：节点总数 解题思路 No. 思路 时间复杂度 空间复杂度 01 层序遍历(书上方法) O(n) O(n) 02 递归 O(n) O(n) func levelOrder(root *TreeNode) [][]int { res := make([][]int, 0) if root == nil { return res } list := make([]*TreeNode, 0) list = append(list, root) for len(list) > 0 { length := len(list) temp := make([]int,0) for i := 0; i 面试题32-III.从上到下打印二叉树III(2) 题目 请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印， 第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。 例如:给定二叉树: [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 返回其层次遍历结果： [ [3], [20,9], [15,7] ] 提示：节点总数 解题思路 No. 思路 时间复杂度 空间复杂度 01 层序遍历(书上方法) O(n) O(n) 02 递归 O(n) O(n) func levelOrder(root *TreeNode) [][]int { res := make([][]int, 0) if root == nil { return res } list := make([]*TreeNode, 0) list = append(list, root) level := 0 for len(list) > 0 { length := len(list) temp := make([]int, 0) for i := 0; i = 0; i-- { temp = append(temp, list[i].Val) } } list = list[length:] res = append(res, temp) level++ } return res } # func levelOrder(root *TreeNode) [][]int { if root == nil { return nil } temp := make([][]int, 0) dfs(root, &temp, 0) return temp } func dfs(root *TreeNode, temp *[][]int, level int) { if root == nil { return } if len(*temp)-1 面试题33.二叉搜索树的后序遍历序列(3) 题目 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。 假设输入的数组的任意两个数字都互不相同。 参考以下这颗二叉搜索树： 5 / \\ 2 6 / \\ 1 3 示例 1：输入: [1,6,3,2,5]输出: false 示例 2：输入: [1,3,2,6,5]输出: true 提示： 数组长度 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归(书上方法) O(n^2) O(n) 02 迭代 O(n^2) O(1) 03 栈辅助 O(n) O(n) func verifyPostorder(postorder []int) bool { return dfs(postorder, 0, len(postorder)-1) } func dfs(postorder []int, start, end int) bool { if start >= end { return true } i := 0 for i = start; i postorder[end] { break } } for j := i + 1; j 0 { i := 0 for postorder[i] postorder[last] { i++ } if i != last { return false } last-- } return true } # func verifyPostorder(postorder []int) bool { if len(postorder) = 0; i-- { if postorder[i] > rootValue { // 左子树元素必须要小于递增栈根节点 return false } // 数组元素小于单调栈的元素了，表示往左子树走了，记录上个根节点 for len(stack) > 0 && postorder[i] 面试题34.二叉树中和为某一值的路径(2) 题目 输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。 从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。 示例:给定如下二叉树，以及目标和 sum = 22， 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\ 7 2 5 1 返回: [ [5,4,11,2], [5,8,4,5] ] 提示：节点总数 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归(书上方法) O(n) O(log(n)) 02 迭代 O(n) O(n) var res [][]int func pathSum(root *TreeNode, sum int) [][]int { if root == nil { return nil } res = make([][]int, 0) var arr []int dfs(root, sum, arr) return res } func dfs(root *TreeNode, sum int, arr []int) { if root == nil { return } arr = append(arr, root.Val) if root.Val == sum && root.Left == nil && root.Right == nil { temp := make([]int, len(arr)) copy(temp, arr) res = append(res, temp) } dfs(root.Left, sum-root.Val, arr) dfs(root.Right, sum-root.Val, arr) arr = arr[:len(arr)-1] } # func pathSum(root *TreeNode, sum int) [][]int { res := make([][]int, 0) if root == nil { return res } temp := make([]int, 0) stack := make([]*TreeNode, 0) visited := make(map[*TreeNode]bool) curSum := 0 for root != nil || len(stack) > 0 { for root != nil { temp = append(temp, root.Val) curSum = curSum + root.Val visited[root] = true stack = append(stack, root) root = root.Left } node := stack[len(stack)-1] if node.Right == nil || visited[node.Right] { if node.Left == nil && node.Right == nil && curSum == sum { tmp := make([]int, len(temp)) copy(tmp, temp) res = append(res, tmp) } stack = stack[:len(stack)-1] temp = temp[:len(temp)-1] curSum = curSum - node.Val root = nil } else { root = node.Right } } return res } 面试题35.复杂链表的复制(3) 题目 请实现 copyRandomList 函数，复制一个复杂链表。 在复杂链表中，每个节点除了有一个 next 指针指向下一个节点， 还有一个 random 指针指向链表中的任意节点或者 null。 示例 1： 输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]] 输出：[[7,null],[13,0],[11,4],[10,2],[1,0]] 示例 2：输入：head = [[1,1],[2,1]] 输出：[[1,1],[2,1]] 示例 3：输入：head = [[3,null],[3,0],[3,null]] 输出：[[3,null],[3,0],[3,null]] 示例 4：输入：head = [] 输出：[] 解释：给定的链表为空（空指针），因此返回 null。 提示： -10000 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助-递归 O(n) O(n) 02 哈希辅助 O(n) O(n) 03 复制-删除(书上方法) O(n) O(1) var m map[*Node]*Node func copyRandomList(head *Node) *Node { m = make(map[*Node]*Node) return copyList(head) } func copyList(head *Node) *Node { if head == nil { return head } if node, ok := m[head]; ok { return node } temp := &Node{ Val: head.Val, Next: nil, Random: nil, } m[head] = temp temp.Next = copyList(head.Next) temp.Random = copyList(head.Random) return temp } # func copyRandomList(head *Node) *Node { if head == nil { return nil } res := new(Node) m := make(map[*Node]*Node) temp := head p := res for temp != nil { node := &Node{ Val: temp.Val, Next: nil, Random: nil, } m[temp] = node p.Next = node p = p.Next temp = temp.Next } temp = head p = res.Next for temp != nil { p.Random = m[temp.Random] p = p.Next temp = temp.Next } return res.Next } # 3 func copyRandomList(head *Node) *Node { if head == nil { return nil } res := copyNext(head) res = copyRandom(res) res = cutEven(res) return res } // 原1-复制1-原2-复制2 func copyNext(head *Node) *Node { p := head for p != nil { node := new(Node) node.Val = p.Val node.Next = p.Next p.Next = node p = node.Next } return head } func copyRandom(head *Node) *Node { p := head for p != nil { if p.Random != nil { p.Next.Random = p.Random.Next } p = p.Next.Next } return head } func cutEven(head *Node) *Node { oldNode := head newNode := head.Next cur := newNode for oldNode != nil { oldNode.Next = oldNode.Next.Next if newNode.Next != nil{ newNode.Next = newNode.Next.Next } oldNode = oldNode.Next newNode = newNode.Next } return cur } 面试题38.字符串的排列(2) 题目 输入一个字符串，打印出该字符串中字符的所有排列。 你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。 示例:输入：s = \"abc\" 输出：[\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"] 限制：1 解题思路 No. 思路 时间复杂度 空间复杂度 01 回溯算法 O(n!) O(n!) 02 回溯算法-交换(书上方法) O(n!) O(n!) var m map[string]bool func permutation(s string) []string { m = make(map[string]bool) dfs(s, \"\") res := make([]string, 0) for key := range m { res = append(res, key) } return res } func dfs(s string, str string) { if len(s) == 0 { m[str] = true } for i := 0; i 面试题39.数组中出现次数超过一半的数字(5) 题目 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 示例 1:输入: [1, 2, 3, 2, 2, 2, 5, 4, 2] 输出: 2 限制：1 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序取半 O(nlog(n)) O(1) 02 哈希遍历 O(n) O(n) 03 Boyer-Moore投票算法(书上方法) O(n) O(1) 04 位运算 O(n) O(1) 05 分治法 O(nlog(n)) O(log(n)) func majorityElement(nums []int) int { sort.Ints(nums) return nums[len(nums)/2] } # 2 func majorityElement(nums []int) int { m := make(map[int]int) result := 0 for _, v := range nums{ if _,ok := m[v];ok{ m[v]++ }else { m[v]=1 } if m[v] > (len(nums)/2){ result = v } } return result } # 3 func majorityElement(nums []int) int { result, count := 0, 0 for i := 0; i len(nums)/2 { result = result | mask } mask = mask rightCount { return left } return right } 面试题40.最小的k个数(4) 题目 输入整数数组 arr ，找出其中最小的 k 个数。 例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。 示例 1：输入：arr = [3,2,1], k = 2 输出：[1,2] 或者 [2,1] 示例 2：输入：arr = [0,1,2,1], k = 1 输出：[0] 限制： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序 O(nlog(n)) O(1) 02 堆 O(nlog(n)) O(n) 03 计数统计 O(n) O(n) 04 快排切分(书上方法) O(n) O(1) func getLeastNumbers(arr []int, k int) []int { if len(arr) == 0 || k == 0 { return nil } sort.Ints(arr) return arr[:k] } # type IntHeap []int func (i IntHeap) Len() int { return len(i) } func (i IntHeap) Less(x, y int) bool { return i[x] > i[y] } func (i IntHeap) Swap(x, y int) { i[x], i[y] = i[y], i[x] } func (i *IntHeap) Push(v interface{}) { *i = append(*i, v.(int)) } func (i *IntHeap) Pop() interface{} { value := (*i)[len(*i)-1] *i = (*i)[:len(*i)-1] return value } func getLeastNumbers(arr []int, k int) []int { if len(arr) == 0 || k == 0 { return nil } intHeap := make(IntHeap, 0, k) heap.Init(&intHeap) for i := 0; i 0 { for i := 0; i = value && i = j { break } arr[i], arr[j] = arr[j], arr[i] } arr[left] = arr[i] arr[i] = value return i } 面试题41.数据流中的中位数(1) 题目 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。 如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。 例如， [2,3,4] 的中位数是 3 [2,3] 的中位数是 (2 + 3) / 2 = 2.5 设计一个支持以下两种操作的数据结构： void addNum(int num) - 从数据流中添加一个整数到数据结构中。 double findMedian() - 返回目前所有元素的中位数。 示例 1：输入： [\"MedianFinder\",\"addNum\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\"] [[],[1],[2],[],[3],[]] 输出：[null,null,null,1.50000,null,2.00000] 示例 2： 输入： [\"MedianFinder\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\"] [[],[2],[],[3],[]] 输出：[null,null,2.00000,null,2.50000] 限制：最多会对 addNum、findMedia进行 50000 次调用。 注意：本题与主站 295 题相同： https://leetcode-cn.com/problems/find-median-from-data-stream/ 解题思路 No. 思路 时间复杂度 空间复杂度 01 大小根堆-内置heap接口 O(log(n)) O(n) type MinHeap []int func (i MinHeap) Len() int { return len(i) } func (i MinHeap) Less(x, y int) bool { return i[x] i[y] } func (i MaxHeap) Swap(x, y int) { i[x], i[y] = i[y], i[x] } func (i *MaxHeap) Push(v interface{}) { *i = append(*i, v.(int)) } func (i *MaxHeap) Pop() interface{} { value := (*i)[len(*i)-1] *i = (*i)[:len(*i)-1] return value } type MedianFinder struct { minArr *MinHeap maxArr *MaxHeap } func Constructor() MedianFinder { res := new(MedianFinder) res.minArr = new(MinHeap) res.maxArr = new(MaxHeap) heap.Init(res.minArr) heap.Init(res.maxArr) return *res } func (this *MedianFinder) AddNum(num int) { if this.maxArr.Len() == this.minArr.Len() { heap.Push(this.minArr, num) heap.Push(this.maxArr, heap.Pop(this.minArr)) } else { heap.Push(this.maxArr, num) heap.Push(this.minArr, heap.Pop(this.maxArr)) } } func (this *MedianFinder) FindMedian() float64 { if this.minArr.Len() == this.maxArr.Len() { return (float64((*this.maxArr)[0]) + float64((*this.minArr)[0])) / 2 } else { return float64((*this.maxArr)[0]) } } 面试题42.连续子数组的最大和(4) 题目 输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。 要求时间复杂度为O(n)。 示例1:输入: nums = [-2,1,-3,4,-1,2,1,-5,4]输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 贪心法(书上方法) O(n) O(1) 03 动态规划(书上方法) O(n) O(n) 04 动态规划 O(n) O(1) 05 分治 O(nlog(n)) O(log(n)) func maxSubArray(nums []int) int { result := nums[0] sum := 0 for i := 0; i 0 { sum += nums[i] } else { sum = nums[i] } if sum > result { result = sum } } return result } # func maxSubArray(nums []int) int { dp := make([]int, len(nums)) dp[0] = nums[0] result := nums[0] for i := 1; i nums[i] { dp[i] = dp[i-1] + nums[i] } else { dp[i] = nums[i] } if dp[i] > result { result = dp[i] } } return result } # func maxSubArray(nums []int) int { dp := nums[0] result := dp for i := 1; i nums[i] { dp = dp + nums[i] } else { dp = nums[i] } if dp > result { result = dp } } return result } # func maxSubArray(nums []int) int { result := maxSubArr(nums, 0, len(nums)-1) return result } func maxSubArr(nums []int, left, right int) int { if left == right { return nums[left] } mid := (left + right) / 2 leftSum := maxSubArr(nums, left, mid) // 最大子序在左边 rightSum := maxSubArr(nums, mid+1, right) // 最大子序在右边 midSum := findMaxArr(nums, left, mid, right) // 跨中心 result := max(leftSum, rightSum) result = max(result, midSum) return result } func findMaxArr(nums []int, left, mid, right int) int { leftSum := math.MinInt32 sum := 0 // 从右到左 for i := mid; i >= left; i-- { sum += nums[i] leftSum = max(leftSum, sum) } rightSum := math.MinInt32 sum = 0 // 从左到右 for i := mid + 1; i b { return a } return b } 面试题43.1～n整数中1出现的次数(3) 题目 输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。 例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。 示例 1：输入：n = 12 出：5 示例 2：输入：n = 13 出：6 限制： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 找规律-遍历 O(log(n)) O(1) 02 找规律-递归(书上方法) O(log(n)) O(log(n)) 03 找规律 O(log(n)) O(1) func countDigitOne(n int) int { res := 0 digit := 1 high := n / 10 cur := n % 10 low := 0 for high != 0 || cur != 0 { if cur == 0 { res = res + high*digit } else if cur == 1 { res = res + high*digit + low + 1 } else { res = res + (high+1)*digit } low = low + cur*digit cur = high % 10 high = high / 10 digit = digit * 10 } return res } # func countDigitOne(n int) int { if n = 1 { return 1 } count := 0 if first > 1 { count = int(math.Pow(float64(10), float64(len(str)-1))) } else if first == 1 { count, _ = strconv.Atoi(str[1:]) count = count + 1 } other := first * (len(str) - 1) * int(math.Pow(float64(10), float64(len(str)-2))) numLeft := dfs(str[1:]) return count + numLeft + other } # func countDigitOne(n int) int { if n 面试题44.数字序列中某一位的数字(2) 题目 数字以0123456789101112131415…的格式序列化到一个字符序列中。 在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。 请写一个函数，求任意第n位对应的数字。 示例 1：输入：n = 3 输出：3 示例 2：输入：n = 11 输出：0 限制： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 找规律(书上方法) O(log(n)) O(1) 02 找规律 O(log(n)) O(1) func findNthDigit(n int) int { if n 0 { n = n - digits*count digits++ count = count * 10 number = number * 10 } number = number + (n-1)/digits index := (n - 1) % digits str := strconv.Itoa(number) return int(str[index] - '0') } 面试题45.把数组排成最小的数(3) 题目 输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。 示例 1:输入: [10,2] 输出: \"102\" 示例 2:输入: [3,30,34,5,9] 输出: \"3033459\" 提示:0 解题思路 No. 思路 时间复杂度 空间复杂度 01 自定义排序 O(nlog(n)) O(n) 02 快排(书上方法) O(nlog(n)) O(n) 03 实现sort接口 O(nlog(n)) O(n) func minNumber(nums []int) string { sort.Slice(nums, func(i, j int) bool { if fmt.Sprintf(\"%d%d\", nums[i], nums[j]) = end { return } temp := arr[start] i := start j := end for i = temp+arr[j] { j-- } for i 面试题46.把数字翻译成字符串(4) 题目 给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……， 11 翻译成 “l”，……，25 翻译成 “z”。 一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。 示例 1:输入: 12258 输出: 5 解释: 12258有5种不同的翻译，分别是\"bccfi\", \"bwfi\", \"bczi\", \"mcfi\"和\"mzi\" 提示： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历(书上方法) O(log(n)) O(log(n)) 02 递归 O(log(n)) O(log(n)) 03 遍历-从后往前 O(log(n)) O(1) 04 动态规划-一维数组 O(log(n)) O(log(n)) func translateNum(num int) int { if num = 0; i-- { count = 0 if i = 10 && value 9 { res = res + translateNum(num/100) res = res + translateNum(num/10) } else { res = res + translateNum(num/10) } return res } # // f(i)=f(i-2)+f(i-1) // f(i)=f(i-1) func translateNum(num int) int { if num 0 { i++ arr = append(arr, 0) arr[i] = arr[i-1] digit1 := num % 10 num = num / 10 if digit1 != 0 && prev >= 0 && digit1*10+prev 面试题47.礼物的最大价值(2) 题目 在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。 你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。 给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？ 示例 1:输入: [ [1,3,1], [1,5,1], [4,2,1] ] 输出: 12 解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物 提示： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划(书上方法) O(n^2) O(n^2) 02 动态规划(书上方法) O(n^2) O(n) func maxValue(grid [][]int) int { if len(grid) == 0 || len(grid[0]) == 0 { return 0 } dp := make([][]int, len(grid)) for i := 0; i 0 { left = dp[i-1][j] } if j > 0 { up = dp[i][j-1] } // dp[i][j]=grid[i-1][j-1]+max(dp[i][j-1],dp[i-1][j]) dp[i][j] = max(left, up) + grid[i][j] } } return dp[len(grid)-1][len(grid[0])-1] } func max(a, b int) int { if a > b { return a } return b } # func maxValue(grid [][]int) int { if len(grid) == 0 || len(grid[0]) == 0 { return 0 } dp := make([]int, len(grid)) for i := 0; i 0 { left = dp[j] } if j > 0 { up = dp[j-1] } // dp[j]=grid[i-1][j-1]+max(dp[j-1],dp[j]) dp[j] = max(left, up) + grid[i][j] } } return dp[len(grid[0])-1] } func max(a, b int) int { if a > b { return a } return b } 面试题48.最长不含重复字符的子字符串(4) 题目 请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。 示例 1:输入: \"abcabcbb\" 输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。 示例 2:输入: \"bbbbb\" 输出: 1 解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。 示例 3:输入: \"pwwkew\" 输出: 3 解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。 提示：s.length 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历+滑动窗口 O(n) O(n) 02 双指针 O(n) O(1) 03 动态规划 O(n) O(n) 04 动态规划(书上方法) O(n) O(1) func lengthOfLongestSubstring(s string) int { if len(s) 0 { for len(arr) > 0 && arr[0] != value { m[arr[0]]-- arr = arr[1:] } m[arr[0]]-- arr = arr[1:] } m[value]++ arr = append(arr, value) if len(arr) > res { res = len(arr) } } return res } # func lengthOfLongestSubstring(s string) int { if len(s) 0 { if right-left > res { res = right - left } left++ break } else { m[s[right]]++ right++ } } if right-left > res { res = right - left } if right >= len(s)-1 { break } } return res } # // dp[n]=dp[n-1]+1 // dp[n]=n-lastIndex func lengthOfLongestSubstring(s string) int { if len(s) dp[i-1] { dp[i] = dp[i-1] + 1 } else { dp[i] = i - index } m[s[i]] = i if dp[i] > res { res = dp[i] } } return res } # func lengthOfLongestSubstring(s string) int { if len(s) curLength { curLength++ } else { if curLength > res { res = curLength } curLength = i - preIndex } arr[s[i]] = i } if curLength > res { res = curLength } return res } 面试题49.丑数(1) 题目 我们把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。 示例:输入: n = 10 输出: 12 解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。 说明: 1 是丑数。n 不超过1690。 注意：本题与主站 264 题相同：https://leetcode-cn.com/problems/ugly-number-ii/ 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划(书上方法) O(n) O(n) func nthUglyNumber(n int) int { dp := make([]int, n) dp[0] = 1 // 丑数*2或3或5之后还是丑数 idx2, idx3, idx5 := 0, 0, 0 for i := 1; i b { return b } return a } 面试题50.第一个只出现一次的字符(3) 题目 在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。 示例: s = \"abaccdeff\" 返回 \"b\" s = \"\" 返回 \" \" 限制：0 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助(书上方法) O(n) O(1) 02 数组辅助 O(n) O(1) 03 暴力法 O(n^2) O(1) func firstUniqChar(s string) byte { res := byte(' ') m := make(map[byte]int) for i := 0; i 面试题51.数组中的逆序对(1) 题目 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。 输入一个数组，求出这个数组中的逆序对的总数。 示例 1:输入: [7,5,6,4] 输出: 5 限制：0 解题思路 No. 思路 时间复杂度 空间复杂度 01 归并排序(书上方法) O(nlog(n)) O(n) var res int func reversePairs(nums []int) int { res = 0 if len(nums) = right { return } mid := (left + right) / 2 i, j := left, mid+1 merge(nums, left, mid) merge(nums, mid+1, right) temp := make([]int, 0) for i 面试题52.两个链表的第一个公共节点(4) 题目 输入两个链表，找出它们的第一个公共节点。 如下面的两个链表： 在节点 c1 开始相交。 示例 1： 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出：Reference of the node with value = 8 输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。 从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。 在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2： 输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 输出：Reference of the node with value = 2 输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3： 输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2 输出：null 输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。 解释：这两个链表不相交，因此返回 null。 注意： 如果两个链表没有交点，返回 null. 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。 本题与主站 160 题相同：https://leetcode-cn.com/problems/intersection-of-two-linked-lists/ 解题思路 No. 思路 时间复杂度 空间复杂度 01 计算长度后，对齐长度再比较(书上方法) O(n) O(1) 02 交换后相连，再比较 O(n) O(1) 03 暴力法 O(n^2) O(1) 04 哈希法 O(n) O(n) func getIntersectionNode(headA, headB *ListNode) *ListNode { ALength := 0 A := headA for A != nil { ALength++ A = A.Next } BLength := 0 B := headB for B != nil { BLength++ B = B.Next } pA := headA pB := headB if ALength > BLength { n := ALength - BLength for n > 0 { pA = pA.Next n-- } } else { n := BLength - ALength for n > 0 { pB = pB.Next n-- } } for pA != pB { pA = pA.Next pB = pB.Next } return pA } # func getIntersectionNode(headA, headB *ListNode) *ListNode { A, B := headA, headB for A != B { if A != nil { A = A.Next } else { A = headB } if B != nil { B = B.Next } else { B = headA } } return A } # func getIntersectionNode(headA, headB *ListNode) *ListNode { A, B := headA, headB for A != nil { for B != nil { if A == B { return A } B = B.Next } A = A.Next B = headB } return nil } # 4 func getIntersectionNode(headA, headB *ListNode) *ListNode { m := make(map[*ListNode]bool) for headA != nil { m[headA] = true headA = headA.Next } for headB != nil { if _, ok := m[headB]; ok { return headB } headB = headB.Next } return nil } 面试题53-I.在排序数组中查找数字I(5) 题目 统计一个数字在排序数组中出现的次数。 示例 1:输入: nums = [5,7,7,8,8,10], target = 8 输出: 2 示例 2:输入: nums = [5,7,7,8,8,10], target = 6 输出: 0 限制：0 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(1) 02 遍历 O(n) O(1) 03 双指针遍历 O(n) O(1) 04 二分查找 O(log(n)) O(1) 04 二分查找(书上方法) O(log(n)) O(1) func search(nums []int, target int) int { m := make(map[int]int) for i := 0; i = 0 && nums[j] != target { j-- } if i > j { return 0 } return j - i + 1 } # func search(nums []int, target int) int { left := 0 right := len(nums) - 1 count := 0 for left = 0; i--{ if nums[i] == target{ count++ }else { break } } return count } if nums[mid] > target{ right = mid-1 }else { left = mid+1 } } return count } # func search(nums []int, target int) int { count := 0 if len(nums) > 0 { first := getFirstK(nums, target, 0, len(nums)-1) last := getLastK(nums, target, 0, len(nums)-1) if first > -1 && last > -1 { count = last - first + 1 } } return count } func getFirstK(nums []int, target int, start, end int) int { if start > end { return -1 } mid := start + (end-start)/2 if nums[mid] == target { if (mid > 0 && nums[mid-1] != target) || mid == 0 { return mid } else { end = mid - 1 } } else if nums[mid] > target { end = mid - 1 } else { start = mid + 1 } return getFirstK(nums, target, start, end) } func getLastK(nums []int, target int, start, end int) int { if start > end { return -1 } mid := start + (end-start)/2 if nums[mid] == target { if (mid 面试题53-II.0～n-1中缺失的数字(6) 题目 一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。 在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。 示例 1:输入: [0,1,3] 输出: 2 示例 2:输入: [0,1,2,3,4,5,6,7,9] 输出: 8 限制：1 解题思路 No. 思路 时间复杂度 空间复杂度 01 数学计算 O(n) O(1) 02 遍历 O(n) O(1) 03 异或-位运算 O(n) O(1) 04 哈希辅助 O(n) O(n) 05 二分查找(书上方法) O(log(n)) O(1) 06 内置函数 O(n) O(1) func missingNumber(nums []int) int { n := len(nums) sum := n * (n + 1) / 2 for i := 0; i 面试题54.二叉搜索树的第k大节点(3) 题目 给定一棵二叉搜索树，请找出其中第k大的节点。 示例 1: 输入: root = [3,1,4,null,2], k = 1 3 / \\ 1 4 \\ 2 输出: 4 示例 2:输入: root = [5,3,6,2,4,null,null,1], k = 3 5 / \\ 3 6 / \\ 2 4 / 1 输出: 4 限制：1 ≤ k ≤ 二叉搜索树元素个数 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归(书上方法) O(n) O(log(n)) 02 递归+数组 O(n) O(n) 03 迭代 O(n) O(n) var count int var res int func kthLargest(root *TreeNode, k int) int { count = k res = 0 dfs(root) return res } func dfs(root *TreeNode) { if root == nil { return } dfs(root.Right) count-- if count == 0 { res = root.Val return } dfs(root.Left) } # var arr []int func kthLargest(root *TreeNode, k int) int { arr = make([]int, 0) dfs(root) return arr[k-1] } func dfs(root *TreeNode) { if root == nil { return } dfs(root.Right) arr = append(arr, root.Val) dfs(root.Left) } # func kthLargest(root *TreeNode, k int) int { if root == nil { return 0 } arr := make([]int, 0) stack := make([]*TreeNode, 0) cur := root for len(stack) > 0 || cur != nil { for cur != nil { stack = append(stack, cur) cur = cur.Left } node := stack[len(stack)-1] arr = append(arr, node.Val) stack = stack[:len(stack)-1] cur = node.Right } return arr[len(arr)-k] } 面试题55-I.二叉树的深度(2) 题目 输入一棵二叉树的根节点，求该树的深度。 从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。 例如： 给定二叉树 [3,9,20,null,null,15,7]， 3 / \\ 9 20 / \\ 15 7 返回它的最大深度 3 。 提示：节点总数 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归(书上方法) O(n) O(log(n)) 02 迭代 O(n) O(n) func maxDepth(root *TreeNode) int { if root == nil { return 0 } left := maxDepth(root.Left) right := maxDepth(root.Right) return max(left, right) + 1 } func max(a, b int) int { if a > b { return a } return b } # func maxDepth(root *TreeNode) int { if root == nil { return 0 } queue := make([]*TreeNode, 0) queue = append(queue, root) depth := 0 for len(queue) > 0 { length := len(queue) for i := 0; i 面试题55-II.平衡二叉树(2) 题目 输入一棵二叉树的根节点，判断该树是不是平衡二叉树。 如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。 示例 1:给定二叉树 [3,9,20,null,null,15,7] 3 / \\ 9 20 / \\ 15 7 返回 true 。 示例 2:给定二叉树 [1,2,2,3,3,null,null,4,4] 1 / \\ 2 2 / \\ 3 3 / \\ 4 4 返回 false 。 限制：1 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 递归(书上方法) O(n) O(log(n)) func isBalanced(root *TreeNode) bool { _, isBalanced := recur(root) return isBalanced } func recur(root *TreeNode) (int, bool) { if root == nil { return 0, true } leftDepth, leftIsBalanced := recur(root.Left) if leftIsBalanced == false { return 0, false } rightDepth, rightIsBalanced := recur(root.Right) if rightIsBalanced == false { return 0, false } if -1 b { return a } return b } # func isBalanced(root *TreeNode) bool { return dfs(root) != -1 } func dfs(root *TreeNode) int { if root == nil { return 0 } left := dfs(root.Left) right := dfs(root.Right) if left != -1 && right != -1 && abs(left, right) b { return a } return b } func abs(a, b int) int { if a > b { return a - b } return b - a } 面试题56-I.数组中数字出现的次数(5) 题目 一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。 请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。 示例 1： 输入：nums = [4,1,4,6]输出：[1,6] 或 [6,1] 示例 2：输入：nums = [1,2,10,4,1,4,3,3] 输出：[2,10] 或 [10,2] 限制： 2 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(n) 02 排序 O(nlog(n)) O(1) 03 位运算 O(n) O(1) 04 位运算 O(n) O(1) 05 位运算(书上方法) O(n) O(1) func singleNumbers(nums []int) []int { m := make(map[int]int) for i := 0; i > 1 } return res } func isBit(num int, index int) bool { num = num >> index return num&1 == 1 } 面试题56-II.数组中数字出现的次数II(5) 题目 在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。 示例 1：输入：nums = [3,4,3,3] 输出：4 示例 2：输入：nums = [9,1,7,9,7,9,7] 输出：1 限制： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(n) 02 统计1的位求余(书上方法) O(n) O(1) 03 排序遍历 O(nlog(n)) O(1) 04 求和遍历 O(n) O(n) 05 位运算(有限状态自动机) O(n) O(1) func singleNumber(nums []int) int { m := make(map[int]int) for i := 0; i = 0; j-- { arr[j] = arr[j] + value&1 value = value / 2 } } res := 0 for i := 0; i 面试题57.和为s的两个数字(2) 题目 输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。 如果有多对数字的和等于s，则输出任意一对即可。 示例 1：输入：nums = [2,7,11,15], target = 9 输出：[2,7] 或者 [7,2] 示例 2：输入：nums = [10,26,30,31,47,60], target = 40 输出：[10,30] 或者 [30,10] 限制： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针(书上方法) O(n) O(1) 02 哈希辅助 O(n) O(n) func twoSum(nums []int, target int) []int { i := 0 j := len(nums) - 1 for i target { j-- } else { i++ } } return nil } # func twoSum(nums []int, target int) []int { m := make(map[int]int, len(nums)) for i, b := range nums { if j, ok := m[target-b]; ok { return []int{nums[j], nums[i]} } m[b] = i } return nil } 面试题57-II.和为s的连续正数序列(4) 题目 输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。 序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。 示例 1：输入：target = 9 输出：[[2,3,4],[4,5]] 示例 2：输入：target = 15 输出：[[1,2,3,4,5],[4,5,6],[7,8]] 限制：1 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n) O(1) 02 双指针(书上方法) O(n) O(1) 03 前缀和-暴力法 O(n^2) O(n) 04 数学法 O(n) O(1) func findContinuousSequence(target int) [][]int { res := make([][]int, 0) i := 1 j := 2 for i target && i = 2; i-- { nA1 := target - i*(i-1)/2 if nA1 面试题58-I.翻转单词顺序(3) 题目 输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。 为简单起见，标点符号和普通字母一样处理。 例如输入字符串\"I am a student. \"，则输出\"student. a am I\"。 示例 1：输入: \"the sky is blue\" 输出: \"blue is sky the\" 示例 2：输入: \" hello world! \" 输出: \"world! hello\" 解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 示例 3：输入: \"a good example\" 输出: \"example good a\" 解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 说明： 无空格字符构成一个单词。 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 注意：本题与主站 151 题相同：https://leetcode-cn.com/problems/reverse-words-in-a-string/ 注意：此题对比原题有改动 解题思路 No. 思路 时间复杂度 空间复杂度 01 内置函数 O(n) O(n) 02 遍历-2次反转(书上方法) O(n) O(n) 03 遍历 O(n) O(n) func reverseWords(s string) string { s = strings.Trim(s, \" \") arr := strings.Fields(s) for i := 0; i 0 { return res[1:] } return res } func reverse(arr []byte) []byte { start := 0 end := len(arr) - 1 for start = 0 { if arr[i] == ' ' { if flag == true { res = res + \" \" + string(arr[i+1:j]) flag = false } j = i i-- } else { if i == 0 { res = res + \" \" + string(arr[i:j]) } i-- flag = true } } if len(res) > 0 { return res[1:] } return res } 面试题58-II.左旋转字符串(2) 题目 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。 比如，输入字符串\"abcdefg\"和数字2，该函数将返回左旋转两位得到的结果\"cdefgab\"。 示例 1：输入: s = \"abcdefg\", k = 2 输出: \"cdefgab\" 示例 2：输入: s = \"lrloseumgh\", k = 6 输出: \"umghlrlose\" 限制： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 切片 O(n) O(n) 02 三次反转(书上方法) O(n) O(n) func reverseLeftWords(s string, n int) string { n = n % len(s) return s[n:] + s[:n] } # func reverseLeftWords(s string, n int) string { n = n % len(s) arr := []byte(s) reverse(arr, 0, n-1) reverse(arr, n, len(arr)-1) reverse(arr, 0, len(arr)-1) return string(arr) } func reverse(arr []byte, start, end int) []byte { for start 面试题59-I.滑动窗口的最大值(4) 题目 给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。 示例:输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3 输出: [3,3,5,5,6,7] 解释: 滑动窗口的位置 最大值 --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 提示：你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。 注意：本题与主站 239 题相同：https://leetcode-cn.com/problems/sliding-window-maximum/ 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法 O(n^2) O(n) 02 暴力法-有条件更新最大值 O(n^2) O(n) 03 双端队列(书上方法) O(n) O(n) 04 堆排序 O(nlog(n)) O(n) func maxSlidingWindow(nums []int, k int) []int { res := make([]int, 0) if len(nums) == 0 { return res } for i := 0; i max { max = nums[j] } } res = append(res, max) } return res } # func maxSlidingWindow(nums []int, k int) []int { res := make([]int, 0) if len(nums) == 0 { return res } max := math.MaxInt32 for i := 0; i max { max = nums[j] } } } else { if nums[i+k-1] > max { max = nums[i+k-1] } } res = append(res, max) } return res } # func maxSlidingWindow(nums []int, k int) []int { res := make([]int, 0) if len(nums) == 0 { return res } deque := make([]int, 0) for i := 0; i 0 && nums[i] >= nums[deque[len(deque)-1]] { deque = deque[:len(deque)-1] } deque = append(deque, i) } for i := k; i 0 && nums[i] >= nums[deque[len(deque)-1]] { deque = deque[:len(deque)-1] } if len(deque) > 0 && deque[0] i[y] } func (i IntHeap) Swap(x, y int) { i[x], i[y] = i[y], i[x] } func (i *IntHeap) Push(v interface{}) { *i = append(*i, v.(int)) } func (i *IntHeap) Pop() interface{} { value := (*i)[len(*i)-1] *i = (*i)[:len(*i)-1] return value } func (i *IntHeap) Remove(x interface{}) { for j := 0; j 面试题59-II.队列的最大值(2) 题目 请定义一个队列并实现函数 max_value 得到队列里的最大值， 要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。 若队列为空，pop_front 和 max_value 需要返回 -1 示例 1：输入: [\"MaxQueue\",\"push_back\",\"push_back\",\"max_value\",\"pop_front\",\"max_value\"] [[],[1],[2],[],[],[]] 输出: [null,null,null,2,1,2] 示例 2：输入: [\"MaxQueue\",\"pop_front\",\"max_value\"] [[],[],[]] 输出: [null,-1,-1] 限制： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 双队列(书上方法) O(1) O(n) 02 内置list O(1) O(n) type MaxQueue struct { data []int max []int } func Constructor() MaxQueue { return MaxQueue{ data: make([]int, 0), max: make([]int, 0), } } func (this *MaxQueue) Max_value() int { if len(this.max) == 0 { return -1 } return this.max[0] } func (this *MaxQueue) Push_back(value int) { this.data = append(this.data, value) for len(this.max) > 0 && value > this.max[len(this.max)-1] { this.max = this.max[:len(this.max)-1] } this.max = append(this.max, value) } func (this *MaxQueue) Pop_front() int { res := -1 if len(this.data) > 0 { res = this.data[0] this.data = this.data[1:] if res == this.max[0] { this.max = this.max[1:] } } return res } # type MaxQueue struct { data *list.List max []int } func Constructor() MaxQueue { return MaxQueue{ data:list.New(), max: make([]int, 0), } } func (this *MaxQueue) Max_value() int { if len(this.max) == 0 { return -1 } return this.max[0] } func (this *MaxQueue) Push_back(value int) { this.data.PushBack(value) for len(this.max) > 0 && value > this.max[len(this.max)-1] { this.max = this.max[:len(this.max)-1] } this.max = append(this.max, value) } func (this *MaxQueue) Pop_front() int { res := -1 if this.data.Len() > 0 { res = this.data.Front().Value.(int) this.data.Remove(this.data.Front()) if res == this.max[0] { this.max = this.max[1:] } } return res } 面试题60.n个骰子的点数(2) 题目 把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。 你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。 示例 1:输入: 1 输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667] 示例 2:输入: 2 输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111, 0.08333,0.05556,0.02778] 限制： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 递推-数组辅助(书上方法) O(n) O(n) 02 递推-动态规划 O(n) O(n) 03 递归-超时(书上方法) O(6^n) O(n) func twoSum(n int) []float64 { res := make([]float64, 0) if n = i; j-- { arr[j] = 0 for k := 1; k = i-1 { arr[j] = arr[j] + arr[j-k] } } } } total := math.Pow(float64(6), float64(n)) for i := n; i 面试题61.扑克牌中的顺子(3) 题目 从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。 2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。 示例 1:输入: [1,2,3,4,5] 输出: True 示例 2:输入: [0,0,1,2,5] 输出: True 限制：数组长度为 5 数组的数取值为 [0, 13] . 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序遍历 O(1) O(1) 02 哈希辅助 O(1) O(1) 03 排序遍历(书上方法) O(1) O(1) func isStraight(nums []int) bool { sort.Ints(nums) sum := 0 for i := 0; i max { max = nums[i] } if nums[i] zero { return false } return true } 面试题62.圆圈中最后剩下的数字(2) 约瑟夫环理解参考： https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/huan-ge-jiao-du-ju-li-jie-jue-yue-se-fu-huan-by-as/ 题目 0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。 求出这个圆圈里剩下的最后一个数字。 例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字， 则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。 示例 1：输入: n = 5, m = 3 输出: 3 示例 2：输入: n = 10, m = 17 输出: 2 限制： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(n) 02 递推(书上方法) O(n) O(1) 03 模拟-超时 O(n^2) O(n) func lastRemaining(n int, m int) int { if n == 1 { return 0 } return (lastRemaining(n-1, m) + m) % n } # func lastRemaining(n int, m int) int { res := 0 for i := 2; i 1 { index := (last + m - 1) % len(arr) arr = remove(arr, index) last = index } return arr[0] } func remove(arr []int, index int) []int { if index == 0 { return arr[1:] } if index == len(arr)-1 { return arr[:len(arr)-1] } return append(arr[:index], arr[index+1:]...) } 面试题63.股票的最大利润(3) 题目 假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？ 示例 1:输入: [7,1,5,3,6,4] 输出: 5 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出， 最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2:输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 限制： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法 O(n^2) O(1) 02 动态规划(从前到后) 最大利润=max{前一天最大利润, 今天的价格 - 之前最低价格}(书上方法) O(n) O(1) 03 动态规划(从后到前) O(n) O(1) func maxProfit(prices []int) int { max := 0 length := len(prices) for i := 0; i max { max = prices[j] - prices[i] } } } return max } # func maxProfit(prices []int) int { if len(prices) = 0; i-- { if max 面试题64.求1+2+…+n(2) 题目 求 1+2+...+n ，要求不能使用乘除法、 for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 示例 1：输入: n = 3 输出: 6 示例 2：输入: n = 9 输出: 45 限制：1 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(n) 02 内置函数 O(1) O(1) var res int func sumNums(n int) int { res = 0 dfs(n) return res } func dfs(n int) bool { res = res + n return n > 0 && dfs(n-1) } # func sumNums(n int) int { return (int(math.Pow(float64(n), float64(2))) + n) >> 1 } 面试题65.不用加减乘除做加法(2) 题目 写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。 示例:输入: a = 1, b = 1 输出: 2 提示： a, b 均可能是负数或 0 结果不会溢出 32 位整数 解题思路 No. 思路 时间复杂度 空间复杂度 01 迭代(书上方法) O(1) O(1) 02 递归 O(1) O(1) // 非进位和：异或运算 // 进位：与运算+左移一位 func add(a int, b int) int { for b != 0 { a, b = a^b, (a&b) 面试题66.构建乘积数组(2) 题目 给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]， 其中 B 中的元素 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。 示例:输入: [1,2,3,4,5] 输出: [120,60,40,30,24] 提示：所有元素乘积之和不会溢出 32 位整数 a.length 解题思路 No. 思路 时间复杂度 空间复杂度 01 二次遍历(书上方法) O(n) O(1) 02 数组辅助 O(n) O(n) func constructArr(a []int) []int { res := make([]int, len(a)) if len(a) == 0 { return res } res[0] = 1 for i := 1; i = 0; i-- { res[i] = res[i] * a[i+1] * temp temp = temp * a[i+1] } return res } # func constructArr(a []int) []int { res := make([]int, len(a)) if len(a) == 0 { return res } left := make([]int, len(a)) left[0] = 1 right := make([]int, len(a)) right[len(a)-1] = 1 for i := 1; i = 0; i-- { right[i] = right[i+1] * a[i+1] } for i := 0; i 面试题67.把字符串转换成整数(2) 题目 写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来， 作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、 字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0。 说明： 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 示例 1:输入: \"42\"输出: 42 示例 2:输入: \" -42\"输出: -42 解释: 第一个非空白字符为 '-', 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 示例 3:输入: \"4193 with words\"输出: 4193 解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。 示例 4:输入: \"words and 987\" 输出: 0 解释: 第一个非空字符是 'w', 但它不是数字或正、负号。 因此无法执行有效的转换。 示例 5:输入: \"-91283472332\" 输出: -2147483648 因此返回 INT_MIN (−231) 。 注意：本题与主站 8 题相同：https://leetcode-cn.com/problems/string-to-integer-atoi/ 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(n) 02 正则 O(n) O(n) func strToInt(str string) int { i := 0 for i = '0' && str[j] 0 { break } if str[j] != ' ' && str[j] != '+' && str[j] != '-' { return 0 } if isFlag != ' ' { return 0 } isFlag = str[j] } } res := 0 for i := 0; i math.MaxInt32 { return math.MaxInt32 } } } if isFlag == '-' { return -1 * res } return res } # func strToInt(str string) int { re := regexp.MustCompile(`^[+-]?\\d+`) arrS := re.FindAllString(strings.Trim(str, \" \"), -1) if len(arrS) == 0{ return 0 } arr := arrS[0] res := 0 isFlag := byte(' ') if !(arr[0] >= '0' && arr[0] 214748364 || (res==214748364 && value >= 8) { return math.MinInt32 } } else if isFlag == ' ' || isFlag == '+' { if res > 214748364 || (res==214748364 && value >= 7) { return math.MaxInt32 } } res = res*10 + value } if isFlag == '-' { return -1 * res } return res } Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 09:46:03 "},"docs/source/question/lcci.html":{"url":"docs/source/question/lcci.html","title":"程序员面试金典","keywords":"","body":"程序员面试金典 程序员面试金典 面试题01.01.判定字符是否唯一(5) 面试题01.02.判定是否互为字符重排(2) 面试题01.03.URL化(2) 面试题01.04.回文排列(2) 面试题01.05.一次编辑(2) 面试题01.06.字符串压缩(2) 面试题01.07.旋转矩阵(3) 面试题01.08.零矩阵(4) 面试题01.09.字符串轮转(2) 面试题02.01.移除重复节点(3) 面试题02.02.返回倒数第k个节点(4) 面试题02.03.删除中间节点(1) 面试题02.04.分割链表(2) 面试题02.05.链表求和(2) 面试题02.06.回文链表(4) 面试题02.07.链表相交(4) 面试题02.08.环路检测(3) 面试题03.01.三合一(1) 面试题03.02.栈的最小值(2) 面试题03.03.堆盘子(1) 面试题03.04.化栈为队(3) 面试题03.05.栈排序 题目 解题思路 面试题03.06.动物收容所(2) 面试题04.01.节点间通路(2) 面试题04.02.最小高度树(2) 面试题04.03.特定深度节点链表 题目 解题思路 面试题04.04.检查平衡性(3) 面试题04.05.合法二叉搜索树(5) 面试题04.08.首个共同祖先(2) 面试题04.10.检查子树(2) 面试题04.12.求和路径(4) 面试题05.01.插入(4) 面试题05.02.二进制数转字符串(2) 面试题05.03.翻转数位(2) 面试题05.06.整数转换(4) 面试题05.07.配对交换(2) 面试题08.01.三步问题(2) 面试题08.02.迷路的机器人(2) 面试题08.03.魔术索引(2) 面试题08.04.幂集(3) 面试题08.05.递归乘法(3) 面试题08.06.汉诺塔问题(1) 面试题08.07.无重复字符串的排列组合(3) 面试题08.08.有重复字符串的排列组合(3) 面试题08.09.括号(3) 面试题08.10.颜色填充(2) 面试题08.11.硬币 题目 解题思路 面试题08.12.八皇后(3) 面试题10.01.合并排序的数组(3) 面试题10.02.变位词组(2) 面试题10.03.搜索旋转数组(2) 面试题10.05.稀疏数组搜索(2) 面试题10.09.排序矩阵查找(6) 面试题16.01.交换数字(3) 面试题16.02.单词频率(2) 面试题16.05.阶乘尾数(1) 面试题16.06.最小差(2) 面试题16.07.最大数值(3) 面试题16.10.生存人数(2) 面试题16.11.跳水板(2) 面试题16.15.珠玑妙算(2) 面试题16.16.部分排序(2) 面试题16.17.连续数列(5) 面试题16.19.水域大小(2) 面试题16.21.交换和(1) 面试题16.25.LRU缓存(1) 面试题17.01.不用加号的加法(2) 面试题17.04.消失的数字(5) 面试题17.09.第k个数(1) 面试题17.10.主要元素(5) 面试题17.11.单词距离(2) 面试题17.12.BiNode(2) 面试题17.14.最小K个数(3) 面试题17.16.按摩师(4) 面试题17.19.消失的两个数字(4) 面试题17.21.直方图的水量(4) 面试题01.01.判定字符是否唯一(5) 题目 实现一个算法，确定一个字符串 s 的所有字符是否全都不同。 示例 1：输入: s = \"leetcode\" 输出: false 示例 2：输入: s = \"abc\" 输出: true 限制： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(1) 02 位运算 O(n) O(1) 03 遍历 O(n^2) O(1) 04 排序遍历 O(nlog(n)) O(n) 05 数组辅助 O(n) O(1) func isUnique(astr string) bool { m := make(map[byte]bool) for i := 0; i 0 { return false } arr[astr[i]] = 1 } return true } 面试题01.02.判定是否互为字符重排(2) 题目 给定两个字符串 s1 和 s2，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。 示例 1：输入: s1 = \"abc\", s2 = \"bca\" 输出: true 示例 2：输入: s1 = \"abc\", s2 = \"bad\" 输出: false 说明： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 内置函数 O(nlog(n)) O(n) 02 哈希辅助 O(n) O(1) 03 数组辅助 O(n) O(1) func CheckPermutation(s1 string, s2 string) bool { arr1 := strings.Split(s1, \"\") arr2 := strings.Split(s2, \"\") sort.Strings(arr1) sort.Strings(arr2) return strings.Join(arr1,\"\") == strings.Join(arr2,\"\") // return reflect.DeepEqual(arr1, arr2) } # func CheckPermutation(s1 string, s2 string) bool { if len(s1) != len(s2) { return false } m := make(map[byte]int) for i := 0; i 面试题01.03.URL化(2) 题目 URL化。编写一种方法，将字符串中的空格全部替换为%20。假定该字符串尾部有足够的空间存放新增字符， 并且知道字符串的“真实”长度。（注：用Java实现的话，请使用字符数组实现，以便直接在数组上操作。） 示例1:输入：\"Mr John Smith \", 13 输出：\"Mr%20John%20Smith\" 示例2:输入：\" \", 5 输出：\"%20%20%20%20%20\" 提示： 字符串长度在[0, 500000]范围内。 解题思路 No. 思路 时间复杂度 空间复杂度 01 内置函数 O(n) O(n) 02 遍历 O(n) O(n) func replaceSpaces(S string, length int) string { return strings.ReplaceAll(S[:length], \" \",\"%20\") } # func replaceSpaces(S string, length int) string { res := make([]byte,0) for i := 0; i 面试题01.04.回文排列(2) 题目 给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。 回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。 回文串不一定是字典当中的单词。 示例1：输入：\"tactcoa\" 输出：true（排列有\"tacocat\"、\"atcocta\"，等等） 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(1) 02 数组辅助 O(n) O(1) func canPermutePalindrome(s string) bool { m := make(map[byte]int) for i := 0; i 面试题01.05.一次编辑(2) 题目 字符串有三种编辑操作:插入一个字符、删除一个字符或者替换一个字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。 示例 1:输入: first = \"pale\"second = \"ple\" 输出: True 示例 2:输入: first = \"pales\"second = \"pal\" 输出: False 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 遍历 O(n) O(1) func oneEditAway(first string, second string) bool { if len(first)-len(second) > 1 || len(second)-len(first) > 1 { return false } if first == second { return true } i := 0 for ; i 1 || len(second)-len(first) > 1 { return false } if first == second { return true } if len(first) > len(second) { first, second = second, first } for i := 0; i 面试题01.06.字符串压缩(2) 题目 字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。 比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。 你可以假设字符串中只包含大小写英文字母（a至z）。 示例1:输入：\"aabcccccaaa\" 输出：\"a2b1c5a3\" 示例2:输入：\"abbccd\" 输出：\"abbccd\" 解释：\"abbccd\"压缩后为\"a1b2c2d1\"，比原字符串长度更长。 提示：字符串长度在[0, 50000]范围内。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(n) 02 双指针 O(n) O(n) func compressString(S string) string { if len(S) = len(S) { return S } return res } # func compressString(S string) string { if len(S) = len(S) { return S } return res } 面试题01.07.旋转矩阵(3) 题目 给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。 不占用额外内存空间能否做到？ 示例 1:给定 matrix = [ [1,2,3], [4,5,6], [7,8,9] ], 原地旋转输入矩阵，使其变为: [ [7,4,1], [8,5,2], [9,6,3] ] 示例 2:给定 matrix = [ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16] ], 原地旋转输入矩阵，使其变为: [ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11] ] 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n^2) O(1) 02 遍历 O(n^2) O(1) 03 数组辅助 O(n^2) O(n^2) func rotate(matrix [][]int) { n := len(matrix) // 同行逆置 // [[1 2 3] [4 5 6] [7 8 9]] // [[3 2 1] [6 5 4] [9 8 7]] for i := 0; i 面试题01.08.零矩阵(4) 题目 编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。 示例 1：输入： [ [1,1,1], [1,0,1], [1,1,1] ] 输出： [ [1,0,1], [0,0,0], [1,0,1] ] 示例 2：输入： [ [0,1,2,0], [3,4,5,2], [1,3,1,5] ] 输出： [ [0,0,0,0], [0,4,5,0], [0,3,1,0] ] 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n^2) O(n) 02 暴力法 O(n^4) O(1) 03 遍历 O(n^2) O(1) 04 遍历 O(n^2) O(1) func setZeroes(matrix [][]int) { x := make(map[int]int) y := make(map[int]int) for i := 0; i = 0; i-- { for j := len(matrix[i]) - 1; j >= 1; j-- { if matrix[i][0] == 0 || matrix[0][j] == 0 { matrix[i][j] = 0 } } } // 第一列处理 if flag == true { for i := 0; i 面试题01.09.字符串轮转(2) 题目 字符串轮转。给定两个字符串s1和s2，请编写代码检查s2是否为s1旋转而成（ 比如，waterbottle是erbottlewat旋转后的字符串）。 示例1: 输入：s1 = \"waterbottle\", s2 = \"erbottlewat\" 输出：True 示例2:输入：s1 = \"aa\", s2 = \"aba\" 输出：False 提示：字符串长度在[0, 100000]范围内。 说明: 你能只调用一次检查子串的方法吗？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 内置函数 O(n) O(1) 02 遍历 O(n) O(1) func isFlipedString(s1 string, s2 string) bool { if len(s1) != len(s2){ return false } return strings.Contains(s1+s1, s2) } # func isFlipedString(s1 string, s2 string) bool { if s1 == s2 { return true } if len(s1) != len(s2) { return false } for i := 0; i 面试题02.01.移除重复节点(3) 题目 编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。 示例1:输入：[1, 2, 3, 3, 2, 1]输出：[1, 2, 3] 示例2:输入：[1, 1, 1, 1, 2]输出：[1, 2] 提示： 链表长度在[0, 20000]范围内。 链表元素在[0, 20000]范围内。 进阶：如果不得使用临时缓冲区，该怎么解决？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(n) 02 遍历 O(n^2) O(1) 03 递归 O(n) O(n) func removeDuplicateNodes(head *ListNode) *ListNode { if head == nil { return head } m := make(map[int]bool) m[head.Val] = true temp := head for temp.Next != nil { if m[temp.Next.Val] == true { temp.Next = temp.Next.Next } else { m[temp.Next.Val] = true temp = temp.Next } } return head } # 2 func removeDuplicateNodes(head *ListNode) *ListNode { if head == nil { return head } temp := head for temp != nil { second := temp for second.Next != nil { if second.Next.Val == temp.Val { second.Next = second.Next.Next } else { second = second.Next } } temp = temp.Next } return head } # 3 var m map[int]bool func removeDuplicateNodes(head *ListNode) *ListNode { m = make(map[int]bool) return remove(head) } func remove(head *ListNode) *ListNode { if head == nil { return head } if m[head.Val] == true { return remove(head.Next) } m[head.Val] = true head.Next = remove(head.Next) return head } 面试题02.02.返回倒数第k个节点(4) 题目 实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。 注意：本题相对原题稍作改动 示例：输入： 1->2->3->4->5 和 k = 2 输出： 4 说明：给定的 k 保证是有效的。 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组辅助 O(n) O(n) 02 快慢指针 O(n) O(1) 03 统计+遍历 O(n) O(1) 04 递归 O(n) O(n) func kthToLast(head *ListNode, k int) int { arr := make([]*ListNode, 0) for head != nil { arr = append(arr, head) head = head.Next } if len(arr) >= k { return arr[len(arr)-k].Val } return -1 } # 2 func kthToLast(head *ListNode, k int) int { fast := head for k > 0 && head != nil { fast = fast.Next k-- } if k > 0 { return -1 } slow := head for fast != nil { fast = fast.Next slow = slow.Next } return slow.Val } # 3 func kthToLast(head *ListNode, k int) int { temp := head count := 0 for temp != nil { count++ temp = temp.Next } if count 0 { return -1 } return res.Val } func dfs(node *ListNode, k int) (*ListNode, int) { if node == nil { return node, k } next, nextValue := dfs(node.Next, k) if nextValue 面试题02.03.删除中间节点(1) 题目 实现一种算法，删除单向链表中间的某个节点（即不是第一个或最后一个节点），假定你只能访问该节点。 示例：输入：单向链表a->b->c->d->e->f中的节点c 结果：不返回任何数据，但该链表变为a->b->d->e->f 解题思路 No. 思路 时间复杂度 空间复杂度 01 把当前节点替换成下一个节点 O(1) O(1) func deleteNode(node *ListNode) { // *node = *node.Next node.Val = node.Next.Val node.Next = node.Next.Next } 面试题02.04.分割链表(2) 题目 编写程序以 x 为基准分割链表，使得所有小于 x 的节点排在大于或等于 x 的节点之前。 如果链表中包含 x，x 只需出现在小于 x 的元素之后(如下所示)。 分割元素 x 只需处于“右半部分”即可，其不需要被置于左右两部分之间。 示例:输入: head = 3->5->8->5->10->2->1, x = 5 输出: 3->1->2->10->5->5->8 解题思路 No. 思路 时间复杂度 空间复杂度 01 双指针 O(n) O(1) 02 数组辅助 O(n) O(n) func partition(head *ListNode, x int) *ListNode { first := &ListNode{} second := &ListNode{} a := first b := second for head != nil { if head.Val 面试题02.05.链表求和(2) 题目 给定两个用链表表示的整数，每个节点包含一个数位。 这些数位是反向存放的，也就是个位排在链表首部。 编写函数对这两个整数求和，并用链表形式返回结果。 示例：输入：(7 -> 1 -> 6) + (5 -> 9 -> 2)，即617 + 295 输出：2 -> 1 -> 9，即912 进阶：假设这些数位是正向存放的，请再做一遍。 示例：输入：(6 -> 1 -> 7) + (2 -> 9 -> 5)，即617 + 295 输出：9 -> 1 -> 2，即912 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(n) 02 递归 O(n) O(n) func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { res := &ListNode{} cur := res carry := 0 for l1 != nil || l2 != nil || carry > 0 { sum := carry if l1 != nil { sum += l1.Val l1 = l1.Next } if l2 != nil { sum += l2.Val l2 = l2.Next } carry = sum / 10 // 进位 cur.Next = &ListNode{Val: sum % 10} cur = cur.Next } return res.Next } # 2 func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { if l1 == nil && l2 == nil { return nil } if l1 == nil { return l2 } if l2 == nil { return l1 } sum := l1.Val + l2.Val res := &ListNode{Val: sum % 10} if sum >= 10 { l1.Next = addTwoNumbers(l1.Next, &ListNode{Val: 1}) } res.Next = addTwoNumbers(l1.Next, l2.Next) return res } 面试题02.06.回文链表(4) 题目 编写一个函数，检查输入的链表是否是回文的。 示例 1：输入： 1->2 输出： false 示例 2：输入： 1->2->2->1 输出： true 进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组辅助 O(n) O(n) 02 快慢指针反转链表 O(n) O(1) 03 栈辅助 O(n) O(n) 04 递归 O(n) O(n) func isPalindrome(head *ListNode) bool { m := make([]int, 0) for head != nil { m = append(m, head.Val) head = head.Next } i, j := 0, len(m)-1 for i 面试题02.07.链表相交(4) 题目 给定两个（单向）链表，判定它们是否相交并返回交点。请注意相交的定义基于节点的引用，而不是基于节点的值。 换句话说，如果一个链表的第k个节点与另一个链表的第j个节点是同一节点（引用完全相同），则这两个链表相交。 示例 1： 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出：Reference of the node with value = 8 输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起， 链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。 在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2：输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 输出：Reference of the node with value = 2 输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。 从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。 在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3：输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2 输出：null 输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。 由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。 解释：这两个链表不相交，因此返回 null。 注意： 如果两个链表没有交点，返回 null 。 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。 解题思路 No. 思路 时间复杂度 空间复杂度 01 对齐比较 O(n) O(1) 02 交换比较 O(n) O(1) 03 暴力法 O(n^2) O(1) 04 哈希辅助 O(n) O(n) func getIntersectionNode(headA, headB *ListNode) *ListNode { ALength := 0 A := headA for A != nil { ALength++ A = A.Next } BLength := 0 B := headB for B != nil { BLength++ B = B.Next } pA := headA pB := headB if ALength > BLength { n := ALength - BLength for n > 0 { pA = pA.Next n-- } } else { n := BLength - ALength for n > 0 { pB = pB.Next n-- } } for pA != pB { pA = pA.Next pB = pB.Next } return pA } # 2 func getIntersectionNode(headA, headB *ListNode) *ListNode { A, B := headA, headB for A != B { if A != nil { A = A.Next } else { A = headB } if B != nil { B = B.Next } else { B = headA } } return A } # 3 func getIntersectionNode(headA, headB *ListNode) *ListNode { A, B := headA, headB for A != nil { for B != nil { if A == B { return A } B = B.Next } A = A.Next B = headB } return nil } # 4 func getIntersectionNode(headA, headB *ListNode) *ListNode { m := make(map[*ListNode]bool) for headA != nil { m[headA] = true headA = headA.Next } for headB != nil { if _, ok := m[headB]; ok { return headB } headB = headB.Next } return nil } 面试题02.08.环路检测(3) 题目 给定一个链表，如果它是有环链表，实现一个算法返回环路的开头节点。 有环链表的定义：在链表中某个节点的next元素指向在它前面出现过的节点，则表明该链表存在环路。 示例 1：输入：head = [3,2,0,-4], pos = 1 输出：tail connects to node index 1 解释：链表中有一个环，其尾部连接到第二个节点。 示例 2：输入：head = [1,2], pos = 0 输出：tail connects to node index 0 解释：链表中有一个环，其尾部连接到第一个节点。 示例 3：输入：head = [1], pos = -1 输出：no cycle 解释：链表中没有环。 进阶：你是否可以不用额外空间解决此题？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(n) 02 快慢指针 O(n) O(1) 03 遍历标记 O(n) O(1) func detectCycle(head *ListNode) *ListNode { m := make(map[*ListNode]bool) for head != nil { if m[head] { return head } m[head] = true head = head.Next } return nil } # 2 func detectCycle(head *ListNode) *ListNode { if head == nil { return nil } fast, slow := head, head for fast != nil && fast.Next != nil { fast = fast.Next.Next slow = slow.Next if fast == slow { break } } if fast == nil || fast.Next == nil { return nil } slow = head for fast != slow { fast = fast.Next slow = slow.Next } return slow } # 3 func detectCycle(head *ListNode) *ListNode { for head != nil { if head.Val == math.MaxInt32 { return head } head.Val = math.MaxInt32 head = head.Next } return head } 面试题03.01.三合一(1) 题目 三合一。描述如何只用一个数组来实现三个栈。 你应该实现push(stackNum, value)、pop(stackNum)、isEmpty(stackNum)、peek(stackNum)方法。stackNum表示栈下标，value表示压入的值。 构造函数会传入一个stackSize参数，代表每个栈的大小。 示例1:输入：[\"TripleInOne\", \"push\", \"push\", \"pop\", \"pop\", \"pop\", \"isEmpty\"] [[1], [0, 1], [0, 2], [0], [0], [0], [0]] 输出：[null, null, null, 1, -1, -1, true] 说明：当栈为空时`pop, peek`返回-1，当栈满时`push`不压入元素。 示例2:输入： [\"TripleInOne\", \"push\", \"push\", \"push\", \"pop\", \"pop\", \"pop\", \"peek\"] [[2], [0, 1], [0, 2], [0, 3], [0], [0], [0], [0]] 输出：[null, null, null, null, 2, 1, -1, -1] 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组 O(1) O(n) type TripleInOne struct { arr []int length int index [3]int } func Constructor(stackSize int) TripleInOne { return TripleInOne{ arr: make([]int, stackSize*3), length: stackSize, index: [3]int{0, 0, 0}, } } func (this *TripleInOne) Push(stackNum int, value int) { if this.index[stackNum] 面试题03.02.栈的最小值(2) 题目 请设计一个栈，除了常规栈支持的pop与push函数以外，还支持min函数，该函数返回栈元素中的最小值。 执行push、pop和min操作的时间复杂度必须为O(1)。 示例：MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); --> 返回 -3. minStack.pop(); minStack.top(); --> 返回 0. minStack.getMin(); --> 返回 -2. 解题思路 No. 思路 时间复杂度 空间复杂度 01 结构体 O(n) O(n) 02 双栈 O(n) O(n) type item struct { min, x int } type MinStack struct { stack []item } func Constructor() MinStack { return MinStack{} } func (this *MinStack) Push(x int) { min := x if len(this.stack) > 0 && this.GetMin() 面试题03.03.堆盘子(1) 题目 堆盘子。设想有一堆盘子，堆太高可能会倒下来。因此，在现实生活中，盘子堆到一定高度时，我们就会另外堆一堆盘子。 请实现数据结构SetOfStacks，模拟这种行为。SetOfStacks应该由多个栈组成，并且在前一个栈填满时新建一个栈。 此外，SetOfStacks.push()和SetOfStacks.pop()应该与普通栈的操作方法相同 （也就是说，pop()返回的值，应该跟只有一个栈时的情况一样）。 进阶：实现一个popAt(int index)方法，根据指定的子栈，执行pop操作。 当某个栈为空时，应当删除该栈。当栈中没有元素或不存在该栈时，pop，popAt 应返回 -1. 示例1: 输入：[\"StackOfPlates\", \"push\", \"push\", \"popAt\", \"pop\", \"pop\"] [[1], [1], [2], [1], [], []] 输出：[null, null, null, 2, 1, -1] 示例2:输入： [\"StackOfPlates\", \"push\", \"push\", \"push\", \"popAt\", \"popAt\", \"popAt\"] [[2], [1], [2], [3], [0], [0], [0]] 输出：[null, null, null, null, 2, 1, 3] 解题思路 No. 思路 时间复杂度 空间复杂度 01 栈-二维 O(1) O(n^2) type StackOfPlates struct { cap int stack [][]int } func Constructor(cap int) StackOfPlates { return StackOfPlates{ cap: cap, stack: make([][]int, 0), } } func (this *StackOfPlates) Push(val int) { if this.cap == 0 { return } if len(this.stack) == 0 { newStack := make([]int, 0) newStack = append(newStack, val) this.stack = append(this.stack, newStack) return } last := this.stack[len(this.stack)-1] if len(last) == this.cap { newStack := make([]int, 0) newStack = append(newStack, val) this.stack = append(this.stack, newStack) return } last = append(last, val) this.stack[len(this.stack)-1] = last } func (this *StackOfPlates) Pop() int { if len(this.stack) == 0 { return -1 } last := this.stack[len(this.stack)-1] res := last[len(last)-1] last = last[:len(last)-1] this.stack[len(this.stack)-1] = last if len(last) == 0 { this.stack = this.stack[:len(this.stack)-1] } return res } func (this *StackOfPlates) PopAt(index int) int { if index >= len(this.stack) { return -1 } arr := this.stack[index] res := arr[len(arr)-1] arr = arr[:len(arr)-1] this.stack[index] = arr if len(arr) == 0 { this.stack = append(this.stack[:index], this.stack[index+1:]...) } return res } 面试题03.04.化栈为队(3) 题目 实现一个MyQueue类，该类用两个栈来实现一个队列。 示例：MyQueue queue = new MyQueue(); queue.push(1); queue.push(2); queue.peek(); // 返回 1 queue.pop(); // 返回 1 queue.empty(); // 返回 false 说明： 你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop from top, size 和 is empty 操作是合法的。 你所使用的语言也许不支持栈。 你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。 解题思路 No. 思路 时间复杂度 空间复杂度 01 使用切片 O(1) O(n) 02 使用2个栈实现 O(n) O(n) 03 使用2个切片实现 O(n) O(n) type MyQueue struct { a []int } func Constructor() MyQueue { return MyQueue{} } func (m *MyQueue) Push(x int) { m.a = append(m.a, x) } func (m *MyQueue) Pop() int { if len(m.a) == 0 { return 0 } first := m.a[0] m.a = m.a[1:] return first } func (m *MyQueue) Peek() int { if len(m.a) == 0 { return 0 } return m.a[0] } func (m *MyQueue) Empty() bool { if len(m.a) == 0 { return true } return false } # 2 /* 入队: 直接入栈a 出队: 栈b为空，则把栈a中全部数据出栈进入栈b，然后出栈b,不为空直接出栈b */ type MyQueue struct { a, b *Stack } func Constructor() MyQueue { return MyQueue{ a: NewStack(), b: NewStack(), } } func (m *MyQueue) Push(x int) { m.a.Push(x) } func (m *MyQueue) Pop() int { if m.b.Len() == 0 { for m.a.Len() > 0 { m.b.Push(m.a.Pop()) } } return m.b.Pop() } func (m *MyQueue) Peek() int { res := m.Pop() m.b.Push(res) return res } func (m *MyQueue) Empty() bool { return m.a.Len() == 0 && m.b.Len() == 0 } type Stack struct { nums []int } func NewStack() *Stack { return &Stack{ nums: []int{}, } } func (s *Stack) Push(n int) { s.nums = append(s.nums, n) } func (s *Stack) Pop() int { res := s.nums[len(s.nums)-1] s.nums = s.nums[:len(s.nums)-1] return res } func (s *Stack) Len() int { return len(s.nums) } func (s *Stack) IsEmpty() bool { return s.Len() == 0 } # 3 type MyQueue struct { a []int b []int } func Constructor() MyQueue { return MyQueue{} } func (m *MyQueue) Push(x int) { m.a = append(m.a, x) } func (m *MyQueue) Pop() int { m.Peek() temp := m.b[len(m.b)-1] m.b = m.b[:len(m.b)-1] return temp } func (m *MyQueue) Peek() int { if len(m.b) == 0 { for len(m.a) > 0 { m.b = append(m.b, m.a[len(m.a)-1]) m.a = m.a[:len(m.a)-1] } } if len(m.b) == 0 { return -1 } return m.b[len(m.b)-1] } func (m *MyQueue) Empty() bool { return len(m.a) == 0 && len(m.b) == 0 } 面试题03.05.栈排序 题目 栈排序。 编写程序，对栈进行排序使最小元素位于栈顶。 最多只能使用一个其他的临时栈存放数据，但不得将元素复制到别的数据结构（如数组）中。 该栈支持如下操作：push、pop、peek 和 isEmpty。当栈为空时，peek 返回 -1。 示例1:输入：[\"SortedStack\", \"push\", \"push\", \"peek\", \"pop\", \"peek\"] [[], [1], [2], [], [], []] 输出：[null,null,null,1,null,2] 示例2:输入： [\"SortedStack\", \"pop\", \"pop\", \"push\", \"pop\", \"isEmpty\"] [[], [], [], [1], [], []] 输出：[null,null,null,null,null,true] 说明:栈中的元素数目在[0, 5000]范围内。 解题思路 No. 思路 时间复杂度 空间复杂度 01 广度优先搜索 O(n) O(n) 面试题03.06.动物收容所(2) 题目 动物收容所。有家动物收容所只收容狗与猫，且严格遵守“先进先出”的原则。 在收养该收容所的动物时，收养人只能收养所有动物中“最老”（由其进入收容所的时间长短而定）的动物， 或者可以挑选猫或狗（同时必须收养此类动物中“最老”的）。 换言之，收养人不能自由挑选想收养的对象。 请创建适用于这个系统的数据结构，实现各种操作方法， 比如enqueue、dequeueAny、dequeueDog和dequeueCat。允许使用Java内置的LinkedList数据结构。 enqueue方法有一个animal参数，animal[0]代表动物编号，animal[1]代表动物种类，其中 0 代表猫，1 代表狗。 dequeue*方法返回一个列表[动物编号, 动物种类]，若没有可以收养的动物，则返回[-1,-1]。 示例1:输入： [\"AnimalShelf\", \"enqueue\", \"enqueue\", \"dequeueCat\", \"dequeueDog\", \"dequeueAny\"] [[], [[0, 0]], [[1, 0]], [], [], []] 输出：[null,null,null,[0,0],[-1,-1],[1,0]] 示例2:输入： [\"AnimalShelf\", \"enqueue\", \"enqueue\", \"enqueue\", \"dequeueDog\", \"dequeueCat\", \"dequeueAny\"] [[], [[0, 0]], [[1, 0]], [[2, 1]], [], [], []] 输出：[null,null,null,null,[2,1],[0,0],[1,0]] 说明:收纳所的最大容量为20000 解题思路 No. 思路 时间复杂度 空间复杂度 01 双数组 O(1) O(n) 02 内置list O(1) O(n) type AnimalShelf struct { cat [][]int dog [][]int } func Constructor() AnimalShelf { return AnimalShelf{ cat: make([][]int, 0), dog: make([][]int, 0), } } func (this *AnimalShelf) Enqueue(animal []int) { if animal[1] == 0 { this.cat = append(this.cat, animal) } else { this.dog = append(this.dog, animal) } } func (this *AnimalShelf) DequeueAny() []int { if len(this.dog) == 0 && len(this.cat) == 0 { return []int{-1, -1} } if len(this.dog) == 0 || len(this.cat) == 0 { if len(this.dog) == 0 { res := this.cat[0] this.cat = this.cat[1:] return res } res := this.dog[0] this.dog = this.dog[1:] return res } if this.dog[0][0] > this.cat[0][0] { res := this.cat[0] this.cat = this.cat[1:] return res } res := this.dog[0] this.dog = this.dog[1:] return res } func (this *AnimalShelf) DequeueDog() []int { if len(this.dog) == 0 { return []int{-1, -1} } res := this.dog[0] this.dog = this.dog[1:] return res } func (this *AnimalShelf) DequeueCat() []int { if len(this.cat) == 0 { return []int{-1, -1} } res := this.cat[0] this.cat = this.cat[1:] return res } # 2 type AnimalShelf struct { arr [2]*list.List } func Constructor() AnimalShelf { return AnimalShelf{ arr: [2]*list.List{list.New(), list.New()}, } } func (this *AnimalShelf) Enqueue(animal []int) { this.arr[animal[1]].PushBack(animal[0]) } func (this *AnimalShelf) DequeueAny() []int { if this.arr[0].Len() == 0 && this.arr[1].Len() == 0 { return []int{-1, -1} } if this.arr[1].Len() > 0 && (this.arr[0].Len() == 0 || this.arr[1].Front().Value.(int) 0 { return []int{this.arr[1].Remove(this.arr[1].Front()).(int), 1} } return []int{-1, -1} } func (this *AnimalShelf) DequeueCat() []int { if this.arr[0].Len() > 0 { return []int{this.arr[0].Remove(this.arr[0].Front()).(int), 0} } return []int{-1, -1} } 面试题04.01.节点间通路(2) 题目 节点间通路。给定有向图，设计一个算法，找出两个节点之间是否存在一条路径。 示例1:输入：n = 3, graph = [[0, 1], [0, 2], [1, 2], [1, 2]], start = 0, target = 2 输出：true 示例2:输入：n = 5, graph = [[0, 1], [0, 2], [0, 4], [0, 4], [0, 1], [1, 3], [1, 4], [1, 3], [2, 3], [3, 4]], start = 0, target = 4 输出 true 提示：节点数量n在[0, 1e5]范围内。 节点编号大于等于 0 小于 n。 图中可能存在自环和平行边。 解题思路 No. 思路 时间复杂度 空间复杂度 01 广度优先搜索 O(n) O(n) 02 深度优先搜索 O(n) O(n) func findWhetherExistsPath(n int, graph [][]int, start int, target int) bool { edges := make([][]int, n) // 邻接表 for i := 0; i 0 { node := queue[0] queue = queue[1:] visited[node] = true if node == target { return true } for i := 0; i 面试题04.02.最小高度树(2) 题目 给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。 示例:给定有序数组: [-10,-3,0,5,9], 一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树： 0 / \\ -3 9 / / -10 5 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 迭代 O(n) O(n) func sortedArrayToBST(nums []int) *TreeNode { if len(nums) == 0 { return nil } mid := len(nums) / 2 return &TreeNode{ Val: nums[mid], Left: sortedArrayToBST(nums[:mid]), Right: sortedArrayToBST(nums[mid+1:]), } } # 2 type MyTreeNode struct { root *TreeNode start int end int } func sortedArrayToBST(nums []int) *TreeNode { if len(nums) == 0 { return nil } queue := make([]MyTreeNode, 0) root := &TreeNode{Val: 0} queue = append(queue, MyTreeNode{root, 0, len(nums)}) for len(queue) > 0 { myRoot := queue[0] queue = queue[1:] start := myRoot.start end := myRoot.end mid := (start + end) / 2 curRoot := myRoot.root curRoot.Val = nums[mid] if start 面试题04.03.特定深度节点链表 题目 给定一棵二叉树，设计一个算法，创建含有某一深度上所有节点的链表 （比如，若一棵树的深度为 D，则会创建出 D 个链表）。返回一个包含所有深度的链表的数组。 示例：输入：[1,2,3,4,5,null,7,8] 1 / \\ 2 3 / \\ \\ 4 5 7 / 8 输出：[[1],[2,3],[4,5,7],[8]] 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 面试题04.04.检查平衡性(3) 题目 实现一个函数，检查二叉树是否平衡。在这个问题中，平衡树的定义如下： 任意一个节点，其两棵子树的高度差不超过 1。 示例 1:给定二叉树 [3,9,20,null,null,15,7] 3 / \\ 9 20 / \\ 15 7 返回 true 。 示例 2:给定二叉树 [1,2,2,3,3,null,null,4,4] 1 / \\ 2 2 / \\ 3 3 / \\ 4 4 返回 false 。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 递归 O(n) O(log(n)) 03 递归 O(n) O(log(n)) func isBalanced(root *TreeNode) bool { _, isBalanced := dfs(root) return isBalanced } func dfs(root *TreeNode) (int, bool) { if root == nil { return 0, true } leftDepth, leftIsBalanced := dfs(root.Left) if leftIsBalanced == false { return 0, false } rightDepth, rightIsBalanced := dfs(root.Right) if rightIsBalanced == false { return 0, false } if -1 b { return a } return b } # 2 func isBalanced(root *TreeNode) bool { return dfs(root) != -1 } func dfs(root *TreeNode) int { if root == nil { return 0 } left := dfs(root.Left) right := dfs(root.Right) if left != -1 && right != -1 && abs(left, right) b { return a } return b } func abs(a, b int) int { if a > b { return a - b } return b - a } # 3 func isBalanced(root *TreeNode) bool { if root == nil { return true } if math.Abs(dfs(root.Left)-dfs(root.Right)) 面试题04.05.合法二叉搜索树(5) 题目 实现一个函数，检查一棵二叉树是否为二叉搜索树。 示例 1:输入: 2 / \\ 1 3 输出: true 示例 2:输入: 5 / \\ 1 4 / \\ 3 6 输出: false 解释: 输入为: [5,1,4,null,null,3,6]。根节点的值为 5 ，但是其右子节点值为 4 。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 递归 O(n) O(n) 03 迭代 O(n) O(n) 04 迭代 O(n) O(n) 05 递归 O(n) O(log(n)) func isValidBST(root *TreeNode) bool { return dfs(root, math.MinInt64, math.MaxInt64) } func dfs(root *TreeNode, left, right int) bool { if root == nil { return true } if left >= root.Val || right = res[i+1] { return false } } return true } func dfs(root *TreeNode) { if root != nil { dfs(root.Left) res = append(res, root.Val) dfs(root.Right) } } # 3 func isValidBST(root *TreeNode) bool { if root == nil { return true } stack := make([]*TreeNode, 0) res := make([]int, 0) for len(stack) > 0 || root != nil { for root != nil { stack = append(stack, root) root = root.Left } last := len(stack) - 1 res = append(res, stack[last].Val) root = stack[last].Right stack = stack[:last] } for i := 0; i = res[i+1] { return false } } return true } # 4 func isValidBST(root *TreeNode) bool { if root == nil { return true } stack := make([]*TreeNode, 0) pre := math.MinInt64 for len(stack) > 0 || root != nil { for root != nil { stack = append(stack, root) root = root.Left } last := len(stack) - 1 if stack[last].Val 面试题04.08.首个共同祖先(2) 题目 设计并实现一个算法，找出二叉树中某两个节点的第一个共同祖先。不得将其他的节点存储在另外的数据结构中。 注意：这不一定是二叉搜索树。 例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4] 3 / \\ 5 1 / \\ / \\ 6 2 0 8 / \\ 7 4 示例 1:输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出: 3 解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 示例 2:输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 输出: 5 解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 说明:所有节点的值都是唯一的。p、q 为不同节点且均存在于给定的二叉树中。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 递归 O(n) O(n) func lowestCommonAncestor(root *TreeNode, p *TreeNode, q *TreeNode) *TreeNode { if root == nil { return nil } if root.Val == p.Val || root.Val == q.Val { return root } left := lowestCommonAncestor(root.Left, p, q) right := lowestCommonAncestor(root.Right, p, q) if left != nil && right != nil { return root } if left == nil { return right } return left } # 2 func lowestCommonAncestor(root *TreeNode, p *TreeNode, q *TreeNode) *TreeNode { if root == nil { return nil } m = make(map[int]*TreeNode) dfs(root) visited := make(map[int]bool) for p != nil { visited[p.Val] = true p = m[p.Val] } for q != nil { if visited[q.Val] == true { return q } q = m[q.Val] } return nil } func dfs(root *TreeNode) { if root == nil { return } if root.Left != nil { m[root.Left.Val] = root dfs(root.Left) } if root.Right != nil { m[root.Right.Val] = root dfs(root.Right) } } 面试题04.10.检查子树(2) 题目 检查子树。你有两棵非常大的二叉树：T1，有几万个节点；T2，有几万个节点。 设计一个算法，判断 T2 是否为 T1 的子树。 如果 T1 有这么一个节点 n，其子树与 T2 一模一样，则 T2 为 T1 的子树， 也就是说，从节点 n 处把树砍断，得到的树与 T2 完全相同。 示例1:输入：t1 = [1, 2, 3], t2 = [2] 输出：true 示例2:输入：t1 = [1, null, 2, 4], t2 = [3, 2] 输出：false 提示：树的节点数目范围为[0, 20000]。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n^2) O(log(n)) 02 递归+字符串辅助 O(n) O(log(n)) 03 栈辅助(超时) O(n) O(n) func checkSubTree(t1 *TreeNode, t2 *TreeNode) bool { if t1 == nil { return false } return isSame(t1, t2) || checkSubTree(t1.Left, t2) || checkSubTree(t1.Right, t2) } func isSame(s *TreeNode, t *TreeNode) bool { if s == nil || t == nil { return t == s } return isSame(s.Left, t.Left) && isSame(s.Right, t.Right) && s.Val == t.Val } # 2 func checkSubTree(t1 *TreeNode, t2 *TreeNode) bool { sStr := dfs(t1, \"\") tStr := dfs(t2, \"\") return strings.Contains(sStr, tStr) } func dfs(s *TreeNode, pre string) string { if s == nil { return pre } return fmt.Sprintf(\"#%d%s%s\", s.Val, dfs(s.Left, \"l\"), dfs(s.Right, \"r\")) } # 3 func checkSubTree(t1 *TreeNode, t2 *TreeNode) bool { sStr := preOrder(t1) tStr := preOrder(t2) return strings.Contains(sStr, tStr) } func preOrder(root *TreeNode) string { if root == nil { return \"\" } res := \"!\" stack := make([]*TreeNode, 0) temp := root for { for temp != nil { res += strconv.Itoa(temp.Val) res += \"!\" stack = append(stack, temp) temp = temp.Left } res += \"#!\" if len(stack) > 0 { node := stack[len(stack)-1] stack = stack[:len(stack)-1] temp = node.Right } else { break } } return res } 面试题04.12.求和路径(4) 题目 给定一棵二叉树，其中每个节点都含有一个整数数值(该值或正或负)。设计一个算法， 打印节点数值总和等于某个给定值的所有路径的数量。 注意，路径不一定非得从二叉树的根节点或叶节点开始或结束，但是其方向必须向下(只能从父节点指向子节点方向)。 示例:给定如下二叉树，以及目标和 sum = 22， 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\ 7 2 5 1 返回:3 解释：和为 22 的路径有：[5,4,11,2], [5,8,4,5], [4,11,7] 提示：节点总数 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n^2) O(n) 02 递归 O(n^2) O(n) 03 迭代+递归 O(n^2) O(n) 04 递归+路径 O(n^2) O(n) func pathSum(root *TreeNode, sum int) int { if root == nil { return 0 } res := 0 var dfs func(*TreeNode, int) dfs = func(node *TreeNode, sum int) { if node == nil { return } sum = sum - node.Val // 路径不需要从根节点开始，也不需要在叶子节点结束 if sum == 0 { res++ } dfs(node.Left, sum) dfs(node.Right, sum) } dfs(root, sum) return res + pathSum(root.Left, sum) + pathSum(root.Right, sum) } # 2 func dfs(node *TreeNode, sum int) int { if node == nil { return 0 } sum = sum - node.Val res := 0 if sum == 0 { res = 1 } return res + dfs(node.Left, sum) + dfs(node.Right, sum) } func pathSum(root *TreeNode, sum int) int { if root == nil { return 0 } return dfs(root, sum) + pathSum(root.Left, sum) + pathSum(root.Right, sum) } # 3 func pathSum(root *TreeNode, sum int) int { if root == nil { return 0 } queue := make([]*TreeNode, 0) queue = append(queue, root) res := 0 for len(queue) > 0 { node := queue[0] queue = queue[1:] tempSum := 0 res += dfs(node, sum, tempSum) if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } return res } func dfs(node *TreeNode, sum int, curSum int) int { res := 0 curSum = curSum + node.Val if curSum == sum { res++ } if node.Left != nil { res += dfs(node.Left, sum, curSum) } if node.Right != nil { res += dfs(node.Right, sum, curSum) } return res } # 4 func pathSum(root *TreeNode, sum int) int { return dfs(root, sum, make([]int, 1001), 0) } func dfs(node *TreeNode, sum int, path []int, level int) int { if node == nil { return 0 } res := 0 if sum == node.Val { res = 1 } temp := node.Val for i := level - 1; i >= 0; i-- { temp = temp + path[i] if temp == sum { res++ } } path[level] = node.Val return res + dfs(node.Left, sum, path, level+1) + dfs(node.Right, sum, path, level+1) } 面试题05.01.插入(4) 题目 插入。给定两个32位的整数N与M，以及表示比特位置的i与j。 编写一种方法，将M插入N，使得M从N的第j位开始，到第i位结束。假定从j位到i位足以容纳M，也即若M = 10 011， 那么j和i之间至少可容纳5个位。例如，不可能出现j = 3和i = 2的情况，因为第3位和第2位之间放不下M。 示例1:输入：N = 1024(10000000000), M = 19(10011), i = 2, j = 6 输出：N = 1100(10001001100) 示例2:输入： N = 0, M = 31(11111), i = 0, j = 4 输出：N = 31(11111) 解题思路 No. 思路 时间复杂度 空间复杂度 01 位运算 O(1) O(1) 02 位运算 O(1) O(1) 03 数组辅助 O(1) O(1) 04 位运算 O(1) O(1) func insertBits(N int, M int, i int, j int) int { a := (N >> (j + 1)) >i)= 0; k-- { arr[31-(len(a)-1-k)] = a[k] } count := 0 for k := 31 - i; k >= 31-j; k-- { if count 面试题05.02.二进制数转字符串(2) 题目 二进制数转字符串。给定一个介于0和1之间的实数（如0.72），类型为double，打印它的二进制表达式。 如果该数字不在0和1之间，或者无法精确地用32位以内的二进制表示，则打印“ERROR”。 示例1:输入：0.625 输出：\"0.101\" 示例2:输入：0.1 输出：\"ERROR\" 提示：0.1无法被二进制准确表示 提示：32位包括输出中的\"0.\"这两位。 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(1) O(1) 02 遍历 O(1) O(1) func printBin(num float64) string { res := \"0.\" for num != float64(0) { num = num * 2 if num >= 1 { res = res + \"1\" num = num - 1.0 } else { res = res + \"0\" } if len(res) > 32 { return \"ERROR\" } } return res } # 2 func printBin(num float64) string { res := \"0.\" value := float64(1) for i := 1; i 面试题05.03.翻转数位(2) 题目 给定一个32位整数 num，你可以将一个数位从0变为1。请编写一个程序，找出你能够获得的最长的一串1的长度。 示例 1：输入: num = 1775(110111011112)输出: 8 示例 2：输入: num = 7(01112)输出: 4 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(1) O(1) 02 数组辅助 O(1) O(1) func reverseBits(num int) int { res := 0 a, b := 0, 0 for num != 0 { if num%2 == 1 { a++ } else { b = a a = 0 } res = max(res, a+b) num = num / 2 } return res + 1 } func max(a, b int) int { if a > b { return a } return b } # 2 func reverseBits(num int) int { res := 0 arr := make([]int, 0) count := 0 for num != 0 { if num%2 == 1 { count++ } else { arr = append(arr, count) count = 0 } num = num / 2 } arr = append(arr, count) if len(arr) == 1 { return arr[0] + 1 } for i := 1; i b { return a } return b } 面试题05.06.整数转换(4) 题目 整数转换。编写一个函数，确定需要改变几个位才能将整数A转成整数B。 示例1:输入：A = 29 （或者0b11101）, B = 15（或者0b01111）输出：2 示例2:输入：A = 1，B = 2 输出：2 提示: A，B范围在[-2147483648, 2147483647]之间 解题思路 No. 思路 时间复杂度 空间复杂度 01 内置函数 O(1) O(1) 02 位运算 O(1) O(1) 03 位运算 O(1) O(1) 04 位运算 O(1) O(1) func convertInteger(A int, B int) int { C := uint32(A) ^ uint32(B) return bits.OnesCount(uint(C)) } # 2 func convertInteger(A int, B int) int { C := uint32(A) ^ uint32(B) res := 0 for C != 0 { if C&1 == 1 { res++ } C = C >> 1 } return res } # 3 func convertInteger(A int, B int) int { C := uint32(A) ^ uint32(B) res := 0 for C != 0 { res++ C = C & (C - 1) } return res } # 4 func convertInteger(A int, B int) int { C := A ^ B res := 0 for i := 0; i > 1 } return res } 面试题05.07.配对交换(2) 题目 配对交换。编写程序，交换某个整数的奇数位和偶数位，尽量使用较少的指令 （也就是说，位0与位1交换，位2与位3交换，以此类推）。 示例1:输入：num = 2（或者0b10）输出 1 (或者 0b01) 示例2:输入：num = 3 输出：3 提示:num的范围在[0, 2^30 - 1]之间，不会发生整数溢出。 解题思路 No. 思路 时间复杂度 空间复杂度 01 位运算 O(1) O(1) 02 数组辅助 O(1) O(1) func exchangeBits(num int) int { // 0x55555555 = 01010101010101010101010101010101 提取偶数位=>左移 // 0xaaaaaaaa = 10101010101010101010101010101010 提取奇数位=>右移 a := (num & 0x55555555) > 1 return a | b } # 2 func exchangeBits(num int) int { a := fmt.Sprintf(\"%b\", num) arr := make([]byte, 32) for i := 0; i = 0; i-- { arr[count] = a[i] count-- } for i := len(arr) - 2; i >= 0; i = i - 2 { arr[i], arr[i+1] = arr[i+1], arr[i] } value, _ := strconv.ParseInt(string(arr), 2, 64) return int(value) } 面试题08.01.三步问题(2) 题目 三步问题。有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。 实现一种方法，计算小孩有多少种上楼梯的方式。结果可能很大，你需要对结果模1000000007。 示例1:输入：n = 3 输出：4 说明: 有四种走法 示例2:输入：n = 5输出：13 提示:n范围在[1, 1000000]之间 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n) O(1) 02 动态规划 O(n) O(n) func waysToStep(n int) int { if n == 1 { return 1 } if n == 2 { return 2 } if n == 3 { return 4 } a, b, c := 1, 2, 4 for i := 4; i 面试题08.02.迷路的机器人(2) 题目 设想有个机器人坐在一个网格的左上角，网格 r 行 c 列。 机器人只能向下或向右移动，但不能走到一些被禁止的网格（有障碍物）。 设计一种算法，寻找机器人从左上角移动到右下角的路径。 网格中的障碍物和空位置分别用 1 和 0 来表示。 返回一条可行的路径，路径由经过的网格的行号和列号组成。左上角为 0 行 0 列。 如果没有可行的路径，返回空数组。 示例 1:输入: [ [0,0,0], [0,1,0], [0,0,0] ] 输出: [[0,0],[0,1],[0,2],[1,2],[2,2]] 解释: 输入中标粗的位置即为输出表示的路径，即 0行0列（左上角） -> 0行1列 -> 0行2列 -> 1行2列 -> 2行2列（右下角） 说明：r 和 c 的值均不超过 100。 解题思路 No. 思路 时间复杂度 空间复杂度 01 深度优先搜索 O(n^2) O(n) 02 动态规划 O(n^2) O(1) var res [][]int func pathWithObstacles(obstacleGrid [][]int) [][]int { res = make([][]int, 0) path := make([][]int, 0) path = append(path, []int{0, 0}) dfs(obstacleGrid, path) return res } func dfs(arr [][]int, path [][]int) { if len(res) == 0 { x, y := path[len(path)-1][0], path[len(path)-1][1] if arr[x][y] == 0 { arr[x][y] = 1 if x = 0 && j >= 0 { if obstacleGrid[i][j] == total { newArr := make([][]int, 0) newArr = append(newArr, []int{i, j}) res = append(newArr, res...) total = total - 1 } if i == 0 && j == 0 { break } if i == 0 && obstacleGrid[i][j-1] == total { j-- } else if j == 0 && obstacleGrid[i-1][j] == total { i-- } else if obstacleGrid[i-1][j] == total { i-- } else if obstacleGrid[i][j-1] == total { j-- } } return res } func max(a, b int) int { if a > b { return a } return b } 面试题08.03.魔术索引(2) 题目 魔术索引。 在数组A[0...n-1]中，有所谓的魔术索引，满足条件A[i] = i。 给定一个有序整数数组，编写一种方法找出魔术索引，若有的话，在数组A中找出一个魔术索引，如果没有，则返回-1。 若有多个魔术索引，返回索引值最小的一个。 示例1:输入：nums = [0, 2, 3, 4, 5] 输出：0 说明: 0下标的元素为0 示例2:输入：nums = [1, 1, 1] 输出：1 说明: nums长度在[1, 1000000]之间 此题为原书中的 Follow-up，即数组中可能包含重复元素的版本 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 递归 O(n) O(n) func findMagicIndex(nums []int) int { for i := 0; i right { return -1 } mid := left + (right-left)/2 res := search(nums, left, mid-1) if res != -1 { return res } else if nums[mid] == mid { return mid } return search(nums, mid+1, right) } 面试题08.04.幂集(3) 题目 幂集。编写一种方法，返回某集合的所有子集。集合中不包含重复的元素。 说明：解集不能包含重复的子集。 示例:输入： nums = [1,2,3]输出： [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ] 解题思路 No. 思路 时间复杂度 空间复杂度 01 回溯 O(n*2^n) O(n*2^n) 02 迭代 O(n*2^n) O(n*2^n) 03 位运算 O(n*2^n) O(n*2^n) var res [][]int func subsets(nums []int) [][]int { res = make([][]int, 0) dfs(nums, make([]int, 0), 0) return res } func dfs(nums []int, arr []int, level int) { temp := make([]int, len(arr)) copy(temp, arr) res = append(res, temp) for i := level; i 面试题08.05.递归乘法(3) 题目 递归乘法。 写一个递归函数，不使用 * 运算符， 实现两个正整数的相乘。可以使用加号、减号、位移，但要吝啬一些。 示例1:输入：A = 1, B = 10 输出：10 示例2:输入：A = 3, B = 4 输出：12 提示:保证乘法范围不会溢出 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(n) 02 递归 O(log(n)) O(log(n)) 03 迭代 O(log(n)) O(1) func multiply(A int, B int) int { if B == 0 { return 0 } return multiply(A, B-1) + A } # 2 func multiply(A int, B int) int { if B == 0 { return 0 } if B == 1 { return A } if B%2 == 1 { return multiply(A>1) + A } return multiply(A>1) } # 3 func multiply(A int, B int) int { res := 0 for B != 0{ if B % 2==1{ res = res + A } A = A+A B = B >> 1 } return res } 面试题08.06.汉诺塔问题(1) 题目 在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。 一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。 移动圆盘时受到以下限制: (1) 每次只能移动一个盘子; (2) 盘子只能从柱子顶端滑出移到下一根柱子; (3) 盘子只能叠在比它大的盘子上。 请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。 你需要原地修改栈。 示例1:输入：A = [2, 1, 0], B = [], C = [] 输出：C = [2, 1, 0] 示例2:输入：A = [1, 0], B = [], C = [] 输出：C = [1, 0] 提示:A中盘子的数目不大于14个。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(2^n) O(n) func hanota(A []int, B []int, C []int) []int { if A == nil { return nil } move(len(A), &A, &B, &C) return C } func move(num int, A, B, C *[]int) { if num 面试题08.07.无重复字符串的排列组合(3) 题目 无重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合，字符串每个字符均不相同。 示例1:输入：S = \"qwe\"输出：[\"qwe\", \"qew\", \"wqe\", \"weq\", \"ewq\", \"eqw\"] 示例2:输入：S = \"ab\"输出：[\"ab\", \"ba\"] 提示:字符都是英文字母。 字符串长度在[1, 9]之间。 解题思路 No. 思路 时间复杂度 空间复杂度 01 回溯 O(n^n) O(n*n!) 02 递归 O(n!) O(n*n!) 03 回溯 O(n!) O(n*n!) var res []string func permutation(S string) []string { res = make([]string, 0) nums := []byte(S) visited := make(map[int]bool) dfs(nums, 0, \"\", visited) return res } func dfs(nums []byte, index int, str string, visited map[int]bool) { if index == len(nums) { res = append(res, str) return } for i := 0; i 面试题08.08.有重复字符串的排列组合(3) 题目 有重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合。 示例1:输入：S = \"qqe\" 输出：[\"eqq\",\"qeq\",\"qqe\"] 示例2:输入：S = \"ab\"输出：[\"ab\", \"ba\"] 提示: 字符都是英文字母。 字符串长度在[1, 9]之间。 解题思路 No. 思路 时间复杂度 空间复杂度 01 回溯 O(n!) O(n*n!) 02 回溯 O(n!) O(n*n!) 03 回溯 O(n!) O(n*n!) var res []string func permutation(S string) []string { res = make([]string, 0) nums := []byte(S) sort.Slice(nums, func(i, j int) bool { return nums[i] 0 && nums[i] == nums[i-1] && visited[i-1] == 0 { continue } str = str + string(nums[i]) visited[i] = 1 dfs(nums, index+1, visited, str) visited[i] = 0 str = str[:len(str)-1] } } # 2 var res []string func permutation(S string) []string { res = make([]string, 0) nums := []byte(S) sort.Slice(nums, func(i, j int) bool { return nums[i] 0 && nums[i] == nums[i-1] { continue } str = str + string(nums[i]) arr := append([]byte{}, nums[:i]...) arr = append(arr, nums[i+1:]...) dfs(arr, str) str = str[:len(str)-1] } } 面试题08.09.括号(3) 题目 括号。设计一种算法，打印n对括号的所有合法的（例如，开闭一一对应）组合。 说明：解集不能包含重复的子集。 例如，给出 n = 3，生成结果为： [ \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\" ] 解题思路 No. 思路 时间复杂度 空间复杂度 01 全排列-递归 O(4^n/n^(1/2)) O(4^n/n^(1/2)) 02 动态规划 O(4^n/n^(1/2)) O(4^n/n^(1/2)) 03 广度优先搜索 O(4^n/n^(1/2)) O(4^n/n^(1/2)) var res []string func generateParenthesis(n int) []string { res = make([]string, 0) dfs(0, 0, n, \"\") return res } func dfs(left, right, max int, str string) { if left == right && left == max { res = append(res, str) return } if left 0 { node := queue[0] queue = queue[1:] if node.left == 0 && node.right == 0 { res = append(res, node.str) } if node.left > 0 { queue = append(queue, &Node{ str: node.str + \"(\", left: node.left - 1, right: node.right, }) } if node.right > 0 && node.left 面试题08.10.颜色填充(2) 题目 编写函数，实现许多图片编辑软件都支持的「颜色填充」功能。 待填充的图像用二维数组 image 表示，元素为初始颜色值。初始坐标点的横坐标为 sr 纵坐标为 sc。 需要填充的新颜色为 newColor 。 「周围区域」是指颜色相同且在上、下、左、右四个方向上存在相连情况的若干元素。 请用新颜色填充初始坐标点的周围区域，并返回填充后的图像。 示例：输入： image = [[1,1,1],[1,1,0],[1,0,1]] sr = 1, sc = 1, newColor = 2 输出：[[2,2,2],[2,2,0],[2,0,1]] 解释: 初始坐标点位于图像的正中间，坐标 (sr,sc)=(1,1) 。 初始坐标点周围区域上所有符合条件的像素点的颜色都被更改成 2 。 注意，右下角的像素没有更改为 2 ，因为它不属于初始坐标点的周围区域。 提示： image 和 image[0] 的长度均在范围 [1, 50] 内。 初始坐标点 (sr,sc) 满足 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 广度优先搜索 O(n^2) O(n^2) 02 深度优先搜索 O(n^2) O(n^2) var dx = []int{-1, 1, 0, 0} var dy = []int{0, 0, -1, 1} func floodFill(image [][]int, sr int, sc int, newColor int) [][]int { oldColor := image[sr][sc] if oldColor == newColor { return image } m, n := len(image), len(image[0]) list := make([][]int, 1) list[0] = []int{sr, sc} for len(list) > 0 { node := list[0] list = list[1:] image[node[0]][node[1]] = newColor for i := 0; i = len(image) || sc >= len(image[sr]) || image[sr][sc] == newColor { return image } oldColor := image[sr][sc] image[sr][sc] = newColor for i := 0; i 面试题08.11.硬币 题目 硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。 (结果可能会很大，你需要将结果模上1000000007) 示例1:输入: n = 5 输出：2 解释: 有两种方式可以凑成总金额: 5=5 5=1+1+1+1+1 示例2:输入: n = 10 输出：4 解释: 有四种方式可以凑成总金额: 10=10 10=5+5 10=5+1+1+1+1+1 10=1+1+1+1+1+1+1+1+1+1 说明：注意: 你可以假设： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 回溯 O(n^n) O(n^2) 面试题08.12.八皇后(3) 题目 设计一种算法，打印 N 皇后在 N × N 棋盘上的各种摆法，其中每个皇后都不同行、不同列，也不在对角线上。 这里的“对角线”指的是所有的对角线，不只是平分整个棋盘的那两条对角线。 注意：本题相对原题做了扩展 示例:输入：4 输出：[[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]] 解释: 4皇后问题存在如下两个不同的解法。 [ [\".Q..\", // 解法 1 \"...Q\", \"Q...\", \"..Q.\"], [\"..Q.\", // 解法 2 \"Q...\", \"...Q\", \".Q..\"] ] 解题思路 No. 思路 时间复杂度 空间复杂度 01 回溯 O(n^n) O(n^2) 02 回溯 O(n^n) O(n^2) 03 回溯 O(n^n) O(n^2) var res [][]string func solveNQueens(n int) [][]string { res = make([][]string, 0) // 初始化棋盘 arr := make([][]string, n) for i := 0; i = 0 && col >= 0; row, col = row-1, col-1 { if arr[row][col] == \"Q\" { return false } } // 右上角 for row, col := row-1, col+1; row >= 0 && col >a)&1) != 0 || ((left>>b)&1) != 0 || ((right>>c)&1) != 0 { continue } arr[row][col] = \"Q\" dfs(arr, row+1, rows^(1 面试题10.01.合并排序的数组(3) 题目 给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。 初始化 A 和 B 的元素数量分别为 m 和 n。 示例:输入: A = [1,2,3,0,0,0], m = 3 B = [2,5,6], n = 3 输出: [1,2,2,3,5,6] 说明:A.length == n + m 解题思路 No. 思路 时间复杂度 空间复杂度 01 合并后排序 O(nlog(n)) O(1) 02 双指针法 O(n) O(1) 03 数组辅助 O(n) O(n) func merge(A []int, m int, B []int, n int) { A = A[:m] A = append(A, B[:n]...) sort.Ints(A) } # 2 func merge(A []int, m int, B []int, n int) { for m > 0 && n > 0 { if A[m-1] 0 { for n > 0 { A[n-1] = B[n-1] n-- } } } # 3 func merge(A []int, m int, B []int, n int) { temp := make([]int, m) copy(temp, A) if n == 0 { return } first, second := 0, 0 for i := 0; i = n { A[i] = temp[first] first++ continue } if first >= m { A[i] = B[second] second++ continue } if temp[first] 面试题10.02.变位词组(2) 题目 编写一种方法，对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串。 注意：本题相对原题稍作修改 示例:输入: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"], 输出: [ [\"ate\",\"eat\",\"tea\"], [\"nat\",\"tan\"], [\"bat\"] ] 说明：所有输入均为小写字母。 不考虑答案输出的顺序。 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n^2log(n)) O(n^2) 02 哈希辅助 O(n^2) O(n^2) func groupAnagrams(strs []string) [][]string { m := make(map[string]int) res := make([][]string, 0) for i := 0; i 面试题10.03.搜索旋转数组(2) 题目 搜索旋转数组。给定一个排序后的数组，包含n个整数，但这个数组已被旋转过很多次了，次数不详。 请编写代码找出数组中的某个元素，假设数组元素原先是按升序排列的。若有多个相同元素，返回索引值最小的一个。 示例1: 输入: arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 5 输出: 8（元素5在该数组中的索引） 示例2:输入：arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 11 输出：-1 （没有找到） 提示:arr 长度范围在[1, 1000000]之间 解题思路 No. 思路 时间复杂度 空间复杂度 01 二分查找 O(log(n)) O(1) 02 遍历 O(n) O(1) func search(nums []int, target int) int { left, right := 0, len(nums)-1 for left nums[mid] { // 右边升序 if nums[mid] nums[right] { left = mid + 1 } else { right = mid } } else if nums[left] == nums[mid] { if nums[left] != target { left++ } else { return left } } } if nums[left] == target { return left } return -1 } # func search(nums []int, target int) int { for i := 0; i 面试题10.05.稀疏数组搜索(2) 题目 稀疏数组搜索。有个排好序的字符串数组，其中散布着一些空字符串，编写一种方法，找出给定字符串的位置。 示例1: 输入: words = [\"at\", \"\", \"\", \"\", \"ball\", \"\", \"\", \"car\", \"\", \"\",\"dad\", \"\", \"\"], s = \"ta\" 输出：-1 说明: 不存在返回-1。 示例2: 输入：words = [\"at\", \"\", \"\", \"\", \"ball\", \"\", \"\", \"car\", \"\", \"\",\"dad\", \"\", \"\"], s = \"ball\" 输出：4 提示: words的长度在[1, 1000000]之间 解题思路 No. 思路 时间复杂度 空间复杂度 01 二分查找 O(log(n)) O(1) 02 暴力法 O(n) O(1) func findString(words []string, s string) int { left := 0 right := len(words) - 1 for left 面试题10.09.排序矩阵查找(6) 题目 给定M×N矩阵，每一行、每一列都按升序排列，请编写代码找出某元素。 示例:现有矩阵 matrix 如下： [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] 给定 target = 5，返回 true。 给定 target = 20，返回 false。 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法 O(n^2) O(1) 02 暴力法-优化 O(n^2) O(1) 03 二分查找 O(nlog(n)) O(1) 04 左下角查找 O(n) O(1) 05 右上角查找 O(n) O(1) 06 内置函数 O(n^2) O(1) func searchMatrix(matrix [][]int, target int) bool { if len(matrix) == 0 { return false } if len(matrix[0]) == 0 { return false } for i := 0; i = target { for j := 0; j = target { res := binarySearch(matrix[i], target) if res == true { return true } } } return false } func binarySearch(arr []int, target int) bool { left := 0 right := len(arr) - 1 for left target { right = mid - 1 } else { left = mid + 1 } } return false } # 4 func searchMatrix(matrix [][]int, target int) bool { if len(matrix) == 0 { return false } if len(matrix[0]) == 0 { return false } i := len(matrix) - 1 j := 0 for i >= 0 && j target { i-- } else { j++ } } return false } # 5 func searchMatrix(matrix [][]int, target int) bool { if len(matrix) == 0 { return false } if len(matrix[0]) == 0 { return false } i := 0 j := len(matrix[0]) - 1 for j >= 0 && i target { j-- } else { i++ } } return false } # 6 func searchMatrix(matrix [][]int, target int) bool { if len(matrix) == 0 { return false } if len(matrix[0]) == 0 { return false } for i := 0; i 面试题16.01.交换数字(3) 题目 编写一个函数，不用临时变量，直接交换numbers = [a, b]中a与b的值。 示例：输入: numbers = [1,2] 输出: [2,1] 提示： numbers.length == 2 解题思路 No. 思路 时间复杂度 空间复杂度 01 直接返回 O(1) O(1) 02 位运算 O(1) O(1) 03 加减 O(1) O(1) func swapNumbers(numbers []int) []int { return []int{numbers[1], numbers[0]} } # 2 func swapNumbers(numbers []int) []int { numbers[0] = numbers[0] ^ numbers[1] numbers[1] = numbers[1] ^ numbers[0] numbers[0] = numbers[0] ^ numbers[1] return numbers } # 3 func swapNumbers(numbers []int) []int { numbers[0] = numbers[0] + numbers[1] numbers[1] = numbers[0] - numbers[1] numbers[0] = numbers[0] - numbers[1] return numbers } 面试题16.02.单词频率(2) 题目 设计一个方法，找出任意指定单词在一本书中的出现频率。 你的实现应该支持如下操作： WordsFrequency(book)构造函数，参数为字符串数组构成的一本书 get(word)查询指定单词在书中出现的频率 示例：WordsFrequency wordsFrequency = new WordsFrequency({\"i\", \"have\", \"an\", \"apple\", \"he\", \"have\", \"a\", \"pen\"}); wordsFrequency.get(\"you\"); //返回0，\"you\"没有出现过 wordsFrequency.get(\"have\"); //返回2，\"have\"出现2次 wordsFrequency.get(\"an\"); //返回1 wordsFrequency.get(\"apple\"); //返回1 wordsFrequency.get(\"pen\"); //返回1 提示：book[i]中只包含小写字母 1 解题思路 No. 思路 时间复杂度 空间复杂度 02 map O(1) O(n) 02 trie树 O(1) O(n) type WordsFrequency struct { m map[string]int } func Constructor(book []string) WordsFrequency { res := WordsFrequency{m: make(map[string]int)} for k := range book { res.m[book[k]]++ } return res } func (this *WordsFrequency) Get(word string) int { return this.m[word] } # 2 type WordsFrequency struct { ending int next [26]*WordsFrequency } func Constructor(book []string) WordsFrequency { res := WordsFrequency{} for _, v := range book { res.Insert(v) } return res } func (this *WordsFrequency) Get(word string) int { temp := this for _, v := range word { nextWord := v - 'a' if temp.next[nextWord] == nil { return 0 } temp = temp.next[nextWord] } return temp.ending } func (this *WordsFrequency) Insert(word string) { temp := this for _, v := range word { nextWord := v - 'a' if temp.next[nextWord] == nil { temp.next[nextWord] = &WordsFrequency{} } temp = temp.next[nextWord] } temp.ending = temp.ending + 1 } 面试题16.05.阶乘尾数(1) 题目 设计一个算法，算出 n 阶乘有多少个尾随零。 示例 1:输入: 3 输出: 0 解释: 3! = 6, 尾数中没有零。 示例 2:输入: 5输出: 1 解释: 5! = 120, 尾数中有 1 个零. 说明: 你算法的时间复杂度应为 O(log n) 。 解题思路 No. 思路 时间复杂度 空间复杂度 01 数学，找规律 O(log(n)) O(1) // N!有多少个后缀0，即N!有多少个质因数5。 // N!有多少个质因数5，即N可以划分成多少组5个数字一组， // 加上划分成多少组25个数字一组，加上划分多少组成125个数字一组，等等 // Ans = N/5 + N/(5^2) + N/(5^3) + ... func trailingZeroes(n int) int { result := 0 for n >= 5 { n = n / 5 result = result + n } return result } 面试题16.06.最小差(2) 题目 给定两个整数数组a和b，计算具有最小差绝对值的一对数值（每个数组中取一个值），并返回该对数值的差 示例：输入：{1, 3, 15, 11, 2}, {23, 127, 235, 19, 8} 输出： 3，即数值对(11, 8) 提示： 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序双指针 O(nlog(n)) O(1) 02 排序+二分查找 O(nlog(n)) O(1) func smallestDifference(a []int, b []int) int { sort.Ints(a) sort.Ints(b) i, j := 0, 0 res := math.MaxInt32 for i b[j] { j++ } else { i++ } } return res } func min(a, b int) int { if a > b { return b } return a } func abs(a, b int) int { if a > b { return a - b } return b - a } # 2 func smallestDifference(a []int, b []int) int { sort.Ints(b) res := math.MaxInt32 for i := 0; i a[i] { right = mid - 1 } else { left = mid + 1 } } if left 0 { res = min(res, abs(a[i], b[left-1])) } } return res } func min(a, b int) int { if a > b { return b } return a } func abs(a, b int) int { if a > b { return a - b } return b - a } 面试题16.07.最大数值(3) 题目 编写一个方法，找出两个数字a和b中最大的那一个。不得使用if-else或其他比较运算符。 示例：输入： a = 1, b = 2 输出： 2 解题思路 No. 思路 时间复杂度 空间复杂度 01 数学 O(1) O(1) 02 内置函数 O(1) O(1) 03 位运算 O(1) O(1) func maximum(a int, b int) int { // max(a,b) = (abs(a-b)+a+b)/2 return (int(math.Abs(float64(a-b))) + a + b) / 2 } # 2 func maximum(a int, b int) int { return int(math.Max(float64(a), float64(b))) } # 3 func maximum(a int, b int) int { value := int(uint64(a-b) >> 63) // 取符号位，a-b>0 => 符号位为0 a-b符号位为1 return value*b + int(1^value)*a // value=0=> 0^1=1 1^1=0 } 面试题16.10.生存人数(2) 题目 给定N个人的出生年份和死亡年份，第i个人的出生年份为birth[i]，死亡年份为death[i]， 实现一个方法以计算生存人数最多的年份。 你可以假设所有人都出生于1900年至2000年（含1900和2000）之间。 如果一个人在某一年的任意时期都处于生存状态，那么他们应该被纳入那一年的统计中。 例如，生于1908年、死于1909年的人应当被列入1908年和1909年的计数。 如果有多个年份生存人数相同且均为最大值，输出其中最小的年份。 示例：输入：birth = {1900, 1901, 1950} death = {1948, 1951, 2000} 输出： 1901 提示：0 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序双指针 O(nlog(n)) O(1) 02 计数 O(n) O(n) func maxAliveYear(birth []int, death []int) int { sort.Ints(birth) sort.Ints(death) res := birth[0] max := 0 j := 0 count := 0 for i := 0; i death[j] { count-- j++ } if count > max { max = count res = birth[i] } } return res } # 2 func maxAliveYear(birth []int, death []int) int { arr := make([]int, 102) for i := 0; i max { max = sum res = i + 1900 } } return res } 面试题16.11.跳水板(2) 题目 你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter， 长度较长的木板长度为longer。你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。 返回的长度需要从小到大排列。 示例 1 输入：shorter = 1 longer = 2 k = 3 输出： [3,4,5,6] 解释：可以使用 3 次 shorter，得到结果 3；使用 2 次 shorter 和 1 次 longer，得到结果 4 。 以此类推，得到最终结果。 提示： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(n) 02 遍历 O(n) O(n) func divingBoard(shorter int, longer int, k int) []int { res := make([]int, 0) if k == 0 { return res } if shorter == longer { return []int{shorter * k} } for i := 0; i 面试题16.15.珠玑妙算(2) 题目 珠玑妙算游戏（the game of master mind）的玩法如下。 计算机有4个槽，每个槽放一个球，颜色可能是红色（R）、黄色（Y）、绿色（G）或蓝色（B）。 例如，计算机可能有RGGB 4种（槽1为红色，槽2、3为绿色，槽4为蓝色）。 作为用户，你试图猜出颜色组合。打个比方，你可能会猜YRGB。 要是猜对某个槽的颜色，则算一次“猜中”；要是只猜对颜色但槽位猜错了，则算一次“伪猜中”。 注意，“猜中”不能算入“伪猜中”。 给定一种颜色组合solution和一个猜测guess， 编写一个方法，返回猜中和伪猜中的次数answer，其中answer[0]为猜中的次数，answer[1]为伪猜中的次数。 示例：输入： solution=\"RGBY\",guess=\"GGRR\" 输出： [1,1] 解释： 猜中1次，伪猜中1次。 提示：len(solution) = len(guess) = 4 solution和guess仅包含\"R\",\"G\",\"B\",\"Y\"这4种字符 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(1) O(1) 02 数组辅助 O(1) O(1) func masterMind(solution string, guess string) []int { m := make(map[byte]int) a, b := 0, 0 for i := 0; i 0 { b++ m[guess[i]]-- } } } return []int{a, b} } # 2 func masterMind(solution string, guess string) []int { arr := [256]int{} a, b := 0, 0 for i := 0; i 0 { b++ arr[guess[i]]-- } } } return []int{a, b} } 面试题16.16.部分排序(2) 题目 给定一个整数数组，编写一个函数，找出索引m和n，只要将索引区间[m,n]的元素排好序，整个数组就是有序的。 注意：n-m尽量最小，也就是说，找出符合条件的最短序列。 函数返回值为[m,n]，若不存在这样的m和n（例如整个数组是有序的），请返回[-1,-1]。 示例：输入： [1,2,4,7,10,11,7,12,6,7,16,18,19] 输出： [3,9] 提示：0 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序遍历 O(nlog(n)) O(n) 02 遍历 O(n) O(1) func subSort(array []int) []int { temp := make([]int, len(array)) copy(temp, array) sort.Ints(temp) left, right := -1, -1 for i := 0; i = 0; i-- { if temp[i] != array[i] { right = i break } } return []int{left, right} } # 2 func subSort(array []int) []int { left, right := -1, -1 maxValue := math.MinInt32 minValue := math.MaxInt32 for i := 0; i = maxValue { maxValue = array[i] } else { right = i } } for i := len(array) - 1; i >= 0; i-- { if minValue >= array[i] { minValue = array[i] } else { left = i } } return []int{left, right} } 面试题16.17.连续数列(5) 题目 给定一个整数数组，找出总和最大的连续数列，并返回总和。 示例：输入： [-2,1,-3,4,-1,2,1,-5,4]输出： 6 解释： 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 解题思路 No. 思路 时间复杂度 空间复杂度 01 贪心法 O(n) O(1) 02 暴力法 O(n^2) O(1) 03 动态规划 O(n) O(n) 04 动态规划 O(n) O(1) 05 分治 O(nlog(n)) O(log(n)) func maxSubArray(nums []int) int { result := nums[0] sum := 0 for i := 0; i 0 { sum += nums[i] } else { sum = nums[i] } if sum > result { result = sum } } return result } # 2 func maxSubArray(nums []int) int { result := math.MinInt32 for i := 0; i result { result = sum } } } return result } # 3 // dp[i] = max(dp[i-1]+nums[i], nums[i]) // res = max(dp[i], res) func maxSubArray(nums []int) int { dp := make([]int, len(nums)) dp[0] = nums[0] result := nums[0] for i := 1; i nums[i] { dp[i] = dp[i-1] + nums[i] } else { dp[i] = nums[i] } if dp[i] > result { result = dp[i] } } return result } # 4 func maxSubArray(nums []int) int { dp := nums[0] result := dp for i := 1; i nums[i] { dp = dp + nums[i] } else { dp = nums[i] } if dp > result { result = dp } } return result } # 5 func maxSubArray(nums []int) int { result := maxSubArr(nums, 0, len(nums)-1) return result } func maxSubArr(nums []int, left, right int) int { if left == right { return nums[left] } mid := (left + right) / 2 leftSum := maxSubArr(nums, left, mid) // 最大子序在左边 rightSum := maxSubArr(nums, mid+1, right) // 最大子序在右边 midSum := findMaxArr(nums, left, mid, right) // 跨中心 result := max(leftSum, rightSum) result = max(result, midSum) return result } func findMaxArr(nums []int, left, mid, right int) int { leftSum := math.MinInt32 sum := 0 // 从右到左 for i := mid; i >= left; i-- { sum += nums[i] leftSum = max(leftSum, sum) } rightSum := math.MinInt32 sum = 0 // 从左到右 for i := mid + 1; i b { return a } return b } 面试题16.19.水域大小(2) 题目 你有一个用于表示一片土地的整数矩阵land，该矩阵中每个点的值代表对应地点的海拔高度。 若值为0则表示水域。由垂直、水平或对角连接的水域为池塘。池塘的大小是指相连接的水域的个数。 编写一个方法来计算矩阵中所有池塘的大小，返回值需要从小到大排序。 示例：输入： [ [0,2,1,0], [0,1,0,1], [1,1,0,1], [0,1,0,1] ] 输出： [1,2,4] 提示： 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 深度优先搜索 O(n^2) O(n) 02 深度优先搜索 O(n^2) O(n) func pondSizes(land [][]int) []int { res := make([]int, 0) for i := range land { for j := range land[i] { if land[i][j] == 0 { res = append(res, getArea(land, i, j)) } } } sort.Ints(res) return res } func getArea(grid [][]int, i, j int) int { if grid[i][j] != 0 { return 0 } grid[i][j] = 1 area := 1 for a := i - 1; a = len(grid) || b = len(grid[0]) { continue } area = area + getArea(grid, a, b) } } return area } # 2 func pondSizes(land [][]int) []int { res := make([]int, 0) for i := range land { for j := range land[i] { if land[i][j] == 0 { res = append(res, getArea(land, i, j)) } } } sort.Ints(res) return res } func getArea(grid [][]int, i, j int) int { if i = len(grid) || j = len(grid[0]) || grid[i][j] != 0 { return 0 } grid[i][j] = 1 res := 1 res = res + getArea(grid, i+1, j) res = res + getArea(grid, i+1, j+1) res = res + getArea(grid, i+1, j-1) res = res + getArea(grid, i-1, j) res = res + getArea(grid, i-1, j+1) res = res + getArea(grid, i-1, j-1) res = res + getArea(grid, i, j+1) res = res + getArea(grid, i, j-1) return res } 面试题16.21.交换和(1) 题目 给定两个整数数组，请交换一对数值（每个数组中取一个数值），使得两个数组所有元素的和相等。 返回一个数组，第一个元素是第一个数组中要交换的元素，第二个元素是第二个数组中要交换的元素。 若有多个答案，返回任意一个均可。若无满足条件的数值，返回空数组。 示例:输入: array1 = [4, 1, 2, 1, 1, 2], array2 = [3, 6, 3, 3] 输出: [1, 3] 示例:输入: array1 = [1, 2, 3], array2 = [4, 5, 6] 输出: [] 提示：1 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(n) func findSwapValues(array1 []int, array2 []int) []int { m := make(map[int]bool) sumA, sumB := 0, 0 for i := 0; i 面试题16.25.LRU缓存(1) 题目 设计和构建一个“最近最少使用”缓存，该缓存会删除最近最少使用的项目。 缓存应该从键映射到值(允许你插入和检索特定键对应的值)，并在初始化时指定最大容量。 当缓存被填满时，它应该删除最近最少使用的项目。 它应该支持以下操作： 获取数据 get 和 写入数据 put 。 获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。 写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。 当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。 示例:LRUCache cache = new LRUCache( 2 /* 缓存容量 */ ); cache.put(1, 1); cache.put(2, 2); cache.get(1); // 返回 1 cache.put(3, 3); // 该操作会使得密钥 2 作废 cache.get(2); // 返回 -1 (未找到) cache.put(4, 4); // 该操作会使得密钥 1 作废 cache.get(1); // 返回 -1 (未找到) cache.get(3); // 返回 3 cache.get(4); // 返回 4 解题思路 No. 思路 时间复杂度 空间复杂度 01 双向链表 O(1) O(n) type Node struct { key int value int prev *Node next *Node } type LRUCache struct { cap int header *Node tail *Node m map[int]*Node } func Constructor(capacity int) LRUCache { cache := LRUCache{ cap: capacity, header: &Node{}, tail: &Node{}, m: make(map[int]*Node, capacity), } cache.header.next = cache.tail cache.tail.prev = cache.header return cache } func (this *LRUCache) Get(key int) int { if node, ok := this.m[key]; ok { this.remove(node) this.putHead(node) return node.value } return -1 } func (this *LRUCache) Put(key int, value int) { if node, ok := this.m[key]; ok { node.value = value this.remove(node) this.putHead(node) return } if this.cap 面试题17.01.不用加号的加法(2) 题目 设计一个函数把两个数字相加。不得使用 + 或者其他算术运算符。 示例:输入: a = 1, b = 1 输出: 2 提示： a, b 均可能是负数或 0 结果不会溢出 32 位整数 解题思路 No. 思路 时间复杂度 空间复杂度 01 迭代 O(1) O(1) 02 递归 O(1) O(1) /* 0 + 0 = 0 0 + 1 = 1 1 + 0 = 1 1 + 1 = 0（进位 1） 异或的一个重要特性是无进位加法 (a 和 b 的无进位结果) + (a 和 b 的进位结果) */ func add(a int, b int) int { for b != 0 { a, b = a^b, (a&b) 面试题17.04.消失的数字(5) 题目 数组nums包含从0到n的所有整数，但其中缺了一个。请编写代码找出那个缺失的整数。你有办法在O(n)时间内完成吗？ 注意：本题相对书上原题稍作改动 示例 1：输入：[3,0,1]输出：2 示例 2：输入：[9,6,4,2,3,5,7,0,1] 输出：8 解题思路 No. 思路 时间复杂度 空间复杂度 01 数学计算 O(n) O(1) 02 排序遍历 O(nlog(n)) O(1) 03 异或-位运算 O(n) O(1) 04 交换排序(就地排序) O(n) O(1) 05 哈希辅助 O(n) O(n) func missingNumber(nums []int) int { n := len(nums) sum := n * (n + 1) / 2 for i := 0; i 面试题17.09.第k个数(1) 题目 有些数的素因子只有 3，5，7，请设计一个算法找出第 k 个数。 注意，不是必须有这些素因子，而是必须不包含其他的素因子。 例如，前几个数按顺序应该是 1，3，5，7，9，15，21。 示例 1:输入: k = 5输出: 9 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n) O(n) func getKthMagicNumber(k int) int { dp := make([]int, k) dp[0] = 1 // *3或5或7之后得到 idx3, idx5, idx7 := 0, 0, 0 for i := 1; i b { return b } return a } 面试题17.10.主要元素(5) 题目 数组中占比超过一半的元素称之为主要元素。给定一个整数数组，找到它的主要元素。若没有，返回-1。 示例 1：输入：[1,2,5,9,5,9,5,5,5]输出：5 示例 2：输入：[3,2]输出：-1 示例 3：输入：[2,2,1,1,1,2,2]输出：2 说明：你有办法在时间复杂度为 O(N)，空间复杂度为 O(1) 内完成吗？ 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(n) 02 Boyer-Moore投票算法 O(n) O(1) 03 排序 O(nlog(n)) O(1) 04 位运算 O(n) O(1) 05 分治法 O(nlog(n)) O(log(n)) func majorityElement(nums []int) int { m := make(map[int]int) result := -1 for _, v := range nums{ if _,ok := m[v];ok{ m[v]++ }else { m[v]=1 } if m[v] > (len(nums)/2){ result = v } } return result } # 2 func majorityElement(nums []int) int { result, count := 0, 0 for i := 0; i len(nums)/2 { result = result | mask } mask = mask rightCount { return left } return right } 面试题17.11.单词距离(2) 题目 有个内含单词的超大文本文件，给定任意两个单词，找出在这个文件中这两个单词的最短距离(相隔单词数)。 如果寻找过程在这个文件中会重复多次，而每次寻找的单词不同，你能对此优化吗? 示例：输入：words = [\"I\",\"am\",\"a\",\"student\",\"from\",\"a\",\"university\",\"in\",\"a\",\"city\"], word1 = \"a\", word2 = \"student\" 输出：1 提示：words.length 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 数组辅助 O(n) O(n) func findClosest(words []string, word1 string, word2 string) int { res := len(words) - 1 a, b := -1, -1 for i := 0; i b { return a - b } return b - a } # 2 func findClosest(words []string, word1 string, word2 string) int { res := len(words) - 1 arrA, arrB := make([]int, 0), make([]int, 0) for i := 0; i b { return a - b } return b - a } 面试题17.12.BiNode(2) 题目 二叉树数据结构TreeNode可用来表示单向链表（其中left置空，right为下一个链表节点）。 实现一个方法，把二叉搜索树转换为单向链表，要求依然符合二叉搜索树的性质，转换操作应是原址的， 也就是在原始的二叉搜索树上直接修改。 返回转换后的单向链表的头节点。 注意：本题相对原题稍作改动 示例：输入： [4,2,5,1,3,null,6,0] 输出： [0,null,1,null,2,null,3,null,4,null,5,null,6] 提示：节点数量不会超过 100000。 解题思路 No. 思路 时间复杂度 空间复杂度 01 递归 O(n) O(log(n)) 02 迭代 O(n) O(n) func convertBiNode(root *TreeNode) *TreeNode { head := &TreeNode{} cur := head dfs(root, cur) return head.Right } func dfs(root, cur *TreeNode) *TreeNode { if root != nil { cur = dfs(root.Left, cur) root.Left = nil cur.Right = root cur = root cur = dfs(root.Right, cur) } return cur } # 2 func convertBiNode(root *TreeNode) *TreeNode { head := &TreeNode{} cur := head stack := make([]*TreeNode, 0) node := root for node != nil || len(stack) > 0 { if node != nil { stack = append(stack, node) node = node.Left } else { node = stack[len(stack)-1] stack = stack[:len(stack)-1] node.Left = nil cur.Right = node cur = node node = node.Right } } return head.Right } 面试题17.14.最小K个数(3) 题目 设计一个算法，找出数组中最小的k个数。以任意顺序返回这k个数均可。 示例：输入： arr = [1,3,5,7,2,4,6,8], k = 4 输出： [1,2,3,4] 提示：0 解题思路 No. 思路 时间复杂度 空间复杂度 01 堆排序 O(nlog(n)) O(n) 02 快排 O(nlog(n)) O(log(n)) 03 内置函数 O(nlog(n)) O(1) func smallestK(arr []int, k int) []int { intHeap := make(IntHeap, 0) heap.Init(&intHeap) for i := 0; i func (h IntHeap) Less(i, j int) bool { return h[i] right { return nil } index := partition(arr, left, right) if index == k { return arr[:k] } else if index 面试题17.16.按摩师(4) 题目 一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。 在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。 给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。 注意：本题相对原题稍作改动 示例 1：输入： [1,2,3,1] 输出： 4 解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。 示例 2：输入： [2,7,9,3,1] 输出： 12 解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。 示例 3：输入： [2,1,4,5,3,1,1,3] 输出： 12 解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。 解题思路 No. 思路 时间复杂度 空间复杂度 01 动态规划 O(n) O(1) 02 动态规划+一维数组 O(n) O(n) 03 动态规划+二维数组 O(n) O(n) 04 奇偶法 O(n) O(1) func massage(nums []int) int { if len(nums) == 0 { return 0 } if len(nums) == 1 { return nums[0] } a := nums[0] b := max(a, nums[1]) for i := 2; i b { return a } return b } # 2 func massage(nums []int) int { n := len(nums) if n == 0 { return 0 } if n == 1 { return nums[0] } dp := make([]int, n) dp[0] = nums[0] if nums[0] > nums[1] { dp[1] = nums[0] } else { dp[1] = nums[1] } for i := 2; i b { return a } return b } # 3 func massage(nums []int) int { if len(nums) == 0 { return 0 } if len(nums) == 1 { return nums[0] } n := len(nums) dp := make([][]int, n) for n := range dp { dp[n] = make([]int, 2) } dp[0][0], dp[0][1] = 0, nums[0] for i := 1; i b { return a } return b } # 4 func massage(nums []int) int { var a, b int for i, v := range nums { if i%2 == 0 { a = max(a+v, b) } else { b = max(a, b+v) } } return max(a, b) } func max(a, b int) int { if a > b { return a } return b } 面试题17.19.消失的两个数字(4) 题目 给定一个数组，包含从 1 到 N 所有的整数，但其中缺了两个数字。 你能在 O(N) 时间内只用 O(1) 的空间找到它们吗？ 以任意顺序返回这两个数字均可。 示例 1:输入: [1] 输出: [2,3] 示例 2:输入: [2,3] 输出: [1,4] 提示：nums.length 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(n) 02 数学 O(n) O(1) 03 交换 O(n) O(1) 04 异或 O(n) O(1) func missingTwo(nums []int) []int { res := make([]int, 0) m := make(map[int]bool) for i := 0; i 面试题17.21.直方图的水量(4) 题目 给定一个直方图(也称柱状图)，假设有人从上面源源不断地倒水，最后直方图能存多少水量?直方图的宽度为 1。 上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的直方图， 在这种情况下，可以接 6 个单位的水（蓝色部分表示水）。 感谢 Marcos 贡献此图。 示例:输入: [0,1,0,2,1,0,1,3,2,1,2,1] 输出: 6 解题思路 No. 思路 时间复杂度 空间复杂度 01 暴力法 O(n^2) O(1) 02 数组辅助 O(n) O(n) 03 栈辅助 O(n) O(n) 04 双指针 O(n) O(1) func trap(height []int) int { res := 0 for i := 0; i = 0; j-- { left = max(left, height[j]) } for j := i; j b { return a } return b } func min(a, b int) int { if a > b { return b } return a } # 2 func trap(height []int) int { res := 0 if len(height) == 0 { return 0 } left := make([]int, len(height)) right := make([]int, len(height)) left[0] = height[0] right[len(right)-1] = height[len(height)-1] for i := 1; i = 0; i-- { right[i] = max(height[i], right[i+1]) } for i := 0; i b { return a } return b } func min(a, b int) int { if a > b { return b } return a } # 3 func trap(height []int) int { res := 0 stack := make([]int, 0) for i := 0; i 0 && height[i] > height[stack[len(stack)-1]] { bottom := height[stack[len(stack)-1]] stack = stack[:len(stack)-1] if len(stack) > 0 { prev := stack[len(stack)-1] // 横着的面积=长(min(height[i], height[prev])-bottom)*宽(i-prev-1) h := min(height[i], height[prev]) - bottom w := i - prev - 1 area := h * w res = res + area } } stack = append(stack, i) } return res } func min(a, b int) int { if a > b { return b } return a } # 4 func trap(height []int) int { res := 0 if len(height) == 0 { return 0 } left := 0 right := len(height) - 1 leftMax := 0 // 左边的最大值 rightMax := 0 // 右边的最大值 for left = leftMax { // 递增无法蓄水 leftMax = height[left] } else { res = res + leftMax - height[left] } left++ } else { // 也可以写成这样 // rightMax = max(rightMax, height[right]) // res = res + rightMax - height[right] if height[right] >= rightMax { // 递减无法蓄水 rightMax = height[right] } else { res = res + rightMax - height[right] } right-- } } return res } Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 11:39:59 "},"docs/source/classification/same.html":{"url":"docs/source/classification/same.html","title":"重复问题","keywords":"","body":"leetcode重复/类似的题目 No. 01 530.二叉搜索树的最小绝对差 Easy 783.二叉搜索树节点最小距离 Easy 02 509.斐波那契数 Easy 面试题10- I.斐波那契数列 Easy 03 70.爬楼梯 Easy 面试题10- II.青蛙跳台阶问题 Easy 04 154.寻找旋转排序数组中的最小值II Hard 面试题11.旋转数组的最小数字 Easy 05 105.从前序与中序遍历序列构造二叉树 Medium 面试题07.重建二叉树 Medium 06 79.单词搜索 Medium 面试题12.矩阵中的路径 Medium 07 343.整数拆分 Medium 面试题14- I.剪绳子 Medium面试题14-II.剪绳子 II Medium 08 240.搜索二维矩阵II Medium74.搜索二维矩阵 Medium 面试题04.二维数组中的查找 Easy面试题10.09.排序矩阵查找 Medium 09 191.位1的个数 Easy 面试题15.二进制中1的个数 Easy 10 50.Pow(x,n) Medium 面试题16.数值的整数次方 Medium 11(相似) 203.移除链表元素 Easy237.删除链表中的节点 Easy 面试题18.删除链表的节点 Easy面试题02.03.删除中间节点 Easy 12 905.按奇偶排序数组 Easy 面试题21.调整数组顺序使奇数位于偶数前面 Easy 13 206.反转链表 Easy 面试题24.反转链表 Easy 14 21.合并两个有序链表 Easy 面试题25.合并两个排序的链表 Easy 15 226.翻转二叉树 Easy 面试题27.二叉树的镜像 Easy 16 101.对称二叉树 Easy 面试题28.对称的二叉树 Easy 17 54.螺旋矩阵 Medium 面试题29.顺时针打印矩阵 Easy 18 155.最小栈 Easy 面试题30.包含min函数的栈 Easy面试题03.02.栈的最小值 Easy 19 946.验证栈序列 Medium 面试题31. 栈的压入弹出序列 Medium 20 102.二叉树的层序遍历 Medium 面试题32-II.从上到下打印二叉树II Easy 21(相似) 169.多数元素 Easy 面试题39.数组中出现次数超过一半的数字 Easy面试题17.10.主要元素 Easy 22 53.最大子序和 Easy 面试题42.连续子数组的最大和 Easy面试题16.17.连续数列 Easy 23 233.数字1的个数 Hard 面试题43.1～n整数中1出现的次数 Medium 24(相似) 387.字符串中的第一个唯一字符 Easy 面试题50.第一个只出现一次的字符 Easy 25 160.相交链表 Easy 面试题52.两个链表的第一个公共节点 Easy面试题02.07.链表相交 Easy 26(相似) 264.丑数II Medium 面试题49.丑数 Medium面试题17.09.第k个数 Medium 27(相似) 34.在排序数组中查找元素的第一个和最后一个位置 Medium 面试题53-I.在排序数组中查找数字I Easy 28(相似) 268.缺失数字 Easy 面试题53-II.0～n-1中缺失的数字 Easy面试题17.04.消失的数字 Easy 29 104.二叉树的最大深度 Easy 面试题55-I.二叉树的深度 Easy 30 110.平衡二叉树 Easy 面试题55-II.平衡二叉树 Easy面试题04.04.检查平衡性 Easy 31 151.翻转字符串里的单词 Medium 面试题58-I.翻转单词顺序 Easy 32 239.滑动窗口最大值 Hard 面试题59-I.滑动窗口的最大值 Easy 33 121.买卖股票的最佳时机 Easy 面试题63.股票的最大利润 Medium 34 371.两整数之和 Easy 面试题65.不用加减乘除做加法 Easy面试题17.01.不用加号的加法 Easy 35 8.字符串转换整数 (atoi) Medium 面试题67.把字符串转换成整数 Medium 36 235.二叉搜索树的最近公共祖先 Easy 面试题68-I.二叉搜索树的最近公共祖先 [Easy] 37 236.二叉树的最近公共祖先 Medium 面试题68-II.二叉树的最近公共祖先 [Easy]面试题04.08.首个共同祖先 Medium 38 3.无重复字符的最长子串 Medium 面试题48.最长不含重复字符的子字符串 Medium 39 400.第N个数字 Medium 面试题44.数字序列中某一位的数字 Medium 40 297.二叉树的序列化与反序列化 Hard 面试题37.序列化二叉树 [Hard] 41 426 面试题36.二叉搜索树与双向链表 [Medium] 42 138.复制带随机指针的链表 Medium 面试题35.复杂链表的复制 Medium 43 113.路径总和II Medium 面试题34.二叉树中和为某一值的路径 Medium 44 65.有效数字 Hard 面试题20.表示数值的字符串 Medium 45 10.正则表达式匹配 Hard 面试题19.正则表达式匹配 Hard 46 295.数据流的中位数 Hard 面试题41.数据流中的中位数 Hard 47 476.数字的补数 Easy 1009.十进制整数的反码 Easy 48(相似) 1037.有效的回旋镖 Easy 1232.缀点成线 Easy 49 103.二叉树的锯齿形层次遍历 Medium 面试题32-III.从上到下打印二叉树III Medium 50(相似) 179.最大数 Medium 面试题45.把数组排成最小的数 Medium 51(相似) 面试题01.03.URL化 Easy 面试题05.替换空格 Easy 52 48.旋转图像 Medium 面试题01.07.旋转矩阵 Medium 53 73.矩阵置零 Medium 面试题01.08.零矩阵 Medium 54 796.旋转字符串 Easy 面试题01.09.字符串轮转 Easy 55(相似) 287.寻找重复数 Medium 面试题03.数组中重复的数字 Easy 56 88.合并两个有序数组 Easy 面试题10.01.合并排序的数组 Easy 57 198.打家劫舍 Easy 面试题17.16.按摩师 Easy 58 2.两数相加 Medium 面试题02.05.链表求和 Medium 59 86.分隔链表 Medium 面试题02.04.分割链表 Medium 60 234.回文链表 Easy 面试题02.06.回文链表 Easy 61(相似) 141.环形链表 Easy142.环形链表II Medium 面试题02.08.环路检测 Medium 62 98.验证二叉搜索树 Medium 面试题04.05.合法二叉搜索树 Medium 63 733.图像渲染 Easy 面试题08.10.颜色填充 Easy 64 172.阶乘后的零 Easy 面试题16.05.阶乘尾数 Easy 65(相似) 面试题02.02.返回倒数第k个节点 Easy 面试题22.链表中倒数第k个节点 Easy 66 572.另一个树的子树 Easy 面试题26.树的子结构 Medium面试题04.10.检查子树 Medium 67 437.路径总和III Easy 面试题04.12.求和路径 Medium 68 22.括号生成 Medium 面试题08.09.括号 Medium 69(相似) 46.全排列 Medium 面试题08.07.无重复字符串的排列组合 Medium 70(相似) 47.全排列II Medium 面试题08.08.有重复字符串的排列组合 Medium 71(相似) 81.搜索旋转排序数组II Medium33.搜索旋转排序数组 Medium 面试题10.03.搜索旋转数组 Medium 72(相似) 461.汉明距离 Easy 面试题05.06.整数转换 Easy 73 42.接雨水 Hard 面试题17.21.直方图的水量 Hard 74(相似) 921.使括号有效的最少添加 Medium 1541.平衡括号字符串的最少插入次数 Medium 75(相似) 779.第K个语法符号 Medium 1545.找出第N个二进制字符串中的第K位 Medium 76(相似) 560.和为K的子数组 Medium 1546.和为目标值的最大数目不重叠非空子数组数目 Medium 77(相似) 51.N皇后 Hard52.N皇后II Hard 面试题08.12.八皇后 Hard 78(相似) 210.课程表II Medium 207.课程表 Medium 79 146.LRU缓存机制 Medium 面试题16.25.LRU缓存 Medium 80(相似) 1493.删掉一个元素以后全为1的最长子数组 Medium 面试题05.03.翻转数位 Easy 81(相似) 62.不同路径 Medium63.不同路径II Medium 面试题08.02.迷路的机器人 Medium 82 108.将有序数组转换为二叉搜索树 Easy 面试题04.02.最小高度树 Easy 83 232.用栈实现队列 Easy 面试题03.04.化栈为队 Easy 84(相似) 5.最长回文子串 Medium 647.回文子串 Medium 85 1143.最长公共子序列 Medium 1035.不相交的线 Medium 86 78.子集 Medium 面试题08.04.幂集 Medium 87(相似) 695.岛屿的最大面积 Medium 面试题16.19.水域大小 Medium 88 49.字母异位词分组 Medium 面试题10.02.变位词组 Medium 89(相似) 888.公平的糖果交换 Easy 面试题16.21.交换和 Medium 90 316.去除重复字母 Hard 1081.不同字符的最小子序列 Medium 91(相似) 486.预测赢家 Medium 877.石子游戏 Medium Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 09:46:03 "},"docs/source/classification/class.html":{"url":"docs/source/classification/class.html","title":"系列问题","keywords":"","body":"系列问题集合 1.数组 子数组 Title Tag 难度 完成情况 152.乘积最大子数组 数组、动态规划 Medium 完成 209.长度最小的子数组 数组、双指针、二分查找 Medium 完成 560.和为K的子数组 数组、哈希表 Medium 完成 581.最短无序连续子数组 数组 Easy 完成 643.子数组最大平均数I 数组 Easy 完成 718.最长重复子数组 数组、哈希表、二分查找、动态规划 Medium 完成 974.和可被K整除的子数组 数组、哈希表 Medium 完成 1460.通过翻转子数组使两个数组相等 数组 Easy 完成 1493.删掉一个元素以后全为1的最长子数组 数组 Medium 完成 1508.子数组和排序后的区间和 排序、数组 Medium 完成 1526.形成目标数组的子数组最少增加次数 线段树 Hard 完成 只出现一次的数字 Title Tag 难度 完成情况 136.只出现一次的数字 位运算、哈希表 Easy 完成 137.只出现一次的数字II 位运算 Medium 完成 260.只出现一次的数字III 位运算 Medium 完成 数组交集 Title Tag 难度 完成情况 349.两个数组的交集 排序、哈希表、双指针、二分查找 Easy 完成 350.两个数组的交集II 排序、哈希表、双指针、二分查找 Easy 完成 重复元素 Title Tag 难度 完成情况 217.存在重复元素 数组、哈希表 Easy 完成 219.存在重复元素II 数组、哈希表 Easy 完成 220.存在重复元素III 排序、Ordered Map Medium 完成 442.数组中重复的数据 数组 Medium 完成 448.找到所有数组中消失的数字 数组 Easy 完成 旋转数组 Title Tag 难度 完成情况 81.搜索旋转排序数组II 数组、二分查找 Medium 完成 杨辉三角 Title Tag 难度 完成情况 118.杨辉三角 数组 Easy 完成 119.杨辉三角II 数组 Easy 完成 2.字符串 回文字符串(高频)(动态规划/中心扩展/马拉车算法) Title Tag 难度 完成情况 5.最长回文子串 字符串、动态规划 Medium 完成 9.回文数 数学 Easy 完成 125.验证回文串 双指针、字符串 Easy 完成 131.分割回文串 回溯算法 Medium 完成 214.最短回文串 字符串 Hard 完成 409.最长回文串 哈希表 Easy 完成 516.最长回文子序列 动态规划 Medium 完成 647.回文子串 字符串、动态规划 Medium 完成 680.验证回文字符串Ⅱ 字符串 Easy 完成 1332.删除回文子序列 字符串 Easy 完成 马拉车(manacher)算法 Title Tag 难度 完成情况 5.最长回文子串 字符串、动态规划 Medium 完成 214.最短回文串 字符串 Hard 完成 647.回文子串 字符串、动态规划 Medium 完成 反转字符串 Title Tag 难度 完成情况 344.反转字符串 双指针、字符串 Easy 完成 541.反转字符串II 字符串 Easy 完成 557.反转字符串中的单词III 字符串 Easy 完成 345.反转字符串中的元音字母 双指针、字符串 Easy 完成 子串问题 Title Tag 难度 完成情况 3.无重复字符的最长子串 哈希表、双指针、字符串 Sliding Window Medium 完成 5.最长回文子串 字符串、动态规划 Medium 完成 1513.仅含1的子串数 数学、字符串 Medium 完成 696.计数二进制子串 字符串 Easy 完成 子序问题 Title Tag 难度 完成情况 53.最大子序和 数组、分治算法、动态规划 Easy 完成 300.最长上升子序列 二分查找、动态规划 Medium 完成 392.判断子序列 贪心算法、二分查找、动态规划 Easy 完成 594.最长和谐子序列 哈希表 Easy 完成 1332.删除回文子序列 字符串 Easy 完成 1403.非递增顺序的最小子序列 贪心算法、排序 Easy 完成 3.链表 有序链表删除重复元素 Title Tag 难度 完成情况 83.删除排序链表中的重复元素 链表 Easy 完成 82.删除排序链表中的重复元素II 链表 Medium 完成 4.树 二叉树 路径总和 Title Tag 难度 完成情况 112.路径总和 树、深度优先搜索 Easy 完成 113.路径总和II 树、深度优先搜索 Medium 完成 437.路径总和III 树 Easy 完成 多叉树 动态规划 股票问题 Title Tag 难度 完成情况 121.买卖股票的最佳时机 数组、动态规划 Easy 完成 122.买卖股票的最佳时机II 贪心算法、数组 Easy 完成 123.买卖股票的最佳时机III 数组、动态规划 Hard 完成 188.买卖股票的最佳时机IV 动态规划 Hard 完成 309.最佳买卖股票时机含冷冻期 动态规划 Medium 完成 714.买卖股票的最佳时机含手续费 贪心算法、数组、动态规划 Medium 完成 面试题63.股票的最大利润 动态规划 Medium 完成 901.股票价格跨度 栈 Medium 完成 502.IPO 堆、贪心算法 Hard 完成 打家劫舍问题 Title Tag 难度 完成情况 198.打家劫舍 动态规划 Easy 完成 213.打家劫舍II 动态规划 Medium 完成 337.打家劫舍III 树、深度优先搜索 Medium 完成 零钱兑换 Title Tag 难度 完成情况 322.零钱兑换 动态规划 Medium 完成 518.零钱兑换II Medium 完成 回溯算法 组合问题 Title Tag 难度 完成情况 39.组合总和 数组、回溯算法 Medium 完成 40.组合总和II 数组、回溯算法 Medium 完成 216.组合总和III 数组、回溯算法 Medium 完成 77.组合 回溯算法 Medium 完成 全排列问题 Title Tag 难度 完成情况 46.全排列 回溯算法 Medium 完成 47.全排列II 回溯算法 Medium 完成 子集问题 Title Tag 难度 完成情况 78.子集 位运算、数组、回溯算法 Medium 完成 90.子集II 数组、回溯算法 Medium 完成 八皇后 Title Tag 难度 完成情况 51.N皇后 回溯算法 Hard 完成 52.N皇后II 回溯算法 Hard 完成 其他 Top K问题 Title Tag 难度 完成情况 703.数据流中的第K大元素 堆 Easy 完成 215.数组中的第K个最大元素 堆、分治算法 Medium 完成 347.前K个高频元素 堆、哈希表 Medium 完成 378.有序矩阵中第K小的元素 堆、二分查找 Medium 完成 面试题17.09.第k个数 堆、队列、数学 Medium 完成 面试题17.14.最小K个数 堆、排序、分治算法 Medium 完成 博弈问题 石子游戏 Title Tag 难度 完成情况 877.石子游戏 极小化极大、数学、动态规划 Medium 完成 1140 1406 1510.石子游戏IV 动态规划 Hard 完成 1563.石子游戏V 动态规划 Hard 完成 Nim游戏-极小化极大 Title Tag 难度 完成情况 292.Nim游戏 脑筋急转弯、极小化极大 Easy 完成 486.预测赢家 极小化极大、动态规划 Medium 完成 跳跃游戏 Title Tag 难度 完成情况 45.跳跃游戏II 贪心算法、数组 Hard 完成 55.跳跃游戏 贪心算法、数组 Medium 完成 1306.跳跃游戏III 广度优先搜索、图 Medium 完成 灯泡问题 Title Tag 难度 完成情况 319.灯泡开关 脑筋急转弯、数学 Medium 完成 1375.灯泡开关III 数组 Medium 完成 1529.灯泡开关IV 字符串 Medium 完成 单调栈 Title Tag 难度 完成情况 42.接雨水 栈、数组、双指针 Hard 完成 84.柱状图中最大的矩形 栈、数组 Hard 完成 85.最大矩形 栈、数组、哈希表、动态规划 Hard 完成 316.去除重复字母 栈、贪心算法 Hard 完成 496.下一个更大元素I 栈 Easy 完成 739.每日温度 栈、哈希表 Medium 完成 901.股票价格跨度 栈 Medium 完成 1081.不同字符的最小子序列 字符串 Medium 完成 多源广度优先搜索 Title Tag 难度 完成情况 994.腐烂的橘子 广度优先搜索 Medium 完成 1162.地图分析 广度优先搜索、图 Medium 完成 542.01矩阵 深度优先搜索、广度优先搜索 Medium 完成 拓扑排序 Title Tag 难度 完成情况 207.课程表 深度优先搜索、广度优先搜索、图、拓扑排序 Medium 完成 210.课程表II 深度优先搜索、广度优先搜索、图、拓扑排序 Medium 完成 前缀和问题 Title Tag 难度 完成情况 303.区域和检索-数组不可变 动态规划 Easy 完成 304.二维区域和检索-矩阵不可变 动态规划 Medium 完成 523.连续的子数组和 数学、动态规划 Medium 完成 560.和为K的子数组 数组、哈希表 Medium 完成 974.和可被K整除的子数组 数组、哈希表 Medium 完成 1248.统计「优美子数组」 双指针 Medium 完成 二分查找-最大化最小值、最小化最大值 Title Tag 难度 完成情况 410.分割数组的最大值 二分查找、动态规划 Hard 完成 875 1011 1482 1552.两球之间的磁力 数组、二分查找 Medium 完成 LCP12.小张刷题计划 Medium 完成 并查集 Title Tag 难度 完成情况 128.最长连续序列 并查集、数组 Hard 完成 130.被围绕的区域 深度优先搜索、广度优先搜索、并查集 Medium 完成 200.岛屿数量 深度优先搜索、广度优先搜索、并查集 Medium 完成 1568.使陆地分离的最少天数 贪心算法 Medium 完成 滑动窗口 Title Tag 难度 完成情况 3.无重复字符的最长子串 哈希表、双指针、字符串Sliding Window Medium 完成 30.串联所有单词的子串 哈希表、双指针、字符串 Hard 完成 76.最小覆盖子串 哈希表、双指针、字符串、Sliding Window Hard 完成 159 209.长度最小的子数组 数组、双指针、二分查找 Medium 完成 239.滑动窗口最大值 堆、Sliding Window Hard 完成 340 438.找到字符串中所有字母异位词 哈希表 Medium 完成 567.字符串的排列 双指针、Sliding Window Medium 完成 632 727 Trie树 Title Tag 难度 完成情况 208.实现 Trie (前缀树) 设计、字典树 Medium 完成 211.添加与搜索单词-数据结构设计 设计、字典树、回溯算法 Medium 完成 背包问题-完全背包 Title Tag 难度 完成情况 518.零钱兑换II Medium 完成 Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 09:46:03 "},"docs/source/classification/offer.html":{"url":"docs/source/classification/offer.html","title":"书籍-剑指offer-完成","keywords":"","body":"剑指offer 参考资料 本系列共68题，leetcode上共75题， 其中编号36(426)、37(297)、74(235)、75(236)提交没有Go语言，由括号后的题目是leetcode上相同的题目 leetcode专栏链接 https://leetcode-cn.com/problemset/lcof/ http://zhedahht.blog.163.com/ 《剑指Offer》第二版源代码 C++ https://github.com/zhedahht/CodingInterviewChinese2 No. Title Tag 难度 完成情况 第二章：面试需要的基础知识 2.2 编程语言 面试题1 赋值运算符函数 - - - 面试题2 实现Singleton模式 - - - 2.3 数据结构 0001 面试题3 面试题03.数组中重复的数字 数组、哈希表 Easy 完成 0002 面试题4 面试题04.二维数组中的查找 数组、双指针 Easy 完成 0003 面试题5 面试题05.替换空格 Easy 完成 0004 面试题6 面试题06.从尾到头打印链表 Easy 完成 0005 面试题7 面试题07.重建二叉树 树、递归 Medium 完成 面试题8 二叉树的下一个节点 - - - 0006 面试题9 面试题09.用两个栈实现队列 栈、设计 Easy 完成 2.4 算法和数据操作 0007 面试题10 面试题10- I.斐波那契数列 递归 Easy 完成 0008 面试题10- II.青蛙跳台阶问题 递归 Easy 完成 0009 面试题11 面试题11.旋转数组的最小数字 二分查找 Easy 完成 0010 面试题12 面试题12.矩阵中的路径 动态规划 Medium 完成 0011 面试题13 面试题13.机器人的运动范围 Medium 完成 0012 面试题14 面试题14- I.剪绳子 数学、动态规划 Medium 完成 0013 面试题14-II.剪绳子 II 数学、动态规划 Medium 完成 0014 面试题15 面试题15.二进制中1的个数 位运算 Easy 完成 第三章：高质量的代码 3.3 代码的完整性 0015 面试题16 面试题16.数值的整数次方 递归 Medium 完成 0016 面试题17 面试题17.打印从1到最大的n位数 数学 Easy 完成 0017 面试题18 面试题18.删除链表的节点 链表 Easy 完成 0018 面试题19 面试题19.正则表达式匹配 动态规划 Hard 完成 0019 面试题20 面试题20.表示数值的字符串 数学 Medium 完成 0020 面试题21 面试题21.调整数组顺序使奇数位于偶数前面 Easy 完成 3.4 代码的鲁棒性 0021 面试题22 面试题22.链表中倒数第k个节点 链表、双指针 Easy 完成 面试题23 链表中环的入口节点 - - - 0022 面试题24 面试题24.反转链表 链表 Easy 完成 0023 面试题25 面试题25.合并两个排序的链表 分治算法 Easy 完成 0024 面试题26 面试题26.树的子结构 树 Medium 完成 第四章：解决面试题的思路 4.2 画图让抽象问题形象化 0025 面试题27 面试题27.二叉树的镜像 树 Easy 完成 0026 面试题28 面试题28.对称的二叉树 树 Easy 完成 0027 面试题29 面试题29.顺时针打印矩阵 数组 Easy 完成 4.3 举例让抽象问题具体化 0028 面试题30 面试题30.包含min函数的栈 栈、设计 Easy 完成 0029 面试题31 面试题31. 栈的压入弹出序列 Medium 完成 0030 面试题32 面试题32-I.从上到下打印二叉树 树、广度优先搜索 Medium 完成 0031 面试题32-II.从上到下打印二叉树II 树、广度优先搜索 Easy 完成 0032 面试题32-III.从上到下打印二叉树III 树、广度优先搜索 Medium 完成 0033 面试题33 面试题33.二叉搜索树的后序遍历序列 Medium 完成 0034 面试题34 面试题34.二叉树中和为某一值的路径 树、深度优先搜索 Medium 完成 4.4 分解让复杂问题简单化 0035 面试题35 面试题35.复杂链表的复制 链表 Medium 完成 0036 面试题36 面试题36.二叉搜索树与双向链表 分治算法 Medium [提交没有Go语言]426替代 0037 面试题37 面试题37.序列化二叉树 树、设计 Hard [提交没有Go语言]297替代 0038 面试题38 面试题38.字符串的排列 回溯算法 Medium 完成 第五章：优化时间和空间效率 5.2 时间效率 0039 面试题39 面试题39.数组中出现次数超过一半的数字 位运算、分治算法 Easy 完成 0040 面试题40 面试题40.最小的k个数 堆、分治算法 Easy 完成 0041 面试题41 面试题41.数据流中的中位数 堆、设计 Hard 完成 0042 面试题42 面试题42.连续子数组的最大和 分治算法、动态规划 Easy 完成 0043 面试题43 面试题43.1～n整数中1出现的次数 数学 Medium 完成 0044 面试题44 面试题44.数字序列中某一位的数字 数学 Medium 完成 0045 面试题45 面试题45.把数组排成最小的数 排序 Medium 完成 0046 面试题46 面试题46.把数字翻译成字符串 Medium 完成 0047 面试题47 面试题47.礼物的最大价值 动态规划 Medium 完成 0048 面试题48 面试题48.最长不含重复字符的子字符串 哈希表、双指针、Sliding Window Medium 完成 5.3 时间效率与空间效率的平衡 0049 面试题49 面试题49.丑数 数学 Medium 完成 0050 面试题50 面试题50.第一个只出现一次的字符 哈希表 Easy 完成 0051 面试题51 面试题51.数组中的逆序对 Hard 完成 0052 面试题52 面试题52.两个链表的第一个公共节点 链表 Easy 完成 第六章：面试中的各项能力 6.3 知识迁移能力 0053 面试题53 面试题53-I.在排序数组中查找数字I 数组、二分查找 Easy 完成 0054 面试题53-II.0～n-1中缺失的数字 数组、二分查找 Easy 完成 0055 面试题54 面试题54.二叉搜索树的第k大节点 树 Easy 完成 0056 面试题55 面试题55-I.二叉树的深度 树、深度优先搜索 Easy 完成 0057 面试题55-II.平衡二叉树 树、深度优先搜索 Easy 完成 0058 面试题56 面试题56-I.数组中数字出现的次数 Medium 完成 0059 面试题56-II.数组中数字出现的次数II Medium 完成 0060 面试题57 面试题57.和为s的两个数字 Easy 完成 0061 面试题57-II.和为s的连续正数序列 Easy 完成 0062 面试题58 面试题58-I.翻转单词顺序 字符串 Easy 完成 0063 面试题58-II.左旋转字符串 字符串 Easy 完成 0064 面试题59 面试题59-I.滑动窗口的最大值 栈、Sliding Window Easy 完成 0065 面试题59-II.队列的最大值 栈、Sliding Window Medium 完成 6.4 抽象建模能力 0066 面试题60 面试题60.n个骰子的点数 Easy 完成 0067 面试题61 面试题61.扑克牌中的顺子 Easy 完成 0068 面试题62 面试题62.圆圈中最后剩下的数字 Easy 完成 0069 面试题63 面试题63.股票的最大利润 动态规划 Medium 完成 6.5 发散思维能力 0070 面试题64 面试题64.求1+2+…+n Medium 完成 0071 面试题65 面试题65.不用加减乘除做加法 Easy 完成 0072 面试题66 面试题66.构建乘积数组 Easy 完成 第七章：两个面试案例 0073 面试题67 面试题67.把字符串转换成整数 数学、字符串 Medium 完成 0074 面试题68 面试题68-I.二叉搜索树的最近公共祖先 树 Easy [提交没有Go语言]235替代 0075 面试题68-II.二叉树的最近公共祖先 树 Easy [提交没有Go语言]236替代 Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 09:46:03 "},"docs/source/classification/lcci.html":{"url":"docs/source/classification/lcci.html","title":"书籍-程序员面试金典","keywords":"","body":"程序员面试金典 参考资料 本系统共109题 leetcode专栏链接 https://leetcode-cn.com/problemset/lcci/ https://github.com/careercup/ctci No. Title Tag 难度 完成情况 第1期 0001 面试题01.01.判定字符是否唯一 数组 Easy 完成 0002 面试题01.02.判定是否互为字符重排 数组、字符串 Easy 完成 0003 面试题01.03.URL化 字符串 Easy 完成 0004 面试题01.04.回文排列 哈希表、字符串 Easy 完成 0005 面试题01.05.一次编辑 字符串、动态规划 Medium 完成 0006 面试题01.06.字符串压缩 字符串 Easy 完成 0007 面试题01.07.旋转矩阵 数组 Medium 完成 0008 面试题01.08.零矩阵 数组 Medium 完成 0009 面试题01.09.字符串轮转 字符串 Easy 完成 0010 面试题02.01.移除重复节点 链表 Easy 完成 第2期 0011 面试题02.02.返回倒数第k个节点 链表、双指针 Easy 完成 0012 面试题02.03.删除中间节点 链表 Easy 完成 0013 面试题02.04.分割链表 链表、双指针 Medium 完成 0014 面试题02.05.链表求和 链表、数学 Medium 完成 0015 面试题02.06.回文链表 链表 Easy 完成 0016 面试题02.07.链表相交 链表 Easy 完成 0017 面试题02.08.环路检测 链表 Medium 完成 0018 面试题03.01.三合一 设计 Easy 完成 0019 面试题03.02.栈的最小值 栈 Easy 完成 0020 面试题03.03.堆盘子 设计 Medium 完成 第3期 0021 面试题03.04.化栈为队 栈 Easy 完成 0022 面试题03.05.栈排序 设计 Medium 0023 面试题03.06.动物收容所 设计 Easy 完成 0024 面试题04.01.节点间通路 图 Medium 完成 0025 面试题04.02.最小高度树 树、深度优先搜索 Easy 完成 0026 面试题04.03.特定深度节点链表 树、广度优先搜索 Medium 0027 面试题04.04.检查平衡性 树、深度优先搜索 Easy 完成 0028 面试题04.05.合法二叉搜索树 树、深度优先搜索 Medium 完成 0029 0030 面试题04.08.首个共同祖先 树 Medium 完成 第4期 0031 09 0032 面试题04.10.检查子树 树 Medium 完成 0033 面试题04.12.求和路径 树、深度优先搜索 Medium 完成 0034 面试题05.01.插入 位运算 Easy 完成 0035 面试题05.02.二进制数转字符串 字符串 Medium 完成 0036 面试题05.03.翻转数位 位运算 Easy 完成 0037 04 0038 面试题05.06.整数转换 位运算 Easy 完成 0039 面试题05.07.配对交换 位运算 Easy 完成 0040 08 第5期 0041 面试题08.01.三步问题 动态规划 Easy 完成 0042 面试题08.02.迷路的机器人 动态规划 Medium 完成 0043 面试题08.03.魔术索引 数组、二分查找 Easy 完成 0044 面试题08.04.幂集 位运算、数组、回溯算法 Medium 完成 0045 面试题08.05.递归乘法 递归 Medium 完成 0046 面试题08.06.汉诺塔问题 递归 Easy 完成 0047 面试题08.07.无重复字符串的排列组合 回溯算法 Medium 完成 0048 面试题08.08.有重复字符串的排列组合 回溯算法 Medium 完成 0049 面试题08.09.括号 字符串、回溯算法 Medium 完成 0050 面试题08.10.颜色填充 深度优先搜索 Easy 完成 第6期 0051 面试题08.11.硬币 动态规划 Medium 0052 面试题08.12.八皇后 回溯算法 Hard 完成 0053 13 0054 14 0055 面试题10.01.合并排序的数组 数组、双指针 Easy 完成 0056 面试题10.02.变位词组 哈希表、字符串 Medium 完成 0057 面试题10.03.搜索旋转数组 数组、二分查找 Medium 完成 0058 面试题10.05.稀疏数组搜索 二分查找 Easy 完成 0059 面试题10.09.排序矩阵查找 双指针、二分查找、分治算法 Medium 完成 0060 10 第7期 0061 11 0062 面试题16.01.交换数字 位运算、数学 Medium 完成 0063 面试题16.02.单词频率 设计、哈希表 Medium 完成 0064 03 0065 04 0066 面试题16.05.阶乘尾数 数学 Easy 完成 0067 面试题16.06.最小差 数组、双指针 Medium 完成 0068 面试题16.07.最大数值 位运算 Easy 完成 0069 08 0070 09 第8期 0071 面试题16.10.生存人数 数组 Medium 完成 0072 面试题16.11.跳水板 递归、记忆化 Easy 完成 0073 13 0074 14 0075 面试题16.15.珠玑妙算 数组 Easy 完成 0076 面试题16.16.部分排序 排序、数字 Medium 完成 0077 面试题16.17.连续数列 数组、分治算法、动态规划 Easy 完成 0078 18 0079 面试题16.19.水域大小 深度优先搜索、广度优先搜索 Medium 完成 0080 20 第9期 0081 面试题16.21.交换和 排序、数组 Medium 完成 0082 22 0083 24 0084 面试题16.25.LRU缓存 设计 Medium 完成 0085 26 0086 面试题17.01.不用加号的加法 位运算 Easy 完成 0087 面试题17.04.消失的数字 位运算、数组、数字 Easy 完成 0088 05 0089 06 0090 07 第10期 0091 08 0092 面试题17.09.第k个数 堆、队列、数学 Medium 完成 0093 面试题17.10.主要元素 位运算、数组、分治算法 Easy 完成 0094 面试题17.11.单词距离 双指针、字符串 Medium 完成 0095 面试题17.12.BiNode 树、二叉搜索树、递归 Easy 完成 0096 13 0097 面试题17.14.最小K个数 堆、排序、分治算法 Medium 完成 0098 15 0099 面试题17.16.按摩师 动态规划 Easy 完成 0100 17 第11期 0101 18 0102 面试题17.19.消失的两个数字 数组、数学 Hard 完成 0103 20 0104 面试题17.21.直方图的水量 栈、数组、双指针 Hard 完成 0105 0106 0107 0108 0109 Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 09:46:03 "},"docs/source/classification/lcp.html":{"url":"docs/source/classification/lcp.html","title":"lcp","keywords":"","body":"LCP No. Title Tag 难度 完成情况 0001 LCP01.猜数字 Easy 完成 0002 LCP02.分式化简 Easy 完成 0003 LCP03.机器人大冒险 Medium 完成 0004 0005 0006 LCP06.拿硬币 Easy 完成 0007 LCP07.传递信息 Easy 完成 0008 LCP08.剧情触发时间 Medium 完成 0009 0010 0011 LCP11.期望个数统计 Easy 完成 0012 LCP12.小张刷题计划 Medium 完成 Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 09:46:03 "},"docs/source/classification/leetcode_contest.html":{"url":"docs/source/classification/leetcode_contest.html","title":"leetcode-竞赛","keywords":"","body":"周赛 No. 第1题 第2题 第3题 第4题 第196场周赛 1502.判断能否形成等差数列 Easy 第195场周赛 第194场周赛 Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 09:46:03 "},"docs/source/classification/easy.html":{"url":"docs/source/classification/easy.html","title":"初级算法(49)-完成","keywords":"","body":"初级算法(49) 初级算法 - 帮助入门 本系列共49题 原文分类链接 https://leetcode-cn.com/leetbook/detail/top-interview-questions-easy/ 1.数组(11) Title Tag 难度 完成情况 26.删除排序数组中的重复项 数组、双指针 Easy 完成 122.买卖股票的最佳时机 II 贪心算法、数组 Easy 完成 189.旋转数组 数组 Easy 完成 217.存在重复元素 数组、哈希表 Easy 完成 136.只出现一次的数字 位运算、哈希表 Easy 完成 350.两个数组的交集 II 排序、哈希表、双指针、二分查找 Easy 完成 66.加一 数组 Easy 完成 283.移动零 数组、双指针 Easy 完成 1.两数之和 数组、哈希表 Easy 完成 36.有效的数独 哈希表 Medium 完成 48.旋转图像 数组 Medium 完成 2.字符串(9) Title Tag 难度 完成情况 344.反转字符串 双指针、字符串 Easy 完成 7.整数反转 数学 Easy 完成 387.字符串中的第一个唯一字符 哈希表、字符串 Easy 完成 242.有效的字母异位词 排序、哈希 Easy 完成 验证回文字符串125.验证回文串 双指针、字符串 Easy 完成 8.字符串转换整数 (atoi) 数字、字符串 Medium 完成 28.实现strStr() 双指针、字符串 Easy 完成 外观数列 38.报数 字符串 Easy 完成 14.最长公共前缀 字符串 Easy 完成 3.链表(6) Title Tag 难度 完成情况 237.删除链表中的节点 链表 Easy 完成 19.删除链表的倒数第N个节点 链表、双指针 Medium 完成 206.反转链表 链表 Easy 完成 21.合并两个有序链表 链表 Easy 完成 234.回文链表 链表、双指针 Easy 完成 141.环形链表 链表、双指针 Easy 完成 4.树(5) Title Tag 难度 完成情况 104.二叉树的最大深度 树、深度优先搜索 Easy 完成 98.验证二叉搜索树 树、深度优先搜索 Medium 完成 101.对称二叉树 树、深度优先搜索、广度优先搜索 Easy 完成 102.二叉树的层序遍历 树、广度优先搜索 Medium 完成 108.将有序数组转换为二叉搜索树 树、深度优先搜索 Easy 完成 5.排序和搜索(2) Title Tag 难度 完成情况 88.合并两个有序数组 数组、双指针 Easy 完成 278.第一个错误的版本 二分查找 Easy 完成 6.动态规划(4) Title Tag 难度 完成情况 70.爬楼梯 动态规划 Easy 完成 121.买卖股票的最佳时机 数组、动态规划 Easy 完成 53.最大子序和 数组、分治算法、动态规划 Easy 完成 198.打家劫舍 动态规划 Easy 完成 7.设计问题(2) Title Tag 难度 完成情况 Shuffle an Array 384.打乱数组 Medium 完成 155.最小栈 栈、设计 Easy 完成 8.数学(4) Title Tag 难度 完成情况 412.Fizz Buzz Easy 完成 204.计数质数 哈希表、数学 Easy 完成 326.3的幂 数学 Easy 完成 13.罗马数字转整数 数学、字符串 Easy 完成 9.其他(6) Title Tag 难度 完成情况 191.位1的个数 位运算 Easy 完成 461.汉明距离 位运算 Easy 完成 190.颠倒二进制位 位运算 Easy 完成 帕斯卡三角形 118.杨辉三角 数组 Easy 完成 20.有效的括号 栈、字符串 Easy 完成 268.缺失数字 位运算、数组、数学 Easy 完成 Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 09:46:03 "},"docs/source/classification/medium.html":{"url":"docs/source/classification/medium.html","title":"中级算法(45)-完成","keywords":"","body":"中级算法(45) 中级算法 - 巩固训练 本系列共45题 原文分类链接 https://leetcode-cn.com/leetbook/detail/top-interview-questions-medium/ 1.数组和字符串(6) Title Tag 难度 完成情况 15.三数之和 数组、双指针 Medium 完成 73.矩阵置零 数组 Medium 完成 49.字母异位词分组 哈希表、字符串 Medium 完成 3.无重复字符的最长子串 哈希表、双指针、字符串Sliding Window Medium 完成 5.最长回文子串 字符串、动态规划 Medium 完成 334.递增的三元子序列 Medium 完成 2.链表(3) Title Tag 难度 完成情况 2.两数相加 链表、数学 Medium 完成 328.奇偶链表 链表 Medium 完成 160.相交链表 链表 Easy 完成 3.树和图(6) Title Tag 难度 完成情况 中序遍历二叉树 94.二叉树的中序遍历 栈、树、哈希表 Medium 完成 103.二叉树的锯齿形层次遍历 栈、树、广度优先搜索 Medium 完成 105.从前序与中序遍历序列构造二叉树 树、深度优先搜索、数组 Medium 完成 116.填充每个节点的下一个右侧节点指针 树、深度优先搜索 Medium 完成 215.数组中的第K个最大元素 堆、分治算法 Medium 完成 200.岛屿数量 深度优先搜索、广度优先搜索、并查集 Medium 完成 4.回溯算法(5) Title Tag 难度 完成情况 17.电话号码的字母组合 字符串、回溯算法 Medium 完成 22.括号生成 字符串、回溯算法 Medium 完成 46.全排列 回溯算法 Medium 完成 78.子集 位运算、数组、回溯算法 Medium 完成 79.单词搜索 数组、回溯算法 Medium 完成 5.排序和搜索(8) Title Tag 难度 完成情况 75.颜色分类 排序、数组、双指针 Medium 完成 347.前K个高频元素 堆、哈希表 Medium 完成 215.数组中的第K个最大元素 堆、分治算法 Medium 完成 162.寻找峰值 数组、二分查找 Medium 完成 34.在排序数组中查找元素的第一个和最后一个位置 数组、二分查找 Medium 完成 56.合并区间 排序、数组 Medium 完成 33.搜索旋转排序数组 数组、二分查找 Medium 完成 240.搜索二维矩阵II 二分查找、分治算法 Medium 完成 6.动态规划(4) Title Tag 难度 完成情况 55.跳跃游戏 贪心算法、数组 Medium 完成 62.不同路径 数组、动态规划 Medium 完成 322.零钱兑换 动态规划 Medium 完成 300.最长上升子序列 二分查找、动态规划 Medium 完成 7.设计问题(2) Title Tag 难度 完成情况 297.二叉树的序列化与反序列化 树、设计 Hard 完成 380.常数时间插入、删除和获取随机元素 设计、数组、哈希表 Medium 完成 8.数学(7) Title Tag 难度 完成情况 202.快乐数 哈希表、数学 Easy 完成 172.阶乘后的零 数学 Easy 完成 171.Excel表列序号 数学 Easy 完成 50.Pow(x,n) 数学、二分查找 Medium 完成 69.x 的平方根 数学，二分查找 Easy 完成 29.两数相除 数学、二分查找 Medium 完成 166.分数到小数 哈希表、数学 Medium 完成 9.其他(4) Title Tag 难度 完成情况 371.两整数之和 位运算 Easy 完成 150.逆波兰表达式求值 栈 Medium 完成 169.多数元素 位运算、数组、分治算法 Easy 完成 621.任务调度器 贪心算法、队列、数组 Medium 完成 Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 09:46:03 "},"docs/source/classification/hard.html":{"url":"docs/source/classification/hard.html","title":"高级算法","keywords":"","body":"高级算法(47) 高级算法 - 提升进阶 本系列共47题 原文分类链接 https://leetcode-cn.com/leetbook/detail/top-interview-questions-hard/ 1.数组和字符串(11) Title Tag 难度 完成情况 238.除自身以外数组的乘积 数组 Medium 完成 54.螺旋矩阵 数组 Medium 完成 四数相加 II 11.盛最多水的容器 数组、双指针 Medium 完成 289.生命游戏 数组 Medium 完成 41.缺失的第一个正数 数组 Hard 完成 128.最长连续序列 并查集、数组 Hard 完成 287.寻找重复数 数组、双指针、二分查找 Medium 完成 基本计算器 II 239.滑动窗口最大值 堆、Sliding Window Hard 完成 76.最小覆盖子串 哈希表、双指针、字符串、Sliding Window Hard 完成 2.链表(3) Title Tag 难度 完成情况 23.合并K个排序链表 堆、链表、分治算法 Hard 完成 148.排序链表 排序、链表 Medium 完成 138.复制带随机指针的链表 哈希表、链表 Medium 完成 3.树和图(9) Title Tag 难度 完成情况 127.单词接龙 广度优先搜索 Medium 完成 130.被围绕的区域 深度优先搜索、广度优先搜索、并查集 Medium 完成 236.二叉树的最近公共祖先 树 Medium 完成 124.二叉树中的最大路径和 树、深度优先搜索 Hard 完成 Friend Circles 207.课程表 深度优先搜索、广度优先搜索、图、拓扑排序 Medium 完成 210.课程表II 深度优先搜索、广度优先搜索、图、拓扑排序 Medium 完成 矩阵中的最长递增路径 计算右侧小于当前元素的个数 4.回溯算法(5) Title Tag 难度 完成情况 131.分割回文串 回溯算法 Medium 完成 单词搜索 II 301.删除无效的括号 深度优先搜索、广度优先搜索 Hard 完成 44.通配符匹配 贪心算法、字符串、动态规划、回溯算法 Hard 完成 10.正则表达式匹配 字符串、动态规划、回溯算法 Hard 完成 5.排序和搜索(3) Title Tag 难度 完成情况 摆动排序 II 378.有序矩阵中第K小的元素 堆、二分查找 Medium 完成 4.寻找两个正序数组的中位数 数组、二分查找、分治算法 Hard 完成 6.动态规划(6) Title Tag 难度 完成情况 152.乘积最大子数组 数组、动态规划 Medium 完成 309.最佳买卖股票时机含冷冻期 动态规划 Medium 完成 279.完全平方数 广度优先搜索、数学、动态规划 Medium 完成 139.单词拆分 动态规划 Medium 完成 单词拆分 II 312.戳气球 分治算法、动态规划 Hard 完成 7.设计问题(4) Title Tag 难度 完成情况 146.LRU缓存机制 设计 Medium 完成 208.实现 Trie (前缀树) 设计、字典树 Medium 完成 295.数据流的中位数 堆、设计 Hard 完成 8.数学(2) Title Tag 难度 完成情况 179.最大数 排序 Medium 完成 9.其他(4) Title Tag 难度 完成情况 406.根据身高重建队列 贪心算法 Medium 完成 42.接雨水 栈、数组、双指针 Hard 完成 天际线问题 84.柱状图中最大的矩形 栈、数组 Hard 完成 Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 09:46:03 "},"docs/source/classification/hot-100.html":{"url":"docs/source/classification/hot-100.html","title":"热题100(100)-完成","keywords":"","body":"热题Hot100 本系列共100题(253、399待做) 原文分类链接 https://leetcode-cn.com/problemset/leetcode-hot-100/ No. Title Tag 难度 完成情况 第1期 0001 1.两数之和 数组、哈希表 Easy 完成 0002 2.两数相加 链表、数学 Medium 完成 0003 3.无重复字符的最长子串 哈希表、双指针、字符串Sliding Window Medium 完成 0004 4.寻找两个正序数组的中位数 数组、二分查找、分治算法 Hard 完成 0005 5.最长回文子串 字符串、动态规划 Medium 完成 0006 10.正则表达式匹配 字符串、动态规划、回溯算法 Hard 完成 0007 11.盛最多水的容器 数组、双指针 Medium 完成 0008 15.三数之和 数组、双指针 Medium 完成 0009 17.电话号码的字母组合 字符串、回溯算法 Medium 完成 0010 19.删除链表的倒数第N个节点 链表、双指针 Medium 完成 第2期 0011 20.有效的括号 栈、字符串 Easy 完成 0012 21.合并两个有序链表 链表 Easy 完成 0013 22.括号生成 字符串、回溯算法 Medium 完成 0014 23.合并K个排序链表 堆、链表、分治算法 Hard 完成 0015 31.下一个排列 数组 Medium 完成 0016 32.最长有效括号 字符串、动态规划 Hard 完成 0017 33.搜索旋转排序数组 数组、二分查找 Medium 完成 0018 34.在排序数组中查找元素的第一个和最后一个位置 数组、二分查找 Medium 完成 0019 39.组合总和 数组、回溯算法 Medium 完成 0020 42.接雨水 栈、数组、双指针 Hard 完成 第3期 0021 46.全排列 回溯算法 Medium 完成 0022 48.旋转图像 数组 Medium 完成 0023 49.字母异位词分组 哈希表、字符串 Medium 完成 0024 53.最大子序和 数组、分治算法、动态规划 Easy 完成 0025 55.跳跃游戏 贪心算法、数组 Medium 完成 0026 56.合并区间 排序、数组 Medium 完成 0027 62.不同路径 数组、动态规划 Medium 完成 0028 64.最小路径和 数组、动态规划 Medium 完成 0029 70.爬楼梯 动态规划 Easy 完成 0030 72.编辑距离 字符串、动态规划 Hard 完成 第4期 0031 75.颜色分类 排序、数组、双指针 Medium 完成 0032 76.最小覆盖子串 哈希表、双指针、字符串、Sliding Window Hard 完成 0033 78.子集 位运算、数组、回溯算法 Medium 完成 0034 79.单词搜索 数组、回溯算法 Medium 完成 0035 84.柱状图中最大的矩形 栈、数组 Hard 完成 0036 85.最大矩形 栈、数组、哈希表、动态规划 Hard 完成 0037 94.二叉树的中序遍历 栈、树、哈希表 Medium 完成 0038 96.不同的二叉搜索树 树、动态规划 Medium 完成 0039 98.验证二叉搜索树 树、深度优先搜索 Medium 完成 0040 101.对称二叉树 树、深度优先搜索、广度优先搜索 Easy 完成 第5期 0041 102.二叉树的层序遍历 树、广度优先搜索 Medium 完成 0042 104.二叉树的最大深度 树、深度优先搜索 Easy 完成 0043 105.从前序与中序遍历序列构造二叉树 树、深度优先搜索、数组 Medium 完成 0044 114.二叉树展开为链表 树、深度优先搜索 Medium 完成 0045 121.买卖股票的最佳时机 数组、动态规划 Easy 完成 0046 124.二叉树中的最大路径和 树、深度优先搜索 Hard 完成 0047 128.最长连续序列 并查集、数组 Hard 完成 0048 136.只出现一次的数字 位运算、哈希表 Easy 完成 0049 139.单词拆分 动态规划 Medium 完成 0050 141.环形链表 链表、双指针 Easy 完成 第6期 0051 142.环形链表II 链表、双指针 Medium 完成 0052 146.LRU缓存机制 设计 Medium 完成 0053 148.排序链表 排序、链表 Medium 完成 0054 152.乘积最大子数组 数组、动态规划 Medium 完成 0055 155.最小栈 栈、设计 Easy 完成 0056 160.相交链表 链表 Easy 完成 0057 169.多数元素 位运算、数组、分治算法 Easy 完成 0058 198.打家劫舍 动态规划 Easy 完成 0059 200.岛屿数量 深度优先搜索、广度优先搜索、并查集 Medium 完成 0060 206.反转链表 链表 Easy 完成 第7期 0061 207.课程表 深度优先搜索、广度优先搜索、图、拓扑排序 Medium 完成 0062 208.实现 Trie (前缀树) 设计、字典树 Medium 完成 0063 215.数组中的第K个最大元素 堆、分治算法 Medium 完成 0064 221.最大正方形 动态规划 Medium 完成 0065 226.翻转二叉树 树 Easy 完成 0066 234.回文链表 链表、双指针 Easy 完成 0067 236.二叉树的最近公共祖先 树 Medium 完成 0068 238.除自身以外数组的乘积 数组 Medium 完成 0069 239.滑动窗口最大值 堆、Sliding Window Hard 完成 0070 240.搜索二维矩阵II 二分查找、分治算法 Medium 完成 第8期 0071 253 0072 279.完全平方数 广度优先搜索、数学、动态规划 Medium 完成 0073 283.移动零 数组、双指针 Easy 完成 0074 287.寻找重复数 数组、双指针、二分查找 Medium 完成 0075 297.二叉树的序列化与反序列化 树、设计 Hard 完成 0076 300.最长上升子序列 二分查找、动态规划 Medium 完成 0077 301.删除无效的括号 深度优先搜索、广度优先搜索 Hard 完成 0078 309.最佳买卖股票时机含冷冻期 动态规划 Medium 完成 0079 312.戳气球 分治算法、动态规划 Hard 完成 0080 322.零钱兑换 动态规划 Medium 完成 第9期 0081 337.打家劫舍III 树、深度优先搜索 Medium 完成 0082 338.比特位计数 位运算、动态规划 Medium 完成 0083 347.前K个高频元素 堆、哈希表 Medium 完成 0084 394.字符串解码 栈、深度优先搜索 Medium 完成 0085 399 0086 406.根据身高重建队列 贪心算法 Medium 完成 0087 416.分割等和子集 动态规划 Medium 完成 0088 437.路径总和III 树 Easy 完成 0089 438.找到字符串中所有字母异位词 哈希表 Medium 完成 0090 448.找到所有数组中消失的数字 数组 Easy 完成 第10期 0091 461.汉明距离 位运算 Easy 完成 0092 494.目标和 深度优先搜索、动态规划 Medium 完成 0093 538.把二叉搜索树转换为累加树 树 Easy 完成 0094 543.二叉树的直径 树 Easy 完成 0095 560.和为K的子数组 数组、哈希表 Medium 完成 0096 581.最短无序连续子数组 数组 Easy 完成 0097 617.合并二叉树 树 Easy 完成 0098 621.任务调度器 贪心算法、队列、数组 Medium 完成 0099 647.回文子串 字符串、动态规划 Medium 完成 0100 739.每日温度 栈、哈希表 Medium 完成 Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 09:46:03 "},"docs/source/classification/50.html":{"url":"docs/source/classification/50.html","title":"腾讯精选练习50题(50)-完成","keywords":"","body":"腾讯精选练习 50 题 本系列共50题 原文分类链接：https://leetcode-cn.com/problemset/50/ No. Title Tag 难度 完成情况 第1期 0001 2.两数相加 链表、数学 Medium 完成 0002 4.寻找两个正序数组的中位数 数组、二分查找、分治算法 Hard 完成 0003 5.最长回文子串 字符串、动态规划 Medium 完成 0004 7.整数反转 数学 Easy 完成 0005 8.字符串转换整数(atoi) 数字、字符串 Medium 完成 0006 9.回文数 数学 Easy 完成 0007 11.盛最多水的容器 数组、双指针 Medium 完成 0008 14.最长公共前缀 字符串 Easy 完成 0009 15.三数之和 数组、双指针 Medium 完成 0010 16.最接近的三数之和 数组、双指针 Medium 完成 第2期 0011 20.有效的括号 栈、字符串 Easy 完成 0012 21.合并两个有序链表 链表 Easy 完成 0013 23.合并K个排序链表 堆、链表、分治算法 Hard 完成 0014 26.删除排序数组中的重复项 数组、双指针 Easy 完成 0015 33.搜索旋转排序数组 数组、二分查找 Medium 完成 0016 43.字符串相乘 数学、字符串 Medium 完成 0017 46.全排列 回溯算法 Medium 完成 0018 53.最大子序和 数组、分治算法、动态规划 Easy 完成 0019 54.螺旋矩阵 数组 Medium 完成 0020 59.螺旋矩阵II 数组 Medium 完成 第3期 0021 61.旋转链表 链表、双指针 Medium 完成 0022 62.不同路径 数组、动态规划 Medium 完成 0023 70.爬楼梯 动态规划 Easy 完成 0024 78.子集 位运算、数组、回溯算法 Medium 完成 0025 88.合并两个有序数组 数组、双指针 Easy 完成 0026 89.格雷编码 回溯算法 Medium 完成 0027 104.二叉树的最大深度 树、深度优先搜索 Easy 完成 0028 121.买卖股票的最佳时机 数组、动态规划 Easy 完成 0029 122.买卖股票的最佳时机II 贪心算法、数组 Easy 完成 0030 124.二叉树中的最大路径和 树、深度优先搜索 Hard 完成 第4期 0031 136.只出现一次的数字 位运算、哈希表 Easy 完成 0032 141.环形链表 链表、双指针 Easy 完成 0033 142.环形链表II 链表、双指针 Medium 完成 0034 146.LRU缓存机制 设计 Medium 完成 0035 148.排序链表 排序、链表 Medium 完成 0036 155.最小栈 栈、设计 Easy 完成 0037 160.相交链表 链表 Easy 完成 0038 169.多数元素 位运算、数组、分治算法 Easy 完成 0039 206.反转链表 链表 Easy 完成 0040 215.数组中的第K个最大元素 堆、分治算法 Medium 完成 第5期 0041 217.存在重复元素 数组、哈希表 Easy 完成 0042 230.二叉搜索树中第K小的元素 树、二分查找 Medium 完成 0043 231.2的幂 位运算、数学 Easy 完成 0044 235.二叉搜索树的最近公共祖先 树 Easy 完成 0045 236.二叉树的最近公共祖先 树 Medium 完成 0046 237.删除链表中的节点 链表 Easy 完成 0047 238.除自身以外数组的乘积 数组 Medium 完成 0048 292.Nim游戏 脑筋急转弯、极小化极大 Easy 完成 0049 344.反转字符串 双指针、字符串 Easy 完成 0050 557.反转字符串中的单词III 字符串 Easy 完成 Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 09:46:03 "},"docs/source/classification/data-array_and_string.html":{"url":"docs/source/classification/data-array_and_string.html","title":"数据结构-数组与字符串(22)-完成","keywords":"","body":"数组和字符串 数组和字符串系列 本系列共22题 原文分类链接 https://leetcode-cn.com/leetbook/detail/array-and-string/ 1-数组简介(3) Title Tag 难度 完成情况 724.寻找数组的中心索引 数组 Easy 完成 35.搜索插入位置 数组、二分查找 Easy 完成 56.合并区间 排序、数组 Medium 完成 2-二维数组简介(3) Title Tag 难度 完成情况 旋转矩阵 48.旋转图像 数组 Medium 完成 零矩阵 73.矩阵置零 数组 Medium 完成 498.对角线遍历 Medium 完成 3-字符串简介(4) Title Tag 难度 完成情况 14.最长公共前缀 字符串 Easy 完成 5.最长回文子串 字符串、动态规划 Medium 完成 151.翻转字符串里的单词 字符串 Medium 完成 28.实现strStr() 双指针、字符串 Easy 完成 4-双指针技巧(6) Title Tag 难度 完成情况 344.反转字符串 双指针、字符串 Easy 完成 561.数组拆分 I 数组 Easy 完成 167.两数之和 II - 输入有序数组 数组、双指针、二分查找 Easy 完成 27.移除元素 数组、双指针 Easy 完成 485.最大连续1的个数 数组 Easy 完成 209.长度最小的子数组 数组、双指针、二分查找 Medium 完成 5-小结(6) Title Tag 难度 完成情况 118.杨辉三角 数组 Easy 完成 119.杨辉三角 II 数组 Easy 完成 557.反转字符串中的单词 III 字符串 Easy 完成 153.寻找旋转排序数组中的最小值 数组、二分查找 Medium 完成 26.删除排序数组中的重复项 数组、双指针 Easy 完成 283.移动零 数组、双指针 Easy 完成 Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 09:46:03 "},"docs/source/classification/data-queue-stack.html":{"url":"docs/source/classification/data-queue-stack.html","title":"数据结构-队列与栈(19)-完成","keywords":"","body":"队列&栈 队列和栈系列 本系列共19题 原文分类链接 https://leetcode-cn.com/leetbook/detail/queue-stack/ 2-队列：先入先出的数据结构(2) Title Tag 难度 完成情况 622.设计循环队列 设计、队列 Medium 完成 346.数据流中的移动平均值 3-队列和广度优先搜索(3) Title Tag 难度 完成情况 200.岛屿数量 深度优先搜索、广度优先搜索、并查集 Medium 完成 752.打开转盘锁 广度优先搜索 Medium 完成 279.完全平方数 广度优先搜索、数学、动态规划 Medium 完成 4-栈：后入先出的数据结构(4) Title Tag 难度 完成情况 155.最小栈 栈、设计 Easy 完成 20.有效的括号 栈、字符串 Easy 完成 739.每日温度 栈、哈希表 Medium 完成 150.逆波兰表达式求值 栈 Medium 完成 5-栈和深度优先搜索(4) Title Tag 难度 完成情况 200.岛屿数量 深度优先搜索、广度优先搜索、并查集 Medium 完成 133.克隆图 深度优先搜索、广度优先搜索、图 Medium 完成 494.目标和 深度优先搜索、动态规划 Medium 完成 94.二叉树的中序遍历 栈、树、哈希表 Medium 完成 6-小结(6) Title Tag 难度 完成情况 232.用栈实现队列 栈、设计 Easy 完成 225.用队列实现栈 栈、设计 Easy 完成 394.字符串解码 栈、深度优先搜索 Medium 完成 733.图像渲染 深度优先搜索 Easy 完成 542.01矩阵 深度优先搜索、广度优先搜索 Medium 完成 841.钥匙和房间 深度优先搜索、图 Medium 完成 Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 09:46:03 "},"docs/source/classification/data-recursion.html":{"url":"docs/source/classification/data-recursion.html","title":"数据结构-递归(12)-完成","keywords":"","body":"递归 递归系列 本系列共12题 原文分类链接 https://leetcode-cn.com/leetbook/detail/recursion/ 1.递归原理(2) Title Tag 难度 完成情况 344.反转字符串 双指针、字符串 Easy 完成 24.两两交换链表中的节点 链表 Medium 完成 2.递推关系(3) Title Tag 难度 完成情况 118.杨辉三角 数组 Easy 完成 119.杨辉三角 II 数组 Easy 完成 206.反转链表 链表 Easy 完成 3.Memorization(记忆化)计数(2) Title Tag 难度 完成情况 509.斐波那契数 数组 Easy 完成 70.爬楼梯 动态规划 Easy 完成 4.复杂度分析(2) Title Tag 难度 完成情况 104.二叉树的最大深度 树、深度优先搜索 Easy 完成 50.Pow(x,n) 数学、二分查找 Medium 完成 5.总结(3) Title Tag 难度 完成情况 21.合并两个有序链表 链表 Easy 完成 779.第K个语法符号 递归 Medium 完成 95.不同的二叉搜索树II 树、动态规划 Medium 完成 Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 09:46:03 "},"docs/source/classification/nowcoder_hw.html":{"url":"docs/source/classification/nowcoder_hw.html","title":"牛客-华为","keywords":"","body":"牛客-华为机试 本系统共108题目 https://www.nowcoder.com/ta/huawei No. Title Tag(知识点) 难度 完成情况 第1期 0001 字符串最后一个单词的长度 字符串 较难 完成 0002 计算字符个数 字符串、哈希 较难 完成 0003 明明的随机数 数组 较难 完成 0004 字符串分隔 字符串 较难 完成 0005 进制转换 字符串 中等 完成 0006 质数因子 排序 中等 完成 0007 取近似值 数学、语法题 入门 完成 0008 合并表记录 栈 中等 完成 0009 提取不重复的整数 数组、哈希、位运算 中等 完成 0010 字符个数统计 字符串、哈希 中等 完成 第2期 0011 数字颠倒 字符串 简单 完成 0012 字符串反转 字符串 简单 完成 0013 句子逆序 数组 较难 完成 0014 字串的连接最长路径查找 字符串 中等 完成 0015 求int型正整数在内存中存储时1的个数 位运算 入门 完成 0016 购物单 动态规划 中等 0017 坐标移动 字符串 较难 完成 0018 识别有效的IP地址和掩码并进行分类统计 字符串、查找 困难 Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 09:46:03 "},"docs/source/classification/nowcoder_pdd.html":{"url":"docs/source/classification/nowcoder_pdd.html","title":"牛客-拼多多","keywords":"","body":"牛客-拼多多机试 本系统共x题目 https://www.nowcoder.com/ta/exam-pdd No. Title Tag(知识点) 难度 完成情况 对应leetcode题目 第1期 0001 最大乘积 贪心、模拟 中等 完成 628.三个数的最大乘积 Easy 0002 大整数相乘 模拟 中等 完成 43.字符串相乘 Medium 0003 六一儿童节 贪心 中等 完成 455.分发饼干 Easy 0004 迷宫寻路 模拟 中等 Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 09:46:03 "},"docs/source/classification/patB.html":{"url":"docs/source/classification/patB.html","title":"PAT-乙级","keywords":"","body":"PAT乙 参考 https://blog.csdn.net/weixin_38380313 No. Title 分值 完成情况 第1期 1001 害死人不偿命的(3n+1)猜想 15 完成 1002 写出这个数 20 完成 1003 我要通过! 20 完成 1004 成绩排名 20 完成 1005 继续(3n+1)猜想 25 完成 1006 换个格式输出整数 15 完成 1007 素数对猜想 20 完成 1008 数组元素循环右移问题 20 完成 1009 说反话 20 完成 1010 一元多项式求导 25 完成 第2期 1011 A+B 和 C 15 完成 1012 数字分类 20 完成 1013 数素数 20 完成 1014 福尔摩斯的约会 20 完成 1015 德才论 25 完成 1016 部分A+B 15 1017 Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 09:46:03 "},"docs/source/classification/github-labuladong.html":{"url":"docs/source/classification/github-labuladong.html","title":"github-labuladong","keywords":"","body":" 教程链接 https://labuladong.gitbook.io/algo/ 第零章、必读系列 学习算法和刷题的框架思维(5) Title Tag 难度 完成情况 124.二叉树中的最大路径和 树、深度优先搜索 Hard 完成 105.从前序与中序遍历序列构造二叉树 树、深度优先搜索、数组 Medium 完成 99.恢复二叉搜索树 树、深度优先搜索 Hard 完成 322.零钱兑换 动态规划 Medium 完成 51.N皇后 回溯算法 Hard 完成 动态规划解题套路框架(2) Title Tag 难度 完成情况 509.斐波那契数 数组 Easy 完成 322.零钱兑换 动态规划 Medium 完成 回溯算法解题套路框架(2) Title Tag 难度 完成情况 46.全排列 回溯算法 Medium 完成 51.N皇后 回溯算法 Hard 完成 BFS 算法解题套路框架(2) Title Tag 难度 完成情况 111.二叉树的最小深度 树、深度优先搜索、广度优先搜索 Easy 完成 752.打开转盘锁 广度优先搜索 Medium 完成 我写了首诗，让你闭着眼睛也能写对二分搜索(2) Title Tag 难度 完成情况 704.二分查找 二分查找 Easy 完成 34.在排序数组中查找元素的第一个和最后一个位置 数组、二分查找 Medium 完成 我写了首诗，把滑动窗口算法算法变成了默写题(4) Title Tag 难度 完成情况 3.无重复字符的最长子串 哈希表、双指针、字符串 Sliding Window Medium 完成 76.最小覆盖子串 哈希表、双指针、字符串、 Sliding Window Hard 完成 438.找到字符串中所有字母异位词 哈希表 Medium 完成 567.字符串的排列 双指针、Sliding Window Medium 完成 一个方法团灭 LeetCode 股票买卖问题(6) Title Tag 难度 完成情况 121.买卖股票的最佳时机 数组、动态规划 Easy 完成 122.买卖股票的最佳时机II 贪心算法、数组 Easy 完成 123.买卖股票的最佳时机III 数组、动态规划 Hard 完成 188.买卖股票的最佳时机IV 动态规划 Hard 完成 309.最佳买卖股票时机含冷冻期 动态规划 Medium 完成 714.买卖股票的最佳时机含手续费 贪心算法、数组、动态规划 Medium 完成 一个方法团灭 LeetCode 打家劫舍问题(3) Title Tag 难度 完成情况 198.打家劫舍 动态规划 Easy 完成 213.打家劫舍II 动态规划 Medium 完成 337.打家劫舍III 树、深度优先搜索 Medium 完成 一个方法团灭 nSum 问题(2) Title Tag 难度 完成情况 15.三数之和 数组、双指针 Medium 完成 18.四数之和 数组、哈希表、双指针 Medium 完成 经典动态规划：高楼扔鸡蛋(1) Title Tag 难度 完成情况 887.鸡蛋掉落 数学、二分查找、动态规划 Hard 经典动态规划：子集背包问题(1) Title Tag 难度 完成情况 416.分割等和子集 动态规划 Medium 完成 经典动态规划：完全背包问题(1) Title Tag 难度 完成情况 518.零钱兑换II Medium 完成 表达式求值算法：实现计算器(3) Title Tag 难度 完成情况 224 227.基本计算器II 字符串 Medium 772 第一章、动态规划系列 动态规划解题套路框架(2) Title Tag 难度 完成情况 509.斐波那契数 数组 Easy 完成 322.零钱兑换 动态规划 Medium 完成 Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 09:46:03 "},"docs/source/algorithm/1-search.html":{"url":"docs/source/algorithm/1-search.html","title":"查找","keywords":"","body":"查找算法 总结 1. Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 09:46:03 "},"docs/source/algorithm/2-sort.html":{"url":"docs/source/algorithm/2-sort.html","title":"排序","keywords":"","body":"排序算法 参考 https://www.cnblogs.com/onepixel/articles/7674659.html总结 No. 排序方法 时间复杂度(平均) 时间复杂度(最坏) 时间复杂度(最好) 空间复杂度 稳定性 01 冒泡排序 O(n^2) O(n^2) O(n) O(1) 稳定 02 选择排序 O(n^2) O(n^2) O(n^2) O(1) 不稳定 03 插入排序 O(n^2) O(n^2) O(n) O(1) 稳定 04 希尔排序 O(n^1.3) O(n^2) O(n) O(1) 不稳定 05 归并排序 O(nlog(n)) P O(nlog(n)) O(n) 稳定 06 快速排序 O(nlog(n)) O(n^2) O(nlog(n)) O(log(n)) 不稳定 07 堆排序 O(nlog(n)) O(nlog(n)) O(nlog(n)) O(1) 不稳定 08 计数排序 O(n+k) O(n+k) O(n+k) O(n+k) 稳定 09 桶排序 O(n+k) O(n^2) O(n) O(n+k) 稳定 10 基数排序 O(n*k) O(n*k) O(n*k) O(n+k) 稳定 1.冒泡排序 // 依次比较和交换，把最大值或者最小值交换到后面已经排好序数组之前 func bubbleSort(arr []int) { for i := 0; i arr[j+1] { arr[j], arr[j+1] = arr[j+1], arr[j] } } } } 2.选择排序 // 每次选择未排好序数组的最小值，添加到已经排好序后面 // 序列5 8 5 2 9，第一遍选择第1个元素5会和2交换，破坏稳定性 func selectionSort(arr []int) { for i := 0; i 3.插入排序 // 依次选择一个数据，插入到前面已经排好序中，需要数据后移 func insertionSort(arr []int) { for i := 1; i = 0 && arr[pos] > cur { arr[pos+1] = arr[pos] // 后移 pos-- } arr[pos+1] = cur } } 4.希尔排序 // 选定间隔 func shellSort(arr []int) { n := len(arr) for gap := n / 2; gap > 0; gap = gap / 2 { for i := gap; i = 0 && cur 5.归并排序 func mergeSort(arr []int) []int { n := len(arr) if n 0 && len(right) > 0 { if left[0] 0 { res = append(res, left...) } if len(right) > 0 { res = append(res, right...) } return res } 6.快排排序 func quickSort(arr []int) { quick(arr, 0, len(arr)-1) } func quick(arr []int, left, right int) { if left >= right { return } index := partition(arr, left, right) quick(arr, left, index-1) quick(arr, index+1, right) } func partition(arr []int, left, right int) int { baseValue := arr[left] // 基准值 for left 7.堆排序 堆排序 func heapSort(arr []int) { buildHeap(arr, len(arr)) for i := len(arr) - 1; i > 0; i-- { arr[0], arr[i] = arr[i], arr[0] heapModify(arr, 0, i-1) } } func buildHeap(arr []int, length int) { for i := len(arr)/2 - 1; i >= 0; i-- { heapModify(arr, i, length-1) } } func heapModify(arr []int, start, end int) { temp := arr[start] for left := 2*start + 1; left 内置heap type IntHeap []int func (h IntHeap) Len() int { return len(h) } // 小根堆 func (h IntHeap) Less(i, j int) bool { return h[i] 8.计数排序 func countingSort(arr []int) []int { maxValue := 0 for i := 0; i maxValue { maxValue = arr[i] } } bucket := make([]int, maxValue+1) for i := 0; i 0 { arr[index] = i index++ bucket[i]-- } } return arr } 9.桶排序 10.基数排序 Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 09:46:03 "},"docs/source/algorithm/trie.html":{"url":"docs/source/algorithm/trie.html","title":"Trie树(前缀树/字典树)","keywords":"","body":"Trie树(前缀树/字典树) 定义：Trie树，又经常叫前缀树，字典树等等 百度百科：又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。 典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。 它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。 1.Go实现 实现参考：leetcode208.实现 Trie (前缀树) Insert操作 Search操作 type Trie struct { next [26]*Trie // 下一级指针，如不限于小写字母，[26]=>[256] ending int // 次数（可以改为bool） } func Constructor() Trie { return Trie{ next: [26]*Trie{}, ending: 0, } } // 插入word func (this *Trie) Insert(word string) { temp := this for _, v := range word { value := v - 'a' if temp.next[value] == nil { temp.next[value] = &Trie{ next: [26]*Trie{}, ending: 0, } } temp = temp.next[value] } temp.ending++ } // 查找 func (this *Trie) Search(word string) bool { temp := this for _, v := range word { value := v - 'a' if temp = temp.next[value]; temp == nil { return false } } if temp.ending > 0 { return true } return false } // 查找前缀 func (this *Trie) StartsWith(prefix string) bool { temp := this for _, v := range prefix { value := v - 'a' if temp = temp.next[value]; temp == nil { return false } } return true } 2.Leetcode Trie树应用 Title Tag 难度 完成情况 14.最长公共前缀 字符串 Easy 完成 208.实现 Trie (前缀树) 设计、字典树 Medium 完成 211.添加与搜索单词-数据结构设计 设计、字典树、回溯算法 Medium 完成 720.词典中最长的单词 字典树、哈希表 Easy 完成 Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 09:46:03 "},"docs/source/algorithm/并查集.html":{"url":"docs/source/algorithm/并查集.html","title":"并查集","keywords":"","body":"Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 09:46:03 "},"docs/source/algorithm/树状数组.html":{"url":"docs/source/algorithm/树状数组.html","title":"树状数组","keywords":"","body":"Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 09:46:03 "},"docs/source/nowcoder/hw.html":{"url":"docs/source/nowcoder/hw.html","title":"华为机试","keywords":"","body":"牛客-华为机试 https://www.nowcoder.com/ta/huawei 牛客-华为机试 1.字符串最后一个单词的长度(5) 2.计算字符个数(4) 3.明明的随机数(2) 4.字符串分隔(2) 5.进制转换(3) 6.质数因子(2) 7.取近似值(2) 8.合并表记录(2) 9.提取不重复的整数(2) 10.字符个数统计(2) 11.数字颠倒(2) 12.字符串反转(2) 13.句子逆序(2) 14.字串的连接最长路径查找(2) 15.求int型正整数在内存中存储时1的个数(2) 16.购物单 题目 解题思路 17.坐标移动(1) 18.识别有效的IP地址和掩码并进行分类统计 题目 解题思路 1.字符串最后一个单词的长度(5) 题目 题目描述:计算字符串最后一个单词的长度，单词以空格隔开。 输入描述:一行字符串，非空，长度小于5000。 输出描述:整数N，最后一个单词的长度。 示例1:输入:hello world 输出:5 解题思路 No. 思路 时间复杂度 空间复杂度 01 内置函数 O(n) O(n) 02 内置函数 O(n) O(n) 03 内置函数 O(n) O(n) 04 内置函数 O(n) O(n) 05 顺序读取 O(n) O(n) package main import ( \"bufio\" \"fmt\" \"os\" \"strings\" ) func main() { reader := bufio.NewReader(os.Stdin) data, _, _ := reader.ReadLine() str := string(data) arr := strings.Fields(str) if len(arr) == 0 { fmt.Println(0) return } fmt.Println(len(arr[len(arr)-1])) return } # 2 package main import ( \"bufio\" \"fmt\" \"os\" \"strings\" ) func main() { scan := bufio.NewScanner(os.Stdin) scan.Scan() str := scan.Text() arr := strings.Fields(str) if len(arr) == 0 { fmt.Println(0) return } fmt.Println(len(arr[len(arr)-1])) return } # 3 package main import ( \"bufio\" \"fmt\" \"os\" \"strings\" ) func main() { reader := bufio.NewReader(os.Stdin) //data, _ := reader.ReadBytes('\\n') data, _ := reader.ReadString('\\n') str := string(data) arr := strings.Fields(str) if len(arr) == 0 { fmt.Println(0) return } fmt.Println(len(arr[len(arr)-1])) return } # 4 package main import ( \"bufio\" \"fmt\" \"os\" \"strings\" ) func main() { scan := bufio.NewScanner(os.Stdin) for scan.Scan() { str := scan.Text() arr := strings.Fields(str) if len(arr) == 0 { fmt.Println(0) } else { fmt.Println(len(arr[len(arr)-1])) } } return } # 5 package main import \"fmt\" func main() { var str string for { flag, _ := fmt.Scan(&str) if flag == 0 { break } } fmt.Println(len(str)) } 2.计算字符个数(4) 题目 题目描述 写出一个程序，接受一个由字母和数字组成的字符串，和一个字符，然后输出输入字符串中含有该字符的个数。 不区分大小写。 输入描述:第一行输入一个有字母和数字以及空格组成的字符串，第二行输入一个字符。 输出描述:输出输入字符串中含有该字符的个数。 示例1 输入 ABCDEF A 输出 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 02 遍历 O(n) O(1) 03 遍历 O(n) O(1) 04 内置函数 O(n) O(1) package main import ( \"bufio\" \"fmt\" \"os\" \"strings\" ) func main() { reader := bufio.NewReader(os.Stdin) data, _ := reader.ReadString('\\n') str := strings.ToLower(data) // data, _ = reader.ReadString('\\n') // c := strings.ToLower(data)[0] c, _, _ := reader.ReadRune() res := 0 for i := 0; i 3.明明的随机数(2) 题目 明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性， 他先用计算机生成了N个1到1000之间的随机整数（N≤1000），对于其中重复的数字，只保留一个，把其余相同的数去掉， 不同的数对应着不同的学生的学号。 然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。 请你协助明明完成“去重”与“排序”的工作(同一个测试用例里可能会有多组数据，希望大家能正确处理)。 Input Param n 输入随机数的个数 inputArray n个随机整数组成的数组 Return Value OutputArray 输出处理后的随机整数 注：测试用例保证输入参数的正确性，答题者无需验证。测试用例不止一组。 样例输入解释： 样例有两组测试 第一组是3个数字，分别是：2，2，1。 第二组是11个数字，分别是：10，20，40，32，67，40，20，89，300，400，15。 输入描述:输入多行，先输入随机整数的个数，再输入相应个数的整数 输出描述:返回多行，处理后的结果 示例1 输入 3 2 2 1 11 10 20 40 32 67 40 20 89 300 400 15 输出 1 2 10 15 20 32 40 67 89 300 400 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历-数组辅助 O(n) O(1) 02 遍历-数组辅助 O(n) O(1) package main import ( \"bufio\" \"fmt\" \"os\" \"strconv\" ) func main() { reader := bufio.NewReader(os.Stdin) for { n, _, _ := reader.ReadLine() if len(n) 4.字符串分隔(2) 题目 题目描述 •连续输入字符串，请按长度为8拆分每个字符串后输出到新的字符串数组； •长度不是8整数倍的字符串请在后面补数字0，空字符串不处理。 输入描述:连续输入字符串(输入2次,每个字符串长度小于100) 输出描述:输出到长度为8的新字符串数组 示例1 输入 abc 123456789 输出 abc00000 12345678 90000000 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(n) 02 遍历 O(n) O(n) package main import ( \"bufio\" \"fmt\" \"os\" ) func main() { scan := bufio.NewScanner(os.Stdin) for i := 0; i 5.进制转换(3) 题目 题目描述 写出一个程序，接受一个十六进制的数，输出该数值的十进制表示。（多组同时输入 ） 输入描述:输入一个十六进制的数值字符串。 输出描述:输出该数值的十进制字符串。 示例1 输入 0xA 输出 10 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(1) O(1) 02 遍历 O(1) O(1) 03 字符串转整数 O(1) O(1) package main import \"fmt\" func main() { var num int for { n, _ := fmt.Scanf(\"0x%x\", &num) if n == 0 { break } fmt.Println(num) } } # package main import \"fmt\" func main() { var num int for { n, _ := fmt.Scanf(\"%v\", &num) if n == 0 { break } fmt.Println(num) } } # package main import ( \"bufio\" \"fmt\" \"os\" \"strconv\" ) func main() { reader := bufio.NewReader(os.Stdin) var num string for { data, _, _ := reader.ReadLine() if len(data) == 0 { break } num = string(data[2:]) value, _ := strconv.ParseInt(num, 16, 32) fmt.Println(value) } } 6.质数因子(2) 题目 题目描述 功能:输入一个正整数，按照从小到大的顺序输出它的所有质因子（重复的也要列举） （如180的质因子为2 2 3 3 5 ） 最后一个数后面也要有空格 输入描述:输入一个long型整数 输出描述:按照从小到大的顺序输出它的所有质数的因子，以空格隔开。最后一个数后面也要有空格。 示例1 输入 180 输出 2 2 3 3 5 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(log(n)) O(1) 02 遍历 O(log(n)) O(1) package main import \"fmt\" func main() { var num int64 for { n, _ := fmt.Scanf(\"%d\", &num) if n == 0 { break } i := int64(2) for num > 1 { if num%i == 0 { fmt.Printf(\"%d \", i) num = num / i } else { i++ } } fmt.Println() } } # package main import \"fmt\" func main() { var num int64 for { n, _ := fmt.Scanf(\"%d\", &num) if n == 0 { break } for i := int64(2); i 7.取近似值(2) 题目 题目描述 写出一个程序，接受一个正浮点数值，输出该数值的近似整数值。如果小数点后数值大于等于5,向上取整； 小于5，则向下取整。 输入描述:输入一个正浮点数值 输出描述:输出该数值的近似整数值 示例1 输入 5.5 输出 6 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(1) O(1) 02 遍历 O(1) O(1) package main import \"fmt\" func main() { var num float32 fmt.Scanf(\"%f\", &num) fmt.Println(int(num + 0.5)) } # package main import ( \"fmt\" \"math\" ) func main() { var num float64 for { n, _ := fmt.Scanf(\"%f\", &num) if n == 0 { break } fmt.Println(int(math.Floor(num + 0.5))) } } 8.合并表记录(2) 题目 题目描述 数据表记录包含表索引和数值（int范围的整数），请对表索引相同的记录进行合并，即将相同索引的数值进行求和运算， 输出按照key值升序进行输出。 输入描述:先输入键值对的个数 然后输入成对的index和value值，以空格隔开 输出描述:输出合并后的键值对（多行） 示例1 输入 4 0 1 0 2 1 2 3 4 输出 0 3 1 2 3 4 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组辅助 O(n) O(1) 02 哈希辅助 O(nlog(n)) O(n) package main import \"fmt\" func main() { var num int for { n, _ := fmt.Scanf(\"%d\", &num) if n == 0 { break } var key, vale int arr := make([]int, 1024) for i := 0; i 9.提取不重复的整数(2) 题目 题目描述:输入一个int型整数，按照从右向左的阅读顺序，返回一个不含重复数字的新的整数。 输入描述:输入一个int型整数 输出描述:按照从右向左的阅读顺序，返回一个不含重复数字的新的整数 示例1 输入 9876673 输出 37689 解题思路 No. 思路 时间复杂度 空间复杂度 01 数组辅助 O(log(n)) O(1) 02 数组辅助 O(log(n)) O(1) package main import ( \"fmt\" ) func main() { var num int for { n, _ := fmt.Scanf(\"%d\", &num) if n == 0 { break } m := make(map[int]int) res := 0 for num > 0 { value := num % 10 num = num / 10 if m[value] == 0 { res = res*10 + value m[value] = 1 } } fmt.Println(res) } } # package main import ( \"fmt\" ) func main() { var num string for { n, _ := fmt.Scanf(\"%s\", &num) if n == 0 { break } m := make(map[byte]int) for i := len(num) - 1; i >= 0; i-- { if m[num[i]] == 0 { fmt.Printf(\"%c\", num[i]) m[num[i]] = 1 } } fmt.Println() } } 10.字符个数统计(2) 题目 题目描述 编写一个函数，计算字符串中含有的不同字符的个数。字符在ACSII码范围内(0~127)，换行表示结束符，不算在字符里。 不在范围内的不作统计。多个相同的字符只计算一次 输入 abaca 输出 3 输入描述:输入N个字符，字符在ACSII码范围内。 输出描述:输出范围在(0~127)字符的个数。 示例1 输入 abc 输出 3 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(1) 02 数组辅助 O(n) O(1) package main import ( \"fmt\" ) func main() { var num string for { n, _ := fmt.Scanf(\"%s\", &num) if n == 0 { break } m := make(map[byte]int) for i := 0; i 11.数字颠倒(2) 题目 题目描述 描述：输入一个整数，将这个整数以字符串的形式逆序输出 程序不考虑负数的情况，若数字含有0，则逆序形式也含有0，如输入为100，则输出为001 输入描述:输入一个int整数 输出描述:将这个整数以字符串的形式逆序输出 示例1 输入 1516000 输出 0006151 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(log(n)) O(1) 02 遍历 O(log(n)) O(1) package main import ( \"fmt\" ) func main() { var num string for { n, _ := fmt.Scanf(\"%s\", &num) if n == 0 { break } for i := len(num) - 1; i >= 0; i-- { // fmt.Print(num[i] - '0') fmt.Print(string(num[i])) } fmt.Println() } } # package main import ( \"fmt\" ) func main() { var num int for { n, _ := fmt.Scanf(\"%d\", &num) if n == 0 { break } for num > 0{ fmt.Print(num%10) num = num/10 } fmt.Println() } } 12.字符串反转(2) 题目 题目描述:写出一个程序，接受一个字符串，然后输出该字符串反转后的字符串。（字符串长度不超过1000） 输入描述:输入N个字符 输出描述:输出该字符串反转后的字符串 示例1 输入 abcd 输出 dcba 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) 01 遍历 O(n) O(1) package main import ( \"fmt\" ) func main() { var str string for { n, _ := fmt.Scanf(\"%s\", &str) if n == 0 { break } for i := len(str) - 1; i >= 0; i-- { fmt.Print(string(str[i])) } fmt.Println() } } # package main import ( \"bufio\" \"fmt\" \"os\" ) func main() { reader := bufio.NewReader(os.Stdin) for { n, _, _ := reader.ReadLine() if len(n) == 0 { break } str := n for i := len(str) - 1; i >= 0; i-- { fmt.Print(string(str[i])) } fmt.Println() } } 13.句子逆序(2) 题目 题目描述 将一个英文语句以单词为单位逆序排放。例如“I am a boy”，逆序排放后为“boy a am I” 所有单词之间用一个空格隔开，语句中除了英文字母外，不再包含其他字符 接口说明 /** * 反转句子 * * @param sentence 原句子 * @return 反转后的句子 */ public String reverse(String sentence); 输入描述:将一个英文语句以单词为单位逆序排放。 输出描述:得到逆序的句子 示例1 输入 I am a boy 输出 boy a am I 解题思路 No. 思路 时间复杂度 空间复杂度 01 内置函数 O(n) O(n) 02 内置函数 O(n) O(n) package main import ( \"bufio\" \"fmt\" \"os\" \"strings\" ) func main() { reader := bufio.NewReader(os.Stdin) for { n, _, _ := reader.ReadLine() if len(n) == 0 { break } str := string(n) arr := strings.Split(str, \" \") for i := 0; i 14.字串的连接最长路径查找(2) 题目 题目描述 给定n个字符串，请对n个字符串按照字典序排列。 输入描述:输入第一行为一个正整数n(1≤n≤1000),下面n行为n个字符串(字符串长度≤100),字符串中只含有大小写字母。 输出描述:数据输出n行，输出结果为按照字典序排列的字符串。 示例1 输入 9 cap to cat card two too up boat boot 输出 boat boot cap card cat to too two up 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序 O(nlog(n)) O(n) 02 排序 O(nlog(n)) O(n) package main import ( \"fmt\" \"sort\" ) func main() { var num int for { n, _ := fmt.Scanf(\"%d\", &num) if n == 0 { break } arr := make([]string, 0) var str string for i := 0; i 15.求int型正整数在内存中存储时1的个数(2) 题目 题目描述:输入一个int型的正整数，计算出该int型数据在内存中存储时1的个数。 输入描述:输入一个整数（int类型） 输出描述:这个数转换成2进制后，输出1的个数 示例1 输入 5 输出 2 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(log(n)) O(1) 02 位运算 O(log(n)) O(1) package main import \"fmt\" func main() { var num int for { n, _ := fmt.Scanf(\"%d\", &num) if n == 0{ break } res := 0 for num > 0{ if num%2 == 1{ res++ } num = num/2 } fmt.Println(res) } } # package main import \"fmt\" func main() { var num int for { n, _ := fmt.Scanf(\"%d\", &num) if n == 0 { break } res := 0 for num > 0 { num = num & (num - 1) res++ } fmt.Println(res) } } 16.购物单 题目 题目描述 王强今天很开心，公司发给N元的年终奖。王强决定把年终奖用于购物，他把想买的物品分为两类： 主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子： 主件 附件 电脑 打印机，扫描仪 书柜 图书 书桌 台灯，文具 工作椅 无 如果要买归类为附件的物品，必须先买该附件所属的主件。 每个主件可以有 0 个、 1 个或 2 个附件。附件不再有从属于自己的附件。 王强想买的东西很多，为了不超出预算，他把每件物品规定了一个重要度，分为 5 等： 用整数 1 ~ 5 表示，第 5 等最重要。他还从因特网上查到了每件物品的价格（都是 10 元的整数倍）。 他希望在不超过 N 元（可以等于 N 元）的前提下，使每件物品的价格与重要度的乘积的总和最大。 设第 j 件物品的价格为 v[j] ，重要度为 w[j] ，共选中了 k 件物品， 编号依次为 j 1 ， j 2 ，……， j k ，则所求的总和为： v[j 1 ]*w[j 1 ]+v[j 2 ]*w[j 2 ]+ … +v[j k ]*w[j k ] 。（其中 * 为乘号） 请你帮助王强设计一个满足要求的购物单。 输入描述: 输入的第 1 行，为两个正整数，用一个空格隔开：N m （其中 N （ 0 ，表示该物品为附件， q 是所属主件的编号） 输出描述:输出文件只有一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值（ 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(log(n)) O(1) 17.坐标移动(1) 题目 题目描述 开发一个坐标计算工具， A表示向左移动，D表示向右移动，W表示向上移动，S表示向下移动。 从（0,0）点开始移动，从输入字符串里面读取一些坐标，并将最终输入结果输出到输出文件里面。 输入：合法坐标为A(或者D或者W或者S) + 数字（两位以内）坐标之间以;分隔。 非法坐标点需要进行丢弃。如AA10; A1A; $%$; YAD; 等。 下面是一个简单的例子 如： A10;S20;W10;D30;X;A1A;B10A11;;A10; 处理过程：起点（0,0） + A10 = （-10,0） + S20 = (-10,-20) + W10 = (-10,-10) + D30 = (20,-10) + x = 无效 + A1A = 无效 + B10A11 = 无效 + 一个空 不影响 + A10 = (10,-10) 结果 （10， -10） 注意请处理多组输入输出 输入描述:一行字符串 输出描述:最终坐标，以,分隔 示例1 输入 A10;S20;W10;D30;X;A1A;B10A11;;A10; 输出 10,-10 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) package main import ( \"fmt\" \"strconv\" \"strings\" ) func main() { var str string for { n, _ := fmt.Scanf(\"%s\", &str) if n == 0 { break } arr := strings.Split(str, \";\") x := 0 y := 0 for i := 0; i 3 { continue } value, _ := strconv.Atoi(arr[i][1:]) switch arr[i][0] { case 'A': x = x - value case 'D': x = x + value case 'W': y = y + value case 'S': y = y - value } } fmt.Printf(\"%d,%d\\n\", x, y) } } # 18.识别有效的IP地址和掩码并进行分类统计 题目 题目描述 请解析IP地址和对应的掩码，进行分类识别。要求按照A/B/C/D/E类地址归类，不合法的地址和掩码单独归类。 所有的IP地址划分为 A,B,C,D,E五类 A类地址1.0.0.0~126.255.255.255; B类地址128.0.0.0~191.255.255.255; C类地址192.0.0.0~223.255.255.255; D类地址224.0.0.0~239.255.255.255； E类地址240.0.0.0~255.255.255.255 私网IP范围是： 10.0.0.0～10.255.255.255 172.16.0.0～172.31.255.255 192.168.0.0～192.168.255.255 子网掩码为二进制下前面是连续的1，然后全是0。（例如：255.255.255.32就是一个非法的掩码） 注意二进制下全是1或者全是0均为非法 注意： 1. 类似于【0.*.*.*】和【127.*.*.*】的IP地址不属于上述输入的任意一类，也不属于不合法ip地址， 计数时可以忽略 2. 私有IP地址和A,B,C,D,E类地址是不冲突的 输入描述: 多行字符串。每行一个IP地址和掩码，用~隔开。 输出描述:统计A、B、C、D、E、错误IP地址或错误掩码、私有IP的个数，之间以空格隔开。 示例1 输入 10.70.44.68~255.254.255.0 1.0.0.1~255.0.0.0 192.168.0.2~255.255.255.0 19..0.~255.255.255.0 输出 1 0 1 0 0 2 1 解题思路 Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 11:25:33 "},"docs/source/nowcoder/pdd.html":{"url":"docs/source/nowcoder/pdd.html","title":"拼多多","keywords":"","body":"牛客-拼多多机试 https://www.nowcoder.com/ta/exam-pdd 牛客-拼多多机试 1.最大乘积(1) 2.大整数相乘(2) 3.六一儿童节(2) 4.迷宫寻路 题目 解题思路 1.最大乘积(1) 题目 题目描述 给定一个无序数组，包含正数、负数和0，要求从中找出3个数的乘积，使得乘积最大， 要求时间复杂度：O(n)，空间复杂度：O(1) 输入描述:输入共2行，第一行包括一个整数n，表示数组长度 第二行为n个以空格隔开的整数，分别为A1,A2, … ,An 输出描述:满足条件的最大乘积 示例1: 输入 4 3 4 1 2 输出: 24 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序 O(nlog(n)) O(1) package main import ( \"fmt\" \"sort\" ) func main() { var n, m int for { a, _ := fmt.Scan(&n) if a == 0 { break } nums := make([]int, 0) for i := 0; i b { return a } return b } 2.大整数相乘(2) 题目 题目描述: 有两个用字符串表示的非常大的大整数,算出他们的乘积，也是用字符串表示。不能用系统自带的大整数类型。 输入描述:空格分隔的两个字符串，代表输入的两个大整数 输出描述:输入的乘积，用字符串表示 示例1: 输入:72106547548473106236 982161082972751393 输出:70820244829634538040848656466105986748 解题思路 No. 思路 时间复杂度 空间复杂度 01 模拟 O(n^2) O(n) 02 内置函数 O(n^2) O(n) package main import ( \"fmt\" ) func main() { var a, b string for { n, _ := fmt.Scanf(\"%s %s\", &a, &b) if n == 0 { break } fmt.Println(multiply(a, b)) } } func multiply(num1 string, num2 string) string { if num1 == \"0\" || num2 == \"0\" { return \"0\" } arr := make([]int, len(num1)+len(num2)) for i := len(num1) - 1; i >= 0; i-- { a := int(num1[i] - '0') for j := len(num2) - 1; j >= 0; j-- { b := int(num2[j] - '0') value := a*b + arr[i+j+1] arr[i+j+1] = value % 10 arr[i+j] = value/10 + arr[i+j] } } res := \"\" for i := 0; i 3.六一儿童节(2) 题目 题目描述:六一儿童节，老师带了很多好吃的巧克力到幼儿园。 每块巧克力j的重量为w[j]，对于每个小朋友i，当他分到的巧克力大小达到h[i] (即w[j]>=h[i])， 他才会上去表演节目。 老师的目标是将巧克力分发给孩子们，使得最多的小孩上台表演。 可以保证每个w[i]> 0且不能将多块巧克力分给一个孩子或将一块分给多个孩子。 输入描述: 第一行：n，表示h数组元素个数 第二行：n个h数组元素 第三行：m，表示w数组元素个数 第四行：m个w数组元素 输出描述:上台表演学生人数 示例1: 输入 3 2 2 3 2 3 1 输出: 1 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序遍历 O(nlog(n)) O(n) 02 排序双指针 O(nlog(n)) O(n) package main import ( \"fmt\" \"sort\" ) func main() { var n, h int var m, w int hArr := make([]int, 0) wArr := make([]int, 0) fmt.Scan(&n) for i := 0; i = 0; i-- { for j := index; j >= 0; j-- { if wArr[i] >= hArr[j] { res++ index = j - 1 break } } } return res } # 2 package main import ( \"fmt\" \"sort\" ) func main() { var n, h int var m, w int need := make([]int, 0) have := make([]int, 0) fmt.Scan(&n) for i := 0; i = need[j] { res++ j++ } } return res } 4.迷宫寻路 题目 题目描述:假设一个探险家被困在了地底的迷宫之中，要从当前位置开始找到一条通往迷宫出口的路径。 迷宫可以用一个二维矩阵组成，有的部分是墙，有的部分是路。 迷宫之中有的路上还有门，每扇门都在迷宫的某个地方有与之匹配的钥匙，只有先拿到钥匙才能打开门。 请设计一个算法，帮助探险家找到脱困的最短路径。 如前所述，迷宫是通过一个二维矩阵表示的，每个元素的值的含义如下 0-墙，1-路，2-探险家的起始位置，3-迷宫的出口，大写字母-门，小写字母-对应大写字母所代表的门的钥匙 输入描述:迷宫的地图，用二维矩阵表示。 第一行是表示矩阵的行数和列数M和N,后面的M行是矩阵的数据，每一行对应与矩阵的一行（中间没有空格）。 M和N都不超过100, 门不超过10扇。 输出描述:路径的长度，是一个整数 示例1:输入 5 5 02111 01a0A 01003 01001 01111 输出: 7 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序遍历 O(nlog(n)) O(n) Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 11:32:56 "},"docs/source/question/patB.html":{"url":"docs/source/question/patB.html","title":"PAT-乙级","keywords":"","body":"PAT (Basic Level) Practice 乙级 PAT (Basic Level) Practice 乙级 1001.害死人不偿命的(3n+1)猜想(1) 1002.写出这个数(1) 1003.我要通过!(1) 1004.成绩排名(1) 1005.继续(3n+1)猜想(1) 1006.换个格式输出整数(1) 1007.素数对猜想(1) 1008.数组元素循环右移问题(1) 1009.说反话(1) 1010.一元多项式求导(1) 1011.A+B 和 C(1) 1012.数字分类(1) 1013.数素数(1) 1014.福尔摩斯的约会(1) 1015.德才论(1) 1001.害死人不偿命的(3n+1)猜想(1) 题目 卡拉兹(Callatz)猜想： 对任何一个正整数 n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把 (3n+1) 砍掉一半。 这样一直反复砍下去，最后一定在某一步得到 n=1。卡拉兹在 1950 年的世界数学家大会上公布了这个猜想， 传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业， 一心只证 (3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展…… 我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过 1000 的正整数 n， 简单地数一下，需要多少步（砍几下）才能得到 n=1？ 输入格式：每个测试输入包含 1 个测试用例，即给出正整数 n 的值。 输出格式：输出从 n 计算到 1 需要的步数。 输入样例：3 输出样例：5 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历模拟 O(log(n)) O(1) package main import \"fmt\" func main() { var n int fmt.Scanf(\"%d \", &n) var res = 0 for n != 1 { if n%2 == 0 { n = n / 2 res++ } else { n = (3*n + 1) / 2 res++ } } fmt.Println(res) } 1002.写出这个数(1) 题目 读入一个正整数 n，计算其各位数字之和，用汉语拼音写出和的每一位数字。 输入格式： 每个测试输入包含 1 个测试用例，即给出自然数 n 的值。这里保证 n 小于 10^100。 输出格式： 在一行内输出 n 的各位数字之和的每一位，拼音数字间有 1 空格，但一行中最后一个拼音数字后没有空格。 输入样例：1234567890987654321123456789 输出样例：yi san wu 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(log(n)) O(1) package main import ( \"fmt\" \"strconv\" ) func main() { var str string m := map[uint8]string{ '0': \"ling\", '1': \"yi\", '2': \"er\", '3': \"san\", '4': \"si\", '5': \"wu\", '6': \"liu\", '7': \"qi\", '8': \"ba\", '9': \"jiu\", } fmt.Scanf(\"%s\", &str) sum := 0 for k := range str { sum = sum + int(str[k]-'0') } toString := strconv.Itoa(sum) for k := range toString { if k != 0 { fmt.Print(\" \") } fmt.Print(m[toString[k]]) } } 1003.我要通过!(1) 题目 “答案正确”是自动判题系统给出的最令人欢喜的回复。 本题属于 PAT 的“答案正确”大派送 —— 只要读入的字符串满足下列条件， 系统就输出“答案正确”，否则输出“答案错误”。 得到“答案正确”的条件是： 字符串中必须仅有 P、 A、 T这三种字符，不可以包含其它字符； 任意形如 xPATx 的字符串都可以获得“答案正确”，其中 x 或者是空字符串，或者是仅由字母 A 组成的字符串； 如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a、 b、 c 均或者是空字符串， 或者是仅由字母 A 组成的字符串。 现在就请你为 PAT 写一个自动裁判程序，判定哪些字符串是可以获得“答案正确”的。 输入格式： 每个测试输入包含 1 个测试用例。第 1 行给出一个正整数 n ( 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(n) package main import \"fmt\" func main() { var n int fmt.Scanf(\"%d\", &n) for i := 0; i 就是P和T中间每增加一个A，需要将P之前的内容复制到字符串末尾，得到的新字符串就也是正确的。 if charMap['P'] == 1 && charMap['T'] == 1 && charMap['A'] != 0 && len(charMap) == 3 && right-length != 1 && l*m == r { return \"YES\" } return \"NO\" } 1004.成绩排名(1) 题目 读入 n（>0）名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。 输入格式：每个测试输入包含 1 个测试用例，格式为 第 1 行：正整数 n 第 2 行：第 1 个学生的姓名 学号 成绩 第 3 行：第 2 个学生的姓名 学号 成绩 ... ... ... 第 n+1 行：第 n 个学生的姓名 学号 成绩 其中姓名和学号均为不超过 10 个字符的字符串，成绩为 0 到 100 之间的一个整数， 这里保证在一组测试用例中没有两个学生的成绩是相同的。 输出格式： 对每个测试用例输出 2 行， 第 1 行是成绩最高学生的姓名和学号，第 2 行是成绩最低学生的姓名和学号，字符串间有 1 空格。 输入样例： 3 Joe Math990112 89 Mike CS991301 100 Mary EE990830 95 输出样例： Mike CS991301 Joe Math990112 解题思路 No. 思路 时间复杂度 空间复杂度 01 哈希辅助 O(n) O(n) package main import \"fmt\" type Student struct { Name string Num string Grade int } func main() { var n int fmt.Scanf(\"%d\", &n) m := make(map[string]Student) var max, low int var maxName, lowName string for i := 0; i max { max = s.Grade maxName = s.Name } if s.Grade 1005.继续(3n+1)猜想(1) 题目 卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。 当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。 例如对 n=3 进行验证的时候，我们需要计算 3、5、8、4、2、1，则当我们对 n=5、8、4、2 进行验证的时候， 就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这 4 个数已经在验证3的时候遇到过了， 我们称 5、8、4、2 是被 3“覆盖”的数。我们称一个数列中的某个数 n 为“关键数”， 如果 n 不能被数列中的其他数字所覆盖。 现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。 你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。 输入格式： 每个测试输入包含 1 个测试用例，第 1 行给出一个正整数 K ( 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序遍历 O(nlog(n)) O(n) package main import ( \"fmt\" \"sort\" ) func main() { var n int fmt.Scanf(\"%d\", &n) arr := make([]int, 10001) maps := make(map[int]int, n) for i := 0; i = 0; i-- { if arr[tempArr[i]] == 0 { if flag == true { fmt.Print(\" \") } fmt.Print(tempArr[i]) flag = true } } } 1006.换个格式输出整数(1) 题目 让我们用字母 B 来表示“百”、字母 S 表示“十”，用 12...n 来表示不为零的个位数字 n（ 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(log(n)) O(1) package main import \"fmt\" func main() { var n int fmt.Scanf(\"%d\", &n) arr := make([]int, 3) i := 0 for { if n == 0 { break } arr[i] = n % 10 n = n / 10 i++ } for k := 0; k 1007.素数对猜想(1) 题目 让我们定义dn为：dn=pn+1−pn，其中pi是第i个素数。 显然有d1=1，且对于n>1有dn是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。 现给定任意正整数N( 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n^3/2) O(1) package main import \"fmt\" func main() { var n int fmt.Scanf(\"%d\", &n) count := 0 // 2 3 5 7 for i := 5; i 1008.数组元素循环右移问题(1) 题目 一个数组A中存有N（>0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（≥0）个位置， 即将A中的数据由（A0A1⋯AN−1）变换为（AN−M⋯AN−1A0A1⋯AN−M−1） （最后M个数循环移至最前面的M个位置）。 如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？ 输入格式: 每个输入包含一个测试用例，第1行输入N（1≤N≤100）和M（≥0）；第2行输入N个整数，之间用空格分隔。 输出格式:在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。 输入样例: 6 2 1 2 3 4 5 6 输出样例:5 6 1 2 3 4 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历交换 O(n) O(n) package main import ( \"fmt\" ) func main() { var N, M int fmt.Scanf(\"%d %d\", &N, &M) M = M % N arr := make([]int, 0) for i := 0; i 1009.说反话(1) 题目 给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。 输入格式： 测试输入包含一个测试用例，在一行内给出总长度不超过 80 的字符串。字符串由若干单词和若干空格组成， 其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用 1 个空格分开，输入保证句子末尾没有多余的空格。 输出格式：每个测试用例的输出占一行，输出倒序后的句子。 输入样例：Hello World Here I Come 输出样例：Come I Here World Hello 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(n) package main import ( \"bufio\" \"fmt\" \"os\" \"strings\" ) func main() { var str string reader := bufio.NewReader(os.Stdin) data, _, _ := reader.ReadLine() str = string(data) arr := strings.Split(str, \" \") for k := len(arr) - 1; k >= 0; k-- { fmt.Print(arr[k]) if k != 0 { fmt.Print(\" \") } } } 1010.一元多项式求导(1) 题目 设计函数求一元多项式的导数。（注：xn（n为整数）的一阶导数为nxn−1。） 输入格式: 以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过 1000 的整数）。数字间以空格分隔。 输出格式: 以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。 注意“零多项式”的指数和系数都是 0，但是表示为 0 0。 输入样例:3 4 -5 2 6 1 -2 0 输出样例:12 3 -10 1 6 0 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) package main import ( \"bufio\" \"fmt\" \"os\" \"strconv\" \"strings\" ) func main() { var str string reader := bufio.NewReader(os.Stdin) data, _, _ := reader.ReadLine() str = string(data) var flag = false arr := strings.Fields(str) for k := 0; k 1011.A+B 和 C(1) 题目 给定区间 [−2^31,2^31] 内的 3 个整数 A、B 和 C，请判断 A+B 是否大于 C。 输入格式： 输入第 1 行给出正整数 T (≤10)，是测试用例的个数。随后给出 T 组测试用例，每组占一行， 顺序给出 A、B 和 C。整数间以空格分隔。 输出格式： 对每组测试用例，在一行中输出 Case #X: true 如果 A+B>C， 否则输出 Case #X: false，其中 X 是测试用例的编号（从 1 开始）。 输入样例： 4 1 2 3 2 3 4 2147483647 0 2147483646 0 -2147483648 -2147483647 输出样例： Case #1: false Case #2: true Case #3: true Case #4: false 解题思路 No. 思路 时间复杂度 空间复杂度 01 计算 O(1) O(1) package main import \"fmt\" func main() { var n int _, _ = fmt.Scanf(\"%d\", &n) for i := 0; i b { result = a - c + b } else { result = b - c + a } if result > 0 { fmt.Print(\"Case #\", i+1, \": \", true, \"\\n\") } else { fmt.Print(\"Case #\", i+1, \": \", false, \"\\n\") } } } 1012.数字分类(1) 题目 给定一系列正整数，请按要求对数字进行分类，并输出以下 5 个数字： A1 = 能被 5 整除的数字中所有偶数的和； A2 = 将被 5 除后余 1 的数字按给出顺序进行交错求和，即计算 n1−n2+n3−n4⋯； A3 = 被 5 除后余 2 的数字的个数； A4 = 被 5 除后余 3 的数字的平均数，精确到小数点后 1 位； A5 = 被 5 除后余 4 的数字中最大数字。 输入格式： 每个输入包含 1 个测试用例。每个测试用例先给出一个不超过 1000 的正整数 N， 随后给出 N 个不超过 1000 的待分类的正整数。数字间以空格分隔。 输出格式： 对给定的 N 个正整数，按题目要求计算 A1~A5 并在一行中顺序输出。 数字间以空格分隔，但行末不得有多余空格。 若其中某一类数字不存在，则在相应位置输出 N。 输入样例 1：13 1 2 3 4 5 6 7 8 9 10 20 16 18 输出样例 1：30 11 2 9.7 9 输入样例 2：8 1 2 4 5 6 7 9 16 输出样例 2：N 11 2 N 9 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) package main import ( \"fmt\" ) func main() { var n int fmt.Scanf(\"%d\", &n) var A1, A2, A5 = 0, 0, 0 var A4 = 0 mapArr := make(map[int][]int) for i := 0; i A5 { A5 = mapArr[i][j] } } } for i := 0; i 1013.数素数(1) 题目 令 Pi 表示第 i 个素数。现任给两个正整数 M≤N≤10^4，请输出 PM 到 PN 的所有素数。 输入格式：输入在一行中给出 M 和 N，其间以空格分隔。 输出格式：输出从 PM 到 PN 的所有素数，每 10 个数字占 1 行，其间以空格分隔，但行末不得有多余空格。 输入样例：5 27 输出样例： 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n^3/2) O(n) package main import \"fmt\" func main() { var N, M int var num = 2 var count int fmt.Scanf(\"%d %d\", &M, &N) result := make([]int, 0) for { if count = M { result = append(result, num) } } num++ } else { break } } for i := 0; i 1014.福尔摩斯的约会(1) 题目 大侦探福尔摩斯接到一张奇怪的字条：我们约会吧！ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&hgsfdk d&Hyscvnm。 大侦探很快就明白了，字条上奇怪的乱码实际上就是约会的时间星期四 14:04， 因为前面两字符串中第 1 对相同的大写英文字母（大小写有区分）是第 4 个字母 D，代表星期四； 第 2 对相同的字符是 E ，那是第 5 个英文字母， 代表一天里的第 14 个钟头（于是一天的 0 点到 23 点由数字 0 到 9、以及大写字母 A 到 N 表示）； 后面两字符串第 1 对相同的英文字母 s 出现在第 4 个位置（从 0 开始计数）上，代表第 4 分钟。 现给定两对字符串，请帮助福尔摩斯解码得到约会的时间。 输入格式：输入在 4 行中分别给出 4 个非空、不包含空格、且长度不超过 60 的字符串。 输出格式： 在一行中输出约会的时间，格式为 DAY HH:MM，其中 DAY 是某星期的 3 字符缩写，即 MON 表示星期一， TUE 表示星期二，WED 表示星期三，THU 表示星期四，FRI 表示星期五，SAT 表示星期六，SUN 表示星期日。 题目输入保证每个测试存在唯一解。 输入样例： 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&hgsfdk d&Hyscvnm 输出样例：THU 14:04 解题思路 No. 思路 时间复杂度 空间复杂度 01 遍历 O(n) O(1) package main import ( \"bufio\" \"fmt\" \"os\" ) var week = []string{ \"MON\", \"TUE\", \"WED\", \"THU\", \"FRI\", \"SAT\", \"SUN\", } func main() { var a, b, c, d string reader := bufio.NewReader(os.Stdin) data, _, _ := reader.ReadLine() a = string(data) data, _, _ = reader.ReadLine() b = string(data) data, _, _ = reader.ReadLine() c = string(data) data, _, _ = reader.ReadLine() d = string(data) len0 := len(a) len2 := len(c) if len(b) > len0 { len0 = len(b) } if len(d) > len2 { len2 = len(d) } flag := true for i := 0; i = 'A' && a[i] = 'A' && a[i] = '0' && a[i] = 'A' && c[i] = 'a' && c[i] 1015.德才论(1) 题目 宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”： “是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人， 君子而与之，与其得小人，不若得愚人。” 现给出一批考生的德才分数，请根据司马光的理论给出录取排名。 输入格式： 输入第一行给出 3 个正整数，分别为： N（≤10^5），即考生总数；L（≥60），为录取最低分数线，即德分和才分均不低于 L 的考生才有资格被考虑录取； H（ 解题思路 No. 思路 时间复杂度 空间复杂度 01 排序 O(nlog(n)) O(n) package main import ( \"bufio\" \"fmt\" \"os\" \"sort\" \"strconv\" \"strings\" ) type Student struct { id int d, c, t int sortNum int } type Students []Student func (s Students) Len() int { return len(s) } func (s Students) Swap(i, j int) { s[i], s[j] = s[j], s[i] } func (s Students) Less(i, j int) bool { if s[i].sortNum == s[j].sortNum { if s[i].t == s[j].t { if s[i].d == s[j].d { return s[i].id s[j].d } return s[i].t > s[j].t } return s[i].sortNum > s[j].sortNum } func main() { reader := bufio.NewReader(os.Stdin) var N, L, H int _, _ = fmt.Scanf(\"%d %d %d\", &N, &L, &H) arr := make(Students, N) count := 0 for i := 0; i = H && d >= H { sortNum = 4 } else if d >= H && c = c { sortNum = 2 } else { sortNum = 1 } arr[i].sortNum = sortNum count++ } fmt.Println(count) sort.Sort(arr) for i := 0; i Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 11:12:02 "},"docs/source/go/1-go语言acm刷题输入问题.html":{"url":"docs/source/go/1-go语言acm刷题输入问题.html","title":"ACM-Go语言处理","keywords":"","body":"ACM题目输入问题 一般校招技术会有笔试，通常在nowcoder上，而题目通常是采用ACM模式，掌握ACM模式的输入很重要 No. 描述 01 02 03 第一行输入N，第二行输入N个数 完成 0.处理多个case 0.1 牛客网 对于传统ACM的OJ模式题目，你的程序需要stdin（标准输入）读取输入，然后stdout（标准输出）来打印结果 https://www.nowcoder.com/discuss/276 package main import ( \"fmt\" ) func main() { a:=0 b:=0 for { n, _ := fmt.Scan(&a,&b) if n == 0 { break } else { fmt.Printf(\"%d\\n\",a+b) } } } 1.字符串输入 1.1 单个字符串输入 适用于单个字符串输入 1.1.1 使用bufio.NewReader(os.Stdin)+ReadLine() package main import ( \"bufio\" \"fmt\" \"os\" ) func main() { reader := bufio.NewReader(os.Stdin) data, _, _ := reader.ReadLine() str := string(data) fmt.Println(str) } 1.1.2 使用bufio.NewReader(os.Stdin)+ReadBytes() package main import ( \"bufio\" \"fmt\" \"os\" ) func main() { reader := bufio.NewReader(os.Stdin) data, _ := reader.ReadBytes('\\n') str := string(data) fmt.Println(str) return } 1.1.3 使用bufio.NewReader(os.Stdin)+ReadString() package main import ( \"bufio\" \"fmt\" \"os\" ) func main() { reader := bufio.NewReader(os.Stdin) data, _ := reader.ReadString('\\n') str := string(data) fmt.Println(str) return } 1.1.4 使用bufio.NewScanner(os.Stdin)+Scan()+Text() package main import ( \"bufio\" \"fmt\" \"os\" ) func main() { scan := bufio.NewScanner(os.Stdin) scan.Scan() str := scan.Text() fmt.Println(str) } 1.2 第一行输入2个字符串a和b package main import ( \"fmt\" ) func main() { var a, b string for { n, _ := fmt.Scanf(\"%s %s\", &a, &b) if n == 0 { break } // 下面是处理逻辑 } } 1.2.1 xx 2.数字输入 2.1 单个数字输入 2.1.1 使用fmt.Scan 输入N，然后输入N个数 第一行输入N， 第二行是N个数 package main import ( \"fmt\" ) func main() { var n, m int for { a, _ := fmt.Scan(&n) if a == 0 { break } nums := make([]int, 0) for i := 0; i Copyright © Zhi2014 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-09 09:46:03 "}}